<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangyuying.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="IoC（Inverse of Control，控制反转）是Spring容器的内核，AOP、声明式事务等功能在此基础上开发结果。">
<meta property="og:type" content="article">
<meta property="og:title" content="IoC容器">
<meta property="og:url" content="http://zhangyuying.cn/2020/03/12/Spring/IoC%E5%AE%B9%E5%99%A8/index.html">
<meta property="og:site_name" content="张玉莹的个人博客">
<meta property="og:description" content="IoC（Inverse of Control，控制反转）是Spring容器的内核，AOP、声明式事务等功能在此基础上开发结果。">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E5%9C%B0%E5%9D%80%E5%89%8D%E7%BC%80.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/BeanFactory%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/ApplicationContext%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg">
<meta property="article:published_time" content="2020-03-12T05:08:43.000Z">
<meta property="article:modified_time" content="2023-03-28T02:25:12.753Z">
<meta property="article:author" content="张玉莹">
<meta property="article:tag" content="Spring">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E5%9C%B0%E5%9D%80%E5%89%8D%E7%BC%80.jpg">

<link rel="canonical" href="http://zhangyuying.cn/2020/03/12/Spring/IoC%E5%AE%B9%E5%99%A8/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>IoC容器 | 张玉莹的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张玉莹的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/aboutme/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2020/03/12/Spring/IoC%E5%AE%B9%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          IoC容器
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2020-03-12 13:08:43" itemprop="dateCreated datePublished" datetime="2020-03-12T13:08:43+08:00">2020-03-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-28 10:25:12" itemprop="dateModified" datetime="2023-03-28T10:25:12+08:00">2023-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spring/" itemprop="url" rel="index"><span itemprop="name">Spring</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>IoC（<code>Inverse of Control</code>，控制反转）是Spring容器的内核，AOP、声明式事务等功能在此基础上开发结果。</p>
<span id="more"></span>

<p>本文目录说明：</p>
<ul>
<li>IoC概述</li>
<li>资源访问利器</li>
<li>BeanFactory和ApplicationContext</li>
<li>Bean的生命周期</li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>包括两个方面的内容：一是控制，二是反转。对于软件来说，即某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定，既由Spring容器借由Bean配置来进行控制</p>
<p>DI（<code>Dependency Injection</code>，依赖注入）是用来替代IoC的概念。即让调用类对某一接口实现类的依赖关系由第三方(容器或协助类)注入，以移除调用类对某一接口实现类的依赖</p>
<p><strong>IoC的类型</strong></p>
<p>从注入方法上看，IoC主要可以划分为3种类型：构造函数注入、属性注入和接口注入，Spring支持构造函数注入和属性注入</p>
<ol>
<li><p>构造函数注入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    user.say(user.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> ZhangSan();</span><br><span class="line">    Work work = <span class="keyword">new</span> Work(user);</span><br><span class="line">    work.goWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性注入</p>
<p>可以有选择的通过Setter方法完成调用类所需依赖的注入，不是必须注入，<strong>使用时才注入</strong>，更加灵活方便</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    user.say(user.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Work work = <span class="keyword">new</span> Work();</span><br><span class="line">    User user = <span class="keyword">new</span> ZhangSan();</span><br><span class="line">   </span><br><span class="line">    work.setUser(user);</span><br><span class="line">    work.goWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口注入</p>
<p>将调用类所有依赖注入的方法抽取到一个接口中，调用类通过实现该接口提供相应的注入方法，所以为了采取接口注入，比如先声明一个接口</p>
<p>注：由于多声明一个额外的接口，增加了类的数目，而且效果和属性注入无区别，因为不提倡此种方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWorkArrangable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">injectUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="title">implement</span> <span class="title">IWorkArrangable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    user.say(user.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Work work = <span class="keyword">new</span> Work();</span><br><span class="line">    User user = <span class="keyword">new</span> ZhangSan();</span><br><span class="line">    work.injectUser(user);</span><br><span class="line">    work.goWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>通过容器完成依赖关系的注入</strong></p>
<p>上述说明的IoC的三种注入方式，依赖关系都是第三方协助类完成的。即<code>Work</code>不关注工作的具体是那个人，交给<code>Leader</code>注入(协助类)。此时虽然<code>Work</code>不必关系依赖关系，但是此部分的代码依然存在（在<code>Leader</code>中）</p>
<p>使用第三方容器注入：帮助完成类的初始化与装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出来，专注业务逻辑开发</p>
<p>Spring就是这样一个容器，通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入工作，如：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.ioc.ZhangSan&quot;</span>/&gt;</span> <span class="comment">&lt;!--实现类实例化--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;work&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuuying.ioc.Work&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:user-ref</span>=<span class="string">&quot;user&quot;</span>/&gt;</span> <span class="comment">&lt;!--建立依赖关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring根据配置文件和注解进而实例化和装配Bean的底层原理：为Java语言本身的类反射功能</p>
<h4 id="资源访问利器"><a href="#资源访问利器" class="headerlink" title="资源访问利器"></a>资源访问利器</h4><p>Spring设计了一个<code>Resource</code>接口，为应用提供了比JDK更强的底层资源访问能力，该接口拥有不用资源类型的实现类</p>
<p><code>Resource</code>接口的主要方法：</p>
<ul>
<li><code>boolean exist()</code>：资源是否存在</li>
<li><code>boolean isOpen()</code>：资源是否打开</li>
<li><code>URL getURL() throws IOException</code>：如果底层资源可以表示成URL，则该方法返回对应的URL对象</li>
<li><code>File getFile() throws IOException</code>：如果底层资源对应一个文件，则该方法返回对应的File对象</li>
<li><code>InputStream getInputStream() throws IOException</code>：返回资源对应的输入流</li>
</ul>
<p><code>Resource</code>在Spring中起着不可或缺的作用，Spring框架使用<code>Resource</code>装载各种资源，包括配置文件、国际化属性文件资源等</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用类路径方式加载文件</span></span><br><span class="line">resource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;conf/file.test&quot;</span>);</span><br><span class="line">res.getInputStream();</span><br></pre></td></tr></table></figure>

<p><strong>资源加载</strong></p>
<p>为了访问不同类型的资源，必须使用相应的<code>Resource</code>实现类，是比较麻烦的，所以 Spring提供了一个强大的加载资源的机制（仅通过资源地址的特殊标识就可以访问响应的资源），不但能通过<code>“classpath:”</code>、<code>“file:”</code>等资源地址前缀识别不同的资源类型，还支持<code>Ant</code>风格带通配符的资源地址</p>
<ol>
<li><p>Spring支持的资源类型的地址前缀</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E5%9C%B0%E5%9D%80%E5%89%8D%E7%BC%80.jpg" alt="资源类型的地址前缀"></p>
<blockquote>
<p><code>&quot;classpath:&quot;</code> 和 <code>“classpath*:”</code>的区别：</p>
<p>假设有多个JAR包或文件系统类路径都拥有一个相同的包名(如<code>cn.zhangyuying</code>)</p>
<ul>
<li><code>&quot;classpath:&quot;</code> 只会在第一个加载的<code>cn.zhangyuying</code>包的类路径下查找<ul>
<li><code>“classpath*:”</code> 会扫描所有这些JAR包及类路径下出现的<code>cn.zhangyuying</code>类路径，这对于分模块打包比较友好</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<ol>
<li>Ant风格的资源地址支持3中匹配符<ul>
<li>? : 匹配文件名中的一个字符，如：<code>classpath:com/t?sr.xml</code></li>
<li>* : 匹配文件名中的任意字符，如：<code>file:D:/conf/*.xml </code>即匹配D:/conf下所有以.xml为后缀的文件</li>
<li>** : 匹配多层路径，如：<code>classpath:com/**/test.xml </code>匹配<code>com</code>类路径下（当前目录及其子孙目录）的<code>test.xml</code>文件</li>
</ul>
</li>
</ol>
<p><strong>资源加载器</strong></p>
<p>Spring定义了一套资源加载接口，并提供了实现类</p>
<ol>
<li><p><code>ResourceLoader</code>接口仅有一个<code>getResource(String location)</code>方法，可以根据一个资源地址加载文件资源，不过只支持带资源类型前缀的表达式，不支持Ant风格的资源路径表达式</p>
</li>
<li><p><code>ResourcePatternResolver</code>扩展<code>ResourceLoader</code>接口，定义了一个新的接口方法<code>getResources(String locationPattern)</code>,该方法支持带资源类型前缀及Ant风格的资源路径表达式</p>
</li>
<li><p><code>PathMatchingResourcePatternResolver</code>是spring提供的标准实现类，</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ResourcePatternResolver resolver -<span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">Resource resources[] = resolver.getResource(<span class="string">&quot;classpath*:cn/zhangyuying/**/*.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用<code>Resource</code>操作文件时，如果资源配置文件在项目发布时会被打包到JAR中，那么不能使用<code>Resource#getFile()</code>，否则会抛出<code>FileNotFoundException</code>，但是可以使用<code>Resource#getInputStream</code></p>
<p>错误读取：<code>(new DefaultResourceLoader()).getResource(&quot;classpath:conf/sys.properties&quot;).getFile()</code></p>
<p>正确读取：<code>(new DefaultResourceLoader()).getResource(&quot;classpath:conf/sys.properties&quot;).getInputStream()</code></p>
</blockquote>
</li>
</ol>
<h4 id="BeanFactory-和-ApplicationContext"><a href="#BeanFactory-和-ApplicationContext" class="headerlink" title="BeanFactory 和 ApplicationContext"></a>BeanFactory 和 ApplicationContext</h4><p>Bean工厂(<code>com.springframework.beans.factory.BeanFactory</code>)是Spring框架最核心的接口，他提供了高级IoC的配置机制，<code>BeanFactory</code>使管理不同类型的Java对象成为可能</p>
<p>应用上下文(<code>com.springframework.context.ApplicationContext</code>)建立在<code>BeanFactory</code>基础之上，提供了更多面向应用的功能，提供了国际化支持和框架事件体系，更易于创建实际应用，偶尔也称为Spring容器</p>
<blockquote>
<p>对于用途可以简单划分</p>
<p><code>BeanFactory</code>是Spring框架的基础设施，面向Spring本身</p>
<p><code>ApplicationContext</code>面向使用Spring框架的开发者，几乎所有应用场合都可以直接使用<code>ApplicationContext</code>而非底层的<code>BeanFactory</code></p>
</blockquote>
<h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>是类的通用工厂，可以创建并管理各种类的对象</p>
<p><code>BeanFactory</code>接口中最主要的方法就是<code>getBean(String beanName)</code>，该方法从容器中返回特定名称的<code>Bean</code>,<code>BeanFactory</code>的功能通过其他接口得到不断扩展，例如<code>DefaultListableBeanFactory</code></p>
<blockquote>
<p>Spring配置文件中每一个<code>&lt;bean&gt;</code>节点元素在Spring容器里都通过一个<code>BeanDefinition</code>对象表示，它描述了<code>Bean</code>的配置信息，<code>BeanDefinitionRegistry</code>接口提供了向容器手工注册<code>BeanDefinition</code>对象的方法，<code>DefaultListableBeanFactory</code>实现了这个接口</p>
</blockquote>
<p>Spring为<code>BeanFactory</code>提供了多种实现，建议使用<code>XmlBeanDefinitionReader</code>、<code>DefaultListableBeanFactory</code></p>
<p>初始化<code>BeanFactory</code>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBean</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">    Resource res = resolver.getResource(<span class="string">&quot;classpatch:cn.zhangyuying/beans.xml&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    reader.loadBeanDefinitions(res);</span><br><span class="line">    </span><br><span class="line">    User user = factory.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br><span class="line">    user.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过<code>BeanFactory</code>启动IoC容器时，并不会初始化配置文件中定义的<code>Bean</code>，初始化动作发生在第一次调用时</strong></p>
<blockquote>
<p>对于单实例（<code>singletion</code>）的<code>Bean</code>来说，<code>BeanFactory</code>会缓存<code>Bean</code>实例，所以第二次调用<code>getBean()</code>获取<code>Bean</code>时，将直接从IoC容器的缓存中获取<code>Bean</code>实例（<code>DefaultSingletionBeanRegistry</code>类中提供了一个用于缓存单实例<code>Bean</code>的缓存器，<code>HashMap</code>实现，单例的<code>Bean</code>以<code>BeanName</code>为键保存在这个<code>HashMap</code>中）</p>
</blockquote>
<h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p><code>ApplicationContext</code>由<code>BeanFactory</code>派生而来，提供了更多面向实际应用的功能</p>
<p><code>ApplicationContext</code>的主要实现类是<code>ClassPathXmlApplicationContext</code> 和<code>FileSystemXmlApplicationContext</code>，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件</p>
<p><code>ApplicationContext</code>初始化示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置文件放在类路径下</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;cn/zhangyuying/beans.xml&quot;</span>); <span class="comment">//可省略classpath:前缀</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;conf/beans.xml&quot;</span>,<span class="string">&quot;conf/beans2.xml&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 配置文件放在文件系统的路径下</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;cn/zhangyuying/beans.xml&quot;</span>); <span class="comment">//可省略file:前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Bean</span></span><br><span class="line">ctx.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>ApplicationContext</code>的初始化和<code>BeanFactory</code>有一个重大的区别</strong> ：<code>BeanFactory</code>在初始化容器时，并未实例化<code>Bean</code>，直到第一次访问某个<code>Bean</code>时才实例化目标<code>Bean</code>；而<code>ApplicationContext</code>则在初始化应用上下文时就实例化所有单实例的<code>Bean</code>，因此，<code>ApplicationContext</code>的初始化时间会比<code>BeanFactory</code>稍长一些</p>
<p><strong>基于类注解配置方式</strong></p>
<p>Spring支持基于类注解的配置方式，主要功能来自Spring的一个名为<code>JavaConfig</code>的子项目，<code>JavaCongfig</code>现已升级为Spring核心架构的一部分，一个标注<code>@Configuration</code>注解的POJO即可提供Spring所需的<code>Bean</code>配置信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beans</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean(name = &quot;user&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">CreateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring为基于注解类配置提供了专门的<code>ApplicationContext</code>实现类：<code>AnnotationConfigApplicationContext</code>，使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Application ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Beans.class);</span><br><span class="line">    User user = ctx.getBean(<span class="string">&quot;user&quot;</span>,User,<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>webApplicationContext</strong></p>
<p><code>webApplicationContext</code>扩展了<code>ApplicationContext</code>，是专门为Web准备的，允许从相对于Web根目录的路径中装载配置文件完成初始化工作</p>
<p><code>webApplicationContext</code>可以获取<code>ServletContext</code>的引用,获取方法：<code>getServletContext()</code></p>
<p><code>servletContext</code>中也可以获取<code>webApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Spring提供方法</span></span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</span><br><span class="line"><span class="comment">//内部实现</span></span><br><span class="line">WebApplicationContext wac = (WebApplicationContext)ServletContext.getAttribut(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br></pre></td></tr></table></figure>

<p><code>WebApplicationContext</code>的初始化：<code>WebApplicationContext</code>的初始化需要<code>ServletContext</code>实例，也就是说，他必须在拥有Web容器的前台下才能完成启动工作</p>
<p>Spring分别提供了用于启动<code>WebApplicationContext</code>的Servlet和Web容器监听器：</p>
<ul>
<li><code>org.springframework.web.context.ContextLoaderServlet</code></li>
<li><code>org.springframework.web.context.ContextLoaderListener</code></li>
</ul>
<p>二者的内部都实现了启动<code>WebApplicationContext</code>实例的逻辑，只要根据Web容器的具体情况选择二者之一，并在web.xml中完成配置即可</p>
<p>配置示例</p>
<ol>
<li><p><code>ContextLoaderListener</code>使用示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/test-dao.xml,/WEB-INF/test-server.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明web容器监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ContextLoaderServlet</code>使用示例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/test-dao.xml,/WEB-INF/test-server.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springContextLoaderServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.context.ContextLoaderservlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用标注<code>@Configuration</code>的Java类提供配置信息，则<code>web.xml</code>需要按一下方式配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过制定context参数，让Spring使用AnnotationConfigWebApplicationContext 而非XmlWebApplicationContext启动容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>organ.springframework.web.context.support.AnnotationConfgiWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--制定标注了@Configuration的配置类，多个可以使用逗号或空格分隔--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>cn.zhangyuying.AppConfig1,cn.zhangyuying.AppConfig2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--ContextLoaderListener监听器将根据上面的配置使用AnnotationConfigWebApplicationContext根据contextConfigLocation指定的配置类启动Spring容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>父子容器</strong></p>
<p>通过<code>HierarchicalBeanFactory</code>接口，Spring的IoC容器可以建立父子层级关联的容器</p>
<ul>
<li>子容器可以访问父容器里面的<code>Bean</code>,但父容器不能访问子容器的<code>Bean</code></li>
<li>容器内，<code>Bean</code>的<code>id</code>必须是唯一的，但子容器可以拥有一个和父容器<code>id</code>相同的<code>Bean</code></li>
<li>父子容器体系增加了Spring容器架构的扩展性和灵活性，因为第三方可以通过编程的方式为一个已经存在的容器添加一个或多个特殊用途的子容器，以提供一些额外功能，Spring中的实现：Spring MVC中，展现层<code>Bean</code>位于一个子容器中，而业务层和持久成<code>Bean</code>位于父容器中</li>
</ul>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p><code>Bean</code>的声明周期由多个特定的生命阶段组成，每个生命阶段都开起了一扇门，允许外界对<code>Bean</code>施加控制</p>
<p><strong><code>BeanFactory</code>中<code>Bean</code>的生命周期</strong></p>
<p>图解：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/BeanFactory%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="BeanFactory中Bean生命周期图解"></p>
<p><code>Bean</code>的完整生命周期从Spring容器着手实例化<code>Bean</code>开始，直到最终销毁<code>Bean</code>，其中经过了许多关键点，每个关键点都涉及特定的方法调用，可以将这些方法大致划分为4类</p>
<ol>
<li><code>Bean</code>自身的方法：如调用<code>Bean</code>构造函数实例化<code>Bean</code>、调用<code>Setter</code>设置<code>Bean</code>的属性值及通过<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>所指定的方法</li>
<li><code>Bean</code>级生命周期接口方法：如<code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>InitializingBean</code>和<code>DisposableBean</code>，这些接口由Bean类直接实现</li>
<li>容器级生命周期接口方法：在图中带 ☆ 的步骤是由<code>InstantiationAwareBeanPostProcessor</code>和<code>BeanPostProcessor</code>这两个接口实现的，一般称他们的实现类为“后处理器”。<ul>
<li>后处理器接口一般不由<code>Bean</code>本身实现，他们独立于<code>Bean</code>，实现类以容器附加装置的形式注册到Spring容器中，并通过接口反射为Spring容器扫描识别。</li>
<li>当Spring容器创建任何<code>Bean</code>的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的，当然用户可以通过合理地编写后处理器，让其仅对感兴趣的<code>Bean</code>进行加工处理</li>
</ul>
</li>
<li>工厂后处理器接口方法：包括<code>AspectJWeavingEnabler</code>、<code>CustomAutowireConfigurer</code>、<code>ConfigurationClassPostProcessor</code>等方法(均实现自<code>BeanFactoryPostProcessor</code>)，工厂后处理器也是容器级的，在应用上下文装配配置文件后立即调用</li>
</ol>
<blockquote>
<ol>
<li><p><code>Bean</code>级生命周期方法和容器级生命周期接口，前者解决<code>Bean</code>个性化处理问题，后者解决容器中某些<code>Bean</code>共性化处理的问题</p>
</li>
<li><p>Spring容器中是可以注册多个后处理器的，只要都同时实现<code>org.springframework.core.Ordered</code>接口，容器将按特定的顺序依次调用这些后处理器，即上图中带☆的步骤，都可能调用多个后处理进行一系列加工操作</p>
</li>
<li><p><code>InstantiationAwareBeanPostProcessor</code>其实是<code>BeanPostProcessor</code>接口的子接口，Spring为其提供了一个适配器类<code>InstantiationAwareBeanPostProcessorAdapter</code>，一般情况下，可以方便的扩展该适配器覆盖感兴趣的方法以定义实现类</p>
</li>
<li><p><code>Bean</code>生命周期接口：虽然让<code>Bean</code>具有更细致的生命周期阶段，但是<code>Bean</code>和Spring框架紧密的绑定在一起了，所以更推荐使用<code>Bean</code>自身的方法，</p>
<ol>
<li><code>InitializingBean</code>和<code>DisposableBean</code>方法：更推荐<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>方法，此外Spring还拥有一个<code>Bean</code>后置处理器<code>InitDestroyAnnotationBeanPostProcessor</code>，它负责对标注了<code>@PostConstruct</code>、<code>@PreDestroy</code>的<code>Bean</code>进行初始化和销毁处理</li>
<li><code>BeanFactoryAware</code>和<code>BeanNameAware</code>接口，一般情况不需要关心</li>
</ol>
<p>所以除非编写一个基于Spring之上的扩展插件或子项目之类的东西，否则完全可以抛开上述4个<code>Bean</code>生命周期的接口类</p>
</li>
<li><p><code>BeanPostProcessor</code>接口和<code>Bean</code>生命周期接口不同，完全像插件一样注册到Spring容器中，Spring容器充分利用了<code>BeanPostPricessor</code>对Bean进行加工处理</p>
</li>
</ol>
</blockquote>
<p><strong>ApplicationContext中Bean的生命周期</strong></p>
<p>和<code>BeanFactory</code>中的声明周期类似，不同的是：如果<code>Bean</code>实现了<code>org.springframework.context.ApplicationContextAware</code>接口，则会增加一个调用该接口方法<code>setApplicationContext()</code>的步骤，图解如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/ApplicationContext%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="ApplicationContext中Bean的生命周期"></p>
<blockquote>
<ol>
<li><p>如果在配置文件中声明了工厂后处理接口<code>BeanFactoryPostProcessor</code>的实现类，则应用上下文在装载配置文件之后、初始化<code>Bean</code>实例之前将调用这些<code>BeanFactoryPostProcess</code>对配置信息进行加工处理</p>
<p>如果在配置文件中定义了多个工厂后处理器，那么最好让他们实现<code>org.springframework.core.Ordered</code>接口,以便Spring以确定顺序调用他们</p>
<p>工厂后处理器是容器级的，仅在应用上下文初始化时调用一次，其目的是完成一些配置文件的加工处理工作</p>
</li>
<li><p><code>ApplicationContext</code>在启动时，将首先为配置文件中的每个<code>&lt;bean&gt;</code>生成一个<code>BeanDefinition</code>对象，<code>beanDefinition</code>是<code>&lt;bean&gt;</code>在Spring容器中的内部表示，当配置文件中的所有<code>&lt;bean&gt;</code>都被解析成<code>BeanDefinition</code>时，<code>ApplicationContext</code>将调用工厂后处理器的方法，因此我们有机会调整Bean的配置信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现BeanFactoryPostProcessor后，实现方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory var1)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  BeanDefinition bd = bf.getBeanDefinition(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><strong><code>ApplicationContext</code>和<code>BeanFactory</code>另一个最大的不同之处在于</strong>：</p>
<ul>
<li><p>前者会利用Java反射机制自动识别出配置文件定义的<code>BeanPostProcessor</code>、<code>InstantiationAwareBeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>，并自动将它们注册到应用上下文中</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--工厂后处理器,继承自BeanFactoryProcessor，可以对上面配置的属性值进行调整--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanFactoryPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.MyBeanFactoryPostProcessor&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册Bean后处理器，也可以对Bean的属性进行调整--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.MyBeanPostProcessor&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后者需要在代码中通过手工调用<code>addBeanPostProcessor()</code>方法进行注册</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//向容器中注册MyBeanPostProcessor后处理器</span></span><br><span class="line">((ConfigurableBeanFactory)beanFactory).addbeanPostProcessor(<span class="keyword">new</span> MyBeanPostProcessor());</span><br><span class="line"><span class="comment">//向容器中注册MyInstantiationAwareBeanPostProcessor后处理器</span></span><br><span class="line">((ConfigurableBeanFactory)beanFactory).addbeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这也是为什么在应用开发中普遍使用<code>ApplicationContext</code>的原因之一</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spring/" rel="tag"># Spring</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/03/12/Spring/Spring%E6%A6%82%E8%BF%B0/" rel="prev" title="Spring概述">
      <i class="fa fa-chevron-left"></i> Spring概述
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/03/13/Spring/%E5%9C%A8IoC%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%A3%85%E9%85%8DBean/" rel="next" title="在IoC容器中装配Bean">
      在IoC容器中装配Bean <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-number">1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%B5%84%E6%BA%90%E8%AE%BF%E9%97%AE%E5%88%A9%E5%99%A8"><span class="nav-number">2.</span> <span class="nav-text">资源访问利器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#BeanFactory-%E5%92%8C-ApplicationContext"><span class="nav-number">3.</span> <span class="nav-text">BeanFactory 和 ApplicationContext</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#BeanFactory"><span class="nav-number">3.1.</span> <span class="nav-text">BeanFactory</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ApplicationContext"><span class="nav-number">3.2.</span> <span class="nav-text">ApplicationContext</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="nav-number">4.</span> <span class="nav-text">Bean的生命周期</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">张玉莹</p>
  <div class="site-description" itemprop="description">路漫漫其修远兮 吾将上下而求索</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">185</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张玉莹</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
