<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangyuying.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="MySQL是开源的关系型数据库管理系统 MySQL是一个基于插件式存储引擎的数据库，本文内容都是基于MySQL InnoDB存储引擎。">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL">
<meta property="og:url" content="http://zhangyuying.cn/2021/07/27/MySQL/MySQL/index.html">
<meta property="og:site_name" content="张玉莹的个人博客">
<meta property="og:description" content="MySQL是开源的关系型数据库管理系统 MySQL是一个基于插件式存储引擎的数据库，本文内容都是基于MySQL InnoDB存储引擎。">
<meta property="og:locale">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/MySQL%E4%BD%93%E7%B3%BB%E5%9B%BE.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/innodb-architecture.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/B%2BTree%E7%BB%93%E6%9E%84.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E5%9B%9E%E8%A1%A8.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/SQL%E7%9A%84%E6%89%A7%E8%A1%8C.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/BufferPool%E8%AE%BE%E8%AE%A1.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/InnodbDQL%E6%93%8D%E4%BD%9C.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/Innodb%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/Next-KeyLocks.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/GapLocks.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/RecordLocks.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E8%84%8F%E8%AF%BB.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png">
<meta property="og:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E5%B9%BB%E8%AF%BB.png">
<meta property="article:published_time" content="2021-07-27T07:27:42.000Z">
<meta property="article:modified_time" content="2023-03-28T02:25:12.749Z">
<meta property="article:author" content="张玉莹">
<meta property="article:tag" content="MySQL">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/MySQL%E4%BD%93%E7%B3%BB%E5%9B%BE.png">

<link rel="canonical" href="http://zhangyuying.cn/2021/07/27/MySQL/MySQL/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>MySQL | 张玉莹的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张玉莹的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/aboutme/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2021/07/27/MySQL/MySQL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          MySQL
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-07-27 15:27:42" itemprop="dateCreated datePublished" datetime="2021-07-27T15:27:42+08:00">2021-07-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-28 10:25:12" itemprop="dateModified" datetime="2023-03-28T10:25:12+08:00">2023-03-28</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/MySQL/" itemprop="url" rel="index"><span itemprop="name">MySQL</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p><code>MySQL</code>是开源的关系型数据库管理系统</p>
<p><code>MySQL</code>是一个基于插件式存储引擎的数据库，本文内容都是基于<code>MySQL InnoDB</code>存储引擎。</p>
<span id="more"></span>

<p>目录</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">MySQL体系结构</a><ul>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB">存储引擎:InnoDB</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E6%96%87%E4%BB%B6">MySQL文件</a><ul>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6">表结构定义文件</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">日志文件</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E7%B4%A2%E5%BC%95">MySQL索引</a><ul>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#B-%E6%A0%91%E7%B4%A2%E5%BC%95">B+树索引</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95">辅助索引</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%A1%E7%90%86">索引的管理</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8">索引的使用</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%87%AA%E9%80%82%E5%BA%94Hash%E7%B4%A2%E5%BC%95">自适应Hash索引</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">MySQL中SQL执行流程</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%BA%8B%E5%8A%A1">MySQL事务</a><ul>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0">MySQL原子性、一致性、持久性的实现</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E9%9A%94%E7%A6%BB%E6%80%A7%E5%AE%9E%E7%8E%B0">MySQL隔离性实现</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88">MySQL优化方案</a><ul>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%AF%AD%E6%B3%95">语法</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E7%B4%A2%E5%BC%95">索引</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E8%87%AA%E5%B8%A6%E7%9A%84%E4%BC%98%E5%8C%96">MySQL自带的优化</a></li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E9%99%84%E5%BD%95">通用概念附录</a><ul>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#SQL%E5%88%86%E7%B1%BB">SQL分类</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7">事务的四大特性</a></li>
<li><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a></li>
</ul>
</li>
</ol>
<hr>
<h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/MySQL%E4%BD%93%E7%B3%BB%E5%9B%BE.png" alt="MySQL体系图"></p>
<p><code>MySQL</code>体系结构包含以下几个重要部分：</p>
<ol>
<li><p>连接管理池（<code>Connection Pool</code>）：用来管理<code>MySQL</code>的连接，缓存连接</p>
<blockquote>
<p><code>MySQL</code>采用的半双工、长连接的方式进行客户端和服务器的连接，并且两种连接协议:</p>
<ul>
<li><code>TCP/IP</code>协议</li>
<li><code>UNIX Socket</code>协议</li>
</ul>
</blockquote>
</li>
<li><p>管理服务和组件（<code>Management Services &amp; UtillIties</code>）：系统管理的控制，比如数据库的备份、恢复，同步、集群等</p>
</li>
<li><p><code>SQL</code>接口（<code>SQL Interface</code>）：用来接受<code>SQL</code>语句，返回结果</p>
</li>
<li><p>解析器（<code>Parser</code>）：对<code>SQl</code>语句进行解析（语法和词法分析），转化成解析树</p>
</li>
<li><p>优化器（<code>Optimizer</code>）：查询优化器、优化传入的<code>SQL</code>命令（生成执行计划的模块）</p>
</li>
<li><p>缓存器（<code>Caches &amp; Buffers</code>）：缓存，用来缓存一部分热点数据</p>
</li>
<li><p>插件式存储引擎（<code>Pluggable Storage Engines</code>）：真正执行查找，存储的数据引擎，不同的引擎支持的操作不同，<code>MySQL</code>的存储引擎是基于表的。</p>
</li>
<li><p>物理文件（<code>File system</code>）：持久化的一些数据，包括存储的数据，<code>Redo</code>,<code>Undo</code>,<code>Index</code>…</p>
</li>
</ol>
<h4 id="存储引擎-InnoDB"><a href="#存储引擎-InnoDB" class="headerlink" title="存储引擎:InnoDB"></a>存储引擎:InnoDB</h4><p><code>MySQL</code>的每一张表都必须指定（有且只有一个）存储引擎</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &#96;test&#96; (</span><br><span class="line">  ...</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>查看当前<code>MySQL</code>服务器的存储引擎列表： <code>show engines</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL5.5&#96;版本及以后默认的存储引擎为&#96;InnoDB</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code> 的存储架构：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/innodb-architecture.png" alt="InnoDB架构"></p>
<p>特点</p>
<ul>
<li>B+树索引</li>
<li>支持事务</li>
<li>行级锁和MVCC</li>
<li>支持索引和数据缓存</li>
<li>聚集索引</li>
<li>外键支持</li>
</ul>
<h3 id="MySQL文件"><a href="#MySQL文件" class="headerlink" title="MySQL文件"></a>MySQL文件</h3><h4 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h4><p>表结构定义文件：我们指定的表的相关属性如编码,最后更新的时间,表的结构等等都将保存在以<code>frm</code> 为后缀(<code>MySQL8.0</code>之前)文件中.</p>
<p><code>MySQL</code>存储的逻辑结构：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="MySQL存储逻辑结构"></p>
<ol>
<li><p>表空间（<code>Tablespace</code>）</p>
<p>表空间是<code>InnoDB</code>存储引擎的最高层，所有的数据都存放在表空间中</p>
<p>在<code>InnoDB</code>中，表空间可以设置为共享表空间和独立表空间</p>
<ul>
<li><p>共享表空间：所有数据存在同一个表空间中，映射文件<code>ibdata1</code>,这个文件会越来越大，而且它的空间 不会收缩</p>
<ul>
<li><p><code>InnoDB Data Dictionary</code></p>
<p><code>InnoDB</code>引擎的系统表，比如记录执行计划的表，索引信息的表等等</p>
</li>
<li><p><code>Double Write Buffer</code></p>
<p>是开在共享表空间的物理文件的<code>buffer</code>，其大小是2MB</p>
<blockquote>
<p>刷脏时，脏页数据备份的位置</p>
</blockquote>
</li>
<li><p><code>Change Buffer</code></p>
<p>是<code>InnoDB Buffer Pool中ChangeBuffer</code>开在共享表空间的屋里映射位置</p>
</li>
<li><p><code>Undo Logs</code></p>
<p><code>Undo Logs</code>开在共享表空间的屋里映射位置</p>
</li>
</ul>
</li>
<li><p>独立表空间：没张表的数据单独放在一个表空间中（仅仅是数据，索引，插入缓冲单独存放，回滚信息，事务信息等还是放在原来的共享表空间中）</p>
</li>
</ul>
</li>
<li><p>段（<code>Segment</code>）</p>
<p>表空间由各个段组成，一般分为数据段，索引段，回滚段等</p>
</li>
<li><p>区（<code>Extent</code>）</p>
<p>段由多个区组成，每个区大小1MB，区是由连续页组成的空间，这些页一定是从物理和逻辑上都是连续的</p>
</li>
<li><p>页（<code>Page</code>）</p>
<p>多个页组成一个区，一般来说，一页的大小为16k,因此64个页组成了一个区，可以通过参数设置页的大小为4k，8k，16k等，页是数据文件管理的最小单位，也是文件空间分配的最小单位</p>
<blockquote>
<p>索引中所说的读取的数据页（B-treee Node），就是这个页概念</p>
</blockquote>
</li>
</ol>
<h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p><strong>Error Log</strong></p>
<p>错误日志文件，错误日志文件记录了<code>MySQL</code>启动，运行，关闭等记录，同时包含一些警告信息，当发现<code>MySQL</code>有异常的时候，应该第一时间查看错误日志文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;log_error&#39;</span><br></pre></td></tr></table></figure>

<p><strong>Slow Log</strong></p>
<p>慢查询日志可以监控执行超过指定时间的<code>SQL</code>，从而记录到日志中，默认情况下<code>MySQL</code>并不启动慢查询日志，用户需要手工将这个参数设置为<code>ON</code>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;log_slow_queries&#39;;  &#x2F;&#x2F;查询是否开启慢查询日志</span><br><span class="line">ShOW VARIABLES LIKE &#39;long_query_time&#39;;    &#x2F;&#x2F;查询慢日志的阈值，默认10s</span><br><span class="line">SHOW VARIABLES LIKE &#39;log_queries_not_using_indexes&#39;; &#x2F;&#x2F;记录所有没有使用索引的SQL</span><br><span class="line">SHOW VARIABLES LIKE &#39;log_throttle_queries_not_using_indexes&#39;;  &#x2F;&#x2F;设置没有记录索引的SQL的运行次数阈值，只有超过这个阈值才记录</span><br><span class="line">SHOW VARIABLES LIKE &#39;log_output&#39;;         &#x2F;&#x2F;看出日志输出格式</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果数据量过多，可以设置<code>log_output</code>格式为<code>TABLE</code>，<code>MySQL</code>会将数据记录到<code>slow_log</code>表中</p>
</blockquote>
<p><strong>查询日志</strong></p>
<p>查询日志记录了所有对<code>MySQL</code>数据库的所有请求信息，无论这些请求是否得到了正确的执行。</p>
<blockquote>
<p>查询日志分为逻辑日志和物理日志，逻辑日志和物理日志的区别：</p>
<p>物理日志：最终的结果记录在文件中</p>
<p>逻辑日志：记录变化过程在文件中</p>
</blockquote>
<p><strong>Binary Log</strong>：</p>
<p><code>Binary Log</code>日志是<code>MySQL Server</code>层的逻辑（过程）日志文件（即不管什么存储引擎都会存在）</p>
<ul>
<li>以时间的形式记录了所有的<code>DDL</code>和<code>DML</code>语句操作</li>
<li>以文件追加的方式进行记录，没有大小的限制</li>
</ul>
<p><code>Binlog</code>默认是关闭的，需要手动启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Binary Log参数开启:</span><br><span class="line">log-bin &#x3D; 路径 </span><br><span class="line">binlog_format &#x3D; MIXED | ROW | STATEMENT  &#x2F;&#x2F;指定记录方式</span><br><span class="line">* Row ，记录每一行记录变化的SQL，生产环境建议使用                	-- 记录详细，占用空间大</span><br><span class="line">* Statement（默认），记录操作的SQL ，不会记录到每一条记录的变化    	-- 减少日志文件的大小</span><br><span class="line">* Mixed：对SQL进行区分和选择，使用哪种记录方式</span><br></pre></td></tr></table></figure>

<p>主要作用：</p>
<ul>
<li>数据恢复：通过二进制日志恢复数据</li>
<li>主从复制：在主从同步的时候，通过二进制日志，将主数据库信息同步到从数据库中</li>
<li>审计：通过二进制日志，可以统计操作，查看是否存在<code>SQL</code>注入</li>
</ul>
<p><strong>Redo Log</strong></p>
<p><code>Redo Log</code> 是存在<code>InnoDB</code>下的重做日志文件，记录的是事务提交过程中数据的变更情况，用于保证数据库服务意外中断，导致脏页数据未及时刷脏时，数据的恢复手段（即保证事务的一致性）</p>
<ul>
<li><p><code>Redo Log</code>是一组固定大小的文件，循环使用的，超过一定数据量，会被覆盖</p>
</li>
<li><p><code>Redo Log</code> 刷盘策略(buffer到log) ：<code>innodb_flush_log_at_trx_commit</code>的取值：默认为<code>1</code>：</p>
<p>刷盘过程为：<code>Buffer</code> —&gt; <code>OS Cache</code> —&gt; 磁盘</p>
<ul>
<li><p><code>0</code>：每秒写入<code>oscache</code>、写入磁盘</p>
<p><code>MySQL</code>服务宕机或者服务器宕机，导致一秒的事务失败</p>
<p>性能最好</p>
</li>
<li><p><code>1</code>：一次事务立刻写入<code>oscache</code> 且 立刻写入磁盘</p>
<p>宕机导致一次事务失败</p>
<p>安全性最高</p>
</li>
<li><p><code>2</code>：每一次事务请求都会写入<code>oscache</code>，<code>oscache</code>写入文件 采用每秒</p>
<p><code>MySQL</code>服务宕机，一次事务失败，服务器宕机，一秒事务失败</p>
<p>安全性和性能居中</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Redo Log Buffer</code> 为<code>Redo Log</code> 在内存中日志缓冲区，一旦<code>Redo Log Buffer</code>中的内容刷到了磁盘的<code>Redo Log</code>文件，事务成功</p>
<p><code>Redo Log Buffer</code>大小设定 ： <code>innodb_log_buffer_size</code>(默认<code>16M</code>)</p>
</blockquote>
<p><strong>Undo Log</strong></p>
<p><code>Undo Log</code> 是物理日志，主要应用在事务中，记录的是事务过程中每条数据的变化结果</p>
<p><code>Undo Log</code>的作用</p>
<ol>
<li><code>undo log</code>中记录的是用户操作的反向逻辑操作。设计初衷主要的作用是在事务异常中断，或者主动（<code>rollback</code>）过程中，我们可以基于<code>Undo Log</code>中记录的日志数据进行数据的回滚，保证 <strong>事务的原子性回滚</strong></li>
<li>由于<code>Undo Log</code>记录了事务操作过程中各个历史的版本，故而在数据的多版本控制层面，<code>Undo Log</code>中的数据可作为数据旧版本快照供其他并发事务进行快照读</li>
</ol>
<blockquote>
<p><code>undo log</code>的持久性保证也是通过<code>redo log</code>来实现，也就是<code>undo log</code>的产生会伴随着<code>redo log</code>的产生。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undo log&#96;默认保存在系统表空间（&#96;ibdata&#96;）中：&#96; innodb_undo_directory</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>在<code>InnoDB</code>中，主要包含3种索引：</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><p>在<code>InnoDB</code>中，索引通过<code>B+</code>树来实现，<code>B+</code>树作为索引的优点：</p>
<ul>
<li>非叶子节点不存储数据，使得每页能存储更多索引，减少<code>IO</code>的次数</li>
<li>叶子节点存在相互索引的指针，便于范围查找</li>
<li>性能稳定，每次查询都需要通过相同的次数才能获取到需要的数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/B%2BTree%E7%BB%93%E6%9E%84.png" alt="B+ Tree结构"></p>
<p>需要知道的是，在<code>InnoDB</code>中，<code>B+</code>树的节点对应的是表结构中的页(<code>Page</code>)，也就是每次<code>IO</code>都是读取<strong>数据页（B-Tree Node）</strong>一页的数据。</p>
<p><code>InnoDB</code>的这种按照索引的结构组织数据的数据表被称为<strong>索引组织表</strong>，<strong>索引组织表</strong>对应的索引被称为聚集索引，指的是索引和数据在逻辑上存储顺序相同，索引组织表的有点如下：</p>
<ul>
<li>数据的相关性大，因为数据都是按照主键顺序存放，因此需要查找可主键相关的数据时，只需要从磁盘读取少量数据就能获取全部相关信息。</li>
<li>数据访问更快，因为索引和数据存放在一起，因此在查找完索引后，就能直接获取到数据</li>
<li>使用索引覆盖扫描的查询可以直接使用叶节点的主键值</li>
</ul>
<p>索引组织表的缺点如下：</p>
<ul>
<li>插入速度严重依赖于插入顺序，如果插入的数据不是有顺的，则会导致<code>InnoDB</code>随机<code>IO</code>磁盘。</li>
<li>更新聚集索引的代价很高，因为数据是按照聚集索引的顺序存放，因此会强制移动所有被更新的行</li>
<li>聚集索引可能会导致全表扫描变慢</li>
<li>聚集索引会导致非聚集索引访问数据需要进行两次查找</li>
</ul>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>辅助索引也叫二级索引，是非聚集索引，其内部结构也是一颗<code>B+</code>树，不过和聚集索引不同的是，聚集索引的叶子节点存储的是数据，而辅助索引叶子节点存放的是聚集索引的<code>key</code>.这样就会带来一个问题就是对于辅助索引的查找，会存在一个二次回表的操作。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E5%9B%9E%E8%A1%A8.png" alt="回表"></p>
<p>比如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;小红&#x27;</span>;   //主键为`id`</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code>会先在<code>name</code>辅助索引上查找对应的<code>id</code>,然后再通过<code>id</code>在聚集索引中查找具体的数据。</p>
<p>如果一个<code>B+</code>树为3层，则此次查找就需要经过6次<code>IO</code></p>
<h4 id="索引的管理"><a href="#索引的管理" class="headerlink" title="索引的管理"></a>索引的管理</h4><p>查看索引： <code>SHOW INDEX FROM t_rule;</code>，返回结果如下：</p>
<ul>
<li><code>Table</code>: 对应的表</li>
<li><code>Non_unique</code>: 是否非唯一</li>
<li><code>Key_name</code>: 索引名</li>
<li><code>Seq_in_index</code>: 索引中，该列的位置</li>
<li><code>Cloum_name</code>: 索引的列的名称</li>
<li><code>Collection</code>: 索引存放方式，一般都是<code>A</code>,表示是<code>B+</code>树</li>
<li><code>Cardinality</code>：非常关键的值，表示索引中唯一值的数目的估计值。<code>Cardinality</code>与表的行数比应尽可能接近1，如果非常小，那么用户需要考虑是否可以删除此索引。</li>
<li><code>Sub_part</code>：是否是列的部分被索引。如果看idx_b这个索引，这里显示100，表示只对b列的前100字符进行索引。如果索引整个列，则该字段为NULL。</li>
<li><code>Packed</code>：关键字如何被压缩。如果没有被压缩，则为NULL。</li>
<li><code>Null</code>：是否索引的列含有NULL值。</li>
<li><code>Index_type</code>：索引的类型。<code>InnoDB</code>存储引擎只支持B+树索引，所以这里显示的都</li>
</ul>
<h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><ul>
<li>不是对于任何查询都适合添加索引的，<code>InnoDB</code>会判定索引的<code>Cardinality</code>值，当该值与数据库的行的比值过小时，<code>InnoDB</code>会忽略此索引,比如性别</li>
<li>索引不是越多越好，索引对于插入和修改存在一定的性能影响，因此对于索引的添加需要有一定的考量</li>
<li>最好在创建表的时候就创建索引，<code>MySQL</code>在线<code>DDL</code>会阻塞数据库</li>
<li>由于<code>B+</code>树的特殊性，因此对于联合索引，需要遵循最左匹配原则。</li>
<li>同理，由于辅助索引的二次回表的特性，对于辅助索引<code>name</code>,等效于<code>name,id</code>（<code>id</code>为主键）</li>
<li>可以利用索引覆盖原理，来避免二次回表，索引覆盖就是需要查询的字段，都在索引中能找到</li>
<li>如果对于数据库来说，二次回表查找的数据过多，导致性能低于全表扫描，<code>MySQL</code>可能会放弃使用索引</li>
</ul>
<h4 id="自适应Hash索引"><a href="#自适应Hash索引" class="headerlink" title="自适应Hash索引"></a>自适应Hash索引</h4><p>在<code>MySQL</code>中，对于等值查询，如果达到一定的条件，<code>MySQL</code>会在内部建立<code>Hash</code>索引优化查询速度，这种索引由<code>MySQL</code>自动建立，自己维护，因此又叫做自适应哈希（<code>AHI</code>,<code>Auto Hash Index</code>）索引，自适应哈索引建立的条件如下：</p>
<ul>
<li>需要对这个也得连续访问模式是一样的，比如<code>where a=xxx</code> 和<code>where a=xxx and b=xxx</code>属于两种访问模式</li>
<li>以同一个模式访问了100次</li>
<li>此页通过该模式访问了<code>N</code>次，其中N=页中记录数/16</li>
</ul>
<blockquote>
<p>InnoDB存储引擎官方文档显示，启用<code>AHI</code>后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。<code>AHI</code>的设计思想是数据库自优化，不需要<code>DBA</code>对数据库进行手动调整。</p>
</blockquote>
<h3 id="MySQL中SQL执行流程"><a href="#MySQL中SQL执行流程" class="headerlink" title="MySQL中SQL执行流程"></a>MySQL中SQL执行流程</h3><p><code>MySQL</code>中在未到存储引擎中的<code>SQL</code>执行过程如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/SQL%E7%9A%84%E6%89%A7%E8%A1%8C.png" alt="SQL的执行"></p>
<ol>
<li>缓存是否存在数据</li>
<li>词法分析、语法分析</li>
<li>最优执行计划生成</li>
<li>执行引擎调用API</li>
</ol>
<p><strong>InnoDB中SQL执行过程</strong>：</p>
<p><code>InnoDB</code>中存在表数据与索引数据的缓存：<code>Buffer Pool</code> ,在<code>SQL</code>执行的过程把磁盘上的数据加载到<code>BufferPool</code>,避免每次访问都进行磁盘IO，起到加速访问的作用</p>
<p><code>Buffer Pool</code> 的存储结构设计总体遵循<code>LRU(Least recently used)</code>的特性</p>
<p><code>Buffer Pool</code>缓存设计问题及解决：</p>
<p>设计问题： 基于空间局部性原理（预读），磁盘访问按数据库页大小读取能够提高性能，缓冲池按数据库页（<code>Innodb_page_size</code>）缓存数据，所以在<code>Buffer Pool</code>中，不仅要缓存实际使用到的数据，而且还需要缓存非目标数据和预读的数据</p>
<p>这就导致两个问题：预读失效 和 缓冲池污染</p>
<ul>
<li>预读失效：由IO操作的特性将未实际使用的数据加载到了<code>Buffer Pool</code>中缓存了，实际上后续却并未使用</li>
<li>缓冲池污染：可能SQL的执行需要扫描大量的页数据，为了缓存这些页数据，导致缓冲池中大量热点数据替换出去</li>
</ul>
<p>设计解决：</p>
<p>分代 + 老生代停留时间配置阈值</p>
<p><code>BufferPool</code> 的设计图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/BufferPool%E8%AE%BE%E8%AE%A1.png" alt="BufferPool的设计"></p>
<p>相关配置参数</p>
<ul>
<li><code>innodb_buffer_pool_size</code>（<code>BufferPool</code>的大小）</li>
<li><code>innodb_old_blocks_pct</code>（老生代和新生代的比值(老生代大小)）</li>
<li><code>innodb_old_blocks_time</code>（老生代停留时间配置阈值）</li>
</ul>
<p>在了解<code>Buffer Pool</code>后，<code>InnoDB</code>中的<code>DQL</code>和事务的执行过程</p>
<ol>
<li><p><code>DQL</code>执行过程：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/InnodbDQL%E6%93%8D%E4%BD%9C.png" alt="InnodbDQL执行过程"></p>
</li>
<li><p>事务执行过程：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/Innodb%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C.png" alt="Innodb事务实行过程"></p>
</li>
</ol>
<p>在<code>Innodb</code>的一次事务提交过程中，事务操作并不会马上将变更的数据刷新到磁盘中</p>
<p>在<code>Innodb</code>中事务的完结只需要将需要变更记录在<code>Buffer Pool</code>中(形成脏页)，完成<code>Redo Log</code>的记录即可</p>
<p>刷脏的时机：</p>
<ul>
<li><p>当<code>Redo Log</code> 写满时</p>
<p>参数：<code>innodb_log_files_in_group</code> 、 <code>innodb_log_file_size</code></p>
</li>
<li><p><code>Buffer Pool</code>空间不够使用时</p>
</li>
<li><p><code>MySQL</code>服务空闲状态</p>
</li>
<li><p><code>MySQL</code>正常关闭时</p>
<blockquote>
<p>脏页是指<code>Buffer Pool</code>记录的数据与磁盘中数据不一致的情况</p>
<p>刷脏是指刷脏线程将<code>BufferPool</code>中的脏页刷新落盘到磁盘的过程</p>
</blockquote>
</li>
</ul>
<h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><p>事务是数据库操作的最小工作单元，是作为单个逻辑工作执行的一些列操作；</p>
<p>事务是一组不可分割的操作集合（工作逻辑单元）：典型事务场景：转账</p>
<p><code>MySQL Innodb</code>事务的手工操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin &#x2F; start transaction        ---手工</span><br><span class="line">commit &#x2F; rollback                ---事务提交或回滚</span><br><span class="line">set session autocommit &#x3D; on&#x2F;off  ---设定事务是否自动开启</span><br><span class="line">commit &#x2F; rollback                ---事务提交或回滚</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7">事务的ACID四大特性</a></p>
<h4 id="MySQL原子性、一致性、持久性的实现"><a href="#MySQL原子性、一致性、持久性的实现" class="headerlink" title="MySQL原子性、一致性、持久性的实现"></a>MySQL原子性、一致性、持久性的实现</h4><p>在<code>MySQL</code>的<code>InnoDB</code>引擎中</p>
<p>通过<code>Undo Log</code>实现事务的原子性(<code>Atomicity</code>)</p>
<p>通过<code>Redo Log</code>实现事务的一致性(<code>Consistency</code>)和持久性(<code>Durability</code>)</p>
<blockquote>
<p><code>Redo Log</code>一致性和持久性的保证：</p>
<ul>
<li><p>正常情况：<code>WAL(Write-ahead logging)</code>+刷脏线程：保证数据恢复</p>
</li>
<li><p>刷脏过程出现页断裂（部分写入失败）时：使用双写机制</p>
<p><code>Double write</code>机制详解：<code>Doublewrite Buffer</code>是开在共享表空间的物理文件的<code>buffer</code>,其大小是2MB.</p>
<ul>
<li>刷脏操作开始之时,先进行脏页’备份’操作.将脏页数据写入<code>Doublewrite Buffer</code></li>
<li>将<code>Doublewrite Buffer</code>(顺序IO)写入磁盘文件中(共享表空间)</li>
<li>进行刷脏操作.(绝大多数是随机IO)</li>
<li><code>Double Write</code>机制其核心思想是:在刷脏之前,建立脏页数据的副本.系统意外宕机造成页断裂的情况可通过脏页数据副本(<code>DoubleWrite Buffer</code>)进行恢复</li>
</ul>
</li>
<li><p>刷脏过程未出现页断裂，也没有刷脏成功：通过<code>Redo Log</code>进行数据的持久化即可</p>
</li>
</ul>
</blockquote>
<h4 id="MySQL隔离性实现"><a href="#MySQL隔离性实现" class="headerlink" title="MySQL隔离性实现"></a>MySQL隔离性实现</h4><p><a target="_blank" rel="noopener" href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务的隔离级别</a></p>
<p><code>MySQL Innodb</code>中<code>RR</code>是默认的事务的默认隔离级别，并且<code>Innodb</code>中 <code>RR</code>级别可以解决幻读问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MySQL Innodb&#96;隔离级别解决方案：&#96;LBCC&#96; + &#96;MVCC</span><br></pre></td></tr></table></figure>

<p><strong>MVCC（Multi Version Concurrency Control）</strong></p>
<p>基于多版本快照的实现：事务并发访问数据时，对正在事务内处理的数据做多版本的管理，避免写操作的堵塞，从而引发读操作的并发阻塞问题，将数据在当下时间点进行一份数据快照（Snapshot）的备份（多版本的管理），并用这个快照来提供给其他事务进行一致性读取</p>
<p><code>MySQL</code>中<code>Undo log</code>保存了<code>MVCC</code>的数据来源</p>
<p><strong>快照读</strong>（<code>SQL</code>读取的数据为历史版本数据）：<code>SQL</code>读取的数据是快照版本，基于<code>MVCC</code></p>
<ul>
<li><p><code>DQL</code> 默认都是快照读</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">普通的select语句均为snapshot read(MVCC) </span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>LBCC（Lock Based Concurrency Control)</strong></p>
<p>基于锁并发的控制实现：事务开始操作数据前，对其加锁，阻止其他事务对数据进行修改，利用锁的排他性独占数据的操作权限。</p>
<p><strong>当前读</strong>（<code>SQL</code>操作的数据是最新数据）：<code>SQL</code>读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改，基于<code>LBCC</code></p>
<ul>
<li><p><code>DML</code>默认都是当前读</p>
</li>
<li><p><code>select</code>语句想要实现当前读：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span> | <span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>Innodb中的锁分类：</strong></p>
<ul>
<li><p>表锁</p>
<ul>
<li><p>意向锁（<code>Intention Locks</code>）</p>
<p>意向锁不是用来锁定数据的，而是用来告诉这个表中是否加了排他锁、共享锁，这样以后再创建表锁的时候不用去扫描表中排它锁、共享锁的状态，直接根据意向锁状态就可以知道是否可以创建，可以理解成一个标记。目的是为了提升加表锁的效率。</p>
<ul>
<li>意向共享锁(<code>Intention Shared Locks</code>，<code>IS</code>)一个数据行加共享锁前必须先取得该表的<code>IS</code>锁，意向共享锁之间是可以相互兼容的</li>
<li>意向排它锁(<code>Intention Exclusive Locks</code>，<code>IX</code>)一个数据行加排他锁前必须先取得该表的<code>IX</code>锁，意向排它锁之间是可以相互兼容的</li>
<li>意向锁(<code>IS</code>、<code>IX</code>)是<code>InnoDB</code>引擎操作数据之前自动加的，不需要用户干预意义：当事务操作需要锁表时，只需判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁</p>
<ul>
<li><p>共享锁（行锁）：<code>Shared Locks</code>，读锁（S锁）</p>
<p>多个事务对于数据可以共享访问，但不能操作修改</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM table WHERE id&#x3D;1 LOCK IN SHARE MODE  --加锁</span><br><span class="line"></span><br><span class="line">COMMIT &#x2F; ROLLBACK                                  --释锁</span><br></pre></td></tr></table></figure>
</li>
<li><p>排它锁（行锁）：<code>Exclusive Locks</code></p>
<p>写锁（X锁），事务获取了X锁，其他事务就不能再获取锁（S锁、X锁）</p>
<p>只有该获取了X锁的事务才可以对数据行进行读取和修改</p>
<p>使用方式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DML（UPDATE、DELETE、INSERT）自动增加排它锁        ---加锁</span><br><span class="line"></span><br><span class="line">SELECT * FROM table WHERE ... FROM UPDATE      ---加锁</span><br><span class="line"></span><br><span class="line">COMMIT &#x2F; ROLLBACK                              ---释锁</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>Innodb</code>行锁实现原理</p>
<ul>
<li><code>Innodb</code>的行锁是通过给<strong>索引的索引项加锁</strong>实现的</li>
<li><code>SQL</code>的执行基于索引的检索，<code>Innodb</code>才使用行锁，未使用索引检索的<code>SQL</code>执行<code>Innodb</code>将使用表锁</li>
<li>基于辅助索引检索的<code>SQL</code>，辅助索引及对应的主键索引都将锁定指定的索引项</li>
</ul>
</blockquote>
<p>行锁的具体实现：</p>
<ul>
<li><p>临键锁 <code>Next-key Locks</code></p>
<ul>
<li>当<code>SQL</code>执行按照索引进行数据的检索，且查询条件为范围查询（<code>between and</code> 、<code>&lt;</code>、<code>&gt;</code> 等）[执行计划 <code>type= range</code> ]，且有数据命中时，该<code>SQL</code>语句事务操作加上的行锁为<code>Next-key locks</code></li>
<li>具体实现：锁住命中记录区间+下一个区间（区间：左开右闭），<code>Next-key Locks=Gap Locks+ Record Locks</code></li>
<li><code>Innodb</code>隔级别<code>RR</code>级别默认的行锁算法，<code>RR</code>的隔离级别才有临键锁，可以解决幻读问题</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/Next-KeyLocks.png" alt="Next-key Locks"></p>
</li>
<li><p>间隙锁 <code>Gap Locks</code></p>
<ul>
<li>当<code>SQL</code>执行按照索引进行数据的检索时，但是执行过程中索引搜索查询条件的<strong>数据不存在</strong>时，这时<code>SQL</code>语句加上的锁即为 <code>Gap locks</code></li>
<li>具体实现：锁住数据不存在的区间（区间：左开右开）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/GapLocks.png" alt="Gap Locks"></p>
</li>
<li><p>记录锁 <code>Record Locks</code></p>
<ul>
<li>当<code>SQL</code>执行基于索引搜索，且按照等值匹配的方式进行数据的检索，且此时查询<strong>等值匹配</strong>且查询的数据命中存在，这是<code>SQL</code>语句加上的锁即为 <code>Record locks</code></li>
<li>具体实现：锁住命中的具体索引的索引项</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/RecordLocks.png" alt="Record Locks"></p>
</li>
</ul>
</li>
</ul>
<h3 id="MySQL优化方案"><a href="#MySQL优化方案" class="headerlink" title="MySQL优化方案"></a>MySQL优化方案</h3><p>对于<code>MySQL</code>来说，想要优化<code>MySQL</code>的时候，就需要理解前面的知识点。</p>
<p>优化<code>MySQL</code>，可以从各个方面入手：</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li><p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型，更小意味着更快。</p>
<p>例如：整型比字符操作代价更低，因为字符串涉及到字符集和校对规则问题</p>
</li>
<li><p>通常情况下最好指定列为<code>NOT NULL</code>，除非真的需要存储<code>NULL</code>值</p>
<p>对于<code>MySQL</code>来说，可以为<code>NULL</code>的列更难优化，因此<code>NULL</code>会影响索引，索引统计和值的比较等，可以为<code>NULL</code>的列会使用更多的存储空间。当对可为<code>NULL</code>的列建立索引的时候，每个索引记录都需要额外使用一个直接。</p>
</li>
<li><p>对于浮点类型，优先选择<code>FLOAT</code>,<code>DOUBLE</code>,只有在真正需要<code>DECIMAL</code>的时候才使用<code>DECIMAL</code>,如果数据量过大的时候，可以考虑使用<code>BIGINT</code>代替<code>DECIMAL</code></p>
</li>
<li><p>注意使用<code>VARCHAR</code></p>
<p>由于<code>VARCHAR</code>类型是一个边长字符串，因此如果这个字符串长度会频繁变化的话，会给<code>MySQL</code>带来内存碎片的问题，同时其在临时表和排序时可能导致悲观的按最大长度分配内存。</p>
</li>
<li><p>定义表的时候，对于浮点型不要指定进度，对于整数，不要指定宽度</p>
<p>在<code>MySQL</code>中对浮点数指定精度会使得<code>MySQL</code>悄悄选择不同的数据类型，或者在存储时对值进行取舍。而这些精度定义是非标准的，因此最好的做法就是只指定数据类型，不指定精度。</p>
</li>
<li><p>注意<code>count(*)</code>和<code>count(字段)</code>的区别在于前者会统计<code>NULL</code>，而后者不会统计<code>NULL</code></p>
</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>说到<code>MySQL</code>优化，可能第一想法就是加索引，因为使用索引能将性能提高几个数量级，但是索引不是万能的，有时候有些场景可能并不适合使用索引，使用索引，首先需要遵从下面的原则：</p>
<ul>
<li>联合索引需要遵从最左匹配原则</li>
<li>对于很长的值，则可以选择使用前缀索引</li>
<li>通常来说，对于联合索引，将选择性更高的索引放在前面可以更好的避免随机<code>IO</code></li>
</ul>
<p><strong>索引覆盖：</strong></p>
<p>可以将需要获取的数据都添加索引，从而实现仅仅通过索引就能获取需要的数据，避免二次回表。例如：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,sex <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;dcc&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>正常来说，如果只建立了<code>name</code>的索引，那么<code>InnoDB</code>再通过二级索引<code>name</code>查找到<code>dcc</code>后，会获取聚集索引<code>id</code>，然后再通过<code>id</code>查找聚集索引来获取具体的数据行。这就是二次回表。</p>
<p>而如果建立的索引是<code>(name,sex)</code>，那么在查找到<code>name</code>为<code>dcc</code>的节点后，就能直接通过二级索引找到<code>sex</code>的值，这样就避免了二次回表，从而带来性能的提升。</p>
<p>使用索引覆盖能解决一些不好优化的问题：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对于<code>MySQL</code>,这种通配符开头的模糊查询，是不会走索引的。</p>
<p>但是如果把<code>name</code>加上索引，又由于<code>id</code>是主键，因此上述查询可以直接通过索引覆盖就能完成，因此可以通过索引覆盖是的上述语句走索引。</p>
<p><strong>延迟关联</strong>：</p>
<p>明白了索引覆盖的原理后，后续一些优化就可以通过索引覆盖来实现：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对比这条<code>SQL</code>和上面的<code>SQL</code>，唯一的区别就是需要获取的数据不同，<code>SELECT *</code>如果列比较多的话，很可能无法实现索引覆盖，那对于这样的查询，应该如何优化呢？</p>
<p>我们可以使用延迟关联：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student s <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>) <span class="keyword">AS</span> s1 <span class="keyword">ON</span>  s.id = s1.id;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过前面的例子我们知道，子语句是会走索引的，而外层查询<code>id</code>是主键，也是会走索引的， 因此这条<code>SQL</code>就被完全优化成走<code>SQL</code>的索引。</p>
<blockquote>
<p>延迟关联只是一种优化思路，其实在<code>MySQL</code>5.6 推出<code>ICP</code>(默认打开)后，有些情况就可以直接通过<code>ICP</code>解决，因为<code>ICP</code>会自动将<code>where</code>过滤条件下沉到存储引擎，存储引擎则可以直接通过索引过滤掉相应的数据。但是<code>ICP</code>也有相应的限制，关于<code>ICP</code>后续详细介绍</p>
</blockquote>
<p><strong>索引的调试：</strong></p>
<p>对于一个查询，是否走了索引，索引的类型是什么，走的联合索引还是部分索引，这些都需要结合<code>SQL</code>进行分析，而在<code>MySQL</code>中，最好分析的索引的方法便是查看执行计划：<code>EXPLAIN</code></p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">class</span>=<span class="string">&#x27;17&#x27;</span> <span class="keyword">AND</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该<code>SQL</code>返回的字段如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">id： 1</span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: t_student</span><br><span class="line">partions: NULL</span><br><span class="line">type: ref</span><br><span class="line">possible_keys:idx_class</span><br><span class="line">key:idx_class</span><br><span class="line">key_len:43</span><br><span class="line">ref:const</span><br><span class="line">rows:749</span><br><span class="line">filterd:11.11</span><br><span class="line">Extra: using index</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里简单说下几个重要的字段：</p>
<ul>
<li><code>type</code>: 表示查询的方式，常见的值有：<ul>
<li><code>ALL</code>:全表扫描</li>
<li><code>index</code>: 索引扫描</li>
<li><code>range</code>: 选择索引的范围进行扫描</li>
<li><code>ref</code>: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><code>eq_ref</code>: 类似<code>ref</code>,区别在于使用的是唯一索引</li>
<li><code>const,system</code>: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。例如<code>where id=xxx</code></li>
</ul>
</li>
<li><code>Key</code>: <code>MySQL</code>实际使用的索引</li>
<li><code>rows</code>:表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
<li><code>Extra</code>:<ul>
<li><code>Using where</code>:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</li>
<li><code>Using temporary</code>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 <code>group by ; order by</code></li>
<li><code>Using filesort</code>：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</li>
<li><code>Using join buffer</code>：强调在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</li>
<li><code>Using index condition</code>: 使用了<code>ICP</code></li>
</ul>
</li>
</ul>
<h4 id="MySQL自带的优化"><a href="#MySQL自带的优化" class="headerlink" title="MySQL自带的优化"></a>MySQL自带的优化</h4><p>在<code>MySQL</code>中，也自带一些优化方案，这些优化策略都是<code>MySQL</code>自带了，了解他们可以避免一些无效优化：</p>
<p><strong>Change Buffer</strong></p>
<p>前面说过，对于聚集索引，存在的一个缺点就是如果插入的数据是无序的，那么可能导致<code>InnoDB</code>随机写磁盘，这样会带来性能问题。</p>
<p>因此在<code>InnoDB</code>中，使用了<code>Change Buffer</code>，<code>Change Buffer</code>会将插入的数据暂时缓存，然后将里面的数据进行排序，最后再进行插入/修改，这样就能减少插入离散数据带来的性能问题。</p>
<p>但是不要过分依赖<code>Change Buffer</code>，如果数据量过大，则可能导致<code>Change Buffer</code>被装满，那么后面的数据依然是离散的，因此如果要插入大量的数据，可以考虑先在代码中排序，然后再插入。</p>
<p><strong>ICP</strong></p>
<p><code>ICP,(Index Condition PushDown,索引条件下推)</code>： 原本对于<code>MySQL</code>来说，有些过滤条件不会推送到存储引擎，因此对于一条查询:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">&#x27;Anneke&#x27;</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%Preusig&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>MySQL</code>会先将<code>first_name=&#39;AnneKe&#39;</code>下推到<code>InnoDB</code>，<code>InnoDB</code>则通过索引查找所有符合要求的数据并返回给<code>MySQL</code>,<code>MySQL</code>拿到数据后，再过滤不满足<code>last_name LIKE &#39;%Preusig&#39;</code>的条件。</p>
<p>这样带来的问题就是存储引擎上推的数据比较大，并且经过了两次过滤。</p>
<p>当开启<code>ICP</code>过后，<code>MySQL</code>会将两个条件都下推给<code>InnoDB</code>，<code>InnoDB</code>可以直接通过索引过滤到所有的数据，直接返回正确的结果。</p>
<p>使用执行过程分析的时候，如果使用了<code>ICP</code>,则<code>Extra</code> 会返回<code>Using index condition</code></p>
<p><code>ICP</code>的生效条件如下：</p>
<ol>
<li>当<code>sql</code>需要全表访问时，<code>ICP</code>的优化策略可用于<code>range, ref, eq_ref, ref_or_null</code>类型的访问数据方法 。</li>
<li>支持InnoDB和MyISAM表。</li>
<li>ICP只能用于二级索引，不能用于主索引。</li>
<li>并非全部<code>where</code>条件都可以用<code>ICP</code>筛选，如果<code>where</code>条件的字段不在索引列中，还是要读取整表的记录到<code>server</code>端做<code>where</code>过滤。</li>
<li><code>ICP</code>的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。</li>
<li>当<code>sql</code>使用覆盖索引时，不支持<code>ICP</code>优化方法。</li>
</ol>
<p><strong>MRR</strong></p>
<p><code>MRR,(Multi-Range Read Optimization)</code> ,<code>MRR</code>和<code>Chaneg Buffer</code>有异曲同工之妙，在没有开启<code>MRR</code>的时候，如果通过聚集索引读取数据，那样是顺序查找，性能比较高，但是对于二级索引的顺序查找，如果再经过二次回表，可能会变成离散<code>IO</code>:</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> birthday&lt;<span class="number">2019</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如上述<code>SQL</code>,<code>birthday</code>是二级索引，<code>id</code>为主键索引。</p>
<p>在<code>InnoDB</code>中，会首先通过<code>birthday</code>的索引查询满足<code>birthday&lt;2019</code>的主键<code>id</code>，由于查询是按照<code>birthday</code>排序的，比如<code>2019,2018,2017,2016</code>，因此返回的主键<code>id</code>则可能是无序的，比如<code>199,1,200,23,3,5040,188</code>,那么再通过<code>id</code>获取所有的数据的时候，就变成了离散读取。</p>
<p><code>MRR</code>的思想就很简单，开启<code>MRR</code>之后，<code>MySQL</code>会将所有返回的主键先进行排序，然后再进行回表。这样就避免了离散读取的问题。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><ul>
<li><code>DQL</code>语句：单指查询<code>sql</code></li>
<li><code>DML</code>: 数据操作语言，<code>update</code> 、 <code>delete</code>、<code>insert</code></li>
<li><code>DDL</code>：数据结构定义,建表、建库、创建视图</li>
<li><code>DCL</code>：数据操控、控制语言：给用户赋予查询、修改等赋权相关操作</li>
</ul>
<h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><ul>
<li><p>原子性（<code>Atomicity</code>）</p>
<ul>
<li>最小的工作单元，要么一起提交成功，要不全部失败回滚</li>
</ul>
</li>
<li><p>一致性（<code>Consistency</code>）</p>
<ul>
<li>事务中操作的数据改变是符合预期的，数据的中间态无需对外暴露，结果符合预期即可</li>
</ul>
</li>
<li><p>隔离性（<code>Isolation</code>）</p>
<ul>
<li><p>并发访问场景下事务间共享的数据可见性设定带来的问题</p>
</li>
<li><p>隔离性带来的问题主要是：脏读、不可重复读、幻读</p>
<ul>
<li><p>脏读：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E8%84%8F%E8%AF%BB.png" alt="脏读"></p>
</li>
<li><p>不可重复读：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="不可重复读"></p>
</li>
<li><p>幻读：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E5%B9%BB%E8%AF%BB.png" alt="幻读"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>持久性（<code>Durability</code>）</p>
<ul>
<li>事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><code>ANSI/ISO</code>标准：</p>
<ul>
<li><p><code>Read Uncommitted</code>(未提交读)</p>
<p>事务未提交对其他事务也是可见的</p>
<blockquote>
<p>未解决并发问题，依然存在脏读、不可重复读、幻读问题</p>
</blockquote>
</li>
<li><p><code>Read Committed</code>(提交读)</p>
<p>一个事务开始之后，只能看到自己提交的事务所做的修改</p>
<blockquote>
<p>解决脏读问题，依然存在不可重复读、幻读问题</p>
</blockquote>
</li>
<li><p><code>Repeatable Read</code>(可重复读)</p>
<p>在同一个事务中多次读取同样的数据结果是一样</p>
<blockquote>
<p>解决脏读、不可重复读问题，依然存在幻读问题</p>
</blockquote>
</li>
<li><p><code>Serializable</code>(串行化)</p>
<p>最高的隔离级别，通过强制事务的串行执行</p>
<blockquote>
<p>隔离性问题都解决</p>
</blockquote>
</li>
</ul>
<p>参考资料</p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6869029652623523848">MySQL总结-掘金</a></p>
<p><a target="_blank" rel="noopener" href="https://www.codenong.com/cs110441924/">MySQL事务隔离级别的实现原理——LBCC + MVCC （InnoDB）</a></p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/MySQL/" rel="tag"># MySQL</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2021/05/27/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/" rel="prev" title="网络基本概念">
      <i class="fa fa-chevron-left"></i> 网络基本概念
    </a></div>
      <div class="post-nav-item">
    <a href="/2021/11/08/Linux/Linux%E5%85%A5%E9%97%A8/" rel="next" title="Linux入门">
      Linux入门 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="nav-number">1.</span> <span class="nav-text">MySQL体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB"><span class="nav-number">1.1.</span> <span class="nav-text">存储引擎:InnoDB</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E6%96%87%E4%BB%B6"><span class="nav-number">2.</span> <span class="nav-text">MySQL文件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6"><span class="nav-number">2.1.</span> <span class="nav-text">表结构定义文件</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6"><span class="nav-number">2.2.</span> <span class="nav-text">日志文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E7%B4%A2%E5%BC%95"><span class="nav-number">3.</span> <span class="nav-text">MySQL索引</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#B-%E6%A0%91%E7%B4%A2%E5%BC%95"><span class="nav-number">3.1.</span> <span class="nav-text">B+树索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95"><span class="nav-number">3.2.</span> <span class="nav-text">辅助索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%A1%E7%90%86"><span class="nav-number">3.3.</span> <span class="nav-text">索引的管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="nav-number">3.4.</span> <span class="nav-text">索引的使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%87%AA%E9%80%82%E5%BA%94Hash%E7%B4%A2%E5%BC%95"><span class="nav-number">3.5.</span> <span class="nav-text">自适应Hash索引</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-number">4.</span> <span class="nav-text">MySQL中SQL执行流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%BA%8B%E5%8A%A1"><span class="nav-number">5.</span> <span class="nav-text">MySQL事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.1.</span> <span class="nav-text">MySQL原子性、一致性、持久性的实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E9%9A%94%E7%A6%BB%E6%80%A7%E5%AE%9E%E7%8E%B0"><span class="nav-number">5.2.</span> <span class="nav-text">MySQL隔离性实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MySQL%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="nav-number">6.</span> <span class="nav-text">MySQL优化方案</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%AD%E6%B3%95"><span class="nav-number">6.1.</span> <span class="nav-text">语法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%B4%A2%E5%BC%95"><span class="nav-number">6.2.</span> <span class="nav-text">索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#MySQL%E8%87%AA%E5%B8%A6%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">6.3.</span> <span class="nav-text">MySQL自带的优化</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%99%84%E5%BD%95"><span class="nav-number">7.</span> <span class="nav-text">附录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#SQL%E5%88%86%E7%B1%BB"><span class="nav-number">7.1.</span> <span class="nav-text">SQL分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="nav-number">7.2.</span> <span class="nav-text">事务的四大特性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="nav-number">7.3.</span> <span class="nav-text">事务隔离级别</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">张玉莹</p>
  <div class="site-description" itemprop="description">路漫漫其修远兮 吾将上下而求索</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">185</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张玉莹</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
