<!DOCTYPE html>
<html lang="">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"zhangyuying.cn","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="对于程序语言的设计者来说，创建一个好的输入&#x2F;输出（I&#x2F;O）系统是一项艰难的任务">
<meta property="og:type" content="article">
<meta property="og:title" content="JAVA编程思想：十八-Java I&#x2F;O系统">
<meta property="og:url" content="http://zhangyuying.cn/2019/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%85%AB-Java-I-O%E7%B3%BB%E7%BB%9F/index.html">
<meta property="og:site_name" content="张玉莹的个人博客">
<meta property="og:description" content="对于程序语言的设计者来说，创建一个好的输入&#x2F;输出（I&#x2F;O）系统是一项艰难的任务">
<meta property="og:locale">
<meta property="article:published_time" content="2019-04-16T16:07:11.000Z">
<meta property="article:modified_time" content="2023-03-28T02:25:12.768Z">
<meta property="article:author" content="张玉莹">
<meta property="article:tag" content="《Thinking in Java》">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://zhangyuying.cn/2019/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%85%AB-Java-I-O%E7%B3%BB%E7%BB%9F/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'default'
  };
</script>

  <title>JAVA编程思想：十八-Java I/O系统 | 张玉莹的个人博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">张玉莹的个人博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/aboutme/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="Searching..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="default">
    <link itemprop="mainEntityOfPage" href="http://zhangyuying.cn/2019/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%85%AB-Java-I-O%E7%B3%BB%E7%BB%9F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="张玉莹">
      <meta itemprop="description" content="路漫漫其修远兮 吾将上下而求索">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张玉莹的个人博客">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JAVA编程思想：十八-Java I/O系统
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2019-04-17 00:07:11" itemprop="dateCreated datePublished" datetime="2019-04-17T00:07:11+08:00">2019-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2023-03-28 10:25:12" itemprop="dateModified" datetime="2023-03-28T10:25:12+08:00">2023-03-28</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>对于程序语言的设计者来说，创建一个好的输入/输出（<code>I/O</code>）系统是一项艰难的任务</p>
<span id="more"></span>

<h4 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h4><p><code>File</code> 既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称（<code>File</code>是文件和目录路径名的抽象形式）</p>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/test.txt/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 可以回去文件信息：file.getName()、file.length()、file.isFile()、file.isDirectory() 等等</span></span><br><span class="line">   </span><br><span class="line">	 <span class="comment">// 创建目录</span></span><br><span class="line">     File filedir = <span class="keyword">new</span> File(<span class="string">&quot;D:/test/test&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(!filedir.exists())&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;路径不存在&quot;</span>);</span><br><span class="line">         filedir.mkdirs();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//可以获取目录信息：filedir.isDirectory()、filedir.isFile()、filedir.list().length等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Java</code>中，<code>File </code>类是 <code>java.io </code>包中唯一代表磁盘文件本身的对象。</p>
<p><code>File</code>类主要用来获取或处理与磁盘文件相关的信息，像文件名、 文件路径、访问权限和修改日期等，还可以浏览子目录层次结构。</p>
<p><code>File </code>类表示处理文件和文件系统的相关信息。也就是说，<code>File</code> 类不具有从文件读取信息和向文件写入信息的功能，它仅描述文件本身的属性。</p>
<h4 id="2-输入和输出"><a href="#2-输入和输出" class="headerlink" title="2.输入和输出"></a>2.输入和输出</h4><p>编程语言的<code>I/O</code>类库中常使用“流’’这个概念，它代表任何有能力产出数据的数据源对象或者有能力接收数据的接收端对象，“流”屏蔽了实际的<code>I/O</code>设备中处理数据的细节</p>
<p><code>java</code>类库中的<code>I/O</code>类分成输入和输出两部分：</p>
<ul>
<li>任何自<code>InputStrean</code>或<code>Reader</code>派生而来的类都含有名为<code>read()</code>的基本方法，用于读取单个字节或者字节数组</li>
<li>任何自<code>OutputStream</code>或<code>Writer</code>派生而来的类都含有名为<code>write()</code>的基本方法，用于写单个字节或者字节数组</li>
</ul>
<p>不过，我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供期望的功能(装饰器模式)</p>
<p><code>java</code>中“流”让人困惑的主要原因就在于：创建单一的结果流，却需要创建多个对象</p>
<p><strong><code>InputStrean</code>类型</strong></p>
<p><code>InputString</code>的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：</p>
<ul>
<li>子节数组（<code>ByteArrayInputStream</code>）</li>
<li><code>String</code>对象（<code>StringBufferInputStream</code>:已弃用）</li>
<li>文件（<code>FileInputStream</code>）</li>
<li>“管道”，工作方式与实际管道相似，即：从一端输入，从另一端输出（<code>PipedInputStream</code>）</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内（<code>SequenceInputStream</code>）</li>
<li>其他数据源，如<code>Internet</code>连接等</li>
</ul>
<p>每一种数据源都有相应的<code>InputStream</code>子类</p>
<p><code>FilterInputStream</code>也属于一种<code>InputStream</code>，为“装饰器”类提供基类，其中“装饰器”类可以把属性或有用的接口与输入流连接在一起</p>
<p><strong><code>OutputStream</code>类型</strong></p>
<p>该类别的类决定了输出所要去往的目标：</p>
<ul>
<li>子节数组(但不是<code>String</code>,不过可以用子节数组自己创建)（<code>ByteArrayOutputStream</code>）</li>
<li>文件（<code>FileOutputStream</code>）</li>
<li>管道（<code>PipeOutputStream</code>）</li>
</ul>
<p><code>FilterOutputStream</code>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来</p>
<h4 id="3-添加属性和有用的接口"><a href="#3-添加属性和有用的接口" class="headerlink" title="3.添加属性和有用的接口"></a>3.添加属性和有用的接口</h4><p><code>java I/O</code>需要多种不同功能的组合，这正是使用装饰器模式的理由所在</p>
<p>装饰器模式也有一个缺点：在编写程序时，他给我们提供了相当多的灵活性（因为我们可以很容易的混合和匹配属性），但是他同样也增加了代码的复杂性</p>
<p>通过<code>FilterInputStream</code>从<code>InputStream</code>读取数据：</p>
<p><code>FilterInputStream</code>类能够完成两件完全不同的事情：</p>
<ul>
<li><code>DataInputStream</code>允许我们读取不同的基本类型数据以及<code>String</code>对象(所有方法都以<code>read</code>开头，例如<code>readByte()</code>等等)，搭配相应的<code>DataOutputStream</code>,我们就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方</li>
<li>其他的<code>FilterInputStream</code>类则在内部修改<code>InputStream</code>的行为方式：是否缓冲、是否保留读过的行等等（其他的<code>FilterInputStream</code>例如：<code>BufferedInputStream</code>）</li>
</ul>
<p>通过<code>FilterOutputStream</code>向<code>OutStream</code>写入：</p>
<p><code>FilterInputStream</code>类包括：</p>
<ul>
<li><p><code>DataOutputStream</code>：与<code>DateInputStream</code>对应的是<code>DataOutputStream,</code>他可以将各种基本数据类型以及<code>String</code>对象格式化输出到“流”中，这样一来，任何机器上的<code>DataInputStream</code>都能够读取他们，所有方法都以<code>write</code>开头，例如<code>writeByte()</code>等等</p>
</li>
<li><p><code>PrintStream</code>的目的是为了格式化输出（<code>DataOutputStream</code>的目的时间数据元素置入“流”中，使<code>DateInputStream</code>能够可移植的重构他们）</p>
<p><code>PrintStream</code>是有一些问题的：一个是捕捉了所有<code>IOException</code>(因为我们必须使用<code>checkErrors</code>自行的检查错误状态)，二是为完全国际化，不能以平台无关的方式处理换行动作（这些问题在<code>printWrite</code>中得到了解决）</p>
</li>
<li><p><code>BufferedOutputStream</code>:对数据使用缓存技术，每次像流写入时，不必每次都进行实际的物理写动作，在输出时，我们可能经常使用它</p>
</li>
</ul>
<h4 id="4-Reader和Writer"><a href="#4-Reader和Writer" class="headerlink" title="4.Reader和Writer"></a>4.<code>Reader</code>和<code>Writer</code></h4><p><code>Reader</code>和<code>Writer</code>是提供兼容<code>Unicode</code>与<strong>面向字符</strong> 的<code>I/O</code>功能</p>
<p>有时候我们需要把字节流的类和字符流的类结合起来使用，为了实现这个目的，要用到适配器类：<code>InputStreamReader</code>可以把<code>InputStream</code>转换为<code>Reader</code>,而<code>OutputStreamWriter</code>可以把<code>OutputStream</code>转换为<code>Writer</code></p>
<p>设计<code>Reader</code>和<code>Writer</code>主要是为了支持国际化，之前的子节流继承结构只支持<code>8</code>位的子节流，不能很好地处理<code>16</code>位的<code>Unicode</code>字符</p>
<p>几乎所有原始的<code>java I/O</code>流类都有相应的<code>Reader</code>和<code>Writer</code>类，来提供天然的<code>Unicode</code>操作</p>
<p>但是有时我们还是需要使用字节流，例如<code>java.util.Zip</code>类库就是面向字节的而不是面向字符的，因此最明智的做法是尽量尝试使用<code>Reader</code>和<code>Writer</code>一旦代码无法成功编译，我们就知道不得不使用面向字节的类库</p>
<p>无论何时我们使用<code>readLine()</code>都不应该使用<code>DataInputStream</code>(过时方法)，而应该使用<code>BufferedReader</code>,除了这一点，<code>DataInputStream</code>仍是I/O类库的首选成员</p>
<h4 id="5-自我独立的类：RandomAccessFile"><a href="#5-自我独立的类：RandomAccessFile" class="headerlink" title="5.自我独立的类：RandomAccessFile"></a>5.自我独立的类：<code>RandomAccessFile</code></h4><p><code>RandomAccessFile</code>不是<code>InputStream</code>和<code>OutputStream</code> 继承层次结构中的一部分，除了实现了<code>DataInput</code>和<code>DateOutput</code>接口（<code>DataInputStream</code>和<code>DataOutputStream</code>也实现了这两个接口）之外，无其他关联</p>
<p><code>RandomAccessFile</code>的工作方式类似于把<code>DataInputStream</code>和<code>DataOutputStream</code>组合起来使用，还添加了一些方法：例如<code>getFilepointer()</code>(查找当前所处的文件位置)</p>
<p>只有<code>RandomAccessFile</code>支持搜寻方法，并且只适用于文件（<code>BufferedInputStream</code>能允许标注位置(<code>mark()</code>),其值存储于内部某个简单变量内）和重新设定位置(<code>reaset()</code>),这些功能很有限，不是非常有用</p>
<p>在<code>JDK1.4</code>中，<code>RandomAccessFile</code>的大多数功能（不是全部）由<code>nio</code>存储映射文件所取代</p>
<h4 id="6-I-O流的典型使用方式"><a href="#6-I-O流的典型使用方式" class="headerlink" title="6.I/O流的典型使用方式"></a>6.<code>I/O</code>流的典型使用方式</h4><ul>
<li><p>1.缓冲输入文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">in.readLine()</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.从内存输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">StringReader in = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">&quot;Test.java&quot;</span>));</span><br><span class="line">in.read()</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.格式化的内存输入</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(BufferedInputFile.read(<span class="string">&quot;Test.java&quot;</span>).getBytes()));</span><br><span class="line">System.out.print(in.readByte());</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.基本的文件输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;Test.out&quot;</span>)));</span><br><span class="line">out.println(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//JAVA SE5在PrintWriter添加了一个辅助构造器，不必自己执行所有装饰工作，不过其他的常见写入任务没有快捷方式</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;Test.out&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.存储和恢复数据</p>
<p><code>PrintWriter</code>可以对数据进行格式化，以便人们的阅读，但是为了输出可供另一个“流”恢复的数据，我们需要用<code>DataOutputStream</code>写入数据，并用<code>DataInputStream</code>恢复数据</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">out.writeUTF(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">out.close();</span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">System.out.println(in.readUTF());</span><br></pre></td></tr></table></figure>

<p>不过，对象序列化和<code>XML</code>可能是更容易的存储和读取复杂数据结构的方式</p>
</li>
<li><p>6.读写随机访问文件</p>
<p><code>RandomAccessFile</code>中，利用<code>seek()</code>可以在文件中到处移动，并修改文件中的某个值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器的第二个参数：r:只读，rw:读写</span></span><br><span class="line">RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">rf.writeUTF(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">rf.close();</span><br><span class="line">display();</span><br><span class="line">RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">rf.seek(<span class="number">5</span>*<span class="number">8</span>);<span class="comment">//double是8个字长，方法的意思是查找第五个双精度的值</span></span><br><span class="line">rf.writeDouble(<span class="string">&quot;50.0&quot;</span>);</span><br><span class="line">display();</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.管道流</p>
<p>多线程中更能体现他的价值，因为管道流用于任务之间的通信</p>
</li>
</ul>
<h4 id="7-标准I-O"><a href="#7-标准I-O" class="headerlink" title="7.标准I/O"></a>7.标准<code>I/O</code></h4><p>标准<code>I/O</code>这个术语是参照<code>Unix</code>中的“程序所使用的单一信息流”这个概念。</p>
<ul>
<li>程序的所有输入都可以来自于标准输入</li>
<li>程序的所有输出都可以发送到标准输出</li>
<li>程序的所有错误信息都可以发送到标准错误</li>
</ul>
<p>标准<code>I/O</code>的意义在于：我们可以很容易的把程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入</p>
<p>按照标准<code>I/O</code>的模型，<code>java</code>提供了<code>System.in</code>、<code>System.out</code>、<code>System.err</code></p>
<ul>
<li><p><code>System.out</code>：标准输出，已经被包装成了<code>printStream</code>对象</p>
<p><code>System.out</code>可以被转化为<code>PrintWriter</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造器的第二个参数要设置为true,以便开启自动清空功能，否则可能看不到输出</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>System.err</code>：标准错误，已经被包装了成<code>printStream</code>对象</p>
</li>
<li><p><code>System.in</code>：标准输入，没有被包装过的，未被加工的<code>InputStream</code>。所以：我们可以立即使用<code>System.out</code>和<code>System.err</code>，但是在读取<code>System.in</code>之前必须对其进行包装，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));<span class="comment">//System.in和大多数流一样，通常应该对它进行缓冲</span></span><br><span class="line">in.readLine();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>标准<code>I/O</code>的重定向：<code>System</code>类提供了一些静态方法，允许对标准输入、输出、错误<code>I/O</code>流进行重定向</p>
<ul>
<li><code>setIn(InputStream)</code></li>
<li><code>setOut(PrintStream)</code></li>
<li><code>setErr(PrintStream)</code></li>
</ul>
<p>当输出滚动太快导致无法阅读或者想重复测试某个特定用户的输入序列的命令行程序的时候，重定向输出就显得尤为有用</p>
<p>需要注意的是：<code>I/O</code>重定向操纵的是字节流，而不是字符流。</p>
<h4 id="8-新I-O"><a href="#8-新I-O" class="headerlink" title="8.新I/O"></a>8.新<code>I/O</code></h4><p><code>JDK 1.4</code>的<code>java.nio.*</code>包中引入了新的<code>javaI/O</code>类库，其目的主要在于提高速度</p>
<p>实际上旧的<code>I/O</code>包已经使用<code>nio</code>重新实现过，以便充分的利用这种速度的提高，因此即使我们没有显示的使用<code>nio</code>编写代码，也能从其中受益</p>
<p>速度的提高在文件<code>I/O</code>和网络<code>I/O</code>中都存在，我们研究前者</p>
<p>速度的提高来自于所使用的结构更接近于操作系统执行<code>I/O</code>的方式：通道和缓冲器</p>
<p>唯一直接与通道交互的缓存器是<code>ByteBuffer</code>（也就是说：可以存储未加工字节的缓冲器）</p>
<p>旧<code>I/O</code>类库中有三个类被修改了，用以产生<code>FileChannel</code>。这三个类为：<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code>，注意这些是子节操作流和底层的<code>nio</code>性质一致，<code>Reader</code>和<code>Writer</code>这种字符模式类不能用于产生通道，但是<code>java.nio.channels.Channels</code>类提供了实用方法，用以在通道中产生<code>Reader</code>和<code>Writer</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>).getChannel();</span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">&quot;some String&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>

<p>通道是一种相当基础的东西：可以向它传送用于读写的<code>ByteBuffer</code>,并且可以锁定文件的某些区域用于独占式访问。</p>
<p>将字节存放于<code>ByteBuffer</code>的方法之一是：</p>
<ul>
<li>使用一种<code>“put”</code>方法直接对他们进行填充，填入一个或多个字节，或基本数据类型的值</li>
<li>使用<code>warp()</code>方法将已存在的字节数组“包装”到<code>ByteBuffer</code>中，一旦如此，就不再复制底层的数组，而是把它作为所产生的<code>ByteBuffer</code>的存储器，我们称之为数组支持的<code>ByteBuffer</code></li>
</ul>
<p>特殊方法<code>transferTo()</code>和<code>transferFrom()</code>允许我们将一个通道和另一个通道直接相连</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileChannel in = <span class="keyword">new</span> FileInputStram(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">  out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">in.transferTo(<span class="number">0</span>,in.size,out);</span><br></pre></td></tr></table></figure>

<p>转换数据：缓冲器容纳的是普通的子节，为了把它们转换城字符，我们要么在输入它们的时候对其进行编码（这样，它们输出时才具有意义），要么在将其从缓冲器输出时对他们进行解码，可以使用<code>java.nio.charset.Charset</code>类实现这些功能，该类提供了把数据编码成多种不同类型的字符集的工具</p>
<p>获取基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">bb.asLongBuffer().put(<span class="number">11111</span>);</span><br><span class="line">bb.getLong();</span><br><span class="line">bb.rewind();</span><br><span class="line">bb.asDoubleBuffer().put(<span class="number">11111</span>);</span><br><span class="line">bb.getDouble();</span><br><span class="line"><span class="comment">//向ByteBuffer插入基本类型数据的最简单的方法是：利用asCharBuffer()、asShortBuffer()等获得该缓冲器上的视图，然后使用视图的put()方法</span></span><br></pre></td></tr></table></figure>

<p>视图缓冲器：可以让我们通过某个特定的基本数据类型的视窗来查看其底层的<code>ByteBuffer</code>，<code>ByteBuffer</code>依然是实际存储数据的地方，“支持着前面的视图”，因此，对视图的任何修改都会映射成为对<code>ByteBuffer</code>中数据的修改，如上的示例</p>
<p>一旦底层的<code>ByteBuffer</code>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写道通道中了</p>
<p>字节存放次序：不同的机器可能会使用不同的字节排序方法来存储数据：</p>
<ul>
<li><code>big endian</code>：高位优先，将最重要的字节存放在地址最低的存储器单元</li>
<li><code>little endian</code>：低位优先，将最重要的字节存放在地址最高的存储器单元</li>
</ul>
<p>当存储量大于一个字节时例如<code> int</code>、<code>float</code>等，就需要考虑字节的顺序问题了</p>
<p><code>ByteBuffer</code>是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式，不过我们可以采用带有参数<code>ByteOrder.BIG_ENDIAN</code>或<code>ByteOrder.LITTLE_ENDIAN</code>的<code>order()</code>方法改变<code>ByteBuffer</code>的字节排序方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.wrap(<span class="keyword">new</span> Byte[<span class="number">12</span>]);</span><br><span class="line">bb.order(ByteOrder.BIG_ENDIAN);<span class="comment">//默认方式</span></span><br><span class="line">bb.order(ByteOrder.LITTLE_ENDIAN);</span><br></pre></td></tr></table></figure>

<p><code>ByteBuffer</code>是将数据库移进移出通道的唯一方式，但是我们不能把基本类型的缓冲器转换为<code>ByteBuffer</code>,所以此时便可使用视图缓冲器将基本类型移进移出<code>ByteBuffer</code></p>
<p><code>Buffer</code>由数据和可以高效地访问及操纵这些数据的四个索引组成，这四个索引是：<code>mark</code>（标记）、<code>position</code>（位置）、<code>limit</code>（界限）、和<code>capacity</code>（容量）</p>
<p>在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化</p>
<p>内存映射文件：内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件，有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问，这种方法极大的简化了用于修改文件的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0X8FFFFF</span>;</span><br><span class="line">MappedByteBuffer out = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>).getChannel().map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,length);</span><br><span class="line">out.put((<span class="keyword">byte</span>)<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">out.get(length/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>MappedByteBuffer</code>是一种特殊类型的直接缓冲器，注意我们必须制定映射文件的初始位置和映射区域的长度，这意味着我们可以映射某个文件的较小部分</p>
<p><code>MappedByteBuffer</code>由<code>ByteBuffer</code>继承而来，因此它具有<code>ByteBuffer</code>的所有方法</p>
<p>尽管“旧”的<code>I/O</code>流在用<code>nio</code>实现后性能有所提高，但是“映射文件访问”往往可以更加显著地加快速度（建立映射文件的花费很大，但是整体收益比起<code>I/O</code>流来说还是很显著的）</p>
<p>文件加锁：<code>JDK1.4</code>引入了文件加锁机制，允许我们同步访问某个作为共享资源的文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">FileLock fl = fos.getChannel().tryLock();</span><br></pre></td></tr></table></figure>

<p>通过对<code>FileChannel</code>调用<code>tryLock()</code>或<code>lock()</code>,就可以获得整个文件的<code>FileLock</code>：</p>
<ul>
<li><p><code>tryLock()</code>是非阻塞式的，他设法获取锁，如果不能获得，将直接从方法调用返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared);<span class="comment">//第三个参数为是否是共享锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lock()</code>是阻塞式的，他要阻塞进程直至锁可以获得，或调用<code>lock()</code>的线程中断，或调用<code>lock()</code>的通道关闭</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, bollean shared);<span class="comment">//第三个参数为是否是共享锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>FileLock.release()</code>可以释放锁</p>
</li>
</ul>
<p>对独占锁或者共享锁的支持必须由底层的操作系统提供，如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么他就会使用独占锁，锁的类型(共享或独占)可以通过<code>FileLock.isShared()</code>进行查询。</p>
<h4 id="9-压缩"><a href="#9-压缩" class="headerlink" title="9.压缩"></a>9.压缩</h4><p><code>java I/O</code>类库中的类支持读写压缩格式的数据流，可以用他们对其他的<code>I/O</code>类进行封装，以提供压缩功能</p>
<p>这些类不是从<code>Reader</code>和<code>Writer</code>类派生而来，而是属于<code>InputStream</code>和<code>OutputStream</code>继承层次结构的一部分，这样做是因为压缩类库是按字节方式而不是字符方式处理的，不过有时我们可能会被迫要混合两种类型的数据流</p>
<p>尽管存在多种压缩算法：<code>GZIP</code>和<code>Zip</code>是最常用的</p>
<p>（1）使用<code>GZIP</code>进行简单压缩</p>
<p><code>GZIP</code>接口非常简单，因此如果我们要对单个数据流进行压缩，是比较合适的选择</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> GZIPOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.gz&quot;</span>)));</span><br><span class="line">out.write(...);</span><br><span class="line">BufferedReader in2 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> GZIPInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>))));</span><br><span class="line">in2.readLine();</span><br></pre></td></tr></table></figure>

<p>（2）使用<code>Zip</code>进行多文件保存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.zip&quot;</span>);</span><br><span class="line">CheckOutputStream csum = <span class="keyword">new</span> CheckOutputStream(f,<span class="keyword">new</span> Adler32());</span><br><span class="line">ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">out.setComment(<span class="string">&quot;String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>java</code>档案文件：<code>Zip</code>格式也被应用于<code>JAR</code>（<code>Java Archive</code>,<code>java</code>档案文件）文件格式中（但是<code>jar</code>工具的功能没有<code>zip</code>工具那么强大）</p>
<h4 id="10-对象序列化"><a href="#10-对象序列化" class="headerlink" title="10.对象序列化"></a>10.对象序列化</h4><p>对象在程序终止时，不会再存在。存在某些情况，若是存在在程序不运行的情况下仍能存在并保存其信息，会非常有用，对象的序列化便可以做到</p>
<p><code>java</code>的对象序列化将那些<strong>实现了<code>Serializable</code>接口</strong>的对象转换成一个字节序列并能够在以后将这个字节序列完全恢复为原来的对象</p>
<ul>
<li>这一过程甚至可以通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异</li>
<li>对象序列化可以实现轻量级持久性，“持久性“意味着一个对象的生存周期并不取决与程序是否在执行，他可以生存于程序的调用之间，通过将一个序列化对象写入磁盘，然后再重新调用程序时恢复该对象，就能实现持久性的效果</li>
</ul>
<p>对象序列化加入到语言中，是为了支持两种特性：</p>
<ul>
<li><code>java</code>的远程方法调用（<code>RMI</code>），他是存活在其他计算机上的对象就像是存活在本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值</li>
<li>对于<code>Java Beans</code>来说，对象序列化也是必需的（可能需要保留状态信息）</li>
</ul>
<p>要序列化一个对象：首先要创建某些<code>OutputStream</code>对象，然后将其封装在一个<code>ObjectOutputStream</code>对象内，这时，调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>。（对象序列化是基于字节的，因此使用<code>InputStream</code>和<code>OutputStream</code>继承结构）要反向进行该过程（即将一个序列还原为一个对象）需要将一个<code>InputStream</code>封装在<code>ObjectInputStream</code>内，然后调用<code>readObject()</code>。[我们获得的是一个引用，指向一个向上转型的<code>Object</code>,需要向下转型]</p>
<ul>
<li>被还原的对象确实包含了<strong>原对象中的所有连接</strong> </li>
<li>在对一个<code>Serializable</code>对象进行还原的过程中，没有调用任何构造器，包括默认的构造器，这个对象都是通过从<code>InputStream</code>中取得数据恢复而来的</li>
</ul>
<p>将一个对象从的序列化状态中恢复出来：需要必须保证<code>Java</code>虚拟机能够找到相关的<code>.class</code>文件</p>
<p>序列化的控制：可通过<code>Externalizable</code>接口代替<code>Serializable</code>接口来对对象的序列化过程进行控制，这个<code>Externalizable</code>继承了<code>Serializable</code>接口，同时新增了两个方法：<code>writeExternal()</code>和<code>readExternal()</code>。这两个方法会在序列化和反序列化还原的过程中被自动调用</p>
<ul>
<li>对于一个<code>Externalizable</code>对象，所有普通的默认构造器都会被调用（包括在字段定义时的初始化，然后调用<code>readExternal()</code>）</li>
<li>我们需要在<code>writeExternal()</code>方法（没有任何默认行为来为<code>Externalizable</code>对象写入任何成员对象）中将来自对象的重要信息写入，还必须在<code>readExternal()</code>方法中恢复数据</li>
</ul>
<p><code>transient</code>(瞬时)关键字：关闭序列化</p>
<p>不想被<code>java</code>的序列化机制自动保存与恢复的子对象，例如密码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br></pre></td></tr></table></figure>

<p>因为<code>Externalizable</code>对象在默认情况下不保存他们的任何字段，所以<code>transient</code>关键字只能和<code>Serializable</code>对象一起使用</p>
<p><code>Externalizable</code>的替代方法：如果不是特别坚持实现<code>Externalizable</code>接口，我们可以实现<code>Serializable</code>接口并添加（不是覆盖或者实现）名为<code>writeObject()</code>和<code>readObject()</code>的方法，这样一旦对象被序列化或者反序列化还原，就会自动地分别调用这两个方法，也就是说，只要我们提供这两个方法，就会使用他们而不是默认的序列化机制</p>
<p>深拷贝：我们可以通过一个字节数组来使用对象序列化，从而实现对任何可<code>Serializable</code>对象的“深度复制”（<code>deep copy</code>）——深度复制意味着我们复制的是整个对象网，而不仅仅是基本对象及其引用</p>
<ul>
<li>如果我们想保存系统状态，最安全的做法是将其作为“原子”操作进行序列化</li>
</ul>
<p>要序列化<code>static</code>值，必须要自己动手去实现：需要添加<code>serializeStaticState()</code>和<code>deserializeStaticState()</code>两个<code>static</code>方法</p>
<h4 id="11-XML"><a href="#11-XML" class="headerlink" title="11.XML"></a>11.XML</h4><p>对象序列化的一个重要限制是他只是<code>Java</code>的解决方案：只有<code>Java</code>程序才能反序列化这种对象，一种更具互操作的解决方案是将数据转换为<code>XML</code>格式，这可以使各种各样的平台和语言使用</p>
<h4 id="12-Preferences"><a href="#12-Preferences" class="headerlink" title="12.Preferences"></a>12.Preferences</h4><p><code>Preferences API</code>(用户偏好)与对象序列化相比，前者与对象持久性更为密切，因为他可以自动存储和读取信息，不过他只能用于小的、受限的数据集合——我们只能存储基本类型和字符串，并且每个字符串的存储长度都不能超过<code>8K</code></p>
<p><code>Preferences API</code>用于存储和读取用户偏好以及程序配置项的设置</p>
<ul>
<li>是一个键-值集合（类似映射）</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreferencesDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Preferences prefs = Preferences.useNodeForPackage(PreferencesDemo.class);</span><br><span class="line">    prefs.put(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;Oz&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Preferences API</code>对于数据的存储是利用了合适的系统资源来完成的： 例如:在<code>Windows </code>下面是使用注册表来保存这些信息，而在<code>Linux</code>下面是使用用户的<code>home</code>目录下面的一个隐藏文件来存储的。</p>
<h4 id="13-总结"><a href="#13-总结" class="headerlink" title="13.总结"></a>13.总结</h4><p><code>Java I/O</code>流类库的确能满足我们的基本需求：我们可以通过控制台、文件、内存块、甚至因特网进行读写。通过继承我们可以创建新类型的输入和输出对象。并且通过重新定义<code>toString()</code>,可以对流接受的对象类型进行简单扩充</p>
<p><strong>理解<code>I/O</code>流类库，需要先理解“装饰器”模式</strong> </p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E3%80%8AThinking-in-Java%E3%80%8B/" rel="tag"># 《Thinking in Java》</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2019/04/04/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-8-cp%E5%91%BD%E4%BB%A4/" rel="prev" title="每天一个Linux命令-8-cp命令">
      <i class="fa fa-chevron-left"></i> 每天一个Linux命令-8-cp命令
    </a></div>
      <div class="post-nav-item">
    <a href="/2019/05/14/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/%E5%AD%97%E7%AC%A6%E9%9B%86/" rel="next" title="字符集">
      字符集 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-File%E7%B1%BB"><span class="nav-number">1.</span> <span class="nav-text">1.File类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">2.</span> <span class="nav-text">2.输入和输出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-%E6%B7%BB%E5%8A%A0%E5%B1%9E%E6%80%A7%E5%92%8C%E6%9C%89%E7%94%A8%E7%9A%84%E6%8E%A5%E5%8F%A3"><span class="nav-number">3.</span> <span class="nav-text">3.添加属性和有用的接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Reader%E5%92%8CWriter"><span class="nav-number">4.</span> <span class="nav-text">4.Reader和Writer</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-%E8%87%AA%E6%88%91%E7%8B%AC%E7%AB%8B%E7%9A%84%E7%B1%BB%EF%BC%9ARandomAccessFile"><span class="nav-number">5.</span> <span class="nav-text">5.自我独立的类：RandomAccessFile</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-I-O%E6%B5%81%E7%9A%84%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F"><span class="nav-number">6.</span> <span class="nav-text">6.I&#x2F;O流的典型使用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-%E6%A0%87%E5%87%86I-O"><span class="nav-number">7.</span> <span class="nav-text">7.标准I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-%E6%96%B0I-O"><span class="nav-number">8.</span> <span class="nav-text">8.新I&#x2F;O</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-%E5%8E%8B%E7%BC%A9"><span class="nav-number">9.</span> <span class="nav-text">9.压缩</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-%E5%AF%B9%E8%B1%A1%E5%BA%8F%E5%88%97%E5%8C%96"><span class="nav-number">10.</span> <span class="nav-text">10.对象序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-XML"><span class="nav-number">11.</span> <span class="nav-text">11.XML</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-Preferences"><span class="nav-number">12.</span> <span class="nav-text">12.Preferences</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-%E6%80%BB%E7%BB%93"><span class="nav-number">13.</span> <span class="nav-text">13.总结</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">张玉莹</p>
  <div class="site-description" itemprop="description">路漫漫其修远兮 吾将上下而求索</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">185</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">20</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">35</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张玉莹</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/three-waves.min.js"></script>


  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
