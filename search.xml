<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Dcoker Compose</title>
    <url>/2019/05/22/Docker/Dcoker%20Compose/</url>
    <content><![CDATA[<p>Compose是一个用于定义和运行多容器Docker应用程序的工具。使用Compose，可以使用YAML文件来配置应用程序的服务。然后，使用单个命令，可以从配置中创建并启动所有服务</p>
<span id="more"></span>

<blockquote>
<p>通过一个单独的 <code>docker-compose.yml</code> 模板文件（YAML 格式）来定义一组相关联的应用容器为一个项目（project）</p>
</blockquote>
<p><code>Compose</code> 项目由 Python 编写，实现上调用了 Docker 服务提供的 API 来对容器进行管理。因此，只要所操作的平台支持 Docker API，就可以在其上利用 <code>Compose</code> 来进行编排管理。</p>
<p>使用Compose基本上是一个三步过程：</p>
<ol>
<li><code>Dockerfile</code> 定义应用的运行环境</li>
<li><code>docker-compose.yml</code>  定义组成应用的各服务（在隔离环境一起运行）</li>
<li><code>docker-compose up</code> 启动整个应用</li>
</ol>
<p>compse 相关的常用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">运行compose项目[在后台运行]</span><br><span class="line">docker-compose up [-d]</span><br><span class="line">停止 up 命令所启动的容器，并移除网络</span><br><span class="line">docker-compose down</span><br><span class="line">列出 Compose 文件中包含的镜像。</span><br><span class="line">docker-compose images</span><br><span class="line">列出项目中目前的所有容器[指定容器]</span><br><span class="line">docker-compose ps [$&#123;server name&#125;]</span><br><span class="line">查看docker-compose运行的容器日志[指定容器]</span><br><span class="line">docker-compose logs [$&#123;server name&#125;]</span><br><span class="line"></span><br><span class="line">设置指定服务运行的容器个数（服务名称&#x3D;数量）</span><br><span class="line">docker-compose scale web&#x3D;3 db&#x3D;2 $&#123;server name &#x3D; num&#125;</span><br></pre></td></tr></table></figure>

<p><code>Compose</code> 面向项目进行管理。可以说在Compose中最重要的就是<code>docker-compose.yml</code>的编写</p>
<p>docker-compose.yml 中有3大块：</p>
<ul>
<li><code>services</code>：一个service代表一个container，这个container可以从dockerhub的image来创建，或者从本地的Dockerfile build出来的image来创建，service的启动类似于docker run，可以指定network和volume </li>
<li><code>networks</code>：service代表的所属的网络</li>
<li><code>volumes</code>：数据卷</li>
</ul>
<h4 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h4><p>1.使用Compose启动一个python程序（统一文件夹，有以下3个文件）</p>
<p>(1)docker-compose.yml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line"></span><br><span class="line">  web:</span><br><span class="line">    build:</span><br><span class="line">      context: .</span><br><span class="line">      dockerfile: Dockerfile</span><br><span class="line">    ports:</span><br><span class="line">       - 80:5000</span><br><span class="line">    environment:</span><br><span class="line">      REDIS_HOST: redis</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> build说明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">build:</span><br><span class="line">     context: .</span><br><span class="line">     dockerfile: Dockerfile</span><br><span class="line">    也可缩写为</span><br><span class="line">   build: .    </span><br></pre></td></tr></table></figure>

<p>(2).Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM python:2.7</span><br><span class="line">LABEL maintaner&#x3D;&quot;zyy&quot;</span><br><span class="line">COPY . &#x2F;app</span><br><span class="line">WORKDIR &#x2F;app</span><br><span class="line">RUN pip install flask redis</span><br><span class="line">EXPOSE 5000</span><br><span class="line">CMD [ &quot;python&quot;, &quot;app.py&quot; ]</span><br></pre></td></tr></table></figure>

<p>(3).app.py</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line">redis &#x3D; Redis(host&#x3D;os.environ.get(&#39;REDIS_HOST&#39;,&#39;127.0.0.1&#39;), port&#x3D;6379)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def hello():</span><br><span class="line">  redis.incr(&#39;hits&#39;)</span><br><span class="line">  return &#39;Hello Container World! zyy come here %s times&#39; % redis.get(&#39;hits&#39;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &quot;__main__&quot;:</span><br><span class="line">  app.run(host&#x3D;&quot;0.0.0.0&quot;, port&#x3D;5000, debug&#x3D;True)</span><br></pre></td></tr></table></figure>

<p>2.运行wordpress的docker-compose.yml文件(作为语法参考)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &#39;3&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">    wordpress:</span><br><span class="line">        image: wordpress</span><br><span class="line">        ports:</span><br><span class="line">            - 8080:80</span><br><span class="line">        environment:</span><br><span class="line">            WORDPRESS_DB_HOST: mysql</span><br><span class="line">            WORDPRESS_DB_PASSWORD: root</span><br><span class="line">        networks:</span><br><span class="line">            - my-bridge</span><br><span class="line">            </span><br><span class="line">    mysql:</span><br><span class="line">        image: mysql</span><br><span class="line">        environment:</span><br><span class="line">            MYSQL_ROOT_PASSWORD: root</span><br><span class="line">            MYSQL_DATABASE: wordpress</span><br><span class="line">        volumes:</span><br><span class="line">            - mysql-data:&#x2F;var&#x2F;lib&#x2F;mysql</span><br><span class="line">        networks:</span><br><span class="line">            - my-bridge</span><br><span class="line">            </span><br><span class="line">volumes:</span><br><span class="line">    mysql-data:</span><br><span class="line">    </span><br><span class="line">networks:</span><br><span class="line">    my-bridge:</span><br><span class="line">        driver: bridge</span><br></pre></td></tr></table></figure>

<h4 id="问题解决："><a href="#问题解决：" class="headerlink" title="问题解决："></a>问题解决：</h4><p><code>docker-compose  up</code> 执行之后，运行的项目被修改之后 镜像不会被重新构建，此时解决方式：</p>
<p>需要删除镜像之后在<code>docker-compose up</code></p>
<p>参考资料</p>
<p><a href="http://landcareweb.com/questions/2645/ru-he-rang-docker-composeshi-zhong-cong-xin-tu-xiang-zhong-xin-chuang-jian-rong-qi">http://landcareweb.com/questions/2645/ru-he-rang-docker-composeshi-zhong-cong-xin-tu-xiang-zhong-xin-chuang-jian-rong-qi</a></p>
<p><a href="https://www.cnblogs.com/ee900222/p/docker_5.html">https://www.cnblogs.com/ee900222/p/docker_5.html</a></p>
<p><a href="https://www.jianshu.com/p/658911a8cff3">https://www.jianshu.com/p/658911a8cff3</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker Volume</title>
    <url>/2019/05/22/Docker/Docker%20Volume/</url>
    <content><![CDATA[<p>想要了解Docker Volume，首先我们需要知道Docker的文件系统是如何工作的。</p>
<span id="more"></span>

<p>Docker镜像是由多个文件系统（只读层）叠加而成。当我们启动一个容器的时候，Docker会加载只读镜像层并在其上（镜像栈顶部）添加一个读写层。如果运行中的容器修改了现有的一个已经存在的文件，那该文件将会从读写层下面的只读层复制到读写层，该文件的只读版本仍然存在，只是已经被读写层中该文件的副本所隐藏。当删除Docker容器，并通过该镜像重新启动时，之前的更改将会丢失。在Docker中，只读层及在顶部的读写层的组合被称为<code>Union File System</code>（联合文件系统）。</p>
<p>为了能够保存（持久化）数据以及共享容器间的数据，Docker提出了<code>Volume</code>的概念。简单来说，<strong>Volume就是目录或者文件，它可以绕过默认的联合文件系统，而以正常的文件或者目录的形式存在于宿主机上。</strong></p>
<p>初始化Volume的两种方式：</p>
<ul>
<li><p>在<code>Dockerfile</code> 中设置数据卷存储地址：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment">#此时定义的是匿名卷</span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash">  [<span class="string">&quot;/opt/config&quot;</span>] </span></span><br></pre></td></tr></table></figure>

<p>此时设置的就是容器运行时内部挂载的数据卷地址，但是此时运行容器(<code>docker run</code>)不指定-v参数，在主机上生成的<code>volume name</code>最后是一串随机id，不易区分和查看，并且默认存储到主机的<code>/var/lib/docker/volumes/dir</code>下</p>
</li>
<li><p><code>docker run</code> 的时候使用<code>-v</code>指定 Volume</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d container-test -h CONTAINER -v &#x2F;data</span><br></pre></td></tr></table></figure>

<p>和Dockerfile中指定是一样的效果<br>将<code>/data</code>挂载到容器中，并绕过联合文件系统，我们可以在主机上直接操作该目录。任何在该镜像<code>/data</code>路径的文件将会被复制到<code>Volume</code>。我们可以使用<code>docker inspect</code>命令找到Volume在主机上的存储位置：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect -f &#123;&#123;.Volumes&#125;&#125; container-test</span><br></pre></td></tr></table></figure>

<p>你会看到类似的输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">map[&#x2F;data:&#x2F;var&#x2F;lib&#x2F;docker&#x2F;volumes&#x2F;dir&#x2F;cde167197ccc3e138a14f1a4f...b32cec92e79059437a9] </span><br></pre></td></tr></table></figure>

<p>这说明Docker默认是把在<code>/var/lib/docker/volumes/dir</code>下的某个目录挂载到了容器内的<code>/data</code>目录下。</p>
<p>此时要修改Volume在主机的存储路径,可使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v &#x2F;home&#x2F;localdata:&#x2F;data</span><br></pre></td></tr></table></figure>

<p>该命令将挂载主机的<code>/home/localdata</code>目录到容器内的<code>/data</code>目录上。即是在运行时指定本地目录与容器中目录的<strong>一一对应关系</strong>(改变一个另一个立即跟着改变，保证两边一致)</p>
<p>这对于在主机和容器之间共享文件是非常有帮助的，例如挂载需要编译的源代码。</p>
<p>为了保证可移植性（并不是所有的系统的主机目录都是可以用的），挂载主机目录不需要从Dockerfile指定。当使用<code>-v</code>参数时，镜像目录下的任何文件都不会被复制到Volume中。（Volume会复制到镜像目录，镜像不会复制到卷）</p>
<ul>
<li><p><code>-v</code> 参数还有一个功能是设置别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -v log-data:&#x2F;var&#x2F;lib&#x2F;data</span><br></pre></td></tr></table></figure>

<p>将当前运行的容器的持久化存储在主机的数据卷名称命名为<code>log-data</code>（<code>/var/lib/docker/volumes/dir</code>目录下）</p>
</li>
</ul>
</li>
</ul>
<h4 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h4><p>如果要授权一个容器访问另一个容器的Volume，我们可以使用<code>-volumes-from</code>参数来执行<code>docker run</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker run -it -h NEWCONTAINER --volumes-from container-test debian &#x2F;bin&#x2F;bash</span><br><span class="line">root@NEWCONTAINER:&#x2F;# ls &#x2F;data</span><br><span class="line">test-file</span><br><span class="line">root@NEWCONTAINER:&#x2F;#</span><br></pre></td></tr></table></figure>

<p>值得注意的是不管<code>container-test</code>是否运行，它都会起作用。只要有容器连接Volume，它就不会被删除。</p>
<h4 id="删除Volumes"><a href="#删除Volumes" class="headerlink" title="删除Volumes"></a>删除Volumes</h4><p>这个功能可能会更加重要，如果你已经使用<code>docker rm</code>来删除你的容器，那可能有很多的孤立的Volume仍在占用着空间。</p>
<p>Volume只有在下列情况下才能被删除：</p>
<ul>
<li>该容器是用<code>docker rm －v</code>命令来删除的（<code>-v</code>是必不可少的）。</li>
<li><code>docker run</code>中使用了<code>--rm</code>参数</li>
</ul>
<p>即使用以上两种命令，也只能删除没有容器连接的Volume。连接到用户指定主机目录的Volume永远不会被docker删除。</p>
<p>除非你已经很小心的，总是像这样来运行容器，否则你将会在<code>/var/lib/docker/volumes/dir</code>目录下得到一些僵尸文件和目录，并且还不容易说出它们到底代表什么。</p>
<p>参考资料</p>
<p><a href="http://dockone.io/article/128">http://dockone.io/article/128</a></p>
<p><a href="https://blog.51cto.com/ityouknow/2088142">https://blog.51cto.com/ityouknow/2088142</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>DockerFile</title>
    <url>/2019/05/20/Docker/DockerFile/</url>
    <content><![CDATA[<p>Dockerfile语法梳理</p>
<span id="more"></span>

<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> scratch  <span class="comment">#制作base image</span></span><br><span class="line"><span class="keyword">FROM</span> centos   <span class="comment">#使用base image 为了安全尽量使用官方提供的快照</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> version=<span class="string">&quot;1.0&quot;</span> <span class="comment">#定义当前image的一个meta data,例如当前image的作者、版本、描述等</span></span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> description=<span class="string">&quot;this is description&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> yum update &amp;&amp; yum install -y vim \  <span class="comment">#运行命令,\:反斜线换行  &amp;&amp;：可以合并命令</span></span></span><br><span class="line">    python-dev   </span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc;echo $&#123;HOME&#125;&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash">  /<span class="built_in">test</span>    <span class="comment">#设置当前目录,如果没有会自动创建</span></span></span><br><span class="line">	<span class="keyword">WORKDIR</span><span class="bash"> /<span class="built_in">test</span></span></span><br><span class="line">	<span class="keyword">WORKDIR</span><span class="bash"> demo</span></span><br><span class="line">	<span class="keyword">WORKDIR</span><span class="bash"> <span class="built_in">pwd</span>   <span class="comment">#输出结果应该是/test/demo</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> hello /<span class="built_in">test</span>/    <span class="comment">#把本地的文件添加到docker image 里面（大部分情况COPY由于ADD）</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> hell0 /			<span class="comment">#和COPY一样，把本地的文件添加到docker image 里面， 但是ADD不只是添加文佳到指定目录还会解压缩</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> test.tar.gz /   <span class="comment">#会将test.tar.gz添加到根目录并解压</span></span></span><br><span class="line">                    <span class="comment">#COPY和ADD是添加本地文件 添加远程文件/目录请使用curl或者wget</span></span><br><span class="line">                    </span><br><span class="line"><span class="keyword">ENV</span> JAVA_PORT=<span class="number">8080</span>  <span class="comment">#定义常量,使用ENV可增加Dockerfile的可维护性</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="bash"> [<span class="string">&quot;/opt/config&quot;</span>]  <span class="comment">#用于存储，数据卷存储</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">5000</span>   <span class="comment">#用于网络，要暴露的端口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#RUN :执行命令并创建新的Image Layer --和CMD、ENTRYPOINT对比</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> <span class="built_in">echo</span> <span class="variable">$&#123;envparam&#125;</span>    <span class="comment">#设置容器启动后默认执行的命令和参数：</span></span></span><br><span class="line">							<span class="comment">#容器启动时默认执行的命令)</span></span><br><span class="line">							<span class="comment">#如果docker run 指定了其他命令，CMD命令被忽略  docker run -it [image] /bin/bash</span></span><br><span class="line">							<span class="comment">#如果定义了多个CMD，只有最后一个会执行</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> 	/config.sh &amp;&amp; java -jar XXX.jar   <span class="comment">#设置容器启动时运行的命令：</span></span></span><br><span class="line">                                                  <span class="comment">#让容器以应用程序或者服务的形式运行</span></span><br><span class="line">                                                  <span class="comment">#不会被忽略、一定会执行</span></span><br></pre></td></tr></table></figure>

<p>Dockerfile简单示例：</p>
<p>​    (1) <code>/opt/docker</code> 下面有DockerFile 和docker-demo.jar</p>
<p>​    (2) <code>docker build -t test .</code></p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> mcr.microsoft.com/java/jdk:<span class="number">11</span>u3-zulu-alpine</span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> descripion test-demo</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> docker-demo.jar /opt/dcoker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /opt/docker</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="bash"> java -jar /opt/docker/ docker-demo.jar</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker核心组件</title>
    <url>/2019/05/18/Docker/Docker%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>Docker中的核心组件为：<code>Image</code> (镜像)、<code>Registry</code> (仓库)、<code>Container</code> (容器)</p>
<span id="more"></span>
<h4 id="Image-镜像"><a href="#Image-镜像" class="headerlink" title="Image(镜像)"></a>Image(镜像)</h4><p>镜像是构建Docker世界的基石。是基于联合(Union)文件系统的一种层式结构</p>
<ul>
<li>文件和<code>meta data</code>的集合（<code>root filesystem</code>）</li>
<li>分层的，并且每一层都可以添加改变删除文件，成为一个新的<code>image</code></li>
<li>不同的<code>image</code>可以共享相同的<code>layer</code></li>
<li><code>Image</code>本身是<code>read-only</code>的</li>
</ul>
<p>获取镜像的方式：</p>
<ul>
<li>从docker仓库拉取(开源docker仓库：<a href="https://hub.docker.com/">docker hub</a> )</li>
<li>编写DockerFile生成(<a href="http://zhangyuying.cn/2019/05/20/Docker/DockerFile/">DockerFile语法梳理及示例</a>)</li>
</ul>
<p>image 相关的常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">获取镜像</span><br><span class="line">docker pull $&#123;image name : image tag&#125;</span><br><span class="line">查看全部镜像</span><br><span class="line">docker image ls</span><br><span class="line">创建镜像</span><br><span class="line">docker build -t $&#123;image name&#125; .</span><br><span class="line">查看镜像历史</span><br><span class="line">docker history $&#123;image id&#125;</span><br><span class="line">运行镜像[在后台运行]</span><br><span class="line">docker run [-d] $&#123;image name&#125;</span><br><span class="line">删除镜像</span><br><span class="line">docker image rm $&#123;image id&#125; 或 docker rmi $&#123;image id&#125;</span><br><span class="line"></span><br><span class="line">示例：</span><br><span class="line">1.拉取一个nginx后，启动镜像：-v 映射数据卷 -p 映射端口</span><br><span class="line"> docker run -v &#x2F;usr&#x2F;local&#x2F;nginx:&#x2F;etc&#x2F;nginx&#x2F;conf.d -p 80:80 -d nginx</span><br><span class="line">2.拉取一个mysql后，启动镜像：</span><br><span class="line"> docker run -d --name myMysql -v &#x2F;data&#x2F;mysql:&#x2F;var&#x2F;lib&#x2F;mysql -p 3306:3306 -e MYSQL_ROOT_PASSWORD&#x3D;root mysql</span><br></pre></td></tr></table></figure>

<p>操作系统的镜像只有<code>rootfs</code>，还是依赖操作系统的</p>
<h4 id="Registry-仓库"><a href="#Registry-仓库" class="headerlink" title="Registry(仓库)"></a>Registry(仓库)</h4><p>保存镜像的仓库，分为</p>
<ul>
<li><p>公共：<a href="https://hub.docker.com/">docker hub</a></p>
</li>
<li><p>私有：自己创建，官方提供了 registry 镜像来启动本地的私有仓库。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -d -v &#x2F;opt&#x2F;registry:&#x2F;var&#x2F;lib&#x2F;registry -p 5000:5000 --restart&#x3D;always registry:2.5.0</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container(容器)"></a>Container(容器)</h4><p>容器是基于镜像启动的，容器中可以运行一个或多个进程。可以理解为：镜像是Docker生命周期的构建或打包阶段，而容器是启动或执行阶段</p>
<ul>
<li>通过<code>Image</code>创建（<code>copy</code>）</li>
<li>在<code>Image layer</code>之上建立一个<code>container layer</code>（可读写）</li>
<li>类比面向对象：镜像和容器相当于类和示例</li>
<li><code>Image</code>负责<code>app</code>的存储和分发，<code>Container</code>负责运行<code>app</code></li>
</ul>
<p>Container相关的常用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看全部容器</span><br><span class="line">docker container ls [-a]</span><br><span class="line">删除容器</span><br><span class="line">docker container rm $&#123;container id&#125; 或 docker rm $&#123;container id&#125;</span><br><span class="line">使用容器生成镜像（不推荐）</span><br><span class="line">docker container commit </span><br><span class="line">进入容器</span><br><span class="line">docker exec -it $&#123;container id&#125; &#x2F;bin&#x2F;sh</span><br><span class="line">停止当前容器</span><br><span class="line">docker container stop $&#123;container id&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《第一本Docker书》</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>IO模型</title>
    <url>/2021/04/25/IO/IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p>本文的IO模型均是基于Linux</p>
<span id="more"></span>

<p>目录：</p>
<p>Linux的内核态和用户态</p>
<p>IO是什么</p>
<p>IO模型</p>
<ul>
<li>BIO</li>
<li>NIO</li>
<li>多路复用IO</li>
<li>异步IO</li>
</ul>
<h3 id="Linux的内核态和用户态"><a href="#Linux的内核态和用户态" class="headerlink" title="Linux的内核态和用户态"></a>Linux的内核态和用户态</h3><p>在了解Linux的IO模型之前，需要先了解Linux的内核态和用户态</p>
<p>在操作系统中，为了保证系统的安全，以及达到进程不能相互影响，操作系统将操作权限分为了用户态和内核态。用户态想要调用与操作系统相关的方法时，只能通过内核代码去执行，内核代码在检查这次访问合法后，才会进行执行。通过这样的方式, 可以防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络等，提高了系统的安全性。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Linux%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="img"></p>
<p><code>Linux</code>模型如上，可以看到，应用程序想要访问内核的东西，只能通过系统调用来实现，系统调用作为一个隔离层，来实现用户态主动切换到内核态的一种主要方式，用户态切换到内核态还有另外两种方式便是异常和中断。</p>
<blockquote>
<p>由于用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗。</p>
<p>I/O调用就是一种访问内核的的系统调用</p>
</blockquote>
<h3 id="IO是什么"><a href="#IO是什么" class="headerlink" title="IO是什么"></a>IO是什么</h3><p>输入/输出（I/O）是主存和外部设备（例如磁盘驱动器、终端和网络）之间复制数据(外部设备—操作系统内核—内存)的过程</p>
<ul>
<li>输入操作是从I/O设备复制数据到主存</li>
<li>输出操作是从主存复制数据到I/O设备</li>
</ul>
<h3 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h3><p>为什么要说内核态和用户态呢，是因为在一次<code>IO</code>中，会涉及到好几次<code>Data Copy</code>。</p>
<p>由于数据基本都都是在磁盘或者网卡这类“内核”中，当应用程序需要从磁盘或网卡读取数据的时候，它会涉及到两个系统对象，一个是调用这个IO的<code>process (or thread)</code>，另一个就是系统内核(<code>kernel</code>)。当一个<code>read</code>操作发生时，该操作会经历两个阶段：</p>
<ul>
<li><p>将数据由网卡或磁盘拷贝到内核中，这一步阻塞时间是最久的，因为磁盘要查找，网卡要等网络传输，</p>
<p>即：等待数据准备 (<code>Waiting for the data to be ready</code>)</p>
</li>
<li><p>将内核的数据拷贝到应用程序中，</p>
<p>即：将数据从内核拷贝到进程中(<code>Copying the data from the kernel to the process</code>)</p>
</li>
</ul>
<p>几乎所有的IO都要经过这两步，而IO模型的区别就是在两个阶段上各有不同的情况。</p>
<h4 id="阻塞IO（BIO-Blocking-IO）"><a href="#阻塞IO（BIO-Blocking-IO）" class="headerlink" title="阻塞IO（BIO,Blocking IO）"></a>阻塞IO（BIO,Blocking IO）</h4><p>在linux中，默认情况下所有的<code>socket</code>都是<code>blocking</code></p>
<p><strong>模型</strong>：一个典型的读操作流程大概是这样：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/IO/BIO.png" alt="BIO模型"></p>
<p><strong>说明</strong>：BIO的特点就是在IO执行的两个阶段（等待数据和拷贝数据两个阶段）都被block了。</p>
<p>一个<code>BIO Server</code>如下（已省略<code>try-catch</code>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="comment">//初始化客户端</span></span><br><span class="line">       ServerSocket serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 建立线程监听请求</span></span><br><span class="line">       <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                   <span class="comment">//监听客户端连接，阻塞：由于不知道客户端多久会来建立连接，因此只能阻塞等待。</span></span><br><span class="line">                   Socket socket = serverSocket.accept();</span><br><span class="line">                   <span class="comment">//成功监听连接后，创建线程处理此连接</span></span><br><span class="line">                   <span class="keyword">new</span> Thread(() -&gt; &#123;                  </span><br><span class="line">                           <span class="keyword">int</span> len;</span><br><span class="line">                           <span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">                           InputStream inputStream = socket.getInputStream();</span><br><span class="line">                           <span class="comment">//读取数据，阻塞：由于不知道客户端数据多久能准备好，因此只能阻塞等待。</span></span><br><span class="line">                           <span class="keyword">while</span> ((len = inputStream.read(data)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                               System.out.println(<span class="keyword">new</span> String(data, <span class="number">0</span>, len));</span><br><span class="line">                           &#125;                        </span><br><span class="line">                   &#125;).start();          </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>那么使用BIO每个客户端的连接和数据读取都是阻塞的，如何监听多个客户端呢？答案是使用多线程，即**<code>multi-threading + blocking IO</code>**</p>
<p><strong><code>BIO</code>的优缺点</strong>：</p>
<p>优点：就是使用简单，按照正常的处理逻辑即可使用</p>
<p>缺点：比较明显，那就是每个来一个客户端连接，就需要创建一个线程，当线程过多的时候，系统的上下文开销会非常大。</p>
<blockquote>
<p>在Java中：<code>java.io</code> — <code>InputStream/OutputStream</code> 就是遵循了BIO设计,即为阻塞IO</p>
</blockquote>
<h4 id="非阻塞IO（NIO-non-Blocking-IO）"><a href="#非阻塞IO（NIO-non-Blocking-IO）" class="headerlink" title="非阻塞IO（NIO,non-Blocking IO）"></a>非阻塞IO（NIO,non-Blocking IO）</h4><p>为了解决<code>BIO</code>带来的问题，于是出现了<code>NIO</code>，<code>NIO</code>顾名思义就是非阻塞<code>IO</code>，在<code>Linux</code>操作系统中，可以通过参数设置<code>socket</code>为非阻塞<code>IO</code>.</p>
<p><strong>模型</strong>：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/IO/NIO.png" alt="NIO模型"></p>
<p><strong>说明</strong>：NIO的特点是在IO执行的第一个等待数据阶段非阻塞而拷贝数据依然是阻塞的。</p>
<p>当<code>IO</code>为非阻塞之后，调用线程就不会被阻塞从而可以执行其他的操作。然后再次带来的一个问题就是线程不知道数据什么时候能准备好，因此需要不断的去轮询数据是否准备完成。</p>
<p><strong><code>NIO</code>的优缺点</strong>：</p>
<p>优点 ： 不会阻塞线程，线程可以在数据准备期间执行其他操作。</p>
<p>缺点：</p>
<ul>
<li>循环主动轮询将将大幅度推高CPU占用率。</li>
<li>由于需要主动轮询数据是否已经准备完成，可能导致数据早已准备完成，但是没有来得及查询，因此会降低系统的吞吐量。</li>
</ul>
<h4 id="多路复用IO-IO-multiplexing"><a href="#多路复用IO-IO-multiplexing" class="headerlink" title="多路复用IO(IO multiplexing)"></a>多路复用IO(IO multiplexing)</h4><p>虽然<code>NIO</code>能够不阻塞线程，但是会降低吞吐量，这是万万不能接受的，因此出现了多路复用<code>IO</code>，有些地方也称这种IO方式为事件驱动IO(<code>event driven IO</code>)</p>
<p>我们都知道，<code>select/epoll</code>的好处就在于单个process就可以同时处理多个网络连接的IO。</p>
<p>多路复用IO的基本原理就是<code>select/epoll</code>这个<code>function</code>会不断的轮询所负责的所有<code>socket</code>，当某个<code>socket</code>有数据到达了，就通知用户进程。</p>
<p><strong>模型</strong>：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/IO/IOmultiplexing.png" alt="多路复用IO"></p>
<p><strong>说明</strong>：当用户进程调用了<code>select</code>，那么整个进程会被<code>block</code>，而同时，<code>kernel</code>会“监视”所有<code>select</code>负责的<code>socket</code>，当任何一个<code>socket</code>中的数据准备好了，<code>select</code>就会返回。这个时候用户进程再调用<code>read</code>操作，将数据从<code>kernel</code>拷贝到用户进程。</p>
<p>这个图和<code>blocking IO</code>的图其实并没有太大的不同，事实上还更差一些。因为这里需要使用两个系统调用(<code>select</code>和<code>recvfrom</code>)，而<code>blocking IO</code>只调用了一个系统调用(<code>recvfrom</code>)。但是，用select的优势在于它可以同时处理多个<code>connection</code>。 所以强调：</p>
<ol>
<li><p>如果处理的连接数不是很高的话，使用<code>select/epoll</code>的web server不一定比使用<code>multi-threading + blocking IO</code>的web server性能更好，可能延迟还更大。<code>select/epoll</code>的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p>
</li>
<li><p>在多路复用模型中，对于每一个<code>socket</code>，一般都设置成为<code>non-blocking</code>，但是，如上图所示，整个用户的<code>process</code>其实是一直被<code>block</code>的。只不过<code>process</code>是被<code>select</code>这个函数block，而不是被<code>socket IO</code>给<code>block</code>。</p>
<p>结论:<code> select</code>的优势在于可以处理多个连接，不适用于单个连接</p>
</li>
</ol>
<p><strong>多路复用IO的优缺点</strong>：</p>
<p>优点 ： 相比其他模型，使用<code>select()</code> 的事件驱动模型只用单线程（进程）执行，占用资源少，不消耗太多 CPU，同时能够为多客户端提供服务。如果试图建立一个简单的事件驱动的服务器程序，这个模型有一定的参考价值</p>
<p>缺点：</p>
<ul>
<li>不同的操作系统提供的<code>epoll</code>接口有很大差异，所以使用类似于<code>epoll</code>的接口实现具有较好跨平台能力的服务器会比较困难。</li>
<li>该模型将事件探测和事件响应夹杂在一起，一旦事件响应的执行体庞大，则对整个模型是灾难性的。</li>
</ul>
<blockquote>
<p><code>Java</code>的<code>NIO</code>使用的是多路复用模型</p>
</blockquote>
<h4 id="异步IO-Asynchronous-I-O"><a href="#异步IO-Asynchronous-I-O" class="headerlink" title="异步IO(Asynchronous I/O)"></a>异步IO(Asynchronous I/O)</h4><p><code>AIO</code>是真正意义的异步<code>IO</code>,<code>AIO</code>完全不会阻塞，当数据拷贝到应用程序中，才会通知，但是<code>AIO</code>使用比较少，在<code>Linux</code> 内核2.6版本才开始引入。只用知道有这个<code>IO</code>模型即可。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/IO/AsynchronousIO.png" alt="异步IO"></p>
<p><code>AIO</code>全程异步，当用户发起<code>IO</code>请求后，只需将应用程序接收数据的地址传给操作系统，操作系统在完成两次<code>Copy</code>之后，才会通知应用程序，应用程序接收到通知之后便可以直接使用数据。</p>
<p>参考资料</p>
<p><a href="https://www.jianshu.com/p/486b0965c296">聊聊Linux五种IO模型</a></p>
<p><a href="https://www.cnblogs.com/Eva-J/articles/8324837.html">python之路——IO模型</a></p>
<p><a href="http://dengchengchao.com/?p=1345">个人理解的IO</a></p>
<p><a href="https://www.zhihu.com/question/60892134">Java NIO direct buffer的优势在哪儿？ – 知乎</a></p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title>Java浮点数运算之BigDecimal</title>
    <url>/2023/01/10/Java/Java%E6%B5%AE%E7%82%B9%E6%95%B0%E8%BF%90%E7%AE%97%E4%B9%8BBigDecimal/</url>
    <content><![CDATA[<p>在<code>Java</code>运算中，为了避免精度丢失，可以使用<code>BigDecimal</code>来进行浮点数的运算</p>
<span id="more"></span>

<h3 id="Java浮点数运算精度丢失"><a href="#Java浮点数运算精度丢失" class="headerlink" title="Java浮点数运算精度丢失"></a>Java浮点数运算精度丢失</h3><p>在计算机中浮点数没有办法用二级制精确表示，因此存在精度丢失的风险。</p>
<p>为什么浮点数没有办法用二进制精确表示：由于计算机是二进制的，在计算机种表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况</p>
<p><code>Java</code>中精度丢失示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> a = <span class="number">2.0f</span> - <span class="number">1.9f</span>;</span><br><span class="line"><span class="keyword">float</span> b = <span class="number">1.8f</span> - <span class="number">1.7f</span>;</span><br><span class="line">System.out.println(a);<span class="comment">// 0.100000024</span></span><br><span class="line">System.out.println(b);<span class="comment">// 0.099999905</span></span><br><span class="line">System.out.println(a == b);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="BigDecimal"><a href="#BigDecimal" class="headerlink" title="BigDecimal"></a>BigDecimal</h3><p><code>Java</code> 提供了<code>BigDecimal</code> 来操作浮点数。想要解决浮点数运算精度丢失这个问题，可以直接使用 <code>BigDecimal</code> 来定义浮点数的值，然后再进行浮点数的运算操作即可</p>
<p>通常情况下，大部分需要浮点数精确运算结果的业务场景(比如涉及到钱的场景)都是通过 <code>BigDecimal</code> 进行运算。</p>
<p><code>BigDecimal</code> 可以实现对浮点数的运算，不会造成精度丢失。示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line">BigDecimal c = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.8&quot;</span>);</span><br><span class="line"></span><br><span class="line">BigDecimal x = a.subtract(b);</span><br><span class="line">BigDecimal y = b.subtract(c);</span><br><span class="line"></span><br><span class="line">System.out.println(x.compareTo(y));<span class="comment">// 0</span></span><br></pre></td></tr></table></figure>

<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ol>
<li>创建、加减乘除</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建</span></span><br><span class="line">BigDecimal a = BigDecimal.valueOf(<span class="number">1D</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.9&quot;</span>);</span><br><span class="line"><span class="comment">// 加减乘除</span></span><br><span class="line">System.out.println(a.add(b));<span class="comment">// 1.9</span></span><br><span class="line">System.out.println(a.subtract(b));<span class="comment">// 0.1</span></span><br><span class="line">BigDecimal multiplyResult = a.multiply(b)</span><br><span class="line">System.out.println(multiplyResult);<span class="comment">// 0.90</span></span><br><span class="line">multiplyResult.setScale(<span class="number">3</span>, RoundingMode.HALF_DOWN); <span class="comment">// 设置保留几位小数和规则</span></span><br><span class="line">System.out.println(a.divide(b));<span class="comment">// 无法除尽，抛出 ArithmeticException 异常</span></span><br><span class="line">System.out.println(a.divide(b, <span class="number">2</span>, RoundingMode.HALF_UP));<span class="comment">// 1.11  三个参数的构造器</span></span><br></pre></td></tr></table></figure>

<p><code>BigDecimal</code>的加减乘除均有3个参数，其中 <strong>scale 表示要保留几位小数</strong> ，<strong>roundingMode代表保留规则</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">divide</span><span class="params">(BigDecimal divisor, <span class="keyword">int</span> scale, RoundingMode roundingMode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> divide(divisor, scale, roundingMode.oldMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>roundingMode</code>保留规则常用取值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 向正无穷方向对齐（转换为正无穷方向最接近的所需数值）</span></span><br><span class="line"><span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2 , // -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">UP(BigDecimal.ROUND_UP),</span><br><span class="line"><span class="comment">// 向负无穷方向对齐</span></span><br><span class="line"><span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1 , // -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">DOWN(BigDecimal.ROUND_DOWN),</span><br><span class="line"><span class="comment">// 向原点的反方向对齐</span></span><br><span class="line"><span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2 , // -1.6 -&gt; -1 , -2.5 -&gt; -2</span></span><br><span class="line">CEILING(BigDecimal.ROUND_CEILING),</span><br><span class="line"><span class="comment">// 向原点方向对齐</span></span><br><span class="line"><span class="comment">// 2.5 -&gt; 2 , 1.6 -&gt; 1 , // -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">FLOOR(BigDecimal.ROUND_FLOOR),</span><br><span class="line"><span class="comment">// “四舍五入”，如果舍弃部分的最高位大于等于 5，向正无穷方向对齐，否则向负无穷方向对齐</span></span><br><span class="line"><span class="comment">// 2.5 -&gt; 3 , 1.6 -&gt; 2 , // -1.6 -&gt; -2 , -2.5 -&gt; -3</span></span><br><span class="line">HALF_UP(BigDecimal.ROUND_HALF_UP),</span><br><span class="line"><span class="comment">// “五舍六入”，如果舍弃部分的最高位大于 5，向正无穷方向对齐，否则向负无穷方向对齐</span></span><br><span class="line">HALF_DOWN(BigDecimal.ROUND_HALF_DOWN)</span><br><span class="line"><span class="comment">// 如果需要舍入，就抛出算术异常</span></span><br><span class="line">ROUND_UNNECESSARY</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>比较</p>
<p><code>BigDecimal</code>的 <code>compareTo()</code> 方法比较的时候会忽略精度。如果相等就返回 <code>0</code>，如果第 <code>1</code> 个数比第 <code>2</code> 个数大则返回 <code>1</code>，反之返回 <code>-1</code>。</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BigDecimal a = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">BigDecimal b = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1.0&quot;</span>);</span><br><span class="line">System.out.println(a.compareTo(b));<span class="comment">//0</span></span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p><code>BigDecimal</code> 的实现利用到了 <code>BigInteger</code> （用来操作大整数）, 所不同的是 <code>BigDecimal</code> 加入了小数位的概念。</p>
<p>即<code>BigDecimal</code>不使用二进制，而是使用十进制(<code>BigInteger</code>) + 小数位(<code>scale</code>) </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;100.001&quot;</span>);</span><br><span class="line"> System.out.println(bd.scale()); <span class="comment">// 3</span></span><br><span class="line"> System.out.println(bd.unscaledValue()); <span class="comment">// 100001</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>BigDecimal</code>的实现避免了小数的出现，当然也就不会有精度问题了。十进制，也就是整数部分使用了<code>BigInteger</code>来表示，小数点位置则使用一个整数<code>scale</code>来表示。当使用<code>BigDecimal</code>进行运算时，也就可以分解成两部分，<code>BigInteger</code>间的运算，以及小数点位置<code>scale</code>的更新</p>
<blockquote>
<p><strong>BigInteger</strong>：可以表示任意精度的整数。当你使用<code>long</code>类型进行运算，可能会产生溢出时就要考虑使用<code>BigInteger</code>了。那么<code>BigInteger</code>是如何做到可以表示任意精度的整数的？答案是使用数组来表示.</p>
</blockquote>
<h3 id="阿里规约中的BigDecimal"><a href="#阿里规约中的BigDecimal" class="headerlink" title="阿里规约中的BigDecimal"></a>阿里规约中的BigDecimal</h3><p>最后看下阿里规约中<code>BigDecimal</code>中的相关内容</p>
<ul>
<li><p>为了避免精度丢失，可以使用 <code>BigDecimal</code> 来进行浮点数的运算</p>
</li>
<li><p>浮点数之间的等值判断，基本数据类型不能用 <code>==</code> 来比较，包装数据类型不能用 <code>equals</code> 来判断。</p>
<blockquote>
<p><code>BigDecimal</code> 的等值比较应使用 <code>compareTo()</code> 方法，而不是 <code>equals()</code> 方法。</p>
<p>说明：<code>equals()</code>方法会比较值和精度（<code>1.0</code> 与 <code>1.00</code> 返回结果为 <code>false</code>），而 <code>compareTo()</code> 则会忽略精度。</p>
</blockquote>
</li>
<li><p>禁止使用构造方法<code>BigDecimal(double)</code>的方式把<code>double</code>值转换为<code>BigDecimal</code>对象</p>
<blockquote>
<p>说明：<code>BigDecimal(double)</code>存在精度损失风险，在精确计算或值比较的场景中，可能会导致业务逻辑出现异常。如：<code>BigDecimal g =new BigDecimal(0.1f);</code> 实际的存储值为<code>0.100000001490116119384765625</code>。</p>
</blockquote>
</li>
</ul>
<p>参考资料</p>
<p><a href="https://javaguide.cn/java/basis/bigdecimal.html#%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4">BigDecimal详解</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1675547">Java BigDecimal 的舍入模式（RoundingMode）详解</a></p>
<p><a href="https://developer.aliyun.com/article/848824">阿里巴巴Java开发手册（第2版）-第1章（4）</a></p>
<p><a href="https://blog.csdn.net/kisimple/article/details/43773899">Java的BigDecimal如何解决浮点数精度问题</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>BigDecimal</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker网络</title>
    <url>/2019/05/21/Docker/Docker%E7%BD%91%E7%BB%9C/</url>
    <content><![CDATA[<p>Docker的网络模式分为4种</p>
<p>​    ——在使用<code>docker run</code>创建Docker容器时，可以用<code>--net</code>选项指定容器的网络模式</p>
<span id="more"></span>

<ul>
<li><code>Bridge</code>模式：默认模式</li>
<li><code>Host</code>模式</li>
<li><code>None</code>模式</li>
<li><code>Container</code>模式</li>
</ul>
<h4 id="Bridge模式"><a href="#Bridge模式" class="headerlink" title="Bridge模式"></a>Bridge模式</h4><p>当Docker进程启动时，会在主机上创建一个名为<code>docker0</code>的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。</p>
<p>从<code>docker0</code>子网中分配一个IP给容器使用，并设置<code>docker0</code>的IP地址为容器的默认网关。在主机上创建一对虚拟网卡<code>veth pair</code>设备，Docker将<code>veth pair</code>设备的一端放在新创建的容器中，并命名为<code>eth0</code>（容器的网卡），另一端放在主机中，以<code>vethxxx</code>这样类似的名字命名，并将这个网络设备加入到<code>docker0</code>网桥中。可以通过**<code>brctl show</code>**命令查看。</p>
<p>使用<code>docker run -p</code>时，docker实际是在<code>iptables</code>做了<code>DNAT</code>规则，实现端口转发功能。可以使用**<code>iptables -t nat -vnL</code>**查看。</p>
<p><code>bridge</code>模式是docker的默认网络模式，不写<code>--net</code>参数，就是<code>bridge</code>模式。</p>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --net&#x3D;bridge --name docker_demo1 ubuntu-base:v3</span><br></pre></td></tr></table></figure>

<p>bridge模式如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Docker/net-bridge.png" alt="bridage模式"></p>
<h4 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h4><p>Docker使用了Linux的Namespaces技术来进行资源隔离，如PID Namespace隔离进程，Mount Namespace隔离文件系统，Network Namespace隔离网络等。</p>
<p>但是如果启动容器的时候使用<code>host</code>模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p>
<p>例如，我们在10.10.101.105/24的机器上用host模式启动一个含有web应用的Docker容器，监听tcp80端口。当我们在容器中执行任何类似<code>ifconfig</code>命令查看网络环境时，看到的都是宿主机上的信息。而外界访问容器中的应用，则直接使用10.10.101.105:80即可，不用任何NAT转换，就如直接跑在宿主机中一样。</p>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run --net&#x3D;host --name docker_demo2 ubuntu-base:v3</span><br></pre></td></tr></table></figure>

<p>host模式如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Docker/net-host.png" alt="host模式"></p>
<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -tid --net&#x3D;none --name docker_demo3 ubuntu-base:v3</span><br></pre></td></tr></table></figure>

<p>none模式如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Docker/net-none.png" alt="none模式"></p>
<h4 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h4><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p>
<p>使用示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -tid --net&#x3D;container:docker_demo1 --name docker_demo5 ubuntu-base:v3</span><br></pre></td></tr></table></figure>

<p>container模式如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Docker/net-container.png" alt="container模式"></p>
<h3 id="跨主机通信"><a href="#跨主机通信" class="headerlink" title="跨主机通信"></a>跨主机通信</h3><p>Docker默认的网络环境下，单台主机上的Docker容器可以通过<code>docker0</code>网桥直接通信，而不同主机上的Docker容器之间只能通过在主机上做端口映射进行通信。这种端口映射方式对很多集群应用来说极不方便。如果能让Docker容器之间直接使用自己的IP地址进行通信，会解决很多问题。按实现原理可分别直接路由方式、桥接方式（如<em>pipework</em>）、<code>Overlay</code>隧道方式（如<em>flannel</em>、<em>ovs+gre</em>）等。</p>
<p>参考资料</p>
<p><a href="https://www.cnblogs.com/yy-cxd/p/6553624.html">https://www.cnblogs.com/yy-cxd/p/6553624.html</a></p>
<p><a href="https://www.cnblogs.com/gispathfinder/p/5871043.html">https://www.cnblogs.com/gispathfinder/p/5871043.html</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker简介</title>
    <url>/2019/05/18/Docker/Docker%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux或Windows 机器上</p>
<blockquote>
<p>一个能够把开发的应用程序自动部署到容器的开源引擎</p>
</blockquote>
<span id="more"></span>

<h4 id="历史进展"><a href="#历史进展" class="headerlink" title="历史进展"></a>历史进展</h4><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Docker/%E5%8E%86%E5%8F%B2%E8%BF%9B%E5%B1%95.png" alt="历史进展"></p>
<p>Docker就是容器技术的实现，但是Docker的底层技术还是利用的操作系统现有的技术：</p>
<ul>
<li><code>Namespaces</code>：做隔离<code>pid</code>、<code>net</code>、<code>ipc</code>、<code>mnt</code>、<code>uts</code></li>
<li><code>Control groups</code>：做资源限制</li>
<li><code>Union file systems</code>：<code>Container</code>和<code>image</code>的分层</li>
</ul>
<h4 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h4><ul>
<li><p>提供一个简单、轻量的建模方式</p>
</li>
<li><p>职责的逻辑分离</p>
<p>主要是分离开发人员和运维人员的职责</p>
</li>
<li><p>快速、高效的开发生命周期</p>
</li>
<li><p>鼓励使用面向服务的架构</p>
</li>
</ul>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><ul>
<li>加速本地开发和构建流程</li>
<li>能够让独立服务或者应用程序在不同的环境中得到相同的运行结果。</li>
<li>用Docker创建隔离环境测试</li>
<li>构建多用户平台基础设施如PaaS</li>
<li>为开发测试提供一个轻量级的独立沙盒环境</li>
<li>高性能超大规模的宿主机部署</li>
</ul>
<h4 id="核心组件"><a href="#核心组件" class="headerlink" title="核心组件"></a><a href="http://zhangyuying.cn/2019/05/18/Docker/Docker%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">核心组件</a></h4><ul>
<li>Docker image：镜像</li>
<li>Docker container：容器</li>
<li>Docker registry：仓库</li>
</ul>
<p><a href="http://zhangyuying.cn/2019/05/18/Docker/Docker%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/">核心组件的具体介绍</a></p>
<p>参考资料</p>
<p>《第一本Docker书》</p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux入门</title>
    <url>/2021/11/08/Linux/Linux%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h2 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h2><p>Linux是一种开源的、免费的操作系统，安装在计算机硬件上、用来管理计算机的硬件和软件资源的系统软件。</p>
<p>Linux注重安全性、稳定性、高并发处理能力，没有优异的可视化界面</p>
<blockquote>
<p>一般来说：windows用于个人计算机上，linux用于企业服务器上</p>
</blockquote>
<span id="more"></span>

<h4 id="Linux的发行版本"><a href="#Linux的发行版本" class="headerlink" title="Linux的发行版本"></a>Linux的发行版本</h4><p>Linus在1991年开发Linux的内核程序，后来很多软件开发组织以及软件公司在内核程序基础之上，陆续退出很多不同版本的Linux操作系统：Ubuntu、ReHat、CentOS</p>
<p>以下某些特定内容基于CentOS 7</p>
<h4 id="Linux的目录结构"><a href="#Linux的目录结构" class="headerlink" title="Linux的目录结构"></a>Linux的目录结构</h4><ol>
<li><p>Linux只有一个根目录：<code>/</code></p>
</li>
<li><p>层级式的目录结构（部分）</p>
<p><code>bin</code> -&gt; <code>usr/bin</code>：系统的可执行文件，可以在任何目录下执行</p>
<p><code>user/local/bin</code>: 用户自己的可执行文件，可以再任何目录下执行</p>
<p><code>etc</code>: 存放配置文件。比如配置环境变量（<code>/etc/profile</code>）</p>
<p><code>home</code>: 每一个用户的根目录，用来保存用户私人的数据，默认情况下，目录名和自己的用户名相同</p>
<p><code>opt</code>: 存档额外安装的软件，相当于windows系统中的Program files目录</p>
</li>
</ol>
<h4 id="Linux中帮助命令"><a href="#Linux中帮助命令" class="headerlink" title="Linux中帮助命令"></a>Linux中帮助命令</h4><ol>
<li><p><code>man</code> 命令名称：用来查看Linux系统手册上的帮助信息</p>
<p><code>q</code>：退出查看</p>
</li>
<li><p><code>help</code> 命令名称：用来查看命令的内置帮助信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">help cd</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Linux中编辑器：vi-和vim"><a href="#Linux中编辑器：vi-和vim" class="headerlink" title="Linux中编辑器：vi 和vim"></a>Linux中编辑器：vi 和vim</h2><p>vi 和vim : Linux中的文本编辑器，用来在linux中查看或者编辑文本文件，就好像windows中的记事本一样</p>
<p>vim是vi的增强版本，vi的绝大多数用法在vim都适用，下面的使用以vim为例</p>
<h4 id="vim编辑器的使用："><a href="#vim编辑器的使用：" class="headerlink" title="vim编辑器的使用："></a>vim编辑器的使用：</h4><p>一般模式</p>
<ul>
<li>进入一般模式<ul>
<li>用vim命令打开文件（<code>vim test.txt</code>）,进入了一般模式</li>
<li>在其他模式中时，按<code>Esc</code>键，可以回到一般模式</li>
</ul>
</li>
<li>可以查看文件的内容</li>
<li>不能编辑文件内容</li>
</ul>
<p>编辑模式：</p>
<ul>
<li>进入编辑模式：在一般模式下，按<code>i</code>键或者<code>a</code>键，进入编辑模式</li>
<li>可以编辑文件内容，但是编辑的内容不会自动保存，此模式下也不能保存编辑的内容</li>
</ul>
<p>命令模式：</p>
<ul>
<li>进入命令模式：在一般模式下，按 <code>:</code> ，进入命令模式</li>
<li>常用命令：<ul>
<li><code>q!</code> ：不保存强制退出编辑器</li>
<li><code>wq</code>：保存并且退出编辑器</li>
<li><code>q</code> ：只是退出编辑器（没有编辑内容的情况下）</li>
</ul>
</li>
</ul>
<h4 id="vim编辑器的常用快捷键"><a href="#vim编辑器的常用快捷键" class="headerlink" title="vim编辑器的常用快捷键"></a>vim编辑器的常用快捷键</h4><blockquote>
<p>无特殊说明，以下快捷键均是在一般模式下操作</p>
</blockquote>
<ol>
<li>复制当前行：<ul>
<li><code>yy</code>：把光标所在行复制到剪切板</li>
<li><code>p</code>: 把剪切板中的内容粘贴到光标所在的下一行</li>
</ul>
</li>
<li>复制当前行往下<code>N</code>行：<ul>
<li><code>nyy</code>：把光标所在行往下N行复制到剪切板,例如5yy</li>
<li><code>p</code>：把剪切板中的内容粘贴到光标所在的下一行</li>
</ul>
</li>
<li>删除当前行：<code>dd</code> : 删除光标所在当前行</li>
<li>删除当前行往下<code>N</code>行：<code>ndd</code>：把光标所在行往下<code>N</code>行删除，例如<code>5dd</code></li>
<li>撤销上次编辑的内容：<code>u</code></li>
<li>到达文档的任意位置<ul>
<li><code>gg</code> ：光标到达文档最首行</li>
<li><code>G</code>：光标到达文档最末行</li>
<li>到达第10行：<ul>
<li>第一步：输入10</li>
<li>第二步：<code>G</code></li>
<li>第三步：回车</li>
</ul>
</li>
</ul>
</li>
<li>在文本文件中查找关键字：在命令模式下<ul>
<li>输入<code>/</code>关键字，回车搜索</li>
<li><code>n</code> : 表示光标查找下一个关键字</li>
</ul>
</li>
<li>行号设置：命令模式下<ul>
<li>设置文件行号：<code>set nu</code></li>
<li>取消文件行号：<code>set nonu</code></li>
</ul>
</li>
</ol>
<h2 id="Linux-用户和组管理"><a href="#Linux-用户和组管理" class="headerlink" title="Linux 用户和组管理"></a>Linux 用户和组管理</h2><h4 id="Linux用户管理"><a href="#Linux用户管理" class="headerlink" title="Linux用户管理"></a>Linux用户管理</h4><ol>
<li><p>任何使用Linux的系统资源的用户，必须使用一个合法的账号和密码，账号和密码一般都是像系统管理员申请</p>
<p><code>root</code>是Linux系统安装时默认创建的系统管理员账号，由<code>root</code>创建普通账号</p>
</li>
<li><p>添加账号：<code>useradd</code> [选项] 用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd zhangsan</span><br></pre></td></tr></table></figure>

<ul>
<li><p>创建一个用户<code>zhangsan</code></p>
</li>
<li><p>在<code>/home</code>目录下自动创建一个用户目录，和用户名相同 即<code>/home/zhangsan</code></p>
</li>
<li><p>创建了一个组：<code>zhangsan</code></p>
<blockquote>
<p>在Linxu中，任何一个用户都至少属于一个组，新建用户时如果不指定组，则会新建一个组，组名和用户名相同，并且把该用户添加到该组中</p>
</blockquote>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -d &#x2F;home&#x2F;zs  zhangsan2 ：创建用户的同时，指定用户的根目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>为用户设置密码：<code>passwd</code> 用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd zhangsan</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除用户：<code>userdel</code> 用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">userdel zhangsan ：删除用户</span><br><span class="line"></span><br><span class="line">userdel -r zhangsan ：删除用户的同时，级联删除用户的主目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看用户信息：<code>id</code> 用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id zhangsan ：用户信息包含用户的标识、用户所在的组等</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换用户：<code>su</code> 用户名</p>
<p><code>su zhangsan</code></p>
<ul>
<li>从权限高的用户切换到权限低的用户，不需要密码验证</li>
<li>从权限低的用户切换到权限高的用户，必须密码验证</li>
</ul>
</li>
</ol>
<h4 id="Linux中组管理"><a href="#Linux中组管理" class="headerlink" title="Linux中组管理"></a>Linux中组管理</h4><ul>
<li><p>Linux中组的概念</p>
<p>Linxu的组主要用于权限管理</p>
<p>Linxu的组对于用户来说相当于角色的概念，可以对有共性的用户进行统一管理：</p>
<ul>
<li>每一个用户至少属于一个组，不能独立于组存在，也可以属于多个组</li>
<li>新建用户时如果不指定组，则会新建一个组，组名跟用户名相同，并且把该用户添加到该组中</li>
</ul>
</li>
<li><p>组操作</p>
<ul>
<li><p>添加组：<code>groupadd</code> 组名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupadd dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除组：<code>groupdel</code> 组名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">groupdel dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>把用户添加到组中：<code>gpasswd -a</code> 用户名 组名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpasswd -a zhangsan dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>把用户从组中移除：<code> gpasswd -d</code> 用户名 组名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gpasswd -d zhangsan dev</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建用户时，指定所属的租（主组）：<code>useradd -g</code> 组名 用户名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">useradd -g dev zhangsan</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h2 id="Linux中文件和目录操作命令"><a href="#Linux中文件和目录操作命令" class="headerlink" title="Linux中文件和目录操作命令"></a>Linux中文件和目录操作命令</h2><ol>
<li><p>查看当前所在目录：<code>pwd</code></p>
</li>
<li><p>查看指定目录下所有的子目录或者文件列表：<code>ls</code> [选项] [指定目录]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ls</span><br><span class="line"></span><br><span class="line">ls &#x2F;home</span><br><span class="line"></span><br><span class="line">ls -l &#x2F;home&#96;</span><br><span class="line"></span><br><span class="line">ls -a &#x2F;home</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换目录：<code>cd</code> 目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ~ ：进入家目录</span><br><span class="line">cd &#x2F; ：进入根目录 </span><br><span class="line">cd ..：进入到当前目录的上一级目录</span><br><span class="line">cd . ：还在当前目录</span><br><span class="line">cd - ：进入当前目录之前的目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建目录：<code>mkdir</code> [选项] 目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mkdir testDir </span><br><span class="line"></span><br><span class="line">mkdir -p testDir&#x2F;test1：一次创建多级目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除空目录：<code>rmdir</code> 目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rmdir testDir</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建一个或者多个空文件：<code>touch</code> 文件名列表(文件名之间用空格隔开)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch test1.txt</span><br><span class="line"></span><br><span class="line">touch test2.txt test3.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制文件或者目录：<code>cp</code> [选项] <code>source</code>(源目录或文件) <code>dest</code>(目标目录)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cp  testDir1&#x2F;test1.txt  testDir2 ：复制文件，如果已存在则询问是否覆盖</span><br><span class="line"></span><br><span class="line">cp -r  testDir1 testDir2 ：把testeDir1目录及其下面目录和文件递归复制到testDir2中（如果没有 -r 只能复制空目录）</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除文件或者目录：<code>rm</code> 文件名 或者<code> rm -r</code> 目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rm testDir1&#x2F;test1.txt ：删除文件，会询问是否删除</span><br><span class="line"></span><br><span class="line">rm -f testDir1&#x2F;test.text : 强制删除文件，不会询问直接删除</span><br><span class="line"></span><br><span class="line">rm -r testDir ：递归删除目录，会每个询问是否删除</span><br><span class="line"></span><br><span class="line">rm -rf testDir ：递归强制删除目录</span><br><span class="line"></span><br><span class="line">rm -rf testDir&#x2F;* ：递归强制删除testDir目录</span><br></pre></td></tr></table></figure>
</li>
<li><p>移动目录或者文件：<code>mv</code> <code>source</code>(远目录或文件) <code>dest</code>(目标目录)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mv testDir1&#x2F;test1 testDir2：将文件移动到目录中</span><br><span class="line"></span><br><span class="line">mv testDir2 testDir3：将目录递归移动到目录中</span><br><span class="line"></span><br><span class="line">mv test1.txt test2.tx：如果test2.txt不存在，则为重命名，如果test2.txt存在，则会询问是否覆盖</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件</p>
<ul>
<li><p><code>cat</code> [选项] 文件名：文章内容一次性显示出来</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cat test1.txt</span><br><span class="line"></span><br><span class="line">cat -n test1.txt ：显示行号</span><br></pre></td></tr></table></figure>
</li>
<li><p>分页查看文件内容：<code>more</code> 文件名：一次性加载文件所有内容到内存，分页显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">more test1.txt</span><br><span class="line"></span><br><span class="line">回车翻一行、空格翻一页、q退出</span><br></pre></td></tr></table></figure>
</li>
<li><p>分页查看文件内容：<code>less</code> 文件名：分页加载文件所有内容到内存，分页显示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">less test1.txt</span><br><span class="line"></span><br><span class="line">回车翻一行、空格翻一页、q退出</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件的头10行：<code>head</code> [选项] 文件名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head test1.txt ：默认返回头10行</span><br><span class="line"></span><br><span class="line">head -n 5 test1.txt :返回头5行</span><br></pre></td></tr></table></figure>
</li>
<li><p>查看文件的后10行：<code>tail</code> [选项] 文件名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tail test1.txt :默认返回最后10行</span><br><span class="line">  </span><br><span class="line">  tail -n 5 text1.txt :返回最后5行</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>输出系统变量或者常量的值到命令行终端：<code>echo</code> 常量 或者 <code>echo</code> $环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo 字符串</span><br><span class="line"></span><br><span class="line">echo $PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>把前一个查看命令的结果输出到指定的文件：查看命令 &gt; 文件名：如果目标文件不存在，则会新建一个文件，如果目标文件已存在，则把文件以前的内容覆盖</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">head test1.txt &gt; test2.txt</span><br><span class="line"></span><br><span class="line">ls &gt; test3.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux中关于日期和时间的操作命令</p>
<ul>
<li><p>系统日期：<code>date</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">date +%Y ：系统当前年份</span><br><span class="line"></span><br><span class="line">date &#39;+%Y-%m-%d %H:%M:%S&#39;  ：按yyyy-MM-dd HH:mm:ss格式显示</span><br><span class="line"></span><br><span class="line">date -S &#39;2021-10-20 10:20:30&#39; ：设置当前的系统时间</span><br></pre></td></tr></table></figure>
</li>
<li><p>系统日历：<code>cal</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cal：查看当前月份的日历</span><br><span class="line">  </span><br><span class="line">  cal 2021：查看指定年份的日历</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>Linux搜索命令</p>
<ul>
<li><p>搜索文件或者目录的命令：<code>find</code> [搜索范围] [搜索标准] 关键字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find *.txt：搜索当前目录下，所有的.txt文件</span><br><span class="line"></span><br><span class="line">find *e*：搜索当前目录下，所有名称中包含e的那些文件或者目录</span><br><span class="line"></span><br><span class="line">find &#x2F;home&#x2F;*.txt ：搜索&#x2F;home目录下所有.txt文件</span><br><span class="line"></span><br><span class="line">find &#x2F;home [-name] &quot;*.txt&quot; ：搜索&#x2F;home目录及其子目录下所有.txt文件(符合条件的路径也会被搜索)</span><br><span class="line"></span><br><span class="line">find &#x2F;home -size +5M ：搜索&#x2F;home目录及其子目录下大约5M的文件（-5K:小于5K）</span><br><span class="line"></span><br><span class="line">find &#x2F;home -user zhangsan：按照文件所有者搜索</span><br></pre></td></tr></table></figure>
</li>
<li><p>在整棵目录树中根据名称搜索文件或目录，效率较高：<code>locate</code> 关键字</p>
<p><code>locate</code>用的不多：因为目录树维护的不及时，需要用之前先同步文件和数据：<code>updatedb</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">updatedb </span><br><span class="line"></span><br><span class="line">locate *.txt</span><br></pre></td></tr></table></figure>
</li>
<li><p>搜索过滤命令，在前一个搜索命令的结果中进行按名称进一步过滤：</p>
<ul>
<li>搜索命令 |<code>grep</code> [选项] 过滤条件</li>
<li>查看命令 |<code>grep</code> [选项] 过滤条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">find *.txt|grep new ：搜索当前目录下，所有名称包含new的.txt文件</span><br><span class="line">  </span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>cat test.txt | grep [-i] beijing ：查询文件中包含beijing的行，-i：忽略大小写，-n：带行号</p>
<p>ls -al |grep new ：展示名字含有new的子目录和文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">    </span><br></pre></td></tr></table></figure>
</li>
<li><p>Linux中压缩和解压缩命令</p>
<ul>
<li><p>压缩或者解压单个文件</p>
<p><code>gzip</code> 文件名：压缩单个文件，生成一个<code>.gz</code>的压缩包，并且会把原来的文件删除</p>
<p><code>gunzip</code> <code>.gz</code>压缩包名：解压<code>.gz</code>压缩包，并且会把原来的<code>.gz</code>压缩包删除</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gzip test.txt</span><br><span class="line"></span><br><span class="line">gunzip test.txt.gz</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩(打包)或者解压多个文件和目录</p>
<p><code>zip</code> 目标压缩包名称(通常使用<code>.zip</code>压缩包) 文件或者目录列表</p>
<p><code>unzip</code> 压缩表名称(一般是<code>xxx.zip</code>) [<code>-d</code> 解压的目录位置]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">zip  test.zip  test1.txt test2.txt textDir1 </span><br><span class="line"></span><br><span class="line">unzip t est.zip   -d &#x2F;home&#x2F;zhangsan&#x2F;unzip</span><br></pre></td></tr></table></figure>
</li>
<li><p>压缩(打包)或者解压多个文件和目录：<code>tar</code></p>
<p><code>tar</code> 选项说明：</p>
<ul>
<li><code>-c</code>：打包或者压缩</li>
<li><code>-x</code>：解压</li>
<li><code>-v</code>：显示详细的信息</li>
<li><code>-f</code>：指定压缩包后的文件名</li>
<li><code>-z</code>：打包同时压缩</li>
<li><code>-C</code>：指定解压到哪个目录</li>
</ul>
<p>打包或压缩： <code>tar</code> <code>-c</code> 目标压缩包名称(<code>xxx.tar.gz</code>) 文件或者目录列表，一般是：<code>tar -zcvf xxx.tar.gz</code> 文件或者目录</p>
<p>解压：<code>tar</code> <code>-x</code> 压缩包名称(<code>xxx.tar.gz</code>) [<code>-C</code> 解压的目录位置]，一般是：<code>tar -zxvf xxx.tar.gz</code> <code>-C</code> 解压目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zcvf testTar.tar.gz   test1.txt test2.txt testDir1</span><br><span class="line"></span><br><span class="line">tar -zxvf testTar.tar.gz -C &#x2F;home&#x2F;zhangsan&#x2F;tarX</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h2 id="Linux文件和目录权限"><a href="#Linux文件和目录权限" class="headerlink" title="Linux文件和目录权限"></a>Linux文件和目录权限</h2><h4 id="Linux文件、目录与组"><a href="#Linux文件、目录与组" class="headerlink" title="Linux文件、目录与组"></a>Linux文件、目录与组</h4><p>在Linux中，每一个文件或者目录都属于一个组，且只能属于一个组</p>
<p>文件或者目录通过组来控制，哪些用户可以对它进行哪些操作，即文件或者目录的访问权限</p>
<p>在文件或者目录来看，linux系统中所有的用户分为三类</p>
<ul>
<li>所有者：默认情况下，文件或者目录的所有者都是创建者，可以修改</li>
<li>同组用户：跟文件或者目录属于同一个组的用户</li>
<li>其他组用户：既不是文件或者目录的所有者，也不是同组用户</li>
</ul>
<ol>
<li><p>查看文件的所有者和所在组</p>
<p><code>ls -l</code></p>
<p>文件和目录：谁创建的谁就是文件的所有者，文件默认的组就是创建者所在的组</p>
</li>
<li><p>修改文件或者目录的所有者和所在组： <code>chown</code> 文件新的所有者 文件名或者目录名</p>
<p> <code>chown</code> 文件新的所有者:新的组 文件名或者目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chown  zhangsan test1.txt</span><br><span class="line"></span><br><span class="line">chown  zhangsan:dev test2.txt</span><br><span class="line"></span><br><span class="line">chown  zhangsan:dev testDir1 ：testDir中里面的文件和目录的所有者和所在组不会改变</span><br><span class="line"></span><br><span class="line">chown -R zhangsan:dev testDir1：递归修改目录的所有者和所在的组</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改文件或者目录的所在组：<code>chgrp</code> 新的组名 文件名或者目录名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chgrp dev test2.txt</span><br><span class="line"></span><br><span class="line">chgrp -R dev testDir2</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="Linux中的文件或者目录的权限管理"><a href="#Linux中的文件或者目录的权限管理" class="headerlink" title="Linux中的文件或者目录的权限管理"></a>Linux中的文件或者目录的权限管理</h4><p>准备工作：</p>
<ul>
<li>一个用户至少属于一个组，也可以属于多个组</li>
<li>一个文件或者目录也必须属于一个且只能属于一个组</li>
<li>对于一个文件或者目录，Linux系统中的所有的用户可以分为三类：所有者、同组用户、其他组用户</li>
</ul>
<p>在Linux中，任何文件或者目录都有三种权限：读（<code>Read</code>）、写（<code>Write</code>）、执行（<code>Execute</code>）</p>
<ul>
<li>对于文件：<ul>
<li>读：可以读取文件、查看文件的内容，比如<code>cat</code>、<code>more</code>、<code>less</code>、<code>head</code>、<code>tail</code>等</li>
<li>写：可以修改文件的内容，比如：<code>vi</code> 或者 <code>vim</code>等</li>
<li>执行：如果该文件是可执行文件(<code>.sh</code>)，可以直接运行，比如：<code>./xxx.sh</code></li>
</ul>
</li>
<li>对于目录：<ul>
<li>读：可以读取或者查看目录中的内容，比如<code>ls</code>等</li>
<li>写：可以修改目录中的内容，创建子目录、删除子目录、创建文件、删除文件、重命名文件或者目录</li>
<li>执行：可以进入该目录，比如：<code>cd</code> 等</li>
</ul>
</li>
</ul>
<p><strong>文件或者目录的权限控制</strong></p>
<p>在Linux中，任何一个文件或者目录都有三部分权限：</p>
<ul>
<li><p>第一部分权限：所有者权限，文件或者目录的所有者所拥有的的权限，使用<code>r</code>、<code>w</code>、<code>x</code> 分别表示读、写、执行的权限。</p>
<p>比如：<code>rwx</code>：拥有读写执行的权限，<code>r--</code>：只拥有读的权限，<code>r-x</code>：拥有读和执行的权限，<code>---</code>：没有任何权限</p>
</li>
<li><p>第二部分权限：同组用户权限，文件或者目录的同组用户所拥有的权限，表示方式同上</p>
</li>
<li><p>第三部分权限：其他组用户权限，文件或者目录的其他组用户所拥有的权限，表示方式同上</p>
</li>
</ul>
<ol>
<li><p>查看文件或者目录的权限：<code>ls -l</code></p>
</li>
<li><p>修改文件或者目录的权限：<code>chmod</code></p>
<p>权限：用<code>r</code>、<code>w</code>、<code>x</code>分别表示读、写、执行</p>
<p>范围：用<code>u</code>、<code>g</code>、<code>o</code>、<code>a</code>分别表示所有者、同组用户(<code>group</code>)、其他组用户(<code>other</code>)、所有用户</p>
<p>操作符：用<code>+</code>、<code>-</code>、<code> =</code>分别表示增加、减少、设置，对应的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chomd g-w,o+w  test1.test</span><br><span class="line"></span><br><span class="line">chmod g&#x3D;rwx  test2.txt</span><br><span class="line"></span><br><span class="line">chmod a-x test3.txt ：所有人都不可以执行</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用数字的方式修改文件或者目录的权限：</p>
<p>每个权限用一个数据来表示</p>
<ul>
<li>读( <code>r</code> , 2^2)：4</li>
<li>写( <code>w</code> ,2 ^1)：2</li>
<li>执行( <code>x</code> , 2^0)：1</li>
</ul>
<p>每一个文件或者目录都有三部分权限，每一部分权限都可以用一组数据之和来表示，三部分的权限就是一组三个数据的序列（比如 655）</p>
<ul>
<li><code>rwx</code>：7</li>
<li><code>rw-</code>：6</li>
<li><code>r-x</code>：5</li>
<li><code>w-x</code>：3</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 777 test1.txt </span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Linux中的进程管理"><a href="#Linux中的进程管理" class="headerlink" title="Linux中的进程管理"></a>Linux中的进程管理</h2><p>进程：一个程序的执行，一个进程占用一个端口</p>
<p>查看正在运行的进程：<code>ps</code> [选项]</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps ：只会显示应用进程</span><br><span class="line"></span><br><span class="line">ps -e ：显示所有进程</span><br><span class="line"></span><br><span class="line">ps -f  ：以全格式的形式显示进程</span><br></pre></td></tr></table></figure>

<p><code>ps</code>一般用于查看Linux系统中某一些软件或者应用是否处于启动状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ps -ef | grep mysql</span><br></pre></td></tr></table></figure>

<h4 id="Linux中服务-守护进程-管理"><a href="#Linux中服务-守护进程-管理" class="headerlink" title="Linux中服务(守护进程)管理"></a>Linux中服务(守护进程)管理</h4><p>服务是支持Linux运行的一些必要程序，本质上也是进程，叫守护进程，守护进程通常默默地运行在后台，为应用程序提供必要支撑，比如sshd、防火墙等</p>
<p>操作服务：<code>systemctl</code> [<code>start|stop|restart|reload|status|enable</code>(设置是否开机启动)] 服务名称</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl  status firewalld  ：查看防火墙的运行状态</span><br><span class="line"></span><br><span class="line">systemctl stop firewalld ：关闭防火墙</span><br><span class="line"></span><br><span class="line">syststem start firewalld ：开启防火墙</span><br><span class="line"></span><br><span class="line">syststem enable firewalld ：设置防火墙开机启动 </span><br></pre></td></tr></table></figure>

<p>【注释：小于CentOS7的版本，命令是 <code>service</code>】</p>
<h2 id="Linux中软件安装包管理"><a href="#Linux中软件安装包管理" class="headerlink" title="Linux中软件安装包管理"></a>Linux中软件安装包管理</h2><p><code>RPM</code>包管理：</p>
<ol>
<li><p><code>RPM</code>：一种Linux的软件包的打包和安装工具，他操作的软件包都是<code>.rpm</code>结尾</p>
</li>
<li><p><code>RPM</code>命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rpm -qa： 查看当前系统中已经安装的rpm软件包</span><br><span class="line"></span><br><span class="line">rpm -e firefox ：卸载RPM软件包</span><br><span class="line"></span><br><span class="line">rpm  -ivh xxx.rpm ：安装rpm包</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><code>YUM</code>包管理：</p>
<ol>
<li><p><code>YUM</code>：是一种基于RPM的软件包管理工具，它能够从指定服务器上自动下载<code>RPM</code>包并且自动安装，可以自动处理软件包之间的依赖关系</p>
</li>
<li><p><code>YUM</code>命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum list installed ：查看当前系统中已经安装的rpm软件包</span><br><span class="line"></span><br><span class="line">yum remove firefox.x86_64 ：卸载rpm包</span><br><span class="line"></span><br><span class="line">yum install firefox ：安装rpm包(需要网络)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h4 id="Linux网络管理"><a href="#Linux网络管理" class="headerlink" title="Linux网络管理"></a>Linux网络管理</h4><p>修改IP地址、网关、和DNS</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vi  &#x2F;etc&#x2F;stsconfig&#x2F;network-scripts&#x2F;ifcfg-ens33</span><br></pre></td></tr></table></figure>

<p>重启：<code>reboot</code></p>
<p>参考资料：</p>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html">Linux命令大全</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令-2-cd命令</title>
    <url>/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-2-cd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>cd </code>命令可以说是<code>Linux</code>中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用<code> cd</code> 命令上的。</p>
<span id="more"></span>

<p>所以，学习<code>Linux</code> 常用命令，首先就要学好<code>cd</code>命令。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>cd</code>  [目录名]</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>切换当前目录至某一个目录</p>
<h4 id="3-常用示例"><a href="#3-常用示例" class="headerlink" title="3.常用示例"></a>3.常用示例</h4><p>（1）进入系统根目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd /                         :直接回到根目录</span><br><span class="line">cd .. 或者 cd ..//		    :回到上一级目录</span><br><span class="line">cd ../.. // 				 :进入当前目录的父目录的父目录。</span><br></pre></td></tr></table></figure>

<p>（2）进入当前用户主目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd  或者  cd ~</span><br></pre></td></tr></table></figure>

<p>（3）跳转到指定目录</p>
<p>跳转到指定目录</p>
<ul>
<li>从根目录开始，目录名称前加 <code>/</code> </li>
<li>当前目录内的子目录直接写名称即可</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd  /opt/log</span><br></pre></td></tr></table></figure>

<p>（4）返回进入此目录之前所在的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure>

<p>（5）把上个命令的参数作为<code>cd</code>参数使用</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cd !$</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/24/2736501.html">http://www.cnblogs.com/peida/archive/2012/10/24/2736501.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令(1):ls命令</title>
    <url>/2019/03/10/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-1-ls%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>ls</code>命令是<code>linux</code>下最常用的命令。</p>
<span id="more"></span>

<ul>
<li><code>ls</code>命令就是<code>list</code>的缩写</li>
<li>缺省下<code>ls</code>用来打印出当前目录的清单，如果<code>ls</code>指定其他目录，那么就会显示指定目录里的文件及文件夹清单。</li>
<li>通过<code>ls </code>命令不仅可以查看<code>linux</code>文件夹包含的文件，而且可以查看文件权限(包括目录、文件夹、文件权限)、查看目录信息等等。</li>
</ul>
<p><code>ls</code> 命令在日常的<code>linux</code>操作中用的很多</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>ls</code>    [参数]    [目录名]</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>列出目标目录中所有的子目录和文件。</p>
<h4 id="3-常用参数（只列举了少数常用部分）"><a href="#3-常用参数（只列举了少数常用部分）" class="headerlink" title="3.常用参数（只列举了少数常用部分）"></a>3.常用参数（只列举了少数常用部分）</h4><p><code>-a</code> ：即<code>-all</code>,列出目录下的所有文件，包括.开头的隐藏文件</p>
<p><code>-l</code>： 除了文件名之外，还将文件的权限、所有者、文件大小等详细信息列出来   <code>ls -l</code>   <code>===</code>   <code>ll</code></p>
<p><code>-t</code>：以文件的修改时间排序</p>
<p><code>-S</code>：根据文件大小排序</p>
<p><code>-s</code>：<code>-size</code>以块大小为单位列出所有文件的大小</p>
<p><code>-R</code>：<code>–recursive</code> 同时列出所有子目录层</p>
<h4 id="4-常用示例"><a href="#4-常用示例" class="headerlink" title="4.常用示例"></a>4.常用示例</h4><p>（1）列出当前目录中所有以<code>“t”</code>开头的详细内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l t*</span><br></pre></td></tr></table></figure>

<p>（2）列出<code>/home/peidachang</code> 文件夹下的所有文件和目录的详细资料</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls -l -R /home/peidachanjavca</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a href="https://www.cnblogs.com/peida/archive/2012/10/23/2734829.html">https://www.cnblogs.com/peida/archive/2012/10/23/2734829.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令-4-mkdir命令</title>
    <url>/2019/03/19/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-4-mkdir%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>mkdir</code> 命令用来创建指定的名称的目录</p>
<p>要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。</p>
<span id="more"></span>

<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>mkdir </code>  [选项]  目录</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>通过 <code>mkdir</code> 命令可以实现在指定位置创建以 <code>DirName</code>(指定的文件名)命名的文件夹或目录。</p>
<p>要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 </p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p> <code>-m</code>： <code>--mode</code> <code>=</code> 模式，设定权限&lt;模式&gt; (类似 <code>chmod</code>)，而不是 <code>rwxrwxrwx  -  umask</code></p>
<p> <code>-p</code>：<code>--parents</code> ,可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; </p>
<p> <code>-v</code>： <code>--verbose</code> ,每次创建新目录都显示信息</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）创建一个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir test</span><br></pre></td></tr></table></figure>

<p>（2）递归创建多个目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p test1/test2</span><br></pre></td></tr></table></figure>

<p>（3）创建权限为777的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -m 777 test3</span><br><span class="line">//此时test3的权限是rwxrwxrwx</span><br></pre></td></tr></table></figure>

<p>（4）创建新的目录并显示信息</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -v test5</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/25/2738271.html">http://www.cnblogs.com/peida/archive/2012/10/25/2738271.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令-5-rm命令</title>
    <url>/2019/04/02/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-5-rm%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>rm</code>  命令。该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。</p>
<span id="more"></span>
<p><code>rm </code>是常用的命令，也是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在<code>/</code>（根目录）下执行<code>rm * -rf</code>）。所以，我们在执行<code>rm</code>之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>rm</code>  [选项]  文件</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>删除一个目录中的一个或多个文件或目录</p>
<p>如果没有使用<code>- r</code>选项，则<code>rm</code>不会删除目录。如果使用 <code>rm</code> 来删除文件，通常仍可以将该文件恢复原状。</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p><code>-f</code>：<code>--force</code>    忽略不存在的文件，从不给出提示。</p>
<p><code>-i</code>： <code>--interactive</code> 进行交互式删除，默认就是<code>-i</code>参数</p>
<p><code>-r</code>： <code>-R</code>,<code> --recursive</code>   指示<code>rm</code>将参数中列出的全部目录和子目录均递归地删除。</p>
<p><code>-v</code>： <code>--verbose</code>    详细显示进行的步骤</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）删除文件file,系统会先询问是否删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm test1.log</span><br></pre></td></tr></table></figure>

<p>（2）强制删除file，系统不在提示</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -f test2.log</span><br></pre></td></tr></table></figure>

<p>（3）删除任何 .log文件，删除前逐一询问确认</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -i *.log</span><br></pre></td></tr></table></figure>

<p>（4）将test2子目录已经子目录中的所有删除</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -r test2</span><br></pre></td></tr></table></figure>

<p>（5）将test2子目录已经子目录中的所有删除，并且不用一一确认</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rm -rf test2</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/26/2740521.html">http://www.cnblogs.com/peida/archive/2012/10/26/2740521.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令-6-rmdir命令</title>
    <url>/2019/04/03/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-6-rmdir%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>rmdir</code> 命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。删除某目录时也必须具有对父目录的写权限。</p>
<span id="more"></span>

<p>注意，<code>rm -r dir</code>命令可代替<code>rmdir</code>，但是有很大危险性。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p>rmdir  [选项]  文件</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p><code>-p</code> ：<code>--parents</code> 递归删除目录，当子目录删除后其父目录为空时，也一同被删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 </p>
<p><code>-v</code> ：<code>--verbose</code>  显示指令执行过程 </p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）删除一个空的目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir test1</span><br></pre></td></tr></table></figure>

<p>（2）当子目录被删除后使它也成为空目录的话，则顺便一并删除 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">rmdir -p test2/test3</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令-3-pwd命令</title>
    <url>/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-3-pwd%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>pwd</code> 命令来查看”当前工作目录“的完整路径。</p>
<p> 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就可以使用<code>pwd</code>来判定当前目录在文件系统内的确切位置。<br> <span id="more"></span></p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p><code>pwd</code>   [选项]</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>查看”当前工作目录“的完整路径</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p>一般情况下不带任何参数</p>
<p>如果目录是链接时：</p>
<p>格式：<code>pwd -P </code> 显示出实际路径，而非使用连接（<code>link</code>）路径。 </p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）查看当前工作目录的完整路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pwd</span><br></pre></td></tr></table></figure>

<p>（2）目录连接链接时，<code>pwd -P</code>  显示出实际路径，而非使用连接（<code>link</code>）路径；<code>pwd</code>显示的是连接路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost soft]# cd /etc/init.d </span><br><span class="line">[root@localhost init.d]# pwd</span><br><span class="line">/etc/init.d</span><br><span class="line">[root@localhost init.d]# pwd -P</span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]#</span><br></pre></td></tr></table></figure>

<p>（3）命令：</p>
<p>​    <code>/bin/pwd</code>   [选项]</p>
<p>​    选项：</p>
<p>​    <code>-L</code> 目录连接链接时，输出连接路径</p>
<p>​    <code>-P</code> 输出物理路径</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost init.d]# /bin/pwd </span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]# /bin/pwd -P</span><br><span class="line">/etc/rc.d/init.d</span><br><span class="line">[root@localhost init.d]# /bin/pwd -L</span><br><span class="line">/etc/init.d</span><br><span class="line">[root@localhost init.d]#</span><br></pre></td></tr></table></figure>

<p>注：当前目录被删除了，而<code>pwd</code>命令仍然显示那个目录</p>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/24/2737730.html">http://www.cnblogs.com/peida/archive/2012/10/24/2737730.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令-7-mv命令</title>
    <url>/2019/04/03/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-7-mv%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><code>mv</code> 命令是<code>move</code>的缩写，可以用来移动文件或者将文件改名（<code>move (rename) files</code>），</p>
<span id="more"></span>

<p>是<code>Linux</code>系统下常用的命令，经常用来备份文件或者目录。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p> <code>mv</code>  [选项]  源文件或目录  目标文件或目录</p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>视<code>mv</code>命令中第二个参数类型的不同（是目标文件还是目标目录），<code>mv</code> 命令将文件重命名或将其移至一个新的目录中。</p>
<ul>
<li>当第二个参数类型是文件时，<code>mv</code>命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。</li>
<li>当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，<code>mv</code>命令将各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，<code>mv</code>先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。</li>
</ul>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p><code>-b</code> ：若需覆盖文件，则覆盖前先行备份。 </p>
<p><code>-f</code> ：<code>force</code> 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</p>
<p><code>-i</code> ：若目标文件 (<code>destination</code>) 已经存在时，就会询问是否覆盖！</p>
<p><code>-u</code> ：若目标文件已经存在，且 <code>source</code> 比较新，才会更新(<code>update</code>)</p>
<p><code>-t</code> ： <code>--target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY</code>，即指定<code>mv</code>的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）文件改名</p>
<p>默认是带有<code> -i</code> 参数，即如果<code>log2</code>已存在，则询问是否覆盖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv log1.log log2.text</span><br></pre></td></tr></table></figure>

<p>（2）文件改名，即使<code>log3.text</code>存在，也是直接覆盖掉。</p>
<p><code>log2.text</code> 的内容直接覆盖了<code>log3.text</code> 内容</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv -f log2.text log3.text</span><br></pre></td></tr></table></figure>

<p>（3）移动文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv log1.log test1</span><br></pre></td></tr></table></figure>

<p>（4）将三个文件一起移动到某一个文件夹</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv -t test2/  log1.text log2.log log3.log</span><br><span class="line"> 或</span><br><span class="line">mv log1.text log2.log log3.log  test3/</span><br></pre></td></tr></table></figure>

<p>（5）移动当前文件夹下所有文件到上一级目录</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv * ../</span><br></pre></td></tr></table></figure>

<p>（6）把当前目录的一个子目录里的文件移动到另一个子目录里</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv test2/*.txt test3</span><br></pre></td></tr></table></figure>

<p>（6）目录的移动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv dir1 dir2</span><br></pre></td></tr></table></figure>

<p>（7）文件被覆盖前做简单的备份，前面加参数 -b</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mv log1.txt -b log2.txt</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p><code>-b</code> 不接受参数，<code>mv</code>会去读取环境变量<code>VERSION_CONTROL</code>来作为备份策略。</p>
<p><code>--backup</code>该选项指定如果目标文件存在时的动作，共有四种备份策略：</p>
<p>1.<code>CONTROL=none或off</code> : 不备份。</p>
<p>2.<code>CONTROL=numbered或t</code>：数字编号的备份</p>
<p>3.<code>CONTROL=existing或nil</code>：如果存在以数字编号的备份，则继续编号备份<code>m+1...n</code>：</p>
<p>执行<code>mv</code>操作前已存在以数字编号的文件<code>log2.txt.~1~</code>，那么再次执行将产生<code>log2.txt~2~</code>，以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。</p>
<p>4.<code>CONTROL=simple或never</code>：使用简单备份：在被覆盖前进行了简单备份，简单备份只能有一份，再次被覆盖时，简单备份也会被覆盖。</p>
<p>参考资料</p>
<p><a href="http://www.cnblogs.com/peida/archive/2012/10/27/2743022.html">http://www.cnblogs.com/peida/archive/2012/10/27/2743022.html</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令-8-cp命令</title>
    <url>/2019/04/04/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-8-cp%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p>cp命令用来复制文件或者目录，一般情况下，</p>
<span id="more"></span>

<p>shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。</p>
<p>但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 </p>
<p>cp命令是Linux系统中最常用的命令之一。</p>
<h4 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式"></a>1.命令格式</h4><p>cp  [选项]  [-T]    源文件 目的文件</p>
<p>或：</p>
<p>cp [选项]   源   目录</p>
<p>或：</p>
<p>cp [选项]  -t  目录  源 </p>
<h4 id="2-命令功能"><a href="#2-命令功能" class="headerlink" title="2.命令功能"></a>2.命令功能</h4><p>将源文件复制至目标文件，或将多个源文件复制至目标目录。</p>
<h4 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3.常用参数"></a>3.常用参数</h4><p>-a ：–archive    等于-dR –preserve=all</p>
<p>-b ：为每个已存在的目标文件创建备份，类似–backup 但不接受参数</p>
<p>-i, –interactive        覆盖前询问(使前面的 -n 选项失效)</p>
<p>-n, –no-clobber   不要覆盖已存在的文件(使前面的 -i 选项失效)</p>
<p>-f, –force        如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项)</p>
<p>-R, -r, –recursive  复制目录及目录内的所有项目</p>
<p>-H                跟随源文件中的命令行符号链接</p>
<p>-l, –link            链接文件而不复制</p>
<p>-L, –dereference   总是跟随符号链接</p>
<p>-d：等于–no-dereference –preserve=links</p>
<p>-P, –no-dereference   不跟随源文件中的符号链接</p>
<p>–preserve[=属性列表   保持指定的属性(默认：模式,所有权,时间戳)，如果 可能保持附加属性：环境、链接、xattr 等</p>
<p>-p       等于–preserve=模式,所有权,时间戳</p>
<p>–copy-contents        在递归处理时复制特殊文件内容</p>
<h4 id="4．常用示例"><a href="#4．常用示例" class="headerlink" title="4．常用示例"></a>4．常用示例</h4><p>（1）</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL实践</title>
    <url>/2021/05/21/SQL/SQL%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<p>主要是实际遇到的SQL场景记录</p>
<span id="more"></span>

<p>目录:</p>
<ul>
<li>一.按时间分段排序</li>
<li>二.字符串批量对批量的查询</li>
</ul>
<h3 id="一-按时间分段排序"><a href="#一-按时间分段排序" class="headerlink" title="一.按时间分段排序"></a>一.按时间分段排序</h3><ol>
<li><p>需求描述</p>
<p>存在一个 健身房预定权限表<code>authority_reserve</code>：规定了每个人可以预定健身多长时间，</p>
<p>获取数据列表，列表排序方式：</p>
<p> ① 当前日期在授权日期范围内的，按照授权开始日期正序；</p>
<p> ② 当前日期未到授权日期范围内，按照授权开始日期正序；</p>
<p> ③ 当前日期已过授权日期范围内的，按照授权开始日期正序。</p>
</li>
</ol>
<p>具体表数据如下：</p>
<table>
<thead>
<tr>
<th>Id</th>
<th>user_id</th>
<th>auth_start_time</th>
<th>auth_end_time</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>100</td>
<td>2021-05-02</td>
<td>2021-05-10</td>
</tr>
<tr>
<td>2</td>
<td>101</td>
<td>2021-05-25</td>
<td>2021-05-30</td>
</tr>
<tr>
<td>3</td>
<td>102</td>
<td>2021-05-20</td>
<td>2021-05-25</td>
</tr>
<tr>
<td>4</td>
<td>103</td>
<td>2021-05-05</td>
<td>2021-05-08</td>
</tr>
<tr>
<td>5</td>
<td>104</td>
<td>2021-05-22</td>
<td>2021-05-23</td>
</tr>
<tr>
<td>6</td>
<td>105</td>
<td>2021-05-19</td>
<td>2021-05-25</td>
</tr>
</tbody></table>
<p>首先注意今天为：2021-05-21</p>
<ol start="2">
<li>SQL实现</li>
</ol>
<ul>
<li><p>使用 <code>order by case when</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id, user_id, auth_start_time, auth_end_time</span><br><span class="line">from authority_reserve</span><br><span class="line">order by </span><br><span class="line">case </span><br><span class="line">   when (auth_start_time &lt; &#39;2021-05-21&#39; and auth_end_time &gt; &#39;2021-05-21&#39;) then 0</span><br><span class="line">   when auth_start_time &gt; &#39;2021-05-21&#39; then 1</span><br><span class="line">   when auth_end_time &lt; &#39;2021-05-21&#39; then 2 end,</span><br><span class="line">auth_start_time asc;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>order by case when</code> 在这个例子中不是很灵活，其更适用于排序随意数字，比如:</p>
<p>健身房<code>gym</code>状态字段state，0:未投入使用 1:正常使用中 2:停止使用，按照正常使用–未投入使用–停止使用的顺序排序</p>
<p>select id, state from gym<br>order by case<br>when state=1 then 0<br>when state=0 then 1<br>when state=2 then 2 end;</p>
</blockquote>
</li>
<li><p>使用 <code>union all</code></p>
<p>使用 <code>union all</code> 灵活性比较高，比如第一段当前日期在授权日期范围内的，也可以按照授权开始时间倒序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(select id, user_id, auth_start_time, auth_end_time</span><br><span class="line"> from authority_reserve</span><br><span class="line"> where auth_start_time &lt; &#39;2021-05-21&#39; and  auth_end_time &gt; &#39;2021-05-21&#39; order by auth_start_time asc)</span><br><span class="line">union all</span><br><span class="line">(select id, user_id, auth_start_time, auth_end_time</span><br><span class="line"> from authority_reserve</span><br><span class="line"> where auth_start_time &gt; &#39;2021-05-21&#39; order by auth_start_time asc)</span><br><span class="line">union all</span><br><span class="line">(select id, user_id, auth_start_time, auth_end_time</span><br><span class="line"> from authority_reserve</span><br><span class="line"> where auth_end_time &lt; &#39;2021-05-21&#39; order by auth_start_time asc);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="3">
<li>查询结果</li>
</ol>
<table>
<thead>
<tr>
<th>Id</th>
<th>user_id</th>
<th>auth_start_time</th>
<th>auth_end_time</th>
</tr>
</thead>
<tbody><tr>
<td>6</td>
<td>105</td>
<td>2021-05-19</td>
<td>2021-05-25</td>
</tr>
<tr>
<td>3</td>
<td>102</td>
<td>2021-05-20</td>
<td>2021-05-25</td>
</tr>
<tr>
<td>5</td>
<td>104</td>
<td>2021-05-22</td>
<td>2021-05-23</td>
</tr>
<tr>
<td>2</td>
<td>101</td>
<td>2021-05-25</td>
<td>2021-05-30</td>
</tr>
<tr>
<td>1</td>
<td>100</td>
<td>2021-05-02</td>
<td>2021-05-10</td>
</tr>
<tr>
<td>4</td>
<td>103</td>
<td>2021-05-05</td>
<td>2021-05-08</td>
</tr>
</tbody></table>
<h3 id="二-字符串批量对批量的查询"><a href="#二-字符串批量对批量的查询" class="headerlink" title="二.字符串批量对批量的查询"></a>二.字符串批量对批量的查询</h3><p>注意：当前实践实现方式仅限<code>postgreal</code>数据库</p>
<ol>
<li><p>需求描述：健身房<code>gym</code>包括设备：跑步机、高位下拉、俯卧屈腿、倒蹬器 等等</p>
<p>查询条件传入多个设备，健身房有其中任意一个设备即可被查询出来（正常数据库健身房设备应该使用字典表示，此时为了查看方便直接使用汉字表示）</p>
<p>具体表数据如下：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>equipment</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>高位下拉,跑步机</td>
</tr>
<tr>
<td>2</td>
<td>俯卧屈腿,高位下拉</td>
</tr>
<tr>
<td>3</td>
<td>俯卧屈腿,跑步机</td>
</tr>
<tr>
<td>4</td>
<td>跑步机,俯卧屈腿</td>
</tr>
<tr>
<td>5</td>
<td>倒蹬器</td>
</tr>
<tr>
<td>6</td>
<td>倒蹬器,俯卧屈腿,高位下拉</td>
</tr>
</tbody></table>
<ol start="2">
<li>SQL实现</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">select id, equipment from gym</span><br><span class="line">where substring(equipment from &#39;[高位下拉|倒蹬器]&#39;) !&#x3D; &#39;&#39; order by id </span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>substring(string from pattern)</code> : 从字符串中找出与POSIX正则表达式匹配的子字符串。</p>
<p>示例 : <code>substring(&#39;Thomas&#39; from &#39;...$&#39;) mas</code></p>
</blockquote>
<ol start="3">
<li>查询结果</li>
</ol>
<table>
<thead>
<tr>
<th>id</th>
<th>equipment</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>高位下拉,跑步机</td>
</tr>
<tr>
<td>2</td>
<td>跑步机,俯卧屈腿</td>
</tr>
<tr>
<td>5</td>
<td>倒蹬器</td>
</tr>
<tr>
<td>6</td>
<td>倒蹬器,俯卧屈腿,高位下拉</td>
</tr>
</tbody></table>
<p>参考资料</p>
<p><a href="https://help.aliyun.com/document_detail/166200.html">PostgreSQL字符串函数</a></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL的连表查询</title>
    <url>/2021/01/01/SQL/SQL%E7%9A%84%E8%BF%9E%E8%A1%A8%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<p>表的连接包括：内连接、左连接、右连接、外连接，交叉连接</p>
<span id="more"></span>

<h4 id="SQL的四种连接查询"><a href="#SQL的四种连接查询" class="headerlink" title="SQL的四种连接查询"></a>SQL的四种连接查询</h4><ul>
<li><p>内连接查询 join inner join</p>
<p>该查询将返回两表满足匹配关系的记录。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/SQL/%E5%86%85%E8%BF%9E%E6%8E%A5.png" alt="内连接图示"></p>
</li>
<li><p>外连接</p>
<p>外连接可分为：左连接、右连接、完全外连接</p>
<ul>
<li><p>左连接 left join left outer join</p>
<p>获取左表中的所有记录，即使在右表没有对应匹配的记录。</p>
<blockquote>
<p>左外连接包含left join左表所有行，如果左表中某行在右表没有匹配，则结果中对应行右表的部分全部为空(NULL).</p>
<p>注：此时我们不能说结果的行数等于左表数据的行数（只有表关系为一对一的时候相同）。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/SQL/%E5%B7%A6%E8%BF%9E%E6%8E%A5.png" alt="左连接图示"></p>
</li>
<li><p>右连接 right join right outer join</p>
<p>用于获取右表中的所有记录，即使左表没有对应匹配的记录。</p>
<blockquote>
<p>右外连接包含right join右表所有行，如果左表中某行在右表没有匹配，则结果中对应左表的部分全部为空(NULL)。</p>
<p>注：此时我们不能说结果的行数等于右表数据的行数（只有表关系为一对一的时候相同）。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/SQL/%E5%8F%B3%E8%BF%9E%E6%8E%A5.png" alt="右连接图示"></p>
</li>
<li><p>完全连接. Full join</p>
<p>返回两个表中的所有行。</p>
<blockquote>
<p>完全外连接包含full join左右两表中所有的行，如果右表中某行在左表中没有匹配，则结果中对应行右表的部分全部为空(NULL)，如果左表中某行在右表中没有匹配，则结果中对应行左表的部分全部为空(NULL)。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/SQL/%E5%AE%8C%E5%85%A8%E8%BF%9E%E6%8E%A5.png" alt="完全连接图示"></p>
</li>
</ul>
</li>
<li><p>交叉连接 cross join</p>
<p>没有 WHERE 子句的交叉联接将产生连接所涉及的表的笛卡尔积。第一个表的行数乘以第二个表的行数等于笛卡尔积结果集的大小。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/SQL/%E4%BA%A4%E5%8F%89%E8%BF%9E%E6%8E%A5.png" alt="交叉连接图示"></p>
</li>
</ul>
<h4 id="连接查询示例"><a href="#连接查询示例" class="headerlink" title="连接查询示例"></a>连接查询示例</h4><p>A表 user_info</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id    name </span><br><span class="line"> 1    张三</span><br><span class="line"> 2    李四</span><br><span class="line"> 3    王五</span><br></pre></td></tr></table></figure>

<p>B表 user_job</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id    user_id    job</span><br><span class="line"> 4      1        研发</span><br><span class="line"> 5      2        产品</span><br><span class="line"> 6      4        测试</span><br></pre></td></tr></table></figure>

<ul>
<li><p>内连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ui.id,ui.name,uj.id,uj.user_id,uj.job </span><br><span class="line">FROM user_info ui</span><br><span class="line">JOIN user_job uj </span><br><span class="line">ON  ui.id &#x3D; uj.user_id</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;内连接可以省略连接关键字：from user_info ui, user_job uj</span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line"> ui.id  name  uj.id  user_id   job </span><br><span class="line">  1     张三    4       1       研发</span><br><span class="line">  2     李四    5       2       产品</span><br></pre></td></tr></table></figure>
</li>
<li><p>外连接</p>
<ul>
<li><p>左连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ui.id,ui.name,uj.id,uj.user_id,uj.job </span><br><span class="line">FROM user_info ui</span><br><span class="line">LEFT JOIN user_job uj </span><br><span class="line">ON  ui.id &#x3D; uj.user_id</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line"> ui.id  name  uj.id  user_id   job </span><br><span class="line">  1     张三    4       1       研发</span><br><span class="line">  2     李四    5       2       产品</span><br><span class="line">  3     王五    NULL    NULL    NULL</span><br></pre></td></tr></table></figure>
</li>
<li><p>右连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ui.id,ui.name,uj.id,uj.user_id,uj.job </span><br><span class="line">FROM user_info ui</span><br><span class="line">RIGHT JOIN user_job uj </span><br><span class="line">ON  ui.id &#x3D; uj.user_id</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line"> ui.id  name  uj.id  user_id   job </span><br><span class="line">  1     张三    4       1       研发</span><br><span class="line">  2     李四    5       2       产品</span><br><span class="line"> NULL   NULL   6       4       测试</span><br></pre></td></tr></table></figure>
</li>
<li><p>完全连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ui.id,ui.name,uj.id,uj.user_id,uj.job </span><br><span class="line">FROM user_info ui</span><br><span class="line">FULL JOIN user_job uj </span><br><span class="line">ON  ui.id &#x3D; uj.user_id</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line"> ui.id  name  uj.id  user_id   job </span><br><span class="line">  1     张三    4       1       研发</span><br><span class="line">  2     李四    5       2       产品</span><br><span class="line">  3     王五    NULL    NULL    NULL</span><br><span class="line"> NULL   NULL   6       4       测试</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>交叉连接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT ui.id,ui.name,uj.id,uj.user_id,uj.job </span><br><span class="line">FROM user_info ui</span><br><span class="line">CROSS JOIN user_job uj </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;结果：</span><br><span class="line"> ui.id  name  uj.id  user_id   job </span><br><span class="line">  1     张三    4       1       研发</span><br><span class="line">  2     李四    4       1       研发</span><br><span class="line">  3     王五    4       1       研发</span><br><span class="line">  1     张三    5       2       产品</span><br><span class="line">  2     李四    5       2       产品</span><br><span class="line">  3     王五    5       2       产品</span><br><span class="line">  1     张三    6       4       测试</span><br><span class="line">  2     李四    6       4       测试</span><br><span class="line">  3     王五    6       4       测试</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>参考资料</p>
<p><a href="https://www.codeproject.com/Articles/33052/Visual-Representation-of-SQL-Joins">Visual Representation of SQL Joins - CodeProject</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/68136613">SQL多表查询</a></p>
<p><a href="http://dedecms.com/knowledge/data-base/sql-server/2012/0709/2872.html">SQL多表连接查询</a></p>
<p><a href="https://blog.csdn.net/wwwyuanliang10000/article/details/21534365">多对多连表查询</a></p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>每天一个Linux命令目录</title>
    <url>/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>每天一个Linux命令的目录</p>
<span id="more"></span>

<p>一.文件目录操作命令</p>
<ol>
<li><a href="http://zhangyuying.cn/2019/03/10/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-1-ls%E5%91%BD%E4%BB%A4/"><code>ls</code>命令</a></li>
<li><a href="http://zhangyuying.cn/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-2-cd%E5%91%BD%E4%BB%A4/"><code>cd</code>命令</a></li>
<li><a href="http://zhangyuying.cn/2019/03/18/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-3-pwd%E5%91%BD%E4%BB%A4/"><code>pwd</code>命令</a></li>
<li><a href="http://zhangyuying.cn/2019/03/19/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-4-mkdir%E5%91%BD%E4%BB%A4/"><code>mkdir</code>命令</a></li>
<li><a href="http://zhangyuying.cn/2019/04/02/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-5-rm%E5%91%BD%E4%BB%A4/"><code>rm</code>命令</a></li>
<li><a href="http://zhangyuying.cn/2019/04/03/Linux/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AALinux%E5%91%BD%E4%BB%A4-6-rmdir%E5%91%BD%E4%BB%A4/"><code>rmdir</code>命令</a></li>
</ol>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>每天一个Linux命令</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Hash命令</title>
    <url>/2022/06/23/Redis/Redis-Hash%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Redis-Hash操作命令</strong></p>
<span id="more"></span>

<h4 id="设置和获取操作"><a href="#设置和获取操作" class="headerlink" title="设置和获取操作"></a>设置和获取操作</h4><h5 id="hset、hget"><a href="#hset、hget" class="headerlink" title="hset、hget"></a>hset、hget</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hset key field value :用于设置指定 key 的哈希表字段和值（field/value），如果存在旧值将会被覆盖，返回被修改的fiele个数</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># hget key field :获取key关联的哈希字段的值,如果给定的字段或 key 不存在时，返回 nil 。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">heget</span> <span class="string">key1</span> <span class="string">field1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="hsetnx"><a href="#hsetnx" class="headerlink" title="hsetnx"></a>hsetnx</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hsetnx key field value :仅当字段field不存在时，设置哈希表字段的值.(一次只能设置一个field)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hsetnx</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hsetnx</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;valuenew&quot;</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hget</span> <span class="string">key1</span> <span class="string">field1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="hmset、hmget"><a href="#hmset、hmget" class="headerlink" title="hmset、hmget"></a>hmset、hmget</h5><blockquote>
<p>hmset命令和hset命令用法相同，且Redis 4.0.0起，hmset 被废弃，请使用 hset 代替</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># HMGET key field1 [field2] :用于同时获取多个给定哈希字段（field）对应的值。key或者field不存在则返回nil</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hmget</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">field2</span> <span class="string">field3</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">(nil)</span></span><br></pre></td></tr></table></figure>

<h5 id="hgetall"><a href="#hgetall" class="headerlink" title="hgetall"></a>hgetall</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hgetall key :获取key关联的所有字段和值。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hgetall</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;field1&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;field2&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="hkeys、hvals"><a href="#hkeys、hvals" class="headerlink" title="hkeys、hvals"></a>hkeys、hvals</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hkeys key :获取key关联的所有字段，key不存在反悔空表</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hkeys</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;field1&quot;</span></span><br><span class="line"><span class="string">&quot;field2&quot;</span></span><br><span class="line"><span class="comment">#hvals key :用于获取哈希表中的所有字段的值，key不存在返回空表</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key2</span> <span class="string">field3</span> <span class="string">&quot;value3&quot;</span> <span class="string">field4</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hvals</span> <span class="string">key2</span></span><br><span class="line"><span class="string">&quot;vlaue3&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="hscan"><a href="#hscan" class="headerlink" title="hscan"></a>hscan</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hscan key cursor [MATCH pattern] [COUNT count]:迭代哈希表中的所有键值对</span></span><br><span class="line"><span class="comment"># cursor 表示游标，默认为0, pattern :匹配的模式, count :返回元素的数量,默认为10</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;field2&quot;</span> <span class="string">field3</span> <span class="string">&quot;value3&quot;</span> <span class="string">field4</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hscan</span> <span class="string">key1</span> <span class="number">0</span> </span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="number">1</span><span class="string">)</span> <span class="string">&quot;field1&quot;</span></span><br><span class="line">   <span class="number">2</span><span class="string">)</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line">   <span class="number">3</span><span class="string">)</span> <span class="string">&quot;field2&quot;</span></span><br><span class="line">   <span class="number">4</span><span class="string">)</span> <span class="string">&quot;field2&quot;</span></span><br><span class="line">   <span class="number">5</span><span class="string">)</span> <span class="string">&quot;field3&quot;</span></span><br><span class="line">   <span class="number">6</span><span class="string">)</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line">   <span class="number">7</span><span class="string">)</span> <span class="string">&quot;field4&quot;</span></span><br><span class="line">   <span class="number">8</span><span class="string">)</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hscan</span> <span class="string">key1</span> <span class="number">0</span> <span class="string">match</span> <span class="string">&quot;field1*&quot;</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="number">1</span><span class="string">)</span> <span class="string">&quot;field1&quot;</span></span><br><span class="line">   <span class="number">2</span><span class="string">)</span> <span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="判断操作"><a href="#判断操作" class="headerlink" title="判断操作"></a>判断操作</h4><h5 id="hexists"><a href="#hexists" class="headerlink" title="hexists"></a>hexists</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hexists key field :用于确定哈希表字段是否存在,返回1为存在，0为不存在，key或者field不存在则返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hexists</span> <span class="string">key1</span> <span class="string">field1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hexists</span> <span class="string">key1</span> <span class="string">field2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="hlen"><a href="#hlen" class="headerlink" title="hlen"></a>hlen</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#hlen key :获取key中的哈希表的字段(field)的数量。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;value2&quot;</span> <span class="string">field3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hlen</span> <span class="string">key1</span></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="hdel"><a href="#hdel" class="headerlink" title="hdel"></a>hdel</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hdel key field1 [field2] :用于删除一个或多个哈希表字段和值，返回成功删除的字段的数量，不存在的field将被忽略,如果key不存在当做空的哈希表处理，返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hdel</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">field2</span> <span class="string">field3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hlen</span> <span class="string">key1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="值为数据的操作"><a href="#值为数据的操作" class="headerlink" title="值为数据的操作"></a>值为数据的操作</h4><h5 id="hincrby、hincrbyfloat"><a href="#hincrby、hincrbyfloat" class="headerlink" title="hincrby、hincrbyfloat"></a>hincrby、hincrbyfloat</h5><blockquote>
<p>hincrby：本操作的值被限制在 64 位(bit)有符号数字表示之内。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># hincrby key field increment :为key中的域field的值加上增量increment，increment可以为负数,返回操作后value的值</span></span><br><span class="line"><span class="comment"># 如果key不存在，一个新的哈希表被创建并执行hincrby命令，如果域field不存在，那么在执行命令前，域的值被初始化为0，如果value是字符串将会报错</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field1</span> <span class="number">5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hincrby</span> <span class="string">key1</span> <span class="string">field1</span> <span class="number">1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hincrby</span> <span class="string">key1</span> <span class="string">field1</span> <span class="number">-3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># hincrbyfloat key field increment :为key中的域field的值加上浮点数增量increment，increment可以为负数,返回操作后value的值</span></span><br><span class="line"><span class="comment"># 如果key不存在，一个新的哈希表被创建并执行hincrbyfloat命令，如果域field不存在，那么在执行命令前，域的值被初始化为0，如果value是字符串或者increment不能解释(parse)为双精度浮点数将会报错</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hset</span> <span class="string">key1</span> <span class="string">field2</span> <span class="number">5.55</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hincrbyfloat</span> <span class="string">key1</span> <span class="string">field2</span> <span class="number">0.1</span></span><br><span class="line"><span class="number">5.65</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">hincrbyfloat</span> <span class="string">key1</span> <span class="string">field2</span> <span class="number">-5</span></span><br><span class="line"><span class="number">0.65</span></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a href="https://www.redis.com.cn/commands/hdel.html">Redis-Hash命令</a></p>
<p><a href="http://c.biancheng.net/redis/hashes.html">Redis-Hash哈希散列</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Key键</title>
    <url>/2022/07/04/Redis/Redis-Key%E9%94%AE/</url>
    <content><![CDATA[<p>Redis 是一种键值（<code>key-value</code>）型的缓存型数据库，Redis 提供了诸多操作key的命令，从而实现了对存储数据的管理。</p>
<span id="more"></span>

<h4 id="Key的类型"><a href="#Key的类型" class="headerlink" title="Key的类型"></a>Key的类型</h4><p><code>key</code> 的类型并不局限于字符串（空字符串也是有效<code>key</code>值），在 Redis 中 <code>key</code> 具有二进制安全的特性，这意味着它可以使用任何二进制序列，但是这种 <code>key</code> 过于复杂一般不建议采用。</p>
<blockquote>
<p>单例能处理<code>key</code>：2.5亿个</p>
</blockquote>
<h4 id="key的命名规范"><a href="#key的命名规范" class="headerlink" title="key的命名规范"></a>key的命名规范</h4><p>“见名知意”就是 <code>key</code> 最佳的命名规范，<code>key</code> 的命名需要遵循以下规则：</p>
<ul>
<li><code>key</code> 取值不可以太长，否则会影响<code> value</code> 的查找效率，并且浪费内存空间。</li>
<li><code>key</code> 取值也不能过短，否则会使得 <code>key</code> 可读性变差。</li>
</ul>
<blockquote>
<p>在符合业务场景情况下，<code>key</code> 要尽可能的简单明了，可以使用单词的缩写，或者自定义缩写格式。</p>
</blockquote>
<p>例如的人员名称存储key为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">人员数据：id:1 | name:zhangsan ，存储人员名称的key为：</span><br><span class="line">127.0.0.1:6379&gt; set user:id:1:username zhangsan</span><br><span class="line">&quot;OK&quot;</span><br></pre></td></tr></table></figure>

<h4 id="key的过期时间"><a href="#key的过期时间" class="headerlink" title="key的过期时间"></a>key的过期时间</h4><p>Redis支持为<code>key</code>设置过期时间</p>
<ul>
<li>一是可以避免使用频率不高的<code> key</code> 长期存在，从而占用内存资源</li>
<li>二是控制缓存的失效时间。</li>
</ul>
<h4 id="key的存储"><a href="#key的存储" class="headerlink" title="key的存储"></a>key的存储</h4><p>Redis中key和value是使用字典进行存储的，且key都是以SDS格式存储的</p>
<p><strong>dict（字典）</strong></p>
<ul>
<li><p><code>*type</code>： 是一个<code>dictType</code>结构的指针，<code>dictType</code>结构中定义了多个函数。这些函数多是对<code>key</code>和<code>value</code>相关的一些操作。</p>
<blockquote>
<p><code>dictType</code>结构包含若干函数指针，用于<code>dict</code>的调用者对涉及<code>key</code>和<code>value</code>的各种操作进行自定义。比如计算计算<code>key</code>的哈希值、对<code>value</code>的拷贝等</p>
</blockquote>
</li>
<li><p><code>*privdata</code>： 私有数据指针（<code>privdata</code>）由调用者在创建<code>dict</code>的时候传进来,在<code>dictType</code>的某些操作被调用时会传回给调用者</p>
</li>
<li><p><code>ht[2]</code>：底层用来存数据的<code>hash</code>表：2个<code>dictht</code>，（2个<code>dictht</code>，主要涉及到<code>hash</code>表的扩容和缩容。）</p>
<p><strong>dictht</strong>：定义了一个<code>hash</code>表的结构，表中保存的是指向<code>dictEntry</code>的指针。</p>
<ul>
<li><p><code>size</code>： 哈希表大小，即哈希表数组大小</p>
</li>
<li><p><code>sizemask</code>：哈希表大小掩码，总是等于<code>size</code>-1，主要用于计算索引</p>
</li>
<li><p><code>used</code>： 已使用节点数，即已使用键值对数</p>
</li>
<li><p><code>table</code>：<code>hash</code>表数组，内部存储的就是<code>dictEntry</code></p>
<p><strong>dictEntry</strong>：是Redis中<code>key</code>和<code>value</code>的结合。向Redis保存的<code>key</code>和<code>value</code>最后会被封装为一个<code>dictEntry</code>。</p>
<ul>
<li><p><code>key</code>：保存了<code>key</code>的值</p>
</li>
<li><p><code>*val</code>：保存了<code>value</code>的值。这个值可以是一个指向真正值的指针，也可以是一个<code>uint64_t u64</code>或<code>int64_t s64</code>的整数，又或者是一个<code>double</code>类型的数。</p>
</li>
<li><p><code>*next</code>：指向下一个<code>dictEntry</code>的指针。<code>dictEntry</code>最终是保存在一个<code>hash</code>表中，那么在产生<code>hash</code>冲突的时候，就会以链表的方式来连接。这个时候就需要用到这个指针了。</p>
<blockquote>
<p><code>key</code>和<code>value</code>分别是一个<code>redisObject</code>，<code>redisObject</code>相关内容可点击<a href="https://zhangyuying.top/2022/06/30/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/#more">Redis数据类型</a>查看详情</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>Redis中<code>key</code>的存储图示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/Redis-Key%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="Redis-key存储结构"></p>
<p>参考资料</p>
<p><a href="http://c.biancheng.net/redis/keys.html">Redis key键</a></p>
<p><a href="https://blog.csdn.net/weixin_48024348/article/details/119045925">Redis底层是怎样保存一个key和value的</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL</title>
    <url>/2021/07/27/MySQL/MySQL/</url>
    <content><![CDATA[<p><code>MySQL</code>是开源的关系型数据库管理系统</p>
<p><code>MySQL</code>是一个基于插件式存储引擎的数据库，本文内容都是基于<code>MySQL InnoDB</code>存储引擎。</p>
<span id="more"></span>

<p>目录</p>
<ol>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">MySQL体系结构</a><ul>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E-InnoDB">存储引擎:InnoDB</a></li>
</ul>
</li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E6%96%87%E4%BB%B6">MySQL文件</a><ul>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%A1%A8%E7%BB%93%E6%9E%84%E5%AE%9A%E4%B9%89%E6%96%87%E4%BB%B6">表结构定义文件</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6">日志文件</a></li>
</ul>
</li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E7%B4%A2%E5%BC%95">MySQL索引</a><ul>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#B-%E6%A0%91%E7%B4%A2%E5%BC%95">B+树索引</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95">辅助索引</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%A1%E7%90%86">索引的管理</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8">索引的使用</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%87%AA%E9%80%82%E5%BA%94Hash%E7%B4%A2%E5%BC%95">自适应Hash索引</a></li>
</ul>
</li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%B8%ADSQL%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B">MySQL中SQL执行流程</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%BA%8B%E5%8A%A1">MySQL事务</a><ul>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E5%8E%9F%E5%AD%90%E6%80%A7%E3%80%81%E4%B8%80%E8%87%B4%E6%80%A7%E3%80%81%E6%8C%81%E4%B9%85%E6%80%A7%E7%9A%84%E5%AE%9E%E7%8E%B0">MySQL原子性、一致性、持久性的实现</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E9%9A%94%E7%A6%BB%E6%80%A7%E5%AE%9E%E7%8E%B0">MySQL隔离性实现</a></li>
</ul>
</li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88">MySQL优化方案</a><ul>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E8%AF%AD%E6%B3%95">语法</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E7%B4%A2%E5%BC%95">索引</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#MySQL%E8%87%AA%E5%B8%A6%E7%9A%84%E4%BC%98%E5%8C%96">MySQL自带的优化</a></li>
</ul>
</li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E9%99%84%E5%BD%95">通用概念附录</a><ul>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#SQL%E5%88%86%E7%B1%BB">SQL分类</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7">事务的四大特性</a></li>
<li><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务隔离级别</a></li>
</ul>
</li>
</ol>
<hr>
<h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/MySQL%E4%BD%93%E7%B3%BB%E5%9B%BE.png" alt="MySQL体系图"></p>
<p><code>MySQL</code>体系结构包含以下几个重要部分：</p>
<ol>
<li><p>连接管理池（<code>Connection Pool</code>）：用来管理<code>MySQL</code>的连接，缓存连接</p>
<blockquote>
<p><code>MySQL</code>采用的半双工、长连接的方式进行客户端和服务器的连接，并且两种连接协议:</p>
<ul>
<li><code>TCP/IP</code>协议</li>
<li><code>UNIX Socket</code>协议</li>
</ul>
</blockquote>
</li>
<li><p>管理服务和组件（<code>Management Services &amp; UtillIties</code>）：系统管理的控制，比如数据库的备份、恢复，同步、集群等</p>
</li>
<li><p><code>SQL</code>接口（<code>SQL Interface</code>）：用来接受<code>SQL</code>语句，返回结果</p>
</li>
<li><p>解析器（<code>Parser</code>）：对<code>SQl</code>语句进行解析（语法和词法分析），转化成解析树</p>
</li>
<li><p>优化器（<code>Optimizer</code>）：查询优化器、优化传入的<code>SQL</code>命令（生成执行计划的模块）</p>
</li>
<li><p>缓存器（<code>Caches &amp; Buffers</code>）：缓存，用来缓存一部分热点数据</p>
</li>
<li><p>插件式存储引擎（<code>Pluggable Storage Engines</code>）：真正执行查找，存储的数据引擎，不同的引擎支持的操作不同，<code>MySQL</code>的存储引擎是基于表的。</p>
</li>
<li><p>物理文件（<code>File system</code>）：持久化的一些数据，包括存储的数据，<code>Redo</code>,<code>Undo</code>,<code>Index</code>…</p>
</li>
</ol>
<h4 id="存储引擎-InnoDB"><a href="#存储引擎-InnoDB" class="headerlink" title="存储引擎:InnoDB"></a>存储引擎:InnoDB</h4><p><code>MySQL</code>的每一张表都必须指定（有且只有一个）存储引擎</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;test&#96; (</span><br><span class="line">  ...</span><br><span class="line">) ENGINE&#x3D;InnoDB</span><br></pre></td></tr></table></figure>

<p>查看当前<code>MySQL</code>服务器的存储引擎列表： <code>show engines</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL5.5&#96;版本及以后默认的存储引擎为&#96;InnoDB</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code> 的存储架构：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/innodb-architecture.png" alt="InnoDB架构"></p>
<p>特点</p>
<ul>
<li>B+树索引</li>
<li>支持事务</li>
<li>行级锁和MVCC</li>
<li>支持索引和数据缓存</li>
<li>聚集索引</li>
<li>外键支持</li>
</ul>
<h3 id="MySQL文件"><a href="#MySQL文件" class="headerlink" title="MySQL文件"></a>MySQL文件</h3><h4 id="表结构定义文件"><a href="#表结构定义文件" class="headerlink" title="表结构定义文件"></a>表结构定义文件</h4><p>表结构定义文件：我们指定的表的相关属性如编码,最后更新的时间,表的结构等等都将保存在以<code>frm</code> 为后缀(<code>MySQL8.0</code>之前)文件中.</p>
<p><code>MySQL</code>存储的逻辑结构：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/MySQL%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="MySQL存储逻辑结构"></p>
<ol>
<li><p>表空间（<code>Tablespace</code>）</p>
<p>表空间是<code>InnoDB</code>存储引擎的最高层，所有的数据都存放在表空间中</p>
<p>在<code>InnoDB</code>中，表空间可以设置为共享表空间和独立表空间</p>
<ul>
<li><p>共享表空间：所有数据存在同一个表空间中，映射文件<code>ibdata1</code>,这个文件会越来越大，而且它的空间 不会收缩</p>
<ul>
<li><p><code>InnoDB Data Dictionary</code></p>
<p><code>InnoDB</code>引擎的系统表，比如记录执行计划的表，索引信息的表等等</p>
</li>
<li><p><code>Double Write Buffer</code></p>
<p>是开在共享表空间的物理文件的<code>buffer</code>，其大小是2MB</p>
<blockquote>
<p>刷脏时，脏页数据备份的位置</p>
</blockquote>
</li>
<li><p><code>Change Buffer</code></p>
<p>是<code>InnoDB Buffer Pool中ChangeBuffer</code>开在共享表空间的屋里映射位置</p>
</li>
<li><p><code>Undo Logs</code></p>
<p><code>Undo Logs</code>开在共享表空间的屋里映射位置</p>
</li>
</ul>
</li>
<li><p>独立表空间：没张表的数据单独放在一个表空间中（仅仅是数据，索引，插入缓冲单独存放，回滚信息，事务信息等还是放在原来的共享表空间中）</p>
</li>
</ul>
</li>
<li><p>段（<code>Segment</code>）</p>
<p>表空间由各个段组成，一般分为数据段，索引段，回滚段等</p>
</li>
<li><p>区（<code>Extent</code>）</p>
<p>段由多个区组成，每个区大小1MB，区是由连续页组成的空间，这些页一定是从物理和逻辑上都是连续的</p>
</li>
<li><p>页（<code>Page</code>）</p>
<p>多个页组成一个区，一般来说，一页的大小为16k,因此64个页组成了一个区，可以通过参数设置页的大小为4k，8k，16k等，页是数据文件管理的最小单位，也是文件空间分配的最小单位</p>
<blockquote>
<p>索引中所说的读取的数据页（B-treee Node），就是这个页概念</p>
</blockquote>
</li>
</ol>
<h4 id="日志文件"><a href="#日志文件" class="headerlink" title="日志文件"></a>日志文件</h4><p><strong>Error Log</strong></p>
<p>错误日志文件，错误日志文件记录了<code>MySQL</code>启动，运行，关闭等记录，同时包含一些警告信息，当发现<code>MySQL</code>有异常的时候，应该第一时间查看错误日志文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;log_error&#39;</span><br></pre></td></tr></table></figure>

<p><strong>Slow Log</strong></p>
<p>慢查询日志可以监控执行超过指定时间的<code>SQL</code>，从而记录到日志中，默认情况下<code>MySQL</code>并不启动慢查询日志，用户需要手工将这个参数设置为<code>ON</code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SHOW VARIABLES LIKE &#39;log_slow_queries&#39;;  &#x2F;&#x2F;查询是否开启慢查询日志</span><br><span class="line">ShOW VARIABLES LIKE &#39;long_query_time&#39;;    &#x2F;&#x2F;查询慢日志的阈值，默认10s</span><br><span class="line">SHOW VARIABLES LIKE &#39;log_queries_not_using_indexes&#39;; &#x2F;&#x2F;记录所有没有使用索引的SQL</span><br><span class="line">SHOW VARIABLES LIKE &#39;log_throttle_queries_not_using_indexes&#39;;  &#x2F;&#x2F;设置没有记录索引的SQL的运行次数阈值，只有超过这个阈值才记录</span><br><span class="line">SHOW VARIABLES LIKE &#39;log_output&#39;;         &#x2F;&#x2F;看出日志输出格式</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果数据量过多，可以设置<code>log_output</code>格式为<code>TABLE</code>，<code>MySQL</code>会将数据记录到<code>slow_log</code>表中</p>
</blockquote>
<p><strong>查询日志</strong></p>
<p>查询日志记录了所有对<code>MySQL</code>数据库的所有请求信息，无论这些请求是否得到了正确的执行。</p>
<blockquote>
<p>查询日志分为逻辑日志和物理日志，逻辑日志和物理日志的区别：</p>
<p>物理日志：最终的结果记录在文件中</p>
<p>逻辑日志：记录变化过程在文件中</p>
</blockquote>
<p><strong>Binary Log</strong>：</p>
<p><code>Binary Log</code>日志是<code>MySQL Server</code>层的逻辑（过程）日志文件（即不管什么存储引擎都会存在）</p>
<ul>
<li>以时间的形式记录了所有的<code>DDL</code>和<code>DML</code>语句操作</li>
<li>以文件追加的方式进行记录，没有大小的限制</li>
</ul>
<p><code>Binlog</code>默认是关闭的，需要手动启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Binary Log参数开启:</span><br><span class="line">log-bin &#x3D; 路径 </span><br><span class="line">binlog_format &#x3D; MIXED | ROW | STATEMENT  &#x2F;&#x2F;指定记录方式</span><br><span class="line">* Row ，记录每一行记录变化的SQL，生产环境建议使用                	-- 记录详细，占用空间大</span><br><span class="line">* Statement（默认），记录操作的SQL ，不会记录到每一条记录的变化    	-- 减少日志文件的大小</span><br><span class="line">* Mixed：对SQL进行区分和选择，使用哪种记录方式</span><br></pre></td></tr></table></figure>

<p>主要作用：</p>
<ul>
<li>数据恢复：通过二进制日志恢复数据</li>
<li>主从复制：在主从同步的时候，通过二进制日志，将主数据库信息同步到从数据库中</li>
<li>审计：通过二进制日志，可以统计操作，查看是否存在<code>SQL</code>注入</li>
</ul>
<p><strong>Redo Log</strong></p>
<p><code>Redo Log</code> 是存在<code>InnoDB</code>下的重做日志文件，记录的是事务提交过程中数据的变更情况，用于保证数据库服务意外中断，导致脏页数据未及时刷脏时，数据的恢复手段（即保证事务的一致性）</p>
<ul>
<li><p><code>Redo Log</code>是一组固定大小的文件，循环使用的，超过一定数据量，会被覆盖</p>
</li>
<li><p><code>Redo Log</code> 刷盘策略(buffer到log) ：<code>innodb_flush_log_at_trx_commit</code>的取值：默认为<code>1</code>：</p>
<p>刷盘过程为：<code>Buffer</code> —&gt; <code>OS Cache</code> —&gt; 磁盘</p>
<ul>
<li><p><code>0</code>：每秒写入<code>oscache</code>、写入磁盘</p>
<p><code>MySQL</code>服务宕机或者服务器宕机，导致一秒的事务失败</p>
<p>性能最好</p>
</li>
<li><p><code>1</code>：一次事务立刻写入<code>oscache</code> 且 立刻写入磁盘</p>
<p>宕机导致一次事务失败</p>
<p>安全性最高</p>
</li>
<li><p><code>2</code>：每一次事务请求都会写入<code>oscache</code>，<code>oscache</code>写入文件 采用每秒</p>
<p><code>MySQL</code>服务宕机，一次事务失败，服务器宕机，一秒事务失败</p>
<p>安全性和性能居中</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p><code>Redo Log Buffer</code> 为<code>Redo Log</code> 在内存中日志缓冲区，一旦<code>Redo Log Buffer</code>中的内容刷到了磁盘的<code>Redo Log</code>文件，事务成功</p>
<p><code>Redo Log Buffer</code>大小设定 ： <code>innodb_log_buffer_size</code>(默认<code>16M</code>)</p>
</blockquote>
<p><strong>Undo Log</strong></p>
<p><code>Undo Log</code> 是物理日志，主要应用在事务中，记录的是事务过程中每条数据的变化结果</p>
<p><code>Undo Log</code>的作用</p>
<ol>
<li><code>undo log</code>中记录的是用户操作的反向逻辑操作。设计初衷主要的作用是在事务异常中断，或者主动（<code>rollback</code>）过程中，我们可以基于<code>Undo Log</code>中记录的日志数据进行数据的回滚，保证 <strong>事务的原子性回滚</strong></li>
<li>由于<code>Undo Log</code>记录了事务操作过程中各个历史的版本，故而在数据的多版本控制层面，<code>Undo Log</code>中的数据可作为数据旧版本快照供其他并发事务进行快照读</li>
</ol>
<blockquote>
<p><code>undo log</code>的持久性保证也是通过<code>redo log</code>来实现，也就是<code>undo log</code>的产生会伴随着<code>redo log</code>的产生。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">undo log&#96;默认保存在系统表空间（&#96;ibdata&#96;）中：&#96; innodb_undo_directory</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h3><p>在<code>InnoDB</code>中，主要包含3种索引：</p>
<ul>
<li>B+树索引</li>
<li>全文索引</li>
<li>哈希索引</li>
</ul>
<h4 id="B-树索引"><a href="#B-树索引" class="headerlink" title="B+树索引"></a>B+树索引</h4><p>在<code>InnoDB</code>中，索引通过<code>B+</code>树来实现，<code>B+</code>树作为索引的优点：</p>
<ul>
<li>非叶子节点不存储数据，使得每页能存储更多索引，减少<code>IO</code>的次数</li>
<li>叶子节点存在相互索引的指针，便于范围查找</li>
<li>性能稳定，每次查询都需要通过相同的次数才能获取到需要的数据</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/B%2BTree%E7%BB%93%E6%9E%84.png" alt="B+ Tree结构"></p>
<p>需要知道的是，在<code>InnoDB</code>中，<code>B+</code>树的节点对应的是表结构中的页(<code>Page</code>)，也就是每次<code>IO</code>都是读取<strong>数据页（B-Tree Node）</strong>一页的数据。</p>
<p><code>InnoDB</code>的这种按照索引的结构组织数据的数据表被称为<strong>索引组织表</strong>，<strong>索引组织表</strong>对应的索引被称为聚集索引，指的是索引和数据在逻辑上存储顺序相同，索引组织表的有点如下：</p>
<ul>
<li>数据的相关性大，因为数据都是按照主键顺序存放，因此需要查找可主键相关的数据时，只需要从磁盘读取少量数据就能获取全部相关信息。</li>
<li>数据访问更快，因为索引和数据存放在一起，因此在查找完索引后，就能直接获取到数据</li>
<li>使用索引覆盖扫描的查询可以直接使用叶节点的主键值</li>
</ul>
<p>索引组织表的缺点如下：</p>
<ul>
<li>插入速度严重依赖于插入顺序，如果插入的数据不是有顺的，则会导致<code>InnoDB</code>随机<code>IO</code>磁盘。</li>
<li>更新聚集索引的代价很高，因为数据是按照聚集索引的顺序存放，因此会强制移动所有被更新的行</li>
<li>聚集索引可能会导致全表扫描变慢</li>
<li>聚集索引会导致非聚集索引访问数据需要进行两次查找</li>
</ul>
<h4 id="辅助索引"><a href="#辅助索引" class="headerlink" title="辅助索引"></a>辅助索引</h4><p>辅助索引也叫二级索引，是非聚集索引，其内部结构也是一颗<code>B+</code>树，不过和聚集索引不同的是，聚集索引的叶子节点存储的是数据，而辅助索引叶子节点存放的是聚集索引的<code>key</code>.这样就会带来一个问题就是对于辅助索引的查找，会存在一个二次回表的操作。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E5%9B%9E%E8%A1%A8.png" alt="回表"></p>
<p>比如</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_test <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;小红&#x27;</span>;   //主键为`id`</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>InnoDB</code>会先在<code>name</code>辅助索引上查找对应的<code>id</code>,然后再通过<code>id</code>在聚集索引中查找具体的数据。</p>
<p>如果一个<code>B+</code>树为3层，则此次查找就需要经过6次<code>IO</code></p>
<h4 id="索引的管理"><a href="#索引的管理" class="headerlink" title="索引的管理"></a>索引的管理</h4><p>查看索引： <code>SHOW INDEX FROM t_rule;</code>，返回结果如下：</p>
<ul>
<li><code>Table</code>: 对应的表</li>
<li><code>Non_unique</code>: 是否非唯一</li>
<li><code>Key_name</code>: 索引名</li>
<li><code>Seq_in_index</code>: 索引中，该列的位置</li>
<li><code>Cloum_name</code>: 索引的列的名称</li>
<li><code>Collection</code>: 索引存放方式，一般都是<code>A</code>,表示是<code>B+</code>树</li>
<li><code>Cardinality</code>：非常关键的值，表示索引中唯一值的数目的估计值。<code>Cardinality</code>与表的行数比应尽可能接近1，如果非常小，那么用户需要考虑是否可以删除此索引。</li>
<li><code>Sub_part</code>：是否是列的部分被索引。如果看idx_b这个索引，这里显示100，表示只对b列的前100字符进行索引。如果索引整个列，则该字段为NULL。</li>
<li><code>Packed</code>：关键字如何被压缩。如果没有被压缩，则为NULL。</li>
<li><code>Null</code>：是否索引的列含有NULL值。</li>
<li><code>Index_type</code>：索引的类型。<code>InnoDB</code>存储引擎只支持B+树索引，所以这里显示的都</li>
</ul>
<h4 id="索引的使用"><a href="#索引的使用" class="headerlink" title="索引的使用"></a>索引的使用</h4><ul>
<li>不是对于任何查询都适合添加索引的，<code>InnoDB</code>会判定索引的<code>Cardinality</code>值，当该值与数据库的行的比值过小时，<code>InnoDB</code>会忽略此索引,比如性别</li>
<li>索引不是越多越好，索引对于插入和修改存在一定的性能影响，因此对于索引的添加需要有一定的考量</li>
<li>最好在创建表的时候就创建索引，<code>MySQL</code>在线<code>DDL</code>会阻塞数据库</li>
<li>由于<code>B+</code>树的特殊性，因此对于联合索引，需要遵循最左匹配原则。</li>
<li>同理，由于辅助索引的二次回表的特性，对于辅助索引<code>name</code>,等效于<code>name,id</code>（<code>id</code>为主键）</li>
<li>可以利用索引覆盖原理，来避免二次回表，索引覆盖就是需要查询的字段，都在索引中能找到</li>
<li>如果对于数据库来说，二次回表查找的数据过多，导致性能低于全表扫描，<code>MySQL</code>可能会放弃使用索引</li>
</ul>
<h4 id="自适应Hash索引"><a href="#自适应Hash索引" class="headerlink" title="自适应Hash索引"></a>自适应Hash索引</h4><p>在<code>MySQL</code>中，对于等值查询，如果达到一定的条件，<code>MySQL</code>会在内部建立<code>Hash</code>索引优化查询速度，这种索引由<code>MySQL</code>自动建立，自己维护，因此又叫做自适应哈希（<code>AHI</code>,<code>Auto Hash Index</code>）索引，自适应哈索引建立的条件如下：</p>
<ul>
<li>需要对这个也得连续访问模式是一样的，比如<code>where a=xxx</code> 和<code>where a=xxx and b=xxx</code>属于两种访问模式</li>
<li>以同一个模式访问了100次</li>
<li>此页通过该模式访问了<code>N</code>次，其中N=页中记录数/16</li>
</ul>
<blockquote>
<p>InnoDB存储引擎官方文档显示，启用<code>AHI</code>后，读取和写入速度可以提高2倍，辅助索引的连接操作性能可以提高5倍。<code>AHI</code>的设计思想是数据库自优化，不需要<code>DBA</code>对数据库进行手动调整。</p>
</blockquote>
<h3 id="MySQL中SQL执行流程"><a href="#MySQL中SQL执行流程" class="headerlink" title="MySQL中SQL执行流程"></a>MySQL中SQL执行流程</h3><p><code>MySQL</code>中在未到存储引擎中的<code>SQL</code>执行过程如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/SQL%E7%9A%84%E6%89%A7%E8%A1%8C.png" alt="SQL的执行"></p>
<ol>
<li>缓存是否存在数据</li>
<li>词法分析、语法分析</li>
<li>最优执行计划生成</li>
<li>执行引擎调用API</li>
</ol>
<p><strong>InnoDB中SQL执行过程</strong>：</p>
<p><code>InnoDB</code>中存在表数据与索引数据的缓存：<code>Buffer Pool</code> ,在<code>SQL</code>执行的过程把磁盘上的数据加载到<code>BufferPool</code>,避免每次访问都进行磁盘IO，起到加速访问的作用</p>
<p><code>Buffer Pool</code> 的存储结构设计总体遵循<code>LRU(Least recently used)</code>的特性</p>
<p><code>Buffer Pool</code>缓存设计问题及解决：</p>
<p>设计问题： 基于空间局部性原理（预读），磁盘访问按数据库页大小读取能够提高性能，缓冲池按数据库页（<code>Innodb_page_size</code>）缓存数据，所以在<code>Buffer Pool</code>中，不仅要缓存实际使用到的数据，而且还需要缓存非目标数据和预读的数据</p>
<p>这就导致两个问题：预读失效 和 缓冲池污染</p>
<ul>
<li>预读失效：由IO操作的特性将未实际使用的数据加载到了<code>Buffer Pool</code>中缓存了，实际上后续却并未使用</li>
<li>缓冲池污染：可能SQL的执行需要扫描大量的页数据，为了缓存这些页数据，导致缓冲池中大量热点数据替换出去</li>
</ul>
<p>设计解决：</p>
<p>分代 + 老生代停留时间配置阈值</p>
<p><code>BufferPool</code> 的设计图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/BufferPool%E8%AE%BE%E8%AE%A1.png" alt="BufferPool的设计"></p>
<p>相关配置参数</p>
<ul>
<li><code>innodb_buffer_pool_size</code>（<code>BufferPool</code>的大小）</li>
<li><code>innodb_old_blocks_pct</code>（老生代和新生代的比值(老生代大小)）</li>
<li><code>innodb_old_blocks_time</code>（老生代停留时间配置阈值）</li>
</ul>
<p>在了解<code>Buffer Pool</code>后，<code>InnoDB</code>中的<code>DQL</code>和事务的执行过程</p>
<ol>
<li><p><code>DQL</code>执行过程：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/InnodbDQL%E6%93%8D%E4%BD%9C.png" alt="InnodbDQL执行过程"></p>
</li>
<li><p>事务执行过程：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/Innodb%E4%BA%8B%E5%8A%A1%E6%93%8D%E4%BD%9C.png" alt="Innodb事务实行过程"></p>
</li>
</ol>
<p>在<code>Innodb</code>的一次事务提交过程中，事务操作并不会马上将变更的数据刷新到磁盘中</p>
<p>在<code>Innodb</code>中事务的完结只需要将需要变更记录在<code>Buffer Pool</code>中(形成脏页)，完成<code>Redo Log</code>的记录即可</p>
<p>刷脏的时机：</p>
<ul>
<li><p>当<code>Redo Log</code> 写满时</p>
<p>参数：<code>innodb_log_files_in_group</code> 、 <code>innodb_log_file_size</code></p>
</li>
<li><p><code>Buffer Pool</code>空间不够使用时</p>
</li>
<li><p><code>MySQL</code>服务空闲状态</p>
</li>
<li><p><code>MySQL</code>正常关闭时</p>
<blockquote>
<p>脏页是指<code>Buffer Pool</code>记录的数据与磁盘中数据不一致的情况</p>
<p>刷脏是指刷脏线程将<code>BufferPool</code>中的脏页刷新落盘到磁盘的过程</p>
</blockquote>
</li>
</ul>
<h3 id="MySQL事务"><a href="#MySQL事务" class="headerlink" title="MySQL事务"></a>MySQL事务</h3><p>事务是数据库操作的最小工作单元，是作为单个逻辑工作执行的一些列操作；</p>
<p>事务是一组不可分割的操作集合（工作逻辑单元）：典型事务场景：转账</p>
<p><code>MySQL Innodb</code>事务的手工操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">begin &#x2F; start transaction        ---手工</span><br><span class="line">commit &#x2F; rollback                ---事务提交或回滚</span><br><span class="line">set session autocommit &#x3D; on&#x2F;off  ---设定事务是否自动开启</span><br><span class="line">commit &#x2F; rollback                ---事务提交或回滚</span><br></pre></td></tr></table></figure>

<p><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E7%9A%84%E5%9B%9B%E5%A4%A7%E7%89%B9%E6%80%A7">事务的ACID四大特性</a></p>
<h4 id="MySQL原子性、一致性、持久性的实现"><a href="#MySQL原子性、一致性、持久性的实现" class="headerlink" title="MySQL原子性、一致性、持久性的实现"></a>MySQL原子性、一致性、持久性的实现</h4><p>在<code>MySQL</code>的<code>InnoDB</code>引擎中</p>
<p>通过<code>Undo Log</code>实现事务的原子性(<code>Atomicity</code>)</p>
<p>通过<code>Redo Log</code>实现事务的一致性(<code>Consistency</code>)和持久性(<code>Durability</code>)</p>
<blockquote>
<p><code>Redo Log</code>一致性和持久性的保证：</p>
<ul>
<li><p>正常情况：<code>WAL(Write-ahead logging)</code>+刷脏线程：保证数据恢复</p>
</li>
<li><p>刷脏过程出现页断裂（部分写入失败）时：使用双写机制</p>
<p><code>Double write</code>机制详解：<code>Doublewrite Buffer</code>是开在共享表空间的物理文件的<code>buffer</code>,其大小是2MB.</p>
<ul>
<li>刷脏操作开始之时,先进行脏页’备份’操作.将脏页数据写入<code>Doublewrite Buffer</code></li>
<li>将<code>Doublewrite Buffer</code>(顺序IO)写入磁盘文件中(共享表空间)</li>
<li>进行刷脏操作.(绝大多数是随机IO)</li>
<li><code>Double Write</code>机制其核心思想是:在刷脏之前,建立脏页数据的副本.系统意外宕机造成页断裂的情况可通过脏页数据副本(<code>DoubleWrite Buffer</code>)进行恢复</li>
</ul>
</li>
<li><p>刷脏过程未出现页断裂，也没有刷脏成功：通过<code>Redo Log</code>进行数据的持久化即可</p>
</li>
</ul>
</blockquote>
<h4 id="MySQL隔离性实现"><a href="#MySQL隔离性实现" class="headerlink" title="MySQL隔离性实现"></a>MySQL隔离性实现</h4><p><a href="https://zhangyuying.top/2021/07/27/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL/MySQl/#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB">事务的隔离级别</a></p>
<p><code>MySQL Innodb</code>中<code>RR</code>是默认的事务的默认隔离级别，并且<code>Innodb</code>中 <code>RR</code>级别可以解决幻读问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MySQL Innodb&#96;隔离级别解决方案：&#96;LBCC&#96; + &#96;MVCC</span><br></pre></td></tr></table></figure>

<p><strong>MVCC（Multi Version Concurrency Control）</strong></p>
<p>基于多版本快照的实现：事务并发访问数据时，对正在事务内处理的数据做多版本的管理，避免写操作的堵塞，从而引发读操作的并发阻塞问题，将数据在当下时间点进行一份数据快照（Snapshot）的备份（多版本的管理），并用这个快照来提供给其他事务进行一致性读取</p>
<p><code>MySQL</code>中<code>Undo log</code>保存了<code>MVCC</code>的数据来源</p>
<p><strong>快照读</strong>（<code>SQL</code>读取的数据为历史版本数据）：<code>SQL</code>读取的数据是快照版本，基于<code>MVCC</code></p>
<ul>
<li><p><code>DQL</code> 默认都是快照读</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">普通的select语句均为snapshot read(MVCC) </span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>LBCC（Lock Based Concurrency Control)</strong></p>
<p>基于锁并发的控制实现：事务开始操作数据前，对其加锁，阻止其他事务对数据进行修改，利用锁的排他性独占数据的操作权限。</p>
<p><strong>当前读</strong>（<code>SQL</code>操作的数据是最新数据）：<code>SQL</code>读取的数据是最新版本。通过锁机制来保证读取的数据无法通过其他事务进行修改，基于<code>LBCC</code></p>
<ul>
<li><p><code>DML</code>默认都是当前读</p>
</li>
<li><p><code>select</code>语句想要实现当前读：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> ... <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span> | <span class="keyword">SELECT</span> ... <span class="keyword">FOR</span> <span class="keyword">UPDATE</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><strong>Innodb中的锁分类：</strong></p>
<ul>
<li><p>表锁</p>
<ul>
<li><p>意向锁（<code>Intention Locks</code>）</p>
<p>意向锁不是用来锁定数据的，而是用来告诉这个表中是否加了排他锁、共享锁，这样以后再创建表锁的时候不用去扫描表中排它锁、共享锁的状态，直接根据意向锁状态就可以知道是否可以创建，可以理解成一个标记。目的是为了提升加表锁的效率。</p>
<ul>
<li>意向共享锁(<code>Intention Shared Locks</code>，<code>IS</code>)一个数据行加共享锁前必须先取得该表的<code>IS</code>锁，意向共享锁之间是可以相互兼容的</li>
<li>意向排它锁(<code>Intention Exclusive Locks</code>，<code>IX</code>)一个数据行加排他锁前必须先取得该表的<code>IX</code>锁，意向排它锁之间是可以相互兼容的</li>
<li>意向锁(<code>IS</code>、<code>IX</code>)是<code>InnoDB</code>引擎操作数据之前自动加的，不需要用户干预意义：当事务操作需要锁表时，只需判断意向锁是否存在，存在时则可快速返回该表不能启用表锁</li>
</ul>
</li>
</ul>
</li>
<li><p>行锁</p>
<ul>
<li><p>共享锁（行锁）：<code>Shared Locks</code>，读锁（S锁）</p>
<p>多个事务对于数据可以共享访问，但不能操作修改</p>
<p>使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SELECT * FROM table WHERE id&#x3D;1 LOCK IN SHARE MODE  --加锁</span><br><span class="line"></span><br><span class="line">COMMIT &#x2F; ROLLBACK                                  --释锁</span><br></pre></td></tr></table></figure>
</li>
<li><p>排它锁（行锁）：<code>Exclusive Locks</code></p>
<p>写锁（X锁），事务获取了X锁，其他事务就不能再获取锁（S锁、X锁）</p>
<p>只有该获取了X锁的事务才可以对数据行进行读取和修改</p>
<p>使用方式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DML（UPDATE、DELETE、INSERT）自动增加排它锁        ---加锁</span><br><span class="line"></span><br><span class="line">SELECT * FROM table WHERE ... FROM UPDATE      ---加锁</span><br><span class="line"></span><br><span class="line">COMMIT &#x2F; ROLLBACK                              ---释锁</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p><code>Innodb</code>行锁实现原理</p>
<ul>
<li><code>Innodb</code>的行锁是通过给<strong>索引的索引项加锁</strong>实现的</li>
<li><code>SQL</code>的执行基于索引的检索，<code>Innodb</code>才使用行锁，未使用索引检索的<code>SQL</code>执行<code>Innodb</code>将使用表锁</li>
<li>基于辅助索引检索的<code>SQL</code>，辅助索引及对应的主键索引都将锁定指定的索引项</li>
</ul>
</blockquote>
<p>行锁的具体实现：</p>
<ul>
<li><p>临键锁 <code>Next-key Locks</code></p>
<ul>
<li>当<code>SQL</code>执行按照索引进行数据的检索，且查询条件为范围查询（<code>between and</code> 、<code>&lt;</code>、<code>&gt;</code> 等）[执行计划 <code>type= range</code> ]，且有数据命中时，该<code>SQL</code>语句事务操作加上的行锁为<code>Next-key locks</code></li>
<li>具体实现：锁住命中记录区间+下一个区间（区间：左开右闭），<code>Next-key Locks=Gap Locks+ Record Locks</code></li>
<li><code>Innodb</code>隔级别<code>RR</code>级别默认的行锁算法，<code>RR</code>的隔离级别才有临键锁，可以解决幻读问题</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/Next-KeyLocks.png" alt="Next-key Locks"></p>
</li>
<li><p>间隙锁 <code>Gap Locks</code></p>
<ul>
<li>当<code>SQL</code>执行按照索引进行数据的检索时，但是执行过程中索引搜索查询条件的<strong>数据不存在</strong>时，这时<code>SQL</code>语句加上的锁即为 <code>Gap locks</code></li>
<li>具体实现：锁住数据不存在的区间（区间：左开右开）</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/GapLocks.png" alt="Gap Locks"></p>
</li>
<li><p>记录锁 <code>Record Locks</code></p>
<ul>
<li>当<code>SQL</code>执行基于索引搜索，且按照等值匹配的方式进行数据的检索，且此时查询<strong>等值匹配</strong>且查询的数据命中存在，这是<code>SQL</code>语句加上的锁即为 <code>Record locks</code></li>
<li>具体实现：锁住命中的具体索引的索引项</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/RecordLocks.png" alt="Record Locks"></p>
</li>
</ul>
</li>
</ul>
<h3 id="MySQL优化方案"><a href="#MySQL优化方案" class="headerlink" title="MySQL优化方案"></a>MySQL优化方案</h3><p>对于<code>MySQL</code>来说，想要优化<code>MySQL</code>的时候，就需要理解前面的知识点。</p>
<p>优化<code>MySQL</code>，可以从各个方面入手：</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><ul>
<li><p>一般情况下，应该尽量使用可以正确存储数据的最小数据类型，更小意味着更快。</p>
<p>例如：整型比字符操作代价更低，因为字符串涉及到字符集和校对规则问题</p>
</li>
<li><p>通常情况下最好指定列为<code>NOT NULL</code>，除非真的需要存储<code>NULL</code>值</p>
<p>对于<code>MySQL</code>来说，可以为<code>NULL</code>的列更难优化，因此<code>NULL</code>会影响索引，索引统计和值的比较等，可以为<code>NULL</code>的列会使用更多的存储空间。当对可为<code>NULL</code>的列建立索引的时候，每个索引记录都需要额外使用一个直接。</p>
</li>
<li><p>对于浮点类型，优先选择<code>FLOAT</code>,<code>DOUBLE</code>,只有在真正需要<code>DECIMAL</code>的时候才使用<code>DECIMAL</code>,如果数据量过大的时候，可以考虑使用<code>BIGINT</code>代替<code>DECIMAL</code></p>
</li>
<li><p>注意使用<code>VARCHAR</code></p>
<p>由于<code>VARCHAR</code>类型是一个边长字符串，因此如果这个字符串长度会频繁变化的话，会给<code>MySQL</code>带来内存碎片的问题，同时其在临时表和排序时可能导致悲观的按最大长度分配内存。</p>
</li>
<li><p>定义表的时候，对于浮点型不要指定进度，对于整数，不要指定宽度</p>
<p>在<code>MySQL</code>中对浮点数指定精度会使得<code>MySQL</code>悄悄选择不同的数据类型，或者在存储时对值进行取舍。而这些精度定义是非标准的，因此最好的做法就是只指定数据类型，不指定精度。</p>
</li>
<li><p>注意<code>count(*)</code>和<code>count(字段)</code>的区别在于前者会统计<code>NULL</code>，而后者不会统计<code>NULL</code></p>
</li>
</ul>
<h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>说到<code>MySQL</code>优化，可能第一想法就是加索引，因为使用索引能将性能提高几个数量级，但是索引不是万能的，有时候有些场景可能并不适合使用索引，使用索引，首先需要遵从下面的原则：</p>
<ul>
<li>联合索引需要遵从最左匹配原则</li>
<li>对于很长的值，则可以选择使用前缀索引</li>
<li>通常来说，对于联合索引，将选择性更高的索引放在前面可以更好的避免随机<code>IO</code></li>
</ul>
<p><strong>索引覆盖：</strong></p>
<p>可以将需要获取的数据都添加索引，从而实现仅仅通过索引就能获取需要的数据，避免二次回表。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>,sex <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span>=<span class="string">&#x27;dcc&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>正常来说，如果只建立了<code>name</code>的索引，那么<code>InnoDB</code>再通过二级索引<code>name</code>查找到<code>dcc</code>后，会获取聚集索引<code>id</code>，然后再通过<code>id</code>查找聚集索引来获取具体的数据行。这就是二次回表。</p>
<p>而如果建立的索引是<code>(name,sex)</code>，那么在查找到<code>name</code>为<code>dcc</code>的节点后，就能直接通过二级索引找到<code>sex</code>的值，这样就避免了二次回表，从而带来性能的提升。</p>
<p>使用索引覆盖能解决一些不好优化的问题：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对于<code>MySQL</code>,这种通配符开头的模糊查询，是不会走索引的。</p>
<p>但是如果把<code>name</code>加上索引，又由于<code>id</code>是主键，因此上述查询可以直接通过索引覆盖就能完成，因此可以通过索引覆盖是的上述语句走索引。</p>
<p><strong>延迟关联</strong>：</p>
<p>明白了索引覆盖的原理后，后续一些优化就可以通过索引覆盖来实现：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>对比这条<code>SQL</code>和上面的<code>SQL</code>，唯一的区别就是需要获取的数据不同，<code>SELECT *</code>如果列比较多的话，很可能无法实现索引覆盖，那对于这样的查询，应该如何优化呢？</p>
<p>我们可以使用延迟关联：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student s <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> <span class="keyword">id</span> <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>) <span class="keyword">AS</span> s1 <span class="keyword">ON</span>  s.id = s1.id;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>通过前面的例子我们知道，子语句是会走索引的，而外层查询<code>id</code>是主键，也是会走索引的， 因此这条<code>SQL</code>就被完全优化成走<code>SQL</code>的索引。</p>
<blockquote>
<p>延迟关联只是一种优化思路，其实在<code>MySQL</code>5.6 推出<code>ICP</code>(默认打开)后，有些情况就可以直接通过<code>ICP</code>解决，因为<code>ICP</code>会自动将<code>where</code>过滤条件下沉到存储引擎，存储引擎则可以直接通过索引过滤掉相应的数据。但是<code>ICP</code>也有相应的限制，关于<code>ICP</code>后续详细介绍</p>
</blockquote>
<p><strong>索引的调试：</strong></p>
<p>对于一个查询，是否走了索引，索引的类型是什么，走的联合索引还是部分索引，这些都需要结合<code>SQL</code>进行分析，而在<code>MySQL</code>中，最好分析的索引的方法便是查看执行计划：<code>EXPLAIN</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> <span class="keyword">class</span>=<span class="string">&#x27;17&#x27;</span> <span class="keyword">AND</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">&#x27;%cc%&#x27;</span>;</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>该<code>SQL</code>返回的字段如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">id： 1</span><br><span class="line">select_type: SIMPLE</span><br><span class="line">table: t_student</span><br><span class="line">partions: NULL</span><br><span class="line">type: ref</span><br><span class="line">possible_keys:idx_class</span><br><span class="line">key:idx_class</span><br><span class="line">key_len:43</span><br><span class="line">ref:const</span><br><span class="line">rows:749</span><br><span class="line">filterd:11.11</span><br><span class="line">Extra: using index</span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>这里简单说下几个重要的字段：</p>
<ul>
<li><code>type</code>: 表示查询的方式，常见的值有：<ul>
<li><code>ALL</code>:全表扫描</li>
<li><code>index</code>: 索引扫描</li>
<li><code>range</code>: 选择索引的范围进行扫描</li>
<li><code>ref</code>: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值</li>
<li><code>eq_ref</code>: 类似<code>ref</code>,区别在于使用的是唯一索引</li>
<li><code>const,system</code>: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。例如<code>where id=xxx</code></li>
</ul>
</li>
<li><code>Key</code>: <code>MySQL</code>实际使用的索引</li>
<li><code>rows</code>:表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数</li>
<li><code>Extra</code>:<ul>
<li><code>Using where</code>:不用读取表中所有信息，仅通过索引就可以获取所需数据，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤</li>
<li><code>Using temporary</code>：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询，常见 <code>group by ; order by</code></li>
<li><code>Using filesort</code>：当Query中包含 order by 操作，而且无法利用索引完成的排序操作称为“文件排序”</li>
<li><code>Using join buffer</code>：强调在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。</li>
<li><code>Using index condition</code>: 使用了<code>ICP</code></li>
</ul>
</li>
</ul>
<h4 id="MySQL自带的优化"><a href="#MySQL自带的优化" class="headerlink" title="MySQL自带的优化"></a>MySQL自带的优化</h4><p>在<code>MySQL</code>中，也自带一些优化方案，这些优化策略都是<code>MySQL</code>自带了，了解他们可以避免一些无效优化：</p>
<p><strong>Change Buffer</strong></p>
<p>前面说过，对于聚集索引，存在的一个缺点就是如果插入的数据是无序的，那么可能导致<code>InnoDB</code>随机写磁盘，这样会带来性能问题。</p>
<p>因此在<code>InnoDB</code>中，使用了<code>Change Buffer</code>，<code>Change Buffer</code>会将插入的数据暂时缓存，然后将里面的数据进行排序，最后再进行插入/修改，这样就能减少插入离散数据带来的性能问题。</p>
<p>但是不要过分依赖<code>Change Buffer</code>，如果数据量过大，则可能导致<code>Change Buffer</code>被装满，那么后面的数据依然是离散的，因此如果要插入大量的数据，可以考虑先在代码中排序，然后再插入。</p>
<p><strong>ICP</strong></p>
<p><code>ICP,(Index Condition PushDown,索引条件下推)</code>： 原本对于<code>MySQL</code>来说，有些过滤条件不会推送到存储引擎，因此对于一条查询:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> employees <span class="keyword">WHERE</span> first_name=<span class="string">&#x27;Anneke&#x27;</span> <span class="keyword">AND</span> last_name <span class="keyword">LIKE</span> <span class="string">&#x27;%Preusig&#x27;</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p><code>MySQL</code>会先将<code>first_name=&#39;AnneKe&#39;</code>下推到<code>InnoDB</code>，<code>InnoDB</code>则通过索引查找所有符合要求的数据并返回给<code>MySQL</code>,<code>MySQL</code>拿到数据后，再过滤不满足<code>last_name LIKE &#39;%Preusig&#39;</code>的条件。</p>
<p>这样带来的问题就是存储引擎上推的数据比较大，并且经过了两次过滤。</p>
<p>当开启<code>ICP</code>过后，<code>MySQL</code>会将两个条件都下推给<code>InnoDB</code>，<code>InnoDB</code>可以直接通过索引过滤到所有的数据，直接返回正确的结果。</p>
<p>使用执行过程分析的时候，如果使用了<code>ICP</code>,则<code>Extra</code> 会返回<code>Using index condition</code></p>
<p><code>ICP</code>的生效条件如下：</p>
<ol>
<li>当<code>sql</code>需要全表访问时，<code>ICP</code>的优化策略可用于<code>range, ref, eq_ref, ref_or_null</code>类型的访问数据方法 。</li>
<li>支持InnoDB和MyISAM表。</li>
<li>ICP只能用于二级索引，不能用于主索引。</li>
<li>并非全部<code>where</code>条件都可以用<code>ICP</code>筛选，如果<code>where</code>条件的字段不在索引列中，还是要读取整表的记录到<code>server</code>端做<code>where</code>过滤。</li>
<li><code>ICP</code>的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例。</li>
<li>当<code>sql</code>使用覆盖索引时，不支持<code>ICP</code>优化方法。</li>
</ol>
<p><strong>MRR</strong></p>
<p><code>MRR,(Multi-Range Read Optimization)</code> ,<code>MRR</code>和<code>Chaneg Buffer</code>有异曲同工之妙，在没有开启<code>MRR</code>的时候，如果通过聚集索引读取数据，那样是顺序查找，性能比较高，但是对于二级索引的顺序查找，如果再经过二次回表，可能会变成离散<code>IO</code>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> t_student <span class="keyword">WHERE</span> birthday&lt;<span class="number">2019</span></span><br><span class="line">复制代码</span><br></pre></td></tr></table></figure>

<p>如上述<code>SQL</code>,<code>birthday</code>是二级索引，<code>id</code>为主键索引。</p>
<p>在<code>InnoDB</code>中，会首先通过<code>birthday</code>的索引查询满足<code>birthday&lt;2019</code>的主键<code>id</code>，由于查询是按照<code>birthday</code>排序的，比如<code>2019,2018,2017,2016</code>，因此返回的主键<code>id</code>则可能是无序的，比如<code>199,1,200,23,3,5040,188</code>,那么再通过<code>id</code>获取所有的数据的时候，就变成了离散读取。</p>
<p><code>MRR</code>的思想就很简单，开启<code>MRR</code>之后，<code>MySQL</code>会将所有返回的主键先进行排序，然后再进行回表。这样就避免了离散读取的问题。</p>
<h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="SQL分类"><a href="#SQL分类" class="headerlink" title="SQL分类"></a>SQL分类</h4><ul>
<li><code>DQL</code>语句：单指查询<code>sql</code></li>
<li><code>DML</code>: 数据操作语言，<code>update</code> 、 <code>delete</code>、<code>insert</code></li>
<li><code>DDL</code>：数据结构定义,建表、建库、创建视图</li>
<li><code>DCL</code>：数据操控、控制语言：给用户赋予查询、修改等赋权相关操作</li>
</ul>
<h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><ul>
<li><p>原子性（<code>Atomicity</code>）</p>
<ul>
<li>最小的工作单元，要么一起提交成功，要不全部失败回滚</li>
</ul>
</li>
<li><p>一致性（<code>Consistency</code>）</p>
<ul>
<li>事务中操作的数据改变是符合预期的，数据的中间态无需对外暴露，结果符合预期即可</li>
</ul>
</li>
<li><p>隔离性（<code>Isolation</code>）</p>
<ul>
<li><p>并发访问场景下事务间共享的数据可见性设定带来的问题</p>
</li>
<li><p>隔离性带来的问题主要是：脏读、不可重复读、幻读</p>
<ul>
<li><p>脏读：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E8%84%8F%E8%AF%BB.png" alt="脏读"></p>
</li>
<li><p>不可重复读：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png" alt="不可重复读"></p>
</li>
<li><p>幻读：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/MySQL/%E5%B9%BB%E8%AF%BB.png" alt="幻读"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>持久性（<code>Durability</code>）</p>
<ul>
<li>事务所做的修改就会永久保存，不会因为系统意外导致数据的丢失</li>
</ul>
</li>
</ul>
<h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><code>ANSI/ISO</code>标准：</p>
<ul>
<li><p><code>Read Uncommitted</code>(未提交读)</p>
<p>事务未提交对其他事务也是可见的</p>
<blockquote>
<p>未解决并发问题，依然存在脏读、不可重复读、幻读问题</p>
</blockquote>
</li>
<li><p><code>Read Committed</code>(提交读)</p>
<p>一个事务开始之后，只能看到自己提交的事务所做的修改</p>
<blockquote>
<p>解决脏读问题，依然存在不可重复读、幻读问题</p>
</blockquote>
</li>
<li><p><code>Repeatable Read</code>(可重复读)</p>
<p>在同一个事务中多次读取同样的数据结果是一样</p>
<blockquote>
<p>解决脏读、不可重复读问题，依然存在幻读问题</p>
</blockquote>
</li>
<li><p><code>Serializable</code>(串行化)</p>
<p>最高的隔离级别，通过强制事务的串行执行</p>
<blockquote>
<p>隔离性问题都解决</p>
</blockquote>
</li>
</ul>
<p>参考资料</p>
<p><a href="https://juejin.cn/post/6869029652623523848">MySQL总结-掘金</a></p>
<p><a href="https://www.codenong.com/cs110441924/">MySQL事务隔离级别的实现原理——LBCC + MVCC （InnoDB）</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-List命令</title>
    <url>/2022/06/24/Redis/Redis-List%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Redis-List操作命令</strong></p>
<span id="more"></span>

<blockquote>
<p>命令参数统一说明:</p>
<ol>
<li><p>索引（<code>index</code>）：</p>
<ul>
<li><code>0</code>表示第一个，<code>1</code>表示第二个，以此往后推</li>
<li><code>-1</code>表示列表的最后一个，<code>-2</code>表示倒数第二个，以此往前推</li>
</ul>
</li>
<li><p>阻塞时的超时时间（<code>timeout</code>）</p>
<p>表示的是一个指定阻塞的最大秒数的整型值，Redis版本<code>&gt;=6.0</code>，<code>timeout</code> 支持双精度浮点。</p>
<p>当<code>timeout</code>为<code>0</code>是表示永久阻塞</p>
</li>
</ol>
</blockquote>
<h4 id="设置和获取操作"><a href="#设置和获取操作" class="headerlink" title="设置和获取操作"></a>设置和获取操作</h4><h5 id="lpush、rpush、lrange"><a href="#lpush、rpush、lrange" class="headerlink" title="lpush、rpush、lrange"></a>lpush、rpush、lrange</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#lpush key value1 [value2] :在列表头部插入一个或者多个值,如果key不存在，那么在进行push操作前会创建一个空列表,元素从左到右依次插入到list的头部,返回操作后的列表长度</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># rpush key value1 [value2] :在列表尾部添加一个或多个值。如果key不存在，那么会创建一个空的列表然后再进行push操作，元素是从左到右按序从list尾部插入，返回操作后的列表长度</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key1</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="comment">#lrange key start stop :获取列表指定范围内的元素,0表示第一个1表示第二个，-1表示列表的最后一个，-2表示倒数第二个</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">-3</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="lpushx、rpushx"><a href="#lpushx、rpushx" class="headerlink" title="lpushx、rpushx"></a>lpushx、rpushx</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lpushx key value :当储存列表的key存在时，用于将值插入到列表的头部，key不存在不会进行任何操作，返回操作后list的长度</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpushx</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpushx</span> <span class="string">key1</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="comment"># rpushx key value :当存储列表的key存在时，用于将值插入到列表的尾部，key不存在不会进行任何操作，返回操作后list的长度</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpushx</span> <span class="string">key2</span> <span class="string">&quot;value1&quot;</span> </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpushx</span> <span class="string">key1</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="lset、lindex"><a href="#lset、lindex" class="headerlink" title="lset、lindex"></a>lset、lindex</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lset key index value :表示通过其索引设置列表中元素的值,当index超出列表索引范围时会返回错误</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lset</span> <span class="string">key1</span> <span class="number">0</span> <span class="string">&quot;value3-new&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lset</span> <span class="string">key1</span> <span class="number">-1</span> <span class="string">&quot;value1-new&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value3-new&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1-new&quot;</span></span><br><span class="line"><span class="comment"># lindex key index :通过索引获取列表中的元素。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lindex</span> <span class="string">key1</span> <span class="number">0</span></span><br><span class="line"><span class="string">&quot;value3-new&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lindex</span> <span class="string">key1</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value1-new&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lindex</span> <span class="string">key1</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="linsert"><a href="#linsert" class="headerlink" title="linsert"></a>linsert</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># linsert key before|after pivot value :用于把value插入到列表key中参考值pivot的前面或后面。key不存在什么都不执行，返回操作后列表的长度，如果pivot参考值不存在的时候返回-1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">linsert</span> <span class="string">key1</span> <span class="string">before</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value2-before&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2-before&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="ltrim"><a href="#ltrim" class="headerlink" title="ltrim"></a>ltrim</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ltrim key start stop :只保留列表中指定范围内的元素值。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ltrim</span> <span class="string">key1</span> <span class="number">1</span> <span class="number">-2</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ltrim</span> <span class="string">key1</span> <span class="number">1</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="判断操作"><a href="#判断操作" class="headerlink" title="判断操作"></a>判断操作</h4><h5 id="llen"><a href="#llen" class="headerlink" title="llen"></a>llen</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># llen key :用于获取列表的长度,key不存在返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">llen</span> <span class="string">key1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="lrem"><a href="#lrem" class="headerlink" title="lrem"></a>lrem</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lrem key count value :从列表key中删除前count个值等于value的元素,返回删除元素的个数，key不存在会被当作空list处理，返回0</span></span><br><span class="line"><span class="comment"># count取值说明：(1)count&gt;0:从头到尾删除值为value的元素。(2)count&lt;0:从尾到头删除值为value的元素。(3)count=0:移除所有值为value的元素。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value6&quot;</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrem</span> <span class="string">key1</span> <span class="number">-2</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrem</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value8&quot;</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value10&quot;</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">9</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrem</span> <span class="string">key1</span> <span class="number">0</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="string">&quot;value8&quot;</span></span><br><span class="line"><span class="string">&quot;value10&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="lpop、rpop"><a href="#lpop、rpop" class="headerlink" title="lpop、rpop"></a>lpop、rpop</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lpop key :删除并返回存储在key中的列表的第一个元素，key不存在的时候返回nil 。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpop</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">(nil)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpop</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="comment"># rpop key :删除并返回存储在key中的列表的最后一个元素，key 不存在时返回nil。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key1</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpop</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="blpop、brpop"><a href="#blpop、brpop" class="headerlink" title="blpop、brpop"></a>blpop、brpop</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># blpop key1 [key2 ] timeout :用于删除并返回列表中的第一个元素（头部操作），如果列表中没有元素，就会发生阻塞，直到列表等待超时或发现可弹出元素为止。timeout参数表示的是一个指定阻塞的最大秒数的整型值。当timeout为0是表示永久阻塞，lpop的阻塞版本</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key2</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;vbalue4&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">blpop</span> <span class="string">key1</span> <span class="string">key2</span> <span class="number">0</span></span><br><span class="line"><span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="string">&quot;vlaue2&quot;</span></span><br><span class="line"><span class="comment"># brpop key1 [key2 ] timeout :用于删除并返回列表中的最后一个元素（尾部操作），如果列表中没有元素，就会发生阻塞，直到列表等待超时或发现可弹出元素为止。timeout参数表示的是一个指定阻塞的最大秒数的整型值。当timeout为0是表示永久阻塞，rpop的阻塞版本</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">key3</span> <span class="string">&quot;value5&quot;</span> <span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key4</span> <span class="string">&quot;value7&quot;</span> <span class="string">&quot;vbalue8&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">brpop</span> <span class="string">key4</span> <span class="string">key3</span> <span class="number">0</span></span><br><span class="line"><span class="string">&quot;key4&quot;</span></span><br><span class="line"><span class="string">&quot;value8&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="rpoplpush、brpoplpush"><a href="#rpoplpush、brpoplpush" class="headerlink" title="rpoplpush、brpoplpush"></a>rpoplpush、brpoplpush</h5><blockquote>
<p>从 Redis 6.2.0起</p>
<p><code>rpoplpush</code> 使用 <code>lmove</code>替代</p>
<p><code>brpoplpush</code> 使用<code>blmove</code>替代</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rpoplpush source destination :从列表source中移除并返回最后一个元素，然后把这个元素插入为列表destination的第一个元素，如果source不存在返回nil</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key2</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;vbalue4&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpoplpush</span> <span class="string">key1</span> <span class="string">key2</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key2</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="comment"># brpoplpush source destination timeout :rpoplpush的阻塞版本。如果列表中没有元素，就会发生阻塞，直到等待超时或发现可弹出元素时为止。timeout参数表示的是一个指定阻塞的最大秒数的整型值。当timeout为0是表示永久阻塞</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">brpoplpush</span> <span class="string">key2</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key2</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="lmove、blmove"><a href="#lmove、blmove" class="headerlink" title="lmove、blmove"></a>lmove、blmove</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># lmove source destination left|right left|right :原子地从列表source中移除并返回第一个或最后一个元素（头或尾取决于wherefrom参数)，然后把这个元素插入到列表destination的第一个或最后一个元素（头或尾取决于 wherefrom参数)，返回移除并在此插入的元素，如果source不存在，返回nil，什么也不执行</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rpush</span> <span class="string">key2</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;vbalue4&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lmove</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">right</span> <span class="string">left</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key2</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lmove</span> <span class="string">key2</span> <span class="string">key1</span> <span class="string">left</span> <span class="string">right</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lrange</span> <span class="string">key2</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="comment"># blmove source destination left|right left|right timeout，lmove的阻塞版本，如果列表中没有元素，就会发生阻塞，直到等待超时或发现可弹出元素时为止。timeout参数表示的是一个指定阻塞的最大秒数的整型值。当timeout为0是表示永久阻塞</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">blmove</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">right</span> <span class="string">left</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a href="https://www.redis.com.cn/commands/blpop.html">Redis-List命令</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Set命令</title>
    <url>/2022/06/27/Redis/Redis-Set%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Redis-Set操作命令</strong></p>
<span id="more"></span>

<blockquote>
<p>命令参数说明</p>
<ol>
<li>带有操作元素个数参数(<code>count</code>)<ul>
<li><code>count</code>是整数且小于元素的个数，返回含有<code>count</code>个不同的元素的数组，</li>
<li><code>count</code>是个整数且大于集合中元素的个数时，返回整个集合的所有元素，</li>
<li><code>count</code>是负数，则会返回一个包含count的绝对值的个数元素的数组，如果<code>count</code>的绝对值大于元素的个数，则返回的结果集里会出现一个元素出现多次的情况.</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="设置和获取操作"><a href="#设置和获取操作" class="headerlink" title="设置和获取操作"></a>设置和获取操作</h4><h5 id="sadd、smembers"><a href="#sadd、smembers" class="headerlink" title="sadd、smembers"></a>sadd、smembers</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sadd key member1 [member2] :向集合中添加一个或者多个元素，并且自动去重。返回新添加到集合中的袁术数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value3&quot;</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># smembers key :查看集合中所有元素。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="srandmember"><a href="#srandmember" class="headerlink" title="srandmember"></a>srandmember</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># srandmember key [count] :随机返回指定数量的元素，默认返回1个。[类似spop命令，但是srandmember不删除元素]</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">srandmember</span> <span class="string">key1</span> <span class="number">2</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">srandmember</span> <span class="string">key1</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">srandmember</span> <span class="string">key1</span> <span class="number">-5</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="sscan"><a href="#sscan" class="headerlink" title="sscan"></a>sscan</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sscan key cursor [match pattern] [count count]:该命令用来迭代的集合中的元素</span></span><br><span class="line"><span class="comment"># 参数说明：cursor:游标，pattern:正则，count：数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value11&quot;</span> <span class="string">&quot;value12&quot;</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sscan</span> <span class="string">key1</span> <span class="number">0</span> <span class="string">match</span> <span class="string">&quot;value1*&quot;</span> <span class="string">count</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;value12&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sscan</span> <span class="string">key1</span> <span class="number">0</span> <span class="string">match</span> <span class="string">&quot;value1*&quot;</span> <span class="string">count</span> <span class="number">5</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;value12&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;value11&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="判断操作"><a href="#判断操作" class="headerlink" title="判断操作"></a>判断操作</h4><h5 id="scard"><a href="#scard" class="headerlink" title="scard"></a>scard</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scard key :返回集合中元素的个数。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">scard</span> <span class="string">key1</span></span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<h5 id="sismember"><a href="#sismember" class="headerlink" title="sismember"></a>sismember</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sismember key member :查看指定元素是否存在于集合中,返回1未存在，元素不存在或者key不存在返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sismember</span> <span class="string">key1</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sismember</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sismember</span> <span class="string">key2</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><h5 id="sdiff、sdiffstore"><a href="#sdiff、sdiffstore" class="headerlink" title="sdiff、sdiffstore"></a>sdiff、sdiffstore</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sdiff key1 [key2] :返回第一个集合与其他集合之间的差异，也可以认为说第一个集合中独有的元素。不存在的集合key将视为空集。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key2</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value5&quot;</span> <span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key3</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sdiff</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">key3</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="comment"># sdiffstore destination key1 [key2] :同sdiff命令，只是最后结果保存在destination集合，如果destination已存在，则将其覆盖，返回保存到destination集合中的数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key4</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key5</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">deskey6</span> <span class="string">&quot;value5&quot;</span> <span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">deskey6</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sdiffstore</span> <span class="string">deskey6</span> <span class="string">key4</span> <span class="string">key5</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">deskey6</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="sinter、sinterstore"><a href="#sinter、sinterstore" class="headerlink" title="sinter、sinterstore"></a>sinter、sinterstore</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sinter key1 [key2] :返回所有给定集合的成员交集,不存在的key为空集合,如果给定的key中有一个空集合，那么结果集一定是空集合。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sinter</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">key3</span></span><br><span class="line"><span class="string">(empty</span> <span class="string">list</span> <span class="string">or</span> <span class="string">set)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sinter</span> <span class="string">key1</span> <span class="string">key2</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="comment"># sinterstore destination key1 [key2] :同sinter命令，只是最后结果保存在destination集合，如果destination已存在，则将其覆盖，返回保存到destination集合中的数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key4</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key5</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">deskey6</span> <span class="string">&quot;value5&quot;</span> <span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">deskey6</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sinterstore</span> <span class="string">deskey6</span> <span class="string">key4</span> <span class="string">key5</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">deskey6</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="sunion、sunionstore"><a href="#sunion、sunionstore" class="headerlink" title="sunion、sunionstore"></a>sunion、sunionstore</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sunion key1 [key2] :求两个或者多个集合的并集。不存在key当做空集合处理。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sunion</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">key3</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="comment"># sunionstore destination key1 [key2] :同sunion命令，只是最后结果保存在destination集合，如果destination已存在，则将其覆盖，返回保存到destination集合中的数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key4</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key5</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">deskey6</span> <span class="string">&quot;value5&quot;</span> <span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">deskey6</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sunionstore</span> <span class="string">deskey6</span> <span class="string">key4</span> <span class="string">key5</span> </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">deskey6</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="smove"><a href="#smove" class="headerlink" title="smove"></a>smove</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># smove source destination member :原子的从集合source中移动成员member到集合destination,如果destination已经存在member元素，则只操作在source中移除member，移动成功返回1，如果source不存在返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key2</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value5&quot;</span> <span class="string">&quot;value6&quot;</span> </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smove</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">&quot;value7&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smove</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smove</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">key2</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="spop"><a href="#spop" class="headerlink" title="spop"></a>spop</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># spop key [count] :弹出后删除一个或多个随机元素,返回被删除的元素，key不存在返回nil</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">spop</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">spop</span> <span class="string">key1</span> <span class="number">2</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="srem"><a href="#srem" class="headerlink" title="srem"></a>srem</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># srem key member1 [member2] :删除一个或者多个元素，若元素不存在则自动忽略。返回被删除元素的个数，如果key不存在返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value2&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value4&quot;</span> <span class="string">&quot;value5&quot;</span> <span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">srem</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">&quot;value3&quot;</span> <span class="string">&quot;value7&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">smembers</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;value6&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a href="https://www.redis.com.cn/commands/sadd.html">Redis-Set命令</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-String命令</title>
    <url>/2022/06/21/Redis/Redis-String%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Redis-String操作命令</strong></p>
<span id="more"></span>

<blockquote>
<p>Redis的字符串中除了下面这些常用命令，还有一部分是位图操作的命令，位图操作的优势，相比于字符串而言，它不仅效率高，而且还非常的节省空间。但是由于未使用过，所以不详述</p>
</blockquote>
<h4 id="设置和获取操作"><a href="#设置和获取操作" class="headerlink" title="设置和获取操作"></a>设置和获取操作</h4><h5 id="set、-get"><a href="#set、-get" class="headerlink" title="set、 get"></a>set、 get</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># set key value [EX seconds|PX milliseconds] [NX|XX] :设置key和value，默认key的value存在则覆盖，且之前设置的过期时间失效</span></span><br><span class="line"><span class="comment"># set key value [设置指定的过期时间，以秒为单位|设置指定的过期时间，以毫秒为单位] [如果key不存在，则设置key与value|如果key存在，则重新设置 value]</span></span><br><span class="line"><span class="comment"># 在 key 不存在的情况下设置过期时间为 60s</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">test:setget</span> <span class="string">&quot;setgetStr&quot;</span> <span class="string">EX</span> <span class="number">60</span> <span class="string">NX</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="comment"># get key :根据key获取value</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">test:setget</span></span><br><span class="line"><span class="string">&quot;setgetStr&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="setnx、msetnx"><a href="#setnx、msetnx" class="headerlink" title="setnx、msetnx"></a>setnx、msetnx</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setnx key value：当key不存在时设置key和value</span></span><br><span class="line"><span class="comment"># setnx(set if Not eXists)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">setnx</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">setnx</span> <span class="string">key1</span> <span class="string">&quot;value2&quot;</span> <span class="comment">#返回0，说明key存在，导致命令执行失败</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="comment"># msetnx key value [key value ...]：指定的 key 都不存在时，用于设置多个键值对</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">msetnx</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">msetnx</span> <span class="string">key1</span> <span class="string">&quot;valuenew&quot;</span> <span class="string">key3</span> <span class="string">&quot;value3&quot;</span>  <span class="comment">#返回0，key1存在，导致命令执行失败</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">mget</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">key3</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">(nil)</span></span><br></pre></td></tr></table></figure>

<h5 id="setex、psetex"><a href="#setex、psetex" class="headerlink" title="setex、psetex"></a>setex、psetex</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setex key seconds value:设置键key的值设置为value,并将key的过期时间设为seconds(以秒为单位)。</span></span><br><span class="line"><span class="comment"># setex:set expire</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">setex</span> <span class="string">key1</span> <span class="number">10</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ttl</span> <span class="string">key1</span></span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="comment"># psetex key milliseconds value:和setex相似，只是过期时间以毫秒为单位</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">psetex</span> <span class="string">key2</span> <span class="number">1000</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">pttl</span> <span class="string">key2</span></span><br><span class="line"><span class="number">1000</span></span><br></pre></td></tr></table></figure>

<h5 id="mset-、mget"><a href="#mset-、mget" class="headerlink" title="mset 、mget"></a>mset 、mget</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mset key value [key value ...]:同时设置多个键值对</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">mset</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="comment"># mget key1 [key2...]:批量获取一个或者多个key的值</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">mset</span> <span class="string">key1</span> <span class="string">key2</span> </span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="getset"><a href="#getset" class="headerlink" title="getset"></a>getset</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#getset：设置key的值为value,返回key的旧值，如果旧值不存在则返回nilW</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">getset</span> <span class="string">key1</span> <span class="string">&quot;valuenew&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><h5 id="strlen"><a href="#strlen" class="headerlink" title="strlen"></a>strlen</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#strlen key :返回key所存储的字符串值的长度,当key不存在返回0，当value不是字符串类型时返回错误</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">strlen</span> <span class="string">key1</span></span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure>

<h5 id="append"><a href="#append" class="headerlink" title="append"></a>append</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#append key value：为指定的key追加值，返回追加后字符串的长度，如果key不存在，则相当于set</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">append</span> <span class="string">key1</span> <span class="string">&quot;-valuenew&quot;</span></span><br><span class="line"><span class="number">15</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;value1-valuenew&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="子字符串操作"><a href="#子字符串操作" class="headerlink" title="子字符串操作"></a>子字符串操作</h4><h5 id="setrange、getrange"><a href="#setrange、getrange" class="headerlink" title="setrange、getrange"></a>setrange、getrange</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># setrange key offset vlaue :从偏移量offset开始，使用指定的value覆盖的key所存储的部分字符串值,不存在的key当做空白字符，命令执行后会返回被修改之后， 字符串值的长度。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">setrange</span> <span class="string">key1</span> <span class="number">5</span> <span class="string">&quot;new&quot;</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key1</span></span><br><span class="line"><span class="string">&quot;valuenew&quot;</span></span><br><span class="line"><span class="comment">#getrange key start end :返回key中字符串值的子字符，负数偏移提供相对字符串结尾的偏移，即-1表示最后一个字符,返回截取到的子字符串</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">getrange</span> <span class="string">key2</span> <span class="number">0</span> <span class="number">2</span></span><br><span class="line"><span class="string">&quot;val&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">getrange</span> <span class="string">key2</span> <span class="number">0</span> <span class="number">-1</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">getrange</span> <span class="string">key2</span> <span class="number">2</span> <span class="number">-2</span></span><br><span class="line"><span class="string">&quot;lue&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="字符串为数值的操作"><a href="#字符串为数值的操作" class="headerlink" title="字符串为数值的操作"></a>字符串为数值的操作</h4><blockquote>
<p>incr、incrby：操作的值限制在 64 位(bit)有符号数字之内。</p>
</blockquote>
<h5 id="incr、incrby、incrbyfloat"><a href="#incr、incrby、incrbyfloat" class="headerlink" title="incr、incrby、incrbyfloat"></a>incr、incrby、incrbyfloat</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#incr key :将key所存储的整数值加1,如果key不存在，那么key的值会先被初始化为0然后再执行INCR操作。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">incr</span> <span class="string">key1</span> </span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="comment"># incrby key increment :将key所储存的值加上给定的递增值（increment）,如果key不存在，那么key的值会先被初始化为0然后再执行incrby操作。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key2</span> <span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">incrby</span> <span class="string">key2</span> <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">11</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key2</span> </span><br><span class="line"><span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="comment"># incrbyfloat key increment :将key所储存的值加上指定的浮点递增值（increment）,如果key不存在，那么key的值会先被初始化为0然后再执行incrbyfloat操作, INCRBYFLOAT命令的计算结果最多只保留小数点的后十七位。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key3</span> <span class="string">&quot;5.55&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">incrbyfloat</span> <span class="string">key3</span> <span class="string">&quot;-3&quot;</span></span><br><span class="line"><span class="string">&quot;2.55&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key3</span> </span><br><span class="line"><span class="string">&quot;2.55&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="decr、decrby"><a href="#decr、decrby" class="headerlink" title="decr、decrby"></a>decr、decrby</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># decr key :将key所存储的整数值减1，如果键key不存在，那么键key的值会先被初始化为0，然后再执行DECR操作。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">decr</span> <span class="string">key1</span> </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment">#decrby key decrement	 将key所储存的值减去给定的递减值（decrement）,如果键key不存在，那么键key的值会先被初始化为0，然后再执行decrby操作。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key2</span> <span class="string">&quot;11&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">decrby</span> <span class="string">key2</span> <span class="string">&quot;6&quot;</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key2</span> </span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a href="https://www.redis.com.cn/commands/append.html">Redis-String命令</a></p>
<p><a href="http://c.biancheng.net/redis/strings.html">Redis String字符串</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-ZSet命令</title>
    <url>/2022/06/28/Redis/Redis-ZSet%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Redis-ZSet操作命令</strong></p>
<blockquote>
<p>命令参数说明</p>
<ol>
<li><p>分数(<code>score</code>)</p>
<p><code>score</code> 值可以是整数值或双精度浮点数，<code>score</code> 可为正也可以为负。</p>
</li>
<li><p>索引（<code>index</code>）：</p>
<ul>
<li><code>0</code>表示第一个，<code>1</code>表示第二个，以此往后推</li>
<li><code>-1</code>表示列表的最后一个，<code>-2</code>表示倒数第二个，以此往前推</li>
</ul>
</li>
<li><p>是否带分数返回(<code>WITHSCORES</code>)</p>
<p>可选的 <code>WITHSCORES</code> 参数决定结果集是单单返回有序集的成员，还是将有序集成员及其 <code>score</code> 值一起返回</p>
</li>
</ol>
</blockquote>
<h4 id="设置和获取操作"><a href="#设置和获取操作" class="headerlink" title="设置和获取操作"></a>设置和获取操作</h4><h5 id="zadd、zrange、zrevrange"><a href="#zadd、zrange、zrevrange" class="headerlink" title="zadd、zrange、zrevrange"></a>zadd、zrange、zrevrange</h5><blockquote>
<p>= 2.4: 支持一次增加或更新多个成员。<br>= 3.0.2: 增加 XX, NX, CH 和 INCR 选项。<br>=6.2: 增加 GT 和 LT 选项。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zadd key  [nx|xx] [gt|lt] [ch] [incr] score1 member1 [score2 member2...] :用于将一个或多个成员添加到有序集合中，或者更新已存在成员的 score值</span></span><br><span class="line"><span class="comment"># 参数说明 :</span></span><br><span class="line"><span class="comment"># (1)NX: 不更新存在的成员。只添加新成员。 XX: 仅更新存在的成员，不添加新成员。</span></span><br><span class="line"><span class="comment"># (2)GT: 更新新的分值比当前分值大的成员，不存在则新增。 LT: 更新新的分值比当前分值小的成员，不存在则新增。</span></span><br><span class="line"><span class="comment"># (3)CH: 返回变更成员的数量。变更的成员是指 新增成员 和 score值更新的成员，命令指明的和之前score值相同的成员不计在内。 注意: 在通常情况下，ZADD返回值只计算新添加成员的数量。</span></span><br><span class="line"><span class="comment"># (4)INCR: ZADD 使用该参数与 ZINCRBY 功能一样。一次只能操作一个score-element对。</span></span><br><span class="line"><span class="comment"># 注意: GT, LT 和 NX 三者互斥不能同时使用</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> <span class="number">3</span> <span class="string">&quot;value1&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="comment"># zrange key start stop [WITHSCORES] :返回有序集合中指定索引区间内的成员,分数由低到高(由小到大)，具有相同分数值的成员按字典序(lexicographical order)来排列</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> </span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">withscores</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="comment"># zrevrange key start stop [WITHSCORES]	:返回有序集中指定索引区间内的成员，分数从高到低。具有相同score值的成员按字典序的反序排列,除了顺序，和zrang命令相同</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="zincby"><a href="#zincby" class="headerlink" title="zincby"></a>zincby</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zincrby key increment member :为key的成员member的score值加上增量increment。key不存在或者member不存在则直接增加，increment可以为负数</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">withscores</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zincrby</span> <span class="string">key1</span> <span class="number">5</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">7</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">withscores</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;7&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="zrangebylex、zrangebuscore、zrevrangebylex、zrevrangebyscore"><a href="#zrangebylex、zrangebuscore、zrevrangebylex、zrevrangebyscore" class="headerlink" title="zrangebylex、zrangebuscore、zrevrangebylex、zrevrangebyscore"></a>zrangebylex、zrangebuscore、zrevrangebylex、zrevrangebyscore</h5><blockquote>
<p>zrevrangebylex除了返回参数的顺序不同，和zrangebylex相同</p>
<p>zrevrangebyscore除了返回参数的顺序不同，和zrangebuscore相同</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zrangebylex key min max [LIMIT offset count] :返回有序集中指定字典区间内的成员。</span></span><br><span class="line"><span class="comment"># min和max:</span></span><br><span class="line"><span class="comment"># （1）min和max可以是-和+，传入-和+就可以获取所有成员。</span></span><br><span class="line"><span class="comment"># （2）min和max为字母是必须以(或者[开头。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;a&quot;</span> <span class="number">2</span> <span class="string">&quot;b&quot;</span> <span class="number">3</span> <span class="string">&quot;c&quot;</span> <span class="number">4</span> <span class="string">&quot;d&quot;</span> </span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrangebylex</span> <span class="string">key1</span> <span class="string">(a</span> <span class="string">(c</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrangebylex</span> <span class="string">key1</span> <span class="bullet">-</span> [<span class="string">c</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrangebylex</span> <span class="string">key1</span> <span class="bullet">-</span> <span class="string">+</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="comment"># zreveangebylex key max min [LIMIT offset count] :除了相反的顺序外，和zrangebylex命令相同</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrangebylex</span> <span class="string">key1</span> <span class="string">(c</span> <span class="string">(a</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrangebylex</span> <span class="string">key1</span> <span class="string">+</span> [<span class="string">c</span></span><br><span class="line"><span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrangebylex</span> <span class="string">key1</span> <span class="string">+</span> <span class="bullet">-</span></span><br><span class="line"><span class="string">&quot;d&quot;</span></span><br><span class="line"><span class="string">&quot;c&quot;</span></span><br><span class="line"><span class="string">&quot;b&quot;</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># zrangebyscore key min max [WITHSCORES] [LIMIT offset count] :返回有序集合中指定分数区间内的成员。成员按score(包含等于min和max)值递增(从小到大)排列。</span></span><br><span class="line"><span class="comment"># min和max:</span></span><br><span class="line"><span class="comment"># （1）min和 max可以是-inf和+inf，传入-inf和+inf就可以获取所有成员</span></span><br><span class="line"><span class="comment"># （2）默认情况下，区间的取值使用闭区间 (小于等于或大于等于)，可以通过给参数前增加(符号来使用可选的开区间 (小于或大于)。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key2</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> <span class="number">3</span> <span class="string">&quot;value3&quot;</span> <span class="number">4</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrangebyscore</span> <span class="string">key2</span> <span class="string">(1</span> <span class="number">3</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrangebyscore</span> <span class="string">key2</span> <span class="string">-inf</span> <span class="string">+inf</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrangebyscore</span> <span class="string">key2</span> <span class="string">-inf</span> <span class="string">+inf</span> <span class="string">WITHSCORES</span> <span class="string">LIMIT</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="comment"># zrevrangebyscore key max min [WITHSCORES]	除了相反的顺序外，和zrangebuscore命令相同。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key2</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> <span class="number">3</span> <span class="string">&quot;value3&quot;</span> <span class="number">4</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrangebyscore</span> <span class="string">key2</span> <span class="number">3</span> <span class="string">(1</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrangebyscore</span> <span class="string">key2</span> <span class="string">+inf</span> <span class="string">-inf</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrangebyscore</span> <span class="string">key2</span> <span class="string">+inf</span> <span class="string">-inf</span> <span class="string">WITHSCORES</span> <span class="string">LIMIT</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;2&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">4</span><span class="string">)</span> <span class="string">&quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="zscore"><a href="#zscore" class="headerlink" title="zscore"></a>zscore</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zscore key member :返回key中成员member的分数值,如果key不存在或者member不存在，返回nil</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zscore</span> <span class="string">key1</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zscore</span> <span class="string">key1</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">(nil)</span></span><br></pre></td></tr></table></figure>

<h5 id="zrank、zrevrank"><a href="#zrank、zrevrank" class="headerlink" title="zrank、zrevrank"></a>zrank、zrevrank</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zrank key member :返回有序集合中指定成员的排名。其中有序集成员按score值从低到高排序,最低为0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">10</span> <span class="string">&quot;value1&quot;</span> <span class="number">20</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrank</span> <span class="string">key1</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># zrevrank key member	:返回有序集合中指定成员的排名，其中有序集成员按分数值从高到低排序，最低为0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrevrank</span> <span class="string">key1</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="zscan"><a href="#zscan" class="headerlink" title="zscan"></a>zscan</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zscan key cursor [MATCH pattern] [COUNT count] :迭代有序集合中的元素（包括元素成员和元素分值）</span></span><br><span class="line"><span class="comment"># 参数说明：cursor:游标，pattern:正则，count：数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value11&quot;</span> <span class="number">2</span> <span class="string">&quot;value12&quot;</span> <span class="number">3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zscan</span> <span class="string">key1</span> <span class="number">0</span> <span class="string">match</span> <span class="string">&quot;value1*&quot;</span> <span class="string">count</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zscan</span> <span class="string">key1</span> <span class="number">0</span> <span class="string">match</span> <span class="string">&quot;value1*&quot;</span> <span class="string">count</span> <span class="number">5</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;value11&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;value12&quot;</span></span><br><span class="line"><span class="number">4</span><span class="string">)</span> <span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="判断操作"><a href="#判断操作" class="headerlink" title="判断操作"></a>判断操作</h4><h5 id="zcard"><a href="#zcard" class="headerlink" title="zcard"></a>zcard</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zcard key	获取有序集合中成员的数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> <span class="number">3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zcard</span> <span class="string">key1</span> </span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure>

<h5 id="zcount、zlexcount"><a href="#zcount、zlexcount" class="headerlink" title="zcount、zlexcount"></a>zcount、zlexcount</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zcount key min max :返回有序集key中，score值在min和max 之间(默认包括score值等于min或max)的成员的数量。参数min和max的详细使用方法，和zrangebyscore相同.</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> <span class="number">3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zcount</span> <span class="string">key1</span> <span class="string">(1</span> <span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zcount</span> <span class="string">key1</span> <span class="string">-inf</span> <span class="string">+inf</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="comment"># zlexcount key min max :当有序集中的所有成员都有相同的score,zlexcount命令返回有序集中值在min和max之间的成员个数。</span></span><br><span class="line"><span class="comment"># 参数min和max的详细使用方法，和zrangebylex相同。时间复杂度: O(log(N))。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key2</span> <span class="number">0</span> <span class="string">&quot;a&quot;</span> <span class="number">0</span> <span class="string">&quot;b&quot;</span> <span class="number">0</span> <span class="string">&quot;c&quot;</span> <span class="number">0</span> <span class="string">&quot;d&quot;</span> <span class="number">0</span> <span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zlexcount</span> <span class="string">key2</span> [<span class="string">b</span> [<span class="string">f</span></span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zlexcount</span> <span class="string">key2</span> <span class="bullet">-</span> <span class="string">+</span></span><br><span class="line"><span class="number">5</span></span><br></pre></td></tr></table></figure>

<h4 id="集合操作"><a href="#集合操作" class="headerlink" title="集合操作"></a>集合操作</h4><h5 id="zinterstore、zinter"><a href="#zinterstore、zinter" class="headerlink" title="zinterstore、zinter"></a>zinterstore、zinter</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zintserstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] :计算numkeys个有序集合的交集，并且把结果放到destination中,在给定要计算的key和其它参数之前，必须先给定key个数(numberkeys)。默认情况下，结果集中元素的分数是各有序集合中该元素分数之和。如果destination存在，会被覆盖，返回destination中元素个数。</span></span><br><span class="line"><span class="comment"># WEIGHTS:可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认是1</span></span><br><span class="line"><span class="comment"># AGGREGATE:可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中该元素最小或最大score。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key2</span> <span class="number">1</span> <span class="string">&quot;value3&quot;</span> <span class="number">3</span> <span class="string">&quot;value2&quot;</span> <span class="number">3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key3</span> <span class="number">4</span> <span class="string">&quot;value4&quot;</span> <span class="number">5</span> <span class="string">&quot;value5&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key3</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zinterstore</span> <span class="string">key3</span> <span class="number">2</span> <span class="string">key1</span> <span class="string">key2</span>  </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key3</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment"># zinter numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES] :命令类似于 ZINTERSTORE,不同的是他不存储结果集，而是把结果集返回给客户端。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zinter</span> <span class="number">2</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="zunionstore、zunion"><a href="#zunionstore、zunion" class="headerlink" title="zunionstore、zunion"></a>zunionstore、zunion</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zunionstore destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]:计算给定的numkeys个有序集合的并集，并且把结果放到destination中,在给定要计算的key和其它参数之前，必须先给定key个数(numkeys)。默认情况下，结果集中元素的分数是各有序集合中该元素分数之和。如果destination存在，会被覆盖，返回destination中元素个数。</span></span><br><span class="line"><span class="comment"># WEIGHTS:可以为每个给定的有序集指定一个乘法因子，意思就是，每个给定有序集的所有成员的score值在传递给聚合函数之前都要先乘以该因子。如果WEIGHTS没有给定，默认是1</span></span><br><span class="line"><span class="comment"># AGGREGATE:可以指定并集的结果集的聚合方式。默认使用的参数SUM，可以将所有集合中某个成员的score值之和作为结果集中该成员的score值。如果使用参数MIN或者MAX，结果集就是所有集合中该元素最小或最大score。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key2</span> <span class="number">1</span> <span class="string">&quot;value3&quot;</span> <span class="number">3</span> <span class="string">&quot;value2&quot;</span> <span class="number">3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key3</span> <span class="number">4</span> <span class="string">&quot;value4&quot;</span> <span class="number">5</span> <span class="string">&quot;value5&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key3</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zunionstore</span> <span class="string">key3</span> <span class="number">2</span> <span class="string">key1</span> <span class="string">key2</span>  </span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key3</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br><span class="line"><span class="comment"># zunion numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX] [WITHSCORES]:命令类似于zunionstore,不同的是他不存储结果集，而是把结果集返回给客户端。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zunion</span> <span class="string">key3</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;3&quot;</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="zrem"><a href="#zrem" class="headerlink" title="zrem"></a>zrem</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zrem key member [member ...] :从有序集合key中删除指定的成员member。返回删除的元素个数，key或者member返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key1</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span> </span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrem</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrem</span> <span class="string">key1</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key1</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="zremrangebylex"><a href="#zremrangebylex" class="headerlink" title="zremrangebylex"></a>zremrangebylex</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zremrangebylex key min max	:删除成员名称按字典由低到高排序介于min和 max 之间的所有成员（集合中所有成员的分数相同）</span></span><br><span class="line"><span class="comment"># 参数min和max的详细使用方法，和zrangebylex相同。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key2</span> <span class="number">1</span> <span class="string">&quot;a&quot;</span> <span class="number">2</span> <span class="string">&quot;b&quot;</span> <span class="number">3</span> <span class="string">&quot;c&quot;</span> <span class="number">4</span> <span class="string">&quot;d&quot;</span> <span class="number">5</span> <span class="string">&quot;e&quot;</span> </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zremrangebylex</span> <span class="string">key2</span> [<span class="string">b</span> <span class="string">(e</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key2</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;a&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;e&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="zremrangebyrank"><a href="#zremrangebyrank" class="headerlink" title="zremrangebyrank"></a>zremrangebyrank</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zremrangebyrank key start stop :移除有序集key中，指定排名(rank)区间 start 和 stop 内的所有成员。下标参数start和stop都是从0开始计数，0是分数最小的那个元素。索引也可是负数，表示位移从最高分处开始数。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key3</span> <span class="number">10</span> <span class="string">&quot;value1&quot;</span> <span class="number">20</span> <span class="string">&quot;value2&quot;</span>  <span class="number">30</span> <span class="string">&quot;value3&quot;</span>  <span class="number">40</span> <span class="string">&quot;value4&quot;</span>  <span class="number">50</span> <span class="string">&quot;value5&quot;</span> </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zremrangebyrank</span> <span class="string">key3</span> <span class="number">1</span> <span class="number">3</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key3</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;10&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="string">&quot;50&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="zremrangebyscore"><a href="#zremrangebyscore" class="headerlink" title="zremrangebyscore"></a>zremrangebyscore</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># zremrangebyscore key min max :移除有序集key中，所有score值介于min和max之间(包括等于min或max)的成员。</span></span><br><span class="line"><span class="comment"># 参数min和max的详细使用方法，和zrangebyscore相同。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">key4</span> <span class="number">1</span> <span class="string">&quot;value1&quot;</span> <span class="number">2</span> <span class="string">&quot;value2&quot;</span>  <span class="number">3</span> <span class="string">&quot;value3&quot;</span>  <span class="number">4</span> <span class="string">&quot;value4&quot;</span>  <span class="number">5</span> <span class="string">&quot;value5&quot;</span> </span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zremrangebyscore</span> <span class="string">key4</span> <span class="number">2</span> <span class="number">4</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">key4</span> <span class="number">0</span> <span class="number">-1</span> <span class="string">WITHSCORES</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;1&quot;</span></span><br><span class="line"><span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="string">&quot;5&quot;</span></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a href="https://www.redis.com.cn/commands/zadd.html">Redis-ZSer命令</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据的淘汰策略</title>
    <url>/2022/07/08/Redis/Redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>Redis使用内存存储数据，Redis提供了 <strong>maxmemory</strong> 设置其最多可占用的内存空间</p>
<span id="more"></span>

<p>当Redis使用的内存超出<code>maxmemory</code>时，此时已经没有多余可用的内存空间，新的数据将无法写入，基于此Redis提供了几种数据淘汰策略，用于清理数据，腾出空间以继续提供服务。</p>
<blockquote>
<p>淘汰策略并不保证100%能清理出可使用的内存空间，如果不成功就反复执行。当对所有数据尝试完成后，如果不能达到内存清理的要求，将出现错误信息(<code>OOM</code>)。</p>
</blockquote>
<p><strong>相关配置</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">maxmemory :最大可使用内存。占用物理内存的比例，默认0代表不限制。</span><br><span class="line">maxmemory-samples :每次选取的待删除数据的个数。每次选取数据并不是全库扫描，而是随机选取一部分。</span><br><span class="line">maxmemory-policy :淘汰策略。当内存100%使用之后，对挑选出来的数据删除的策略。</span><br></pre></td></tr></table></figure>

<h3 id="淘汰策略"><a href="#淘汰策略" class="headerlink" title="淘汰策略"></a>淘汰策略</h3><p>Redis共支持8种淘汰策略，主要分为3部分</p>
<ol>
<li><p>放弃数据淘汰：</p>
<ul>
<li><p><strong>noeviction</strong>：不会继续服务写请求(<code>del</code>请求可以)，读请求可以继续进行，即可读不可写。</p>
<p>默认策略，该策略不会丢失数据，但是同样生产的写请求不可用也会让业务无法进行下去</p>
</li>
</ul>
</li>
<li><p>易丢失数据：在具有过期时间的key中淘汰(<code>server.db[*].expire</code>)</p>
<ul>
<li><strong>volatile-lru</strong>：最近最少使用的key优先淘汰。</li>
<li><strong>volatile-lfu</strong>：最不经常使用的数据优先淘汰。</li>
<li><strong>volatile-ttl</strong>：比较过期时间ttl的值，值越小越优先淘汰。</li>
<li><strong>volatile-random</strong>：随机淘汰</li>
</ul>
</li>
<li><p>全部数据：在所有key中淘汰(<code>server.db[*].dict</code>)</p>
<ul>
<li><strong>allkeys-lru</strong>：最近最少使用的key优先淘汰。</li>
<li><strong>alikeys-lfu</strong>：最不经常使用的数据优先淘汰</li>
<li><strong>allkeys-random</strong>：随机淘汰</li>
</ul>
</li>
</ol>
<p>以上淘汰策略，除了范围不同，分为：不处理、随机、过期时间、LRU、LFU</p>
<h3 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h3><p>在执行写操作命令前，Redis都会检测内存是否充足，如果内存不满足要加入数据的最低要求，就会触发淘汰策略</p>
<h4 id="随机采样"><a href="#随机采样" class="headerlink" title="随机采样"></a>随机采样</h4><p>Redis在内存不够时执行淘汰策略时，不是操作所选范围内的全部key，而是随机采样出 <strong>maxmemory_samples</strong> (默认值为5) 个key，然后根据选择的算法淘汰掉最旧的一个key，如果淘汰后，内存还是不够，就会继续随机采样淘汰，直到内存对于写入操作可用</p>
<ul>
<li>如果淘汰策略的范围是<code>allkeys</code>，那么在所有<code>key</code>的字典中随机采样</li>
<li>如果淘汰策略的范围是过期的<code>volatile</code>，那么在过期<code>key</code>的字典中随机采样</li>
</ul>
<blockquote>
<p>采样的数量根据 <code>maxmemory_samples</code> 配置得来，采样数量越大，近似算法的效果越接近严格算法本身</p>
<p>Redis还增加了一个淘汰池数组，大小是 <code>maxmemory_samples</code>，在每一次淘汰循环中，新的采样出来的<code>key</code>会和淘汰池中的<code>key</code>进行融合，淘汰掉最旧的一个<code>key</code>，然后将剩余最旧的<code>key</code>列表放入淘汰池，等待下次循环。</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/Redis%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E9%9A%8F%E6%9C%BA%E9%87%87%E6%A0%B7.png" alt="随机采样"></p>
<h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h4><p>Redis的<code>key</code>和<code>value</code>是存储在<code>redisObject</code>中的，<code>redisObject</code>是<code>Redis</code>对内部存储的数据定义的抽象类型，负责装载Redis中的所有键和值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;      <span class="comment">// 数据类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;  <span class="comment">// 编码格式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS;<span class="comment">// 24位，LRU时间戳或LFU计数。</span></span><br><span class="line">    <span class="keyword">int</span> refcount;         <span class="comment">// 引用计数，为了节省内存，Redis会在多处引用同一个redisObject</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;            <span class="comment">// 指向真正存储数据的数据结构，如sds，真正的数据存储在该数据结构中。</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<p><code>redisObject</code>中的<code>lru:LRU_BITS</code>，长度为24个<code>bit</code>，就是淘汰策略为LRU或者LFU时，存储对应数据的字段</p>
<h4 id="LRU和LFU的实现"><a href="#LRU和LFU的实现" class="headerlink" title="LRU和LFU的实现"></a>LRU和LFU的实现</h4><ul>
<li><p>LRU（<code>Least Recently Used</code>）</p>
<p>衡量标准为时间，操作时间离当前时间最远的容易被淘汰，<code>redisObject</code>的<code>lru</code>字段会保存数据被访问时的时间戳(秒)后24位</p>
<blockquote>
<p>24bit并不能保存完整的时间戳</p>
<p>为了性能，系统秒时间不是实时获取的，使用Redis的时间事件，每隔100ms获取一次</p>
<ul>
<li><p>如果系统秒时间的后24位 &gt;= lru记录的时间</p>
<p>相减，数值越大越容易被淘汰</p>
</li>
<li><p>如果系统秒时间的后24位 &lt; lru记录的时间</p>
<p>系统秒时间的后24位+(24位秒时间的最大值-lru记录的时间)， 相差越大越容易被淘汰</p>
</li>
</ul>
</blockquote>
</li>
<li><p>LFU（<code>Least Frequently Used</code>）</p>
<p>Redis4以后支持，复用了<code>lru</code>字段，衡量标准为次数，<code>redisObject</code>的<code>lru</code>字段会保存了16位的时间戳(分钟级)+8位的访问次数</p>
<p><strong>访问次数</strong>：</p>
<p>访问次数只有8bit，即最大值为255，对此Redis采用的不是精确计数，而且近似计数</p>
<ul>
<li><p>访问次数增加：</p>
<p>访问次数在增加时如果已经是最大值，就不在增加</p>
<ul>
<li><p>如果访问次数小于等于5，则每访问一次，次数加1</p>
</li>
<li><p>如果访问次数大于5小于255，次数的增加属于随机增加，次数越大，加1的概率越小，<code>lfu-log-factor</code>配置的值越大，加1的概率越小</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lfu-log-factor :配置，默认10，配置的值越大，对象访问次数增加的概率越小</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>访问次数减少：</p>
<p>访问次数在减少时，如果已经是0，就不在减少，不会减成负数</p>
<ul>
<li><p>根据前16位的对象访问时间，根据系统时间比较获取到多久没有访问过</p>
</li>
<li><p>根据<code>lfu-decay-time</code>，每分钟没有访问减少多少次数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lfu-decay-time：配置，默认1，每分钟没访问，访问次数减1</span><br></pre></td></tr></table></figure>

</li>
</ul>
<blockquote>
<p>LFU访问次数的减少处理也避免了：旧的数据访问次数较多，新数据新增加的访问次数不够，导致新数据进不去，老数据一直被存储</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>随机采样只是保证了局部最优，Redis为了性能，其实牺牲了一些LRU和LFU的准确性，只能说是近似LRU和LFU，但在实际使用过程中也完全足够了甚至更适合Redis</p>
<p>参考资料</p>
<p><a href="https://developer.aliyun.com/article/846108">Redis之淘汰策略</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/353588378">Redis源码剖析之内存淘汰策略(Evict)</a></p>
<p><a href="https://juejin.cn/post/6844904120533401607">Redis内存淘汰策略源码分析以及LFU/LRU实现</a></p>
<p><a href="https://blog.csdn.net/shui2104/article/details/108819770">Redis删除策略</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据的过期策略</title>
    <url>/2022/07/06/Redis/Redis%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>Redis支持给<code>key</code>设置过期时间，并提供过期策略对<code>key</code>进行过期处理</p>
<span id="more"></span>

<h3 id="设置过期时间"><a href="#设置过期时间" class="headerlink" title="设置过期时间"></a>设置过期时间</h3><p>Redis可以为<code>key</code>设置过期时间</p>
<ul>
<li><code>expire</code>：设置<code>key</code>的过期时间，以秒为单位</li>
<li><code>pexpire</code>：设置<code>key</code>的过期时间，以毫秒为单位</li>
<li><code>expireat</code>：设置<code>key</code>的过期时间，参数为以秒为单位的时间戳格式</li>
<li><code>pexpireat</code>：设置<code>key</code>的过期时间，参数为以毫秒为单位的时间戳格式</li>
</ul>
<p>其实<code>expire</code>、<code>pexpire</code>、<code>expireat</code>最终实现都是通过<code>pexpireat</code>实现的，也就是说无论客户端执行哪个命令，Redis都会转换成<code>pexpireat</code>命令执行。所以<code>expires</code>字典中存的时间是用<strong>毫秒时间戳表示的键的过期时间。</strong></p>
<h3 id="Key存储"><a href="#Key存储" class="headerlink" title="Key存储"></a>Key存储</h3><p>Redis会将每个设置了过期时间的<code>key</code>放入一个独立的字典中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisDb</span> &#123;</span> </span><br><span class="line"><span class="keyword">int</span> id; <span class="comment">//id是数据库序号，为0-15(默认Redis有16个数据库) </span></span><br><span class="line"><span class="keyword">long</span> avg_ttl; <span class="comment">//存储的数据库对象的平均ttl(time to live)，用于统计 </span></span><br><span class="line">dict *dict; <span class="comment">//存储数据库所有的key-value </span></span><br><span class="line">dict *expires; <span class="comment">//存储key的过期时间 </span></span><br><span class="line">dict *blocking_keys;<span class="comment">//blpop 存储阻塞key和客户端对象 </span></span><br><span class="line">dict *ready_keys;<span class="comment">//阻塞后push 响应阻塞客户端 存储阻塞后push的key和客户端对象 </span></span><br><span class="line">dict *watched_keys;<span class="comment">//存储watch监控的的key和客户端对象 </span></span><br><span class="line">&#125; redisDb;</span><br></pre></td></tr></table></figure>

<p><code>dict</code> 用来维护一个 Redis 数据库中包含的所有 <code>Key-Value</code> 键值对，<code>expires</code>则用于维护一个 Redis 数据库中设置了失效时间的键(即<code>key</code>与失效时间的映射)，当我们使用<code>expire</code>命令设置一个<code>key</code>的失效时间时，Redis 首先到 <code>dict</code> 这个字典表中查找要设置的<code>key</code>是否存在，</p>
<ul>
<li>如果存在，就将这个<code>key</code>和失效时间添加到 <code>expires</code> 这个字典表</li>
<li>如果不存在，Redis 首先将 <code>key</code> 和 <code>value</code> 添加到 <code>dict</code> 这个字典表中，然后将 <code>key</code> 和失效时间添加到 <code>expires</code> 这个字典表中</li>
</ul>
<blockquote>
<p>注意这里的失效时间是用毫秒的时间戳表示的，比如2022-01-02 22:45:02过期则value为1641134702000</p>
</blockquote>
<h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><p>一般处理过期数据，常用的过期策略有三种</p>
<ul>
<li><p>定时删除：在设置键的过期时间的同时，创建一个定时器，让定时器在键的过期时间来临时，立即执行对键的删除操作。（<strong>创建定时器删除</strong>）</p>
<ul>
<li><p>优点</p>
<p>对内存最友好：通过使用定时器，可以保证过期的键会尽可能快地被删除，释放所占内存</p>
</li>
<li><p>缺点</p>
<p>对CPU最不友好：在过期键比较多的情况下，删除过期键这一行为可能会占用相当一部分CPU的时间，对服务器的响应时间和吞吐量造成影响。</p>
</li>
</ul>
</li>
<li><p>惰性删除：放任键的过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期的话，就删除该键；如果没有过期，就返回该键。（<strong>使用的时候删除</strong>）</p>
<ul>
<li><p>优点</p>
<p>对CPU最友好：只有在取出键的时候才会对过期键进行检查，即不需要CPU定期扫描，也不需要创建大量的定时器。</p>
</li>
<li><p>缺点</p>
<p>对内存最不友好：如果一个键已经过期，但是后面不会被访问到的话，那么就一直保留在数据库中。如果这样的键过多，无疑会占用很大的内存。</p>
</li>
</ul>
</li>
<li><p>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里面过期的键。至于要删除多少过期键，以及要检查多少个数据库，则有算法决定。（<strong>定期扫描删除</strong>）</p>
<p>定期删除是上面的定时删除和惰性删除的一中折中方案。</p>
<ul>
<li><p>优点</p>
<p>① 定期删除每隔一段时间执行一次过期键操作，并通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</p>
<p>② 通过删除过期键，能有效的减少因为过期键而带来的内存浪费</p>
</li>
<li><p>缺点</p>
<p>难以确定删除操作执行的时长和频率</p>
<p>① 如果删除操作执行得太频繁，或者执行的时间太长，定期删除策略就会退化成定时删除，以至于占用太多CPU的执行时间。</p>
<p>② 如果删除操作执行的时间太少，或执行时间太短，定期删除策略又会和惰性删除一样，出现内存浪费。</p>
</li>
</ul>
</li>
</ul>
<h4 id="Redis的过期策略"><a href="#Redis的过期策略" class="headerlink" title="Redis的过期策略"></a>Redis的过期策略</h4><p>Redis采用的是：<strong>惰性删除</strong>和<strong>定期删除</strong>两种策略，通过合理配置，服务器可以很好地在合理使用<code>cpu</code>时间和避免浪费内存空间之间取得平衡。</p>
<p><strong>惰性删除策略</strong></p>
<p>Redis中所有读写数据库的命令在执行之前都会调用先对输入键进行检查，另外因为每个被访问的键都可能被删除，所以每个命令都必须能同时处理键存在以及不存在的情况。</p>
<p>读写操作和访问操作惰性删除流程如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E6%83%B0%E6%80%A7%E8%BF%87%E6%9C%9F%E6%B5%81%E7%A8%8B.png" alt="惰性删除策略流程"></p>
<p><strong>定期删除策略</strong></p>
<p>Redis的定期删除策略周期性的在规定时间内，分多次遍历服务器中各个数据库对过期的key进行删除</p>
<p>Redis默认每秒进行10次过期扫描，且每次循环时间不能超过最大执行时间上限25ms，且每次检查的数据库最大数量就是Redis中的数据库个数</p>
<ol>
<li><p>从当前数据库(<code>current_db</code>)的过期字典中随机选出20个<code>key</code></p>
<blockquote>
<p>以<code>Hash</code>桶的维度，拿到20个<code>key</code>为止，如果到最后一个<code>Hash</code>桶位置拿到所有<code>key</code>后超过20也会一次性取出</p>
</blockquote>
</li>
<li><p>删除这个20key中已经过期的<code>key</code></p>
</li>
<li><p>如果过期<code>key</code>的比例超过1/4，那就循环1、2、3这个过程</p>
</li>
<li><p>如果过期<code>key</code>的比例小于1/4，那么继续检查下一个数据库，循环1、2、3、4</p>
</li>
</ol>
<p>由定期删除过程可以发现：定期删除的定时时间十分重要，如果时间过短，就会对CPU造成很大压力。如果时间过长，就会造成过期数据挤压内存</p>
<h4 id="Redis过期对持久化的影响"><a href="#Redis过期对持久化的影响" class="headerlink" title="Redis过期对持久化的影响"></a>Redis过期对持久化的影响</h4><p><strong>RDB</strong></p>
<p>过期<code>key</code>对RDB没有任何影响</p>
<ul>
<li><p>生成RDB文件：从内存数据库持久化数据到RDB文件</p>
<p>持久化key之前，会检查是否过期，过期的<code>key</code>不进入RDB文件</p>
</li>
<li><p>载入RDB文件：从RDB文件恢复数据到内存数据库</p>
<ul>
<li>如果是主库：数据载入数据库之前，会对<code>key</code>先进行过期检查，如果过期，不导入数据库</li>
<li>如果是从库：无论<code>key</code>是否过期，均会载入到数据库中，过期键会通过与主服务器同步而删除</li>
</ul>
</li>
</ul>
<p><strong>AOF</strong></p>
<p>过期<code>key</code>对AOF没有任何影响</p>
<ul>
<li><p>从内存数据库持久化数据到AOF文件</p>
<ul>
<li>当<code>key</code>过期后，还没有被删除，<code>aof</code>文件不会产生因为影响，此时正常进行执行持久化操作（该<code>key</code>是不会进入<code>aof</code>文件的，因为没有发生修改命令）</li>
<li>当<code>key</code>过期后，在发生删除操作时，程序会向<code>aof</code>文件追加一条<code>del</code>命令（在将来的以<code>aof</code>文件恢复数据的时候该过期的键就会被删掉）</li>
</ul>
</li>
<li><p>AOF重写</p>
<p>重写时，会先判断<code>key</code>是否过期，已过期的<code>key不</code>会重写到<code>aof</code>文件</p>
</li>
</ul>
<p>参考资料</p>
<p><a href="https://juejin.cn/post/7048988049589895175">Redis的过期策略-掘金</a></p>
<p><a href="https://blog.csdn.net/qq_40276626/article/details/120607202">Redis过期时间三种删除策略详解</a></p>
<p><a href="https://www.cnblogs.com/xuliangxing/p/7151812.html">Redis学习笔记–Redis数据过期策略详解</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis数据类型</title>
    <url>/2022/06/30/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p><code>Redis</code> 是 <code>Key-Value</code> 缓存型数据库</p>
<p><code>Redis</code> 为了存储不同类型的数据，提供了五种常用数据类型，如下所示：</p>
<span id="more"></span>

<ul>
<li><code>string</code>（字符串）</li>
<li><code>hash</code>（哈希散列）</li>
<li><code>list</code>（列表）</li>
<li><code>set</code>（集合）</li>
<li><code>zset</code>（<code>sorted set</code>：有序集合）</li>
</ul>
<blockquote>
<p>注意：这里指的数据类型是 <code>Value</code>（值） 的数据类型，而非 <code>key</code>。</p>
<p>除了上述五种类型之外，Redis 还支持一些其他类型，但是不常用。在此不做介绍</p>
</blockquote>
<hr>
<h4 id="redisObject"><a href="#redisObject" class="headerlink" title="redisObject"></a>redisObject</h4><p><code>redisObject</code>是<code>Redis</code>对内部存储的数据定义的抽象类型，<code>redisObject</code>负责装载Redis中的所有键和值，在具体分析<code>Redis</code>的每个数据类型前，我们先了解<code>redisObject</code>，它的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;      <span class="comment">// 数据类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;  <span class="comment">// 编码格式，即存储数据使用的数据结构。同一个类型的数据，Redis会根据数据量、占用内存等情况使用不同的编码，最大限度地节省内存。</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS;<span class="comment">// 24位，LRU时间戳或LFU计数。</span></span><br><span class="line">    <span class="keyword">int</span> refcount;         <span class="comment">// 引用计数，为了节省内存，Redis会在多处引用同一个redisObject。</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;            <span class="comment">// 指向真正存储数据的数据结构，如sds，真正的数据存储在该数据结构中。</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>提示：<code>type</code>、<code>encoding</code>、<code>lru</code>使用了C语言中的位段定义，这3个属性使用同一个<code>unsigned int</code>的不同<code>bit</code>位。这样可以最大限度地节省内存。</p>
</blockquote>
<p><code>Redis</code>定义了以下数据类型和编码，如下表所示</p>
<table>
<thead>
<tr>
<th>数据类型(type)</th>
<th>说明</th>
<th>编码(encoding)</th>
<th>使用的数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>OBJ_STRING</td>
<td>字符串</td>
<td>`OBJ_ENCODING_INT</td>
<td>long long、long</td>
</tr>
<tr>
<td></td>
<td></td>
<td>OBJ_ENCODING_EMBSTR</td>
<td>string</td>
</tr>
<tr>
<td></td>
<td></td>
<td>OBJ_ENCODING_RAW</td>
<td>string</td>
</tr>
<tr>
<td>OBJ_HASH</td>
<td>散列</td>
<td>OBJ_ENCODING_HT</td>
<td>dict</td>
</tr>
<tr>
<td></td>
<td></td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>ziplist</td>
</tr>
<tr>
<td>OBJ_LIST</td>
<td>列表</td>
<td>OBJ_ENCODING_QUICKLIST</td>
<td>quicklist</td>
</tr>
<tr>
<td>OBJ_SET</td>
<td>集合</td>
<td>OBJ_ENCODING_HT</td>
<td>dict</td>
</tr>
<tr>
<td></td>
<td></td>
<td>OBJ_ENCODING_INTSET</td>
<td>intset</td>
</tr>
<tr>
<td>OBJ_ZSET</td>
<td>有序集合</td>
<td>OBJ_ENCODING_ZIPLIST</td>
<td>ziplist</td>
</tr>
<tr>
<td></td>
<td></td>
<td>OBJ_ENCODING_SKIPLIST</td>
<td>skiplist</td>
</tr>
</tbody></table>
<blockquote>
<p><code>object encoding key</code> : 查询某个键内部的编码</p>
</blockquote>
<hr>
<h4 id="String，字符串"><a href="#String，字符串" class="headerlink" title="String，字符串"></a>String，字符串</h4><p><code>String</code> 是<code> Redis</code> 最基本的数据类型。<code>Redis</code>键都是字符串类型，<code>Redis</code>中最简单的值类型也是字符串类型，字符串是一组字节，在 <code>Redis</code> 数据库中，字符串具有二进制安全（<code>binary safe</code>）特性，这意味着它的长度是已知的，不由任何其他终止字符决定的，</p>
<p>一个字符串类型的值最多能够存储 <code>512 MB</code> 的内容。</p>
<blockquote>
<p>二进制安全：是一种主要用于字符串操作函数的计算机编程术语。只关心二进制化的字符串，不关心具体的字符串格式，严格的按照二进制的数据存取。这保证字符串不会因为某些操作而遭到损坏。</p>
</blockquote>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">testkey</span> <span class="string">&quot;testvalue&quot;</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">testkey</span></span><br><span class="line"><span class="string">&quot;testvalue&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zhangyuying.top/2022/06/21/Redis/%E5%91%BD%E4%BB%A4/Redis-String%E5%91%BD%E4%BB%A4/#more"><code>Redis-String</code>操作命令</a></p>
<h5 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h5><p><strong>1.SDS</strong></p>
<p><code>Redis</code>对C语言的字符串做了扩展，定义了字符串类型<code>sds</code>(<code>Simple Dynamic String</code>，简单动态字符串 )</p>
<blockquote>
<p>对于不同长度的字符串，<code>Redis</code>定义了不同的<code>sds</code>结构体(5种)，为了<code>len</code>、<code>alloc</code>使用合适的属性类型，最大限度地节省内存。</p>
</blockquote>
<p><code>sds</code>结构体中除了字段的数据类型不同，字段含义相差无几</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct __attribute__ ((__packed__)) sdshdr8 &#123;</span><br><span class="line">    uint8_t len;   &#x2F;&#x2F;字符串的长度(实际使用的长度)</span><br><span class="line">    uint8_t alloc;  &#x2F;&#x2F;分配内存的大小，即已申请的字节长度(即sds总长度。alloc-len为sds中的可用(空闲)空间。)</span><br><span class="line">    unsigned char flags; &#x2F;&#x2F;标志位，表示sds的类型（sdshdr8、sdshdr16、sdshdr32、sdshdr64）</span><br><span class="line">    char buf[];  &#x2F;&#x2F;字符数组，sds遵循C语言字符串的规范，保存一个空字符作为buf的结尾，并且不计入len、alloc属性，这样还是可以使用C语言的字符串函数直接操作sds</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sds可以在常数时间内获取字符串长度，并使用预分配内存机制减少内存拷贝次数。</p>
</blockquote>
<p><strong>分配冗余空间</strong>：<code>Redis</code> 每次给 <code>string</code> 分配的空间都要大于字符串实际占用的空间，这样就在一定程度上提升了<code> Redis string</code> 存储的效率，比如当字符串长度变大时，无需再重新申请内存空间。</p>
<p><strong><code>SDS</code>的扩容</strong>：当<code>len</code>大小将要超过<code>alloc</code>的时候，<code>SDS</code>会进行扩容操作。</p>
<p>当第一次创建字符串的时候，<code>len</code>和<code>alloc</code>一样长，当使用了<code>append</code>的时候，<code>SDS</code>将会进行扩容，字符串长度小于<code>1M</code>的时候，扩容采用加倍扩容，当长度超过<code>1M</code>，则每次增加<code>1M</code>.</p>
<p>SDS优势：</p>
<ul>
<li>可以常数复杂度获取字符串长度：<code>len</code>属性</li>
<li>防止缓冲区溢出：扩容操作</li>
<li>减少修改字符串导致内存重分配的次数：分配冗余空间。</li>
<li>二进制安全</li>
<li>遵循C语言字符串的规范，保存一个空字符作为字符串的结尾，这样还是可以使用C语言的字符串函数直接操作<code>SDS</code></li>
</ul>
<p><strong>2.Redis内部存储</strong></p>
<p><code>Redis</code>中的字符串数据类型(<code>type</code>)为<code>OBJ_STRING</code>，编码类型(<code>encoding</code>)可以是<code>int</code>、<code>embstr</code>、<code>row </code>中的一个</p>
<blockquote>
<p><code>Redis</code>对数据编码的主要目的是最大限度地节省内存</p>
</blockquote>
<ul>
<li><p><strong><code>int</code>编码</strong>：保存<code>long </code>型的<strong>64位有符号整数</strong>，即对应的编码类型为 <code>OBJ_ENCODING_INT</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;set test:int1 123</span><br><span class="line">127.0.0.1:6379&gt;set test:int2 123</span><br></pre></td></tr></table></figure>

<p>内存结构图示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/String-Int%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="Int编码内存结构"></p>
</li>
</ul>
<blockquote>
<p>1).将数值型字符串转换为整型可以大幅降低数据占用的内存空间，如字符串“<code>123456789012</code>”需要占用<code>12</code>字节，在<code>Redis</code>中，会将它转化为<code>long long</code>类型，只占用8字节。</p>
<p>2).<code>Redis</code> 启动时会预先建立 <code>10000</code> 个分别存储 <code>0~9999</code> 的 <code>redisObject</code>变量作为共享对象，这就意味着如果 <code>set</code>字符串的键值在<code> 0~10000</code> 之间的话，则可以 直接指向共享对象 而不需要再建立新对象，此时键值不占空间</p>
</blockquote>
<ul>
<li><p><strong><code>embstr</code> 编码</strong>：保存长度小于<code>44</code>字节的字符串，即对应的编码类型为<code>OBJ_ENCODING_EMBSTR</code>(<code>embedded string</code>,表示嵌入式的<code>String</code>)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;set test:embstr abc</span><br></pre></td></tr></table></figure>

<p>在该编码中，从内存结构上来讲 即字符串 <code>sds</code>结构体与其对应的 <code>redisObject</code> 对象分配在 <strong>同一块连续的内存空间</strong>，这就仿佛字符串 <code>sds</code> 嵌入在 <code>redisObject</code> 对象之中一样</p>
<p>内存结构图示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/String-embstr%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="embstr编码内存结构"></p>
<p>优点：<code>OBJ_ENCODING_EMBSTR</code>编码是<code>Redis</code>针对短字符串的优化，有如下优点：</p>
<ul>
<li>内存申请和释放都只需要调用一次内存操作函数。</li>
<li><code>redisObject</code>、<code>sds</code>结构保存在一块连续的内存中，减少了内存碎片。</li>
</ul>
</li>
<li><p><strong><code>raw</code> 编码</strong>：保存长度大于<code>44</code>字节的字符串</p>
<blockquote>
<p>和embstr编码不同的是，在该编码中，<code>redisObject</code>、<code>sds</code>结构存放在两个不连续的内存块中。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt;set foo abcdefghijklmnopqrstuvwxyzabcdeffasdffsdaadsx</span><br></pre></td></tr></table></figure>

<p>内存结构图示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/String-row%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="row编码内存结构"></p>
</li>
</ul>
<hr>
<h4 id="Hash，散列"><a href="#Hash，散列" class="headerlink" title="Hash，散列"></a>Hash，散列</h4><p><code>Hash</code> (哈希散列)是由字符串类型的 <code>field</code> 和 <code>value</code> 组成的哈希映射表结构（也称散列表），可以把它理解成一个包含了多个键值对的集合。由于 <code>Hash</code> 类型具有上述特点，所以一般被用来存储对象。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">HSET</span> <span class="string">userid:1</span> <span class="string">username</span> <span class="string">zyy</span> <span class="string">password</span> <span class="number">123456</span> <span class="string">testkey</span> <span class="string">testvalue</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">HGETALL</span> <span class="string">userid:1</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;username&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;zyy&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;password&quot;</span></span><br><span class="line"><span class="number">4</span><span class="string">)</span> <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="number">5</span><span class="string">)</span> <span class="string">&quot;testkey&quot;</span></span><br><span class="line"><span class="number">6</span><span class="string">)</span> <span class="string">&quot;testvalue&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zhangyuying.top/2022/06/23/Redis/%E5%91%BD%E4%BB%A4/Redis-Hash%E5%91%BD%E4%BB%A4/#more"><code>Redis-Hash</code>操作命令</a></p>
<blockquote>
<p>注意：一个 <code>Hash</code> 中最多包含 <code>2^32-1</code> 个键值对。</p>
</blockquote>
<h5 id="实现方式-1"><a href="#实现方式-1" class="headerlink" title="实现方式"></a>实现方式</h5><p><code>Redis</code>中的<code>Hash</code>数据类型(<code>type</code>)为<code>OBJ_HASH</code>，编码类型(<code>encoding</code>)可能为<code>ziplist</code>或者<code>ht</code>其中一种，<code>Redis</code> 会根据<strong>数据量</strong>的情况来<strong>自适应</strong>地选择这两种编码方式中 <strong>较优</strong> 的一种，而这一切对用户完全透明。</p>
<ul>
<li><p><strong><code>ziplist</code>编码</strong>：即对应的编码类型为 <code>OBJ_ENCODING_ZIPLIST</code></p>
<p>同时符合以下两个条件时，才使用<code>ziplist</code>作为底层存储结构</p>
<ul>
<li>哈希对象保存的所有键值对（键和值）的字符串长度都小于<code> 64</code> 个字节。</li>
<li>哈希对象保存的键值对数量要小于<code> 512</code> 个。</li>
</ul>
<p>压缩列表：</p>
<p>压缩列表也不是基础数据结构，而是<code> Redis</code> 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据，压缩列表是<code>Redis</code>为了节约内存而开发的</p>
<blockquote>
<p><code>ziplist</code> 压缩列表是一种紧凑编码格式，总体思想是<strong>时间换空间</strong>，即以部分读写性能为代价，来换取极高的内存空间利用率，因此只会用于 字段个数少，且字段值也较小 的场景。</p>
</blockquote>
<p><code>ziplist</code>结构图参数如下：（ziplist并没有定义明确的结构体，以下代码是根据字段反推的，只是便于理解）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*仅仅是描述使用, 内存中并非如此存储*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ziplist</span>&#123;</span></span><br><span class="line">     <span class="keyword">uint32_t</span> zlbytes; <span class="comment">//是一个无符号整数，表示当前ziplist占用的总字节数；</span></span><br><span class="line">     <span class="keyword">uint32_t</span> zltail; <span class="comment">//指的是压缩列表尾部元素相对于压缩列表起始元素的偏移量(可以确定表尾字节地址)。</span></span><br><span class="line">     <span class="keyword">uint16_t</span> zllen; <span class="comment">//指ziplist中节点(entry)的数量。当zllen比2^16 - 2大时，需要完全遍历所有entry来获取entry的总数目。</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span>* entry[]; <span class="comment">//多个，用来存放ziplist中的具体的数据项，可以是字节数组或整数，长度不定，由保存的内容决定</span></span><br><span class="line">     <span class="keyword">unsigned</span> <span class="keyword">char</span> zlend; <span class="comment">//是一个单字节的特殊值，等于255，起到标识ziplist内存结束点的作用</span></span><br><span class="line">&#125;ziplist;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*仅仅是描述使用, 内存中并非如此存储*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zlentry</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> previous_entry_length; <span class="comment">//记录了前一个节点的长度，单位：字节</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> encoding; <span class="comment">//记录了content中数据的类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> len; <span class="comment">//记录了content中数据的长度</span></span><br><span class="line">     <span class="comment">/*元素实际内容*/</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> content[]; <span class="comment">//节点的值</span></span><br><span class="line">&#125;zlentry;</span><br></pre></td></tr></table></figure>

<p>内存结构图示</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">HSET</span> <span class="string">key1</span> <span class="string">field1</span> <span class="string">&quot;value1&quot;</span> <span class="string">field2</span> <span class="string">&quot;value2&quot;</span> <span class="string">field3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">OK</span></span><br></pre></td></tr></table></figure>

<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/Hash-zipList%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="ziplist编码内存结构"></p>
</li>
</ul>
<blockquote>
<p><code>ziplist</code>来存储<code> Redis</code>的散列类型时，元素的排列方式：<code>field</code>、<code>value</code>都是逻辑连续内存</p>
</blockquote>
<ul>
<li><p><strong>ht编码</strong>：(<code>hashtable</code>)，即对应的编码类型为 <code>OBJ_ENCODING_HT</code></p>
<p>这种编码方式内部才是真正的哈希表结构，或者称为字典结构，其可以实现<code>O(1)</code>复杂度的读写操作，因此效率很高</p>
<p>实现：<code>Redis</code>中的ht编码的结构和<code>Java</code>中的<code>HashMap</code>完全相同，实现方式也是通过<strong>数组+链表</strong>来完成的。</p>
<p>内存结构图示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/Hash-ht%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="ht编码内存结构"></p>
</li>
</ul>
<p><strong>rehash</strong>：散列表的<code>rehash</code>过程类似于数组的收缩与扩容。目的是提升性能或节省内存。</p>
<blockquote>
<p>扩展大小：<code>ht[1]</code>的大小为第一个大于等于<code>ht[0].used*2的2的n次方幂</code>。如:<code>ht[0].used</code>=<code>3</code>则<code>ht[1]</code>的大小为<code>8</code>，<code>ht[0].used=4</code>则<code>ht[1]</code>的大小为8。</p>
<p>收缩大小:<code> ht[1]</code>的大小为 第一个大于等于<code>ht[0].used的2的n次方幂</code>。</p>
</blockquote>
<p><code>rehash</code>是一个时间复杂度为<code>O(n)</code>的操作，为了解决耗时过多问题，<code>Redis</code>采用了两个方式：</p>
<ul>
<li><p>渐进式<code>rehash</code></p>
<p>通过同时保留的旧的<code>hashtable</code>和新的<code>hashtable</code>，使得扩容操作可以逐渐的操作。在rehash进行期间每次对字典执行增删改查操作时，<code>redis</code>都会同时执行<code>rehash</code></p>
<blockquote>
<ol>
<li>因为在进行渐进式 rehash 的过程中，字典会同时使用 <code>ht[0]</code> 和 <code>ht[1]</code> 两个哈希表，所以在渐进式 rehash 进行期间，字典的删除、查找、更新等操作会在两个哈希表上进行。</li>
<li>在渐进式 <code>rehash</code> 执行期间，新添加到字典的键值对一律会被保存到 <code>ht[1]</code> 里面，而 <code>ht[0]</code> 则不再进行任何添加操作：这一措施保证了 <code>ht[0]</code> 包含的键值对数量会只减不增，并随着 <code>rehash</code> 操作的执行而最终变成空表。</li>
</ol>
</blockquote>
</li>
<li><p>定时任务进行<code>rehash</code>。<code>rehash</code>操作需要满足以下条件:</p>
<ol>
<li>服务器目前没有执行<code>BGSAVE</code>(<code>rdb</code>持久化)命令或者<code>BGREWRITEAOF</code>(<code>AOF</code>文件重写)命令，并且散列表的负载因子大于等于<code>1</code>。</li>
<li>服务器目前正在执行<code>BGSAVE</code>命令或者<code>BGREWRITEAOF</code>命令，并且负载因子大于等于<code>5</code>。</li>
<li>当负载因子小于<code>0.1</code>时，程序自动开始执行收缩操作。</li>
</ol>
<blockquote>
<p><code>Redis</code>这么做的目的是基于操作系统创建子进程后写时复制技术，避免不必要的写入操作。</p>
</blockquote>
</li>
</ul>
<hr>
<h4 id="List，列表"><a href="#List，列表" class="headerlink" title="List，列表"></a>List，列表</h4><p><code>List</code> 中的元素是字符串类型，其中的元素按照插入顺序进行排列，允许重复插入，最多可插入的元素个数为<code> 2^32 -1</code> 个（大约<code>40</code>亿个），可以添加一个元素到列表的头部（左边）或者尾部（右边），当列表弹出最后一个元素时，该结构会被自动删除。</p>
<blockquote>
<p><code>List</code>（列表）相当于<code> Java</code> 语言中的<code> LinkedList</code> 结构，是一个链表而非数组，其插入、删除元素的时间复杂度为 <code>O(1)</code>，但是查询速度欠佳，时间复杂度为 <code>O(n)</code>。在实际使用中可以充当栈和队列的角色</p>
</blockquote>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#LPUSH 列表添加元素命令</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">LPUSH</span> <span class="string">testlist</span> <span class="string">Java</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">LPUSH</span> <span class="string">testlist</span> <span class="string">Redis</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">2</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">LPUSH</span> <span class="string">testlist</span> <span class="string">C</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">3</span></span><br><span class="line"><span class="comment">#LRANGE 查看列表元素</span></span><br><span class="line"><span class="comment">#最开始插入的在最后，最后插入位于第一个位置，和队列相似。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">LRANGE</span> <span class="string">testlist</span> <span class="number">0</span> <span class="number">3</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;C&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;Redis&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;Java&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zhangyuying.top/2022/06/24/Redis/%E5%91%BD%E4%BB%A4/Redis-List%E5%91%BD%E4%BB%A4/#more"><code>Redis-List</code>操作命令</a></p>
<h5 id="实现方式-2"><a href="#实现方式-2" class="headerlink" title="实现方式"></a>实现方式</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Redis&#96;中的&#96;List&#96;数据类型(&#96;type&#96;)为&#96;OBJ_LIST&#96;，编码类型(&#96;encoding&#96;)为&#96;quicklist</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在<code>Redis3.2</code>版本以前列表类型的内部编码有两种:<code>ziplist</code>和<code>linkedlist</code>，而在<code>Redis3.2</code>版本开始对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>.</p>
<p>原因：链表的附加空间相对太高，<code>prev</code> 和 <code>next</code> 指针就要占去 <code>16 </code>个字节 (<code>64bit</code> 系统的指针是 <code>8</code> 个字节)，另外每个节点的内存都是单独分配，会加剧内存的碎片化，影响内存管理效率。因此<code>Redis3.2</code>版本开始对列表数据结构进行了改造，使用 <code>quicklist</code> 代替了 <code>ziplist</code> 和 <code>linkedlist</code>.</p>
</blockquote>
<p><strong><code>quicklist</code>编码</strong>：即对应的编码类型为<code>OBJ_ENCODING_QUICKLIST</code></p>
<p><code>quicklist </code>实际上是<code>zipList</code>(具体可参照<code>Hash</code>的实现方式) 和 <code>linkedList</code> 的混合体，它将 <code>linkedList</code> 按段切分，每一段使用 <code>zipList</code> 来紧凑存储，多个 <code>zipList</code> 之间使用双向指针串接起来。</p>
<blockquote>
<p>由于<code>ziplist</code>是数组，因此当需要插入或删除元素的时候，就需要对其重新分配内存，因此<code>ziplist</code>的数据量不能太大(<code>list-max-ziplist-size</code>: 默认<code>8k</code>)。</p>
</blockquote>
<p>内存结构图示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/List-quickList%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="quicklist编码内存结构"></p>
<blockquote>
<p>相对于链表，<code>quciklist</code>压缩了内存，进一步的提高了效率</p>
</blockquote>
<hr>
<h4 id="Set，集合"><a href="#Set，集合" class="headerlink" title="Set，集合"></a>Set，集合</h4><p><code>Set</code> 是一个字符串类型元素构成的无序并唯一的集合。在 <code>Redis</code> 中，集合是通过哈希映射表实现的，所以无论是添加元素、删除元素，亦或是查找元素，它们的时间复杂度都为 <code>O(1)</code>。</p>
<blockquote>
<p>由于 <code>Set</code> 集合中的成员具有唯一性，所以重复插入不会成功，集合的同样可容纳 <code>2^32 -1</code> 个元素。</p>
<p>和其他数据类型一样，当集合中最后一个成员被删除时，存储成员所用的数据结构也会被自动删除。</p>
</blockquote>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">SADD</span> <span class="string">testset</span> <span class="string">HTML</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">SADD</span> <span class="string">testset</span> <span class="string">JS</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">SADD</span> <span class="string">testset</span> <span class="string">HTML</span> <span class="comment">#元素已存在，返回0</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#SMEMBERS命令查看集合中元素，元素会无序排列</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">SMEMBERS</span> <span class="string">testset</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;JS&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;HTML&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zhangyuying.top/2022/06/27/Redis/%E5%91%BD%E4%BB%A4/Redis-Set%E5%91%BD%E4%BB%A4/#more"><code>Redis-Set</code>操作命令</a></p>
<h5 id="实现方式-3"><a href="#实现方式-3" class="headerlink" title="实现方式"></a>实现方式</h5><p><code>Redis</code>中的<code>Set</code>数据类型(<code>type</code>)为<code>OBJ_SET</code>，编码类型(<code>encoding</code>)可能为<code>intset</code>或者<code>ht</code>其中一种，<code>Redis</code> 会根据<strong>数据</strong>的情况来<strong>自适应</strong>地选择这两种编码方式中 <strong>较优</strong> 的一种，而这一切对用户完全透明。</p>
<ul>
<li><p><strong><code>ht</code>编码</strong>：(<code>hashtable</code>)，即对应的编码类型为 <code>OBJ_ENCODING_HT</code></p>
<p><code>set</code>使用<code>ht</code>编码时的实现和<code>hash</code>的<code>ht</code>编码的实现完全一样，不同的是字典中所有的<code>value</code>都是<code>NULL</code>，因此特性也和<code>Hash</code>相同，因此不在赘述</p>
</li>
<li><p><strong><code>intset</code>编码</strong>：即对应的编码类型为 <code>OBJ_ENCODING_INTSET</code></p>
<p>同时符合以下两个条件时，才使用<code>intset</code>作为底层存储结构</p>
<ul>
<li>集合内保存的所有成员都是整数值</li>
<li>集合内保存的成员数量不超过 <code>512 </code>个</li>
</ul>
<p>整数集合(<code>intset</code>)并不是一个基础的数据结构，而是<code>Redis</code>自己设计的一种存储结构，整数集合的底层实现为数组，这个数组以<strong>有序</strong>、无重复的方式保存集合元素,在有需要时,程序会根据新添加元素的类型，改变这个数组的类型。<code>intset</code>结构图参数如下：</p>
<blockquote>
<p>如果元素满足使用inset作为存储结构，那么其实是有序的</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//每个intset结构表示一个整数集合</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span>&#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> encoding; <span class="comment">//编码方式，可取INTSET_ENC_INT16、INTSET_ENC_INT32、INTSET_ENC_INT64</span></span><br><span class="line">    <span class="keyword">uint32_t</span> length;   <span class="comment">//集合中包含的元素数量</span></span><br><span class="line">    <span class="keyword">int8_t</span> contents[]; <span class="comment">//保存元素的数组，整数集合的每个元素都是 contents数组的个数组项(item),各个项在数组中按值的大小从小到大有序地排列,并且数组中不包含任何重复项。</span></span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>

<p>内存结构图示</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key1</span> <span class="number">-10</span> <span class="number">2</span> <span class="number">-2</span> <span class="number">600</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/Set-intSet%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84t.png" alt="inset编码内存结构"></p>
<p><code>intset</code>升级：</p>
<p><code>inset</code>可以保存类型为<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>的整数值，每当我们要将一个新元素添加到整数集合里面,并且新元素的类型比整数集合现有所有元素的类型都要长时，整数集合需要先进行升级,然后才能将新元素添加到整数集合里面。</p>
<blockquote>
<p>整数集合只支持升级操作,不支持降级操作。</p>
</blockquote>
<p><code>inset</code>升级的优点</p>
<ul>
<li><p>为整数集合带来了操作上的灵活性</p>
<p>可以随意将<code>int16_t</code>、<code>int32_t</code>或者<code>int64_t</code>类型的整数添加到集合中,而不必担心出现类型错误,这种做法非常灵活。</p>
</li>
<li><p>节约内存</p>
<p>确保升级操作只会在有需要的时候进行，这可以尽量节省内存。因为如果我们一直只向整数集合添加<code>int16_t</code>类型的值，那么整数集合的底层实现就会一直是<code>int16_t</code>类型的数组，只有在我们要将<code>int32_t</code>类型或者<code>int64_t</code>类型的值添加到集合时，程序才会对数组进行升级。</p>
</li>
</ul>
<hr>
<h4 id="ZSet，有序集合"><a href="#ZSet，有序集合" class="headerlink" title="ZSet，有序集合"></a>ZSet，有序集合</h4><p><code>ZSet</code> 是一个字符串类型元素构成的有序集合，集合中的元素不仅具有唯一性，而且每个元素还会关联一 个<code>double</code> 类型的分数，该分数允许重复。<code>Redis</code> 正是通过这个分数来为集合中的成员排序。</p>
<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">testzset</span> <span class="number">0</span> <span class="string">Python</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">testzset</span> <span class="number">1</span> <span class="string">Java</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">testzset</span> <span class="number">2</span> <span class="string">C++</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">testzset</span> <span class="number">3</span> <span class="string">MySQL</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">testzset</span> <span class="number">4</span> <span class="string">Redis</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#重复元素无法添加成功</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">testzset</span> <span class="number">4</span> <span class="string">Redis</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br><span class="line"><span class="comment">#重复分值添加成功</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zadd</span> <span class="string">testzset</span> <span class="number">4</span> <span class="string">GOLANG</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="comment">#查看指定成员的分值</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ZSCORE</span> <span class="string">testzset</span> <span class="string">Redis</span></span><br><span class="line"><span class="string">&quot;4&quot;</span></span><br><span class="line"><span class="string">查看zset中的所有成员</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">zrange</span> <span class="string">testzset</span> <span class="number">0</span> <span class="number">4</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;Python&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;Java&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;C++&quot;</span></span><br><span class="line"><span class="number">4</span><span class="string">)</span> <span class="string">&quot;MySQL&quot;</span></span><br><span class="line"><span class="number">5</span><span class="string">)</span> <span class="string">&quot;GOLANG&quot;</span></span><br><span class="line"><span class="number">6</span><span class="string">)</span> <span class="string">&quot;Redis&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://zhangyuying.top/2022/06/28/Redis/%E5%91%BD%E4%BB%A4/Redis-ZSet%E5%91%BD%E4%BB%A4/#more"><code>Redis-ZSet</code>操作命令</a></p>
<h5 id="实现方式-4"><a href="#实现方式-4" class="headerlink" title="实现方式"></a>实现方式</h5><p><code>Redis</code>中的<code>ZSet</code>数据类型(<code>type</code>)为<code>OBJ_ZSET</code>，编码类型(<code>encoding</code>)可能为<code>intset</code>或者<code>ht</code>其中一种，<code>Redis</code> 会根据<strong>数据</strong>的情况来<strong>自适应</strong>地选择这两种编码方式中 <strong>较优</strong> 的一种，而这一切对用户完全透明。</p>
<ul>
<li><p><strong>ziplist编码</strong>：即对应的编码类型为 <code>OBJ_ENCODING_ZIPLIST</code></p>
<p>同时符合以下两个条件时，才使用ziplist(具体可参照Hash的实现方式)作为底层存储结构</p>
<ul>
<li>成员的数量小于<code>12</code>8 个</li>
<li>每 <code>member</code>（成员）的字符串长度都小于<code>64</code>个字节。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;zadd</span> <span class="string">key1</span> <span class="number">5</span> <span class="string">&quot;value1&quot;</span> <span class="number">8</span> <span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<p>内存结构图示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/ZSet-zipList%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="ziplist编码内存结构"></p>
</li>
<li><p><strong><code>skiplist</code>编码</strong>：即对应的编码类型为 <code>OBJ_ENCODING_SKIPLIST</code></p>
<p>跳跃列表(<code>skiplist</code>)是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</p>
<blockquote>
<p>为什么元素数量比较多或者成员是比较长的字符串的时，<code>Redis</code>要使用跳跃表来实现？<br>跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。</p>
</blockquote>
<p><code>Redis</code>中<code>skipList</code>数据结构定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span> <span class="comment">// 头指针header,指向跳跃表表头和尾指针tail。指向跳跃表表尾巴节点</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> length; <span class="comment">//链表长度length，即链表包含的节点总数。注意，新创建的skiplist包含一个空的头指针，这个头指针不包含在length计数中。</span></span><br><span class="line">    <span class="keyword">int</span> level; <span class="comment">//表示skiplist的总层数，即所有节点层数的最大值。</span></span><br><span class="line">&#125; zskiplist;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">    robj *obj;     <span class="comment">// 存放节点数据，sds类型</span></span><br><span class="line">    <span class="keyword">double</span> score;  <span class="comment">// 数据对应的分数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span> <span class="comment">//指向链表前一个节点的指针（后退指针）。节点只有1个后退指针，所以只有第1层链表是一个双向链表。</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span><span class="comment">// 前进指针，存放指向各层链表后一个节点的指针（后向指针）,每层对应1个后向指针</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;<span class="comment">//跨度，记录了前进指针所指向节点和当前节点的距离(跨度越大、距离越远)</span></span><br><span class="line">    &#125; level[]; <span class="comment">//层，每个层有两个属性：前进指针和跨度。 每次创建一个新跳跃表节点的时候,程序都根据幂次定律(powerlaw,越大的数出现的概率越小)随机生成一个介于1和32之间的值作为level数组的大小,这个大小就是层的“高度”。</span></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>

<p>内存结构展示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/ZSet-skipList%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.png" alt="skiplist编码内存结构"></p>
</li>
</ul>
<p>参考资料</p>
<p><a href="http://c.biancheng.net/redis/data-types.html">Redis数据类型</a></p>
<p><a href="https://www.jianshu.com/p/666452a22855">Redis字符串类型内部编码剖析-简书</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1914634">Redis剖析-Redis字符串的设计与实现</a></p>
<p><a href="https://www.jianshu.com/p/bccb198d191f">Redis哈希结构内存模型剖析-简书</a></p>
<p><a href="https://www.cnblogs.com/hunternet/p/11306690.html">Redis数据结构-压缩列表</a></p>
<p><a href="https://www.cnblogs.com/hunternet/p/9989771.html">Redis数据结构-字典</a></p>
<p><a href="https://www.cnblogs.com/hunternet/p/12624691.html">Redis数据结构-快速列表</a></p>
<p><a href="https://www.cnblogs.com/hunternet/p/11268067.html">Redis数据结构-整数集合</a></p>
<p><a href="https://www.cnblogs.com/hunternet/p/11248192.html">Redis数据结构-跳跃表</a></p>
<p><a href="https://juejin.cn/post/6844903478196699150">Redis 内部数据结构详解——skiplist</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的事务</title>
    <url>/2022/08/18/Redis/Redis%E7%9A%84%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p>Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p>
<p>总结说：Redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。　　</p>
<span id="more"></span>

<h3 id="Redis事务的特殊性"><a href="#Redis事务的特殊性" class="headerlink" title="Redis事务的特殊性"></a>Redis事务的特殊性</h3><p>事务按理说有四个属性：原子性、一致性、隔离性、持久性</p>
<p>Redis的事务中没有隔离级别的概念，并且Redis的事务不保证原子性也没有回滚</p>
<ul>
<li><p>Redis事务没有隔离级别的概念</p>
<p>Redis一个事务中的命令批量操作在发送 <code>EXEC</code> 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。</p>
</li>
<li><p>Redis事务不保证原子性</p>
<p>Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令可能不执行也可能仍会被执行。</p>
<blockquote>
<p>Redis中为什么不支持回滚？</p>
<p>Redis为提升性能采用的简单的处理的方式：</p>
<ul>
<li>如果事务中存在编译类错误（比如命令输入错误），那么所有命令都不会执行</li>
<li>如果事务中存在运行时异常（比如设置<code>list</code>的<code>key</code>用<code>String</code>类型的命令），则其他的正确命令会被执行，错误命令抛出异常</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="Redis事务的执行"><a href="#Redis事务的执行" class="headerlink" title="Redis事务的执行"></a>Redis事务的执行</h3><p>Redis事务的执行相当于分为三个阶段：开始事务、命令入队、执行事务</p>
<h4 id="事务命令"><a href="#事务命令" class="headerlink" title="事务命令"></a>事务命令</h4><ul>
<li><code>WATCH</code>：<code>watch key1 key2...</code>，监视一或多个<code>key</code>，如果在事务执行之前，被监视的<code>key</code>被其他命令改动，则事务被中断，不会执行事务中的任何命令</li>
<li><code>MULTI</code>：标记一个事务的开始</li>
<li><code>EXEC</code>：执行事务块（一旦执行<code>exec</code>后，之前加的监控锁都会被取消掉）</li>
<li><code>DISCARD</code>：取消事务，放弃事务块中的所有命令</li>
<li><code>UNWATCH</code>：取消<code>watch</code>对所有<code>key</code>的监控</li>
</ul>
<h4 id="事务使用案例"><a href="#事务使用案例" class="headerlink" title="事务使用案例"></a>事务使用案例</h4><ol>
<li><p>正常执行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MULTI</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">EXEC</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">OK</span></span><br><span class="line"><span class="number">2</span><span class="string">)&quot;value1&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">OK</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>放弃事务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MULTI</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-discard&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k2</span> <span class="string">&quot;value2-discard&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">discard</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>事务中存在错误</p>
<p>（1）编译性错误</p>
<p>事务提交失败，所有命令都不会执行</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MULTI</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-error&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sets</span> <span class="string">newKey</span> <span class="string">&quot;newKey&quot;</span></span><br><span class="line"><span class="string">(error)</span> <span class="string">ERR</span> <span class="string">unknown</span> <span class="string">command</span> <span class="string">`sets`,</span> <span class="attr">with args beginning with:</span> <span class="string">`newKey`,</span> <span class="string">`newKey`,</span> </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k2</span> <span class="string">&quot;value2-error&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exec</span></span><br><span class="line"><span class="string">(error)</span> <span class="string">EXECABORT</span> <span class="string">Transaction</span> <span class="string">discarded</span> <span class="string">because</span> <span class="string">of</span> <span class="string">previous</span> <span class="string">errors.</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k2</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>

<p>（2）运行时错误</p>
<p>事务提交成功，除了错误的命令外，其他的正确命令会被执行，错误命令抛出异常</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MULTI</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-exception&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">lpush</span> <span class="string">k2</span> <span class="string">&quot;value2-exception&quot;</span>  <span class="comment">#k2是String 不是list</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k3</span> <span class="string">&quot;value3-exception&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exec</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">OK</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">(error)</span> <span class="string">WRONGTYPE</span> <span class="string">Operation</span> <span class="string">against</span> <span class="string">a</span> <span class="string">key</span> <span class="string">holding</span> <span class="string">the</span> <span class="string">wrong</span> <span class="string">kind</span> <span class="string">of</span> <span class="string">value</span></span><br><span class="line"><span class="number">3</span><span class="string">）OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">&quot;value1-exception&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k2</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k3</span></span><br><span class="line"><span class="string">&quot;value3-exception&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>watch</code>监控事务</p>
<p>（1）监控<code>key</code>未发生改变</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1&quot;</span> <span class="string">k2</span> <span class="string">&quot;valeu2&quot;</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">watch</span> <span class="string">k1</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MULTI</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-watch&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k2</span> <span class="string">&quot;value2-watch&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exec</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">OK</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">&quot;value1-watch&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k2</span></span><br><span class="line"><span class="string">&quot;value2-watch&quot;</span></span><br></pre></td></tr></table></figure>

<p>（2）监控<code>key</code>发生改变</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1&quot;</span> <span class="string">k2</span> <span class="string">&quot;valeu2&quot;</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">watch</span> <span class="string">k1</span>   <span class="comment"># 监控kl</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-new&quot;</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MULTI</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-watch&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k2</span> <span class="string">&quot;value2-watch&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exec</span>  <span class="comment"># 由于监控了k1且k1被修改过，所以事务不执行</span></span><br><span class="line"><span class="string">(nil)</span>   </span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k2</span></span><br><span class="line"><span class="string">&quot;value2&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>unwatch</code>取消监控事务</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1&quot;</span> <span class="string">k2</span> <span class="string">&quot;valeu2&quot;</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">watch</span> <span class="string">k1</span>  <span class="comment"># 监控k1</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-new&quot;</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">unwatch</span> <span class="string">k1</span>  <span class="comment"># 取消监控k1</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MULTI</span></span><br><span class="line"><span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k1</span> <span class="string">&quot;value1-unwatch&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">k2</span> <span class="string">&quot;value2-unwatch&quot;</span></span><br><span class="line"><span class="string">QUEUED</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exec</span>   <span class="comment"># 取消监控后，即使k1被修改过也会执行成功</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">OK</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">OK</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k1</span></span><br><span class="line"><span class="string">&quot;value1-unwatch&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">k2</span></span><br><span class="line"><span class="string">&quot;value2-unwatch&quot;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>参考资料</p>
<p><a href="https://www.cnblogs.com/DeepInThought/p/10720132.html">Redis之Redis事务</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/135241403">彻底搞懂 Redis 事务</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis</title>
    <url>/2022/08/25/Redis/Redis/</url>
    <content><![CDATA[<p>Redis，Remote Dictionary Service(译为远程字典服务)，是现在最受欢迎的NoSQL数据库之一，Redis是一个使用ANSI C编写的开源、基于内存、支持网络、包含多种数据结构、可选持久性的键值对存储数据库</p>
<span id="more"></span>

<h4 id="Redis的特性"><a href="#Redis的特性" class="headerlink" title="Redis的特性"></a>Redis的特性</h4><ul>
<li>基于内存操作，数据不仅可以完全保存在内存中，还可以通过磁盘实现数据的持久存储；</li>
<li>key-value存储系统，支持丰富的数据类型，也被成为<code>数据结构服务器</code></li>
<li>支持分布式，增加系统容量，有效的保证数据的安全性和服务的可用性</li>
<li>开源的使用ANSI C语言编写、遵守BSD协议，并提供多种语言的API</li>
</ul>
<blockquote>
<p>NoSQL：指的是非关系型的数据库。Not Only Sql，不仅仅是SQL</p>
<p>Redis 数据库没有“表”的概念，它通过不同的数据类型来实现存储数据的需求，不同的数据类型能够适应不同的应用场景，从而满足开发者的需求。</p>
</blockquote>
<h4 id="Redis的优势"><a href="#Redis的优势" class="headerlink" title="Redis的优势"></a>Redis的优势</h4><ul>
<li>性能极高：Redis 基于内存实现数据存储，且命令执行是单线程的，它的读取速度是 110000次/s，写速度是 81000次/s；</li>
<li>多用途工具： Redis 有很多的用途，比如可以用作缓存、消息队列等；</li>
<li>高可用性：支持持久化、支持集群扩展</li>
<li>可移植性：Redis 使用用标准 C语言编写的，能够在大多数操作系统上运行，比如 Linux，Mac，Solaris 等</li>
</ul>
<p>Redis 常用来作为缓存，用来缓存一些经常被访问的热点数据、或者需要耗费大量资源的内容，通过把这些内容放到 Redis 中，可以让应用程序快速地读取它们</p>
<blockquote>
<p>Redis 基于内存来实现数据的存储，因此其速度非常快。不过，计算机的内存是非常珍贵的资源，所以 Redis 不适合存储较大的文件或者二进制数据，否则会出现错误，Redis 适合存储较小的文本信息。理论上 Redis 的每个 key、value 的大小不超过 512 MB。</p>
</blockquote>
<h4 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h4><ol>
<li>Redis<ul>
<li><a href="https://zhangyuying.top/2022/06/30/Redis/Redis%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/">Redis数据类型</a><ul>
<li><a href="https://zhangyuying.top/2022/06/21/Redis/%E5%91%BD%E4%BB%A4/Redis-String%E5%91%BD%E4%BB%A4/">String操作命令</a></li>
<li><a href="https://zhangyuying.top/2022/06/23/Redis/%E5%91%BD%E4%BB%A4/Redis-Hash%E5%91%BD%E4%BB%A4/">Hash操作命令</a></li>
<li><a href="https://zhangyuying.top/2022/06/24/Redis/%E5%91%BD%E4%BB%A4/Redis-List%E5%91%BD%E4%BB%A4/">List操作命令</a></li>
<li><a href="https://zhangyuying.top/2022/06/27/Redis/%E5%91%BD%E4%BB%A4/Redis-Set%E5%91%BD%E4%BB%A4/">Set操作命令</a></li>
<li><a href="https://zhangyuying.top/2022/06/28/Redis/%E5%91%BD%E4%BB%A4/Redis-ZSet%E5%91%BD%E4%BB%A4/">ZSet操作命令</a></li>
</ul>
</li>
<li><a href="https://zhangyuying.top/2022/07/04/Redis/Redis-Key%E9%94%AE/">Redis的key键</a><ul>
<li><a href="https://zhangyuying.top/2022/07/01/Redis/%E5%91%BD%E4%BB%A4/Redis-Key%E5%91%BD%E4%BB%A4/">Key操作命令</a></li>
</ul>
</li>
<li><a href="https://zhangyuying.top/2022/07/12/Redis/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/">持久化</a></li>
<li><a href="https://zhangyuying.top/2022/08/18/Redis/Redis%E7%9A%84%E4%BA%8B%E5%8A%A1/">事务</a></li>
<li><a href="https://zhangyuying.top/2022/08/23/Redis/Redis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/">发布订阅</a></li>
<li><a href="https://zhangyuying.top/2022/07/13/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/">部署方式</a></li>
</ul>
</li>
<li>Redis数据处理<ul>
<li><a href="https://zhangyuying.top/2022/07/06/Redis/Redis%E6%95%B0%E6%8D%AE%E7%9A%84%E8%BF%87%E6%9C%9F%E7%AD%96%E7%95%A5/">Redis数据的过期策略</a></li>
<li><a href="https://zhangyuying.top/2022/07/08/Redis/Redis%E6%95%B0%E6%8D%AE%E7%9A%84%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5/">Redis数据的淘汰策略</a></li>
</ul>
</li>
<li>应用<ul>
<li>分布式锁</li>
<li>缓存场景分析(数据一致性、缓存穿透、缓存击穿、缓存雪崩)</li>
<li>分布式队列</li>
<li>延迟队列</li>
<li>布隆过滤器</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的持久化</title>
    <url>/2022/07/12/Redis/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/</url>
    <content><![CDATA[<p>Redis 是一款基于内存的非关系型数据库，它会将数据全部存储在内存中。但是如果 Redis 服务器出现某些意外情况，比如宕机或者断电等，那么内存中的数据就会全部丢失。因此必须有一种机制能够保证 Redis 储存的数据不会因故障而丢失，这就是 Redis 的数据持久化机制。</p>
<span id="more"></span>

<p>Redis 提供了两种持久化机制：</p>
<ul>
<li>RDB ：快照（<code>snapshot</code>）模式</li>
<li>AOF日志：追加日志模式</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RDB文件和AOF文件所在目录</span></span><br><span class="line"><span class="string">dir</span> <span class="string">./</span></span><br></pre></td></tr></table></figure>

<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><p>RDB（<code>Redis DateBase</code>）即快照模式，是Redis默认的数据持久化方式，RDB持久化会将内存中当前进程的数据生成快照保存在硬盘的 <code>.rdb</code> 二进制压缩文件中。当Redis重新启动时，可以读取快照文件恢复数据</p>
<blockquote>
<p>所谓“快照”就是将内存数据以二进制文件的形式保存起来。</p>
</blockquote>
<h4 id="RDB配置"><a href="#RDB配置" class="headerlink" title="RDB配置"></a>RDB配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># RDB文件名</span></span><br><span class="line"><span class="string">dbfilename</span> <span class="string">dump.rdb：</span></span><br><span class="line"><span class="comment"># 当bgsave出现错误时，Redis是否停止执行写命令；</span></span><br><span class="line"><span class="comment"># 设置为yes，则当硬盘出现问题时，可以及时发现，避免数据的大量丢失；</span></span><br><span class="line"><span class="comment"># 设置为no，则Redis无视bgsave的错误继续执行写命令，当对Redis服务器的系统(尤其是硬盘)使用了监控时，该选项考虑设置为no</span></span><br><span class="line"><span class="string">stop-writes-on-bgsave-error</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 是否开启RDB文件压缩,Redis默认采用LZF算法对RDB文件进行压缩。虽然压缩耗时，但是可以大大减小RDB文件的体积，因此压缩默认开启；</span></span><br><span class="line"><span class="comment"># (需要注意的是，RDB文件的压缩并不是针对整个文件进行的，而是对数据库中的字符串进行的，且只有在字符串达到一定长度(20字节)时才会进行。)</span></span><br><span class="line"><span class="string">rdbcompression</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 是否开启RDB文件的校验(sht)，在写入文件和读取文件时都起作用；</span></span><br><span class="line"><span class="comment"># 关闭checksum在写入文件和启动文件时大约能带来10%的性能提升，但是数据损坏时无法发现</span></span><br><span class="line"><span class="string">rdbchecksum</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<h4 id="触发机制"><a href="#触发机制" class="headerlink" title="触发机制"></a>触发机制</h4><ul>
<li><p>手动触发</p>
<ul>
<li><p><code>save</code>：会阻塞Redis服务进程，<code>dump.rdb</code>文件创建过程中，服务器不能处理任何命令请求。线上应谨慎使用</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">SAVE</span></span><br><span class="line"><span class="string">OK</span></span><br></pre></td></tr></table></figure>

<p>执行<code>save</code>命令的时候，如果存在老的快照文件，新的将会替换老的。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/RDB-save.png" alt="RED-save"></p>
<blockquote>
<p>由于<code>save</code>无需创建子进程，所以速度上略快于<code>bgsave</code>命令</p>
</blockquote>
</li>
<li><p><code>bgsave</code>：只有在<code>fork</code>时是阻塞的，即在该命令执行的过程中，并不影响Redis服务器处理客户端的其他请求</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">BGSAVE</span></span><br><span class="line"><span class="string">Background</span> <span class="string">saving</span> <span class="string">started</span></span><br><span class="line"><span class="comment"># lastsave命令可以查看最近一次成功生成快照的时间。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span>  <span class="string">LASTSAVE</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1657522430</span></span><br></pre></td></tr></table></figure>

<p>Redis调用<code>fork</code>创建一个子进程(<code>copy-on-write</code>)，然后子进程负责将快照写入硬盘，而父进程则继续处理命令请求，子进程执行完毕后会通知父进程对原有文件进行原子替换</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/RDB-bgsave.png" alt="img"></p>
</li>
</ul>
</li>
<li><p>自动触发</p>
<ul>
<li><p>通过配置，满足任何一个条件就会通过<code>bgsave</code>创建快照文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># save m n :在时间m秒内，如果Redis数据至少发生了n次变化，那么就自动执行BGSAVE命令。</span></span><br><span class="line"><span class="comment"># 如果不需要RDB方案，注释save或者配置成空字符串&quot;&quot;。</span></span><br><span class="line"><span class="comment">#表示在900秒内，至少更新了1条数据，Redis自动触发BGSAVE命令，将数据保存到硬盘。</span></span><br><span class="line"><span class="string">save</span> <span class="number">900</span> <span class="number">1</span> </span><br><span class="line"><span class="comment">#表示在300秒内，至少更新了10条数据，Redis自动触BGSAVE命令，将数据保存到硬盘。</span></span><br><span class="line"><span class="string">save</span> <span class="number">300</span> <span class="number">10</span> </span><br><span class="line"><span class="comment">#表示60秒内，至少更新了10000条数据，Redis自动触发BGSAVE命令，将数据保存到硬盘。</span></span><br><span class="line"><span class="string">save</span> <span class="number">60</span> <span class="number">10000</span> </span><br></pre></td></tr></table></figure>

<p><strong><code>save m n</code>的实现原理</strong></p>
<p>Redis的<code>save m n</code>，是通过<code>serverCron</code>函数、<code>dirty</code>计数器、和<code>lastsave</code>时间戳来实现的。</p>
<ul>
<li><p><code>dirty</code>计数器是Redis服务器维持的一个状态，记录了上一次执行<code>bgsave/save</code>命令后，服务器状态进行了多少次修改(包括增删改)；而当<code>save/bgsave</code>执行完成后，会将<code>dirty</code>重新置为0。</p>
<blockquote>
<p>例如，如果Redis执行了<code>set key1 v1</code>，则<code>dirty</code>值会+1；如果执行了<code>sadd key1 v1 v2 v3</code>，则<code>dirty</code>值会+3；</p>
<p>注意<code>dirty</code>记录的是服务器进行了多少次修改，而不是客户端执行了多少修改数据的命令。</p>
</blockquote>
</li>
<li><p><code>lastsave</code>时间戳也是Redis服务器维持的一个状态，记录的是上一次成功执行<code>save/bgsave</code>的时间。</p>
</li>
<li><p><code>serverCron</code>是Redis服务器的周期性操作函数，默认每隔100ms执行一次；该函数对服务器的状态进行维护，其中一项工作就是遍历<code>save m n</code>配置的保存条件，只要有一个条件满足，就进行<code>bgsave</code>。对于每一个<code>save m n</code>条件，只有下面两条同时满足时才算满足：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">（1）当前时间-lastsave &gt; m  且 （2）dirty &gt;&#x3D; n</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>其他自动触发机制</p>
<ul>
<li>在主从复制场景下，如果从节点执行全量复制操作，则主节点会执行<code>bgsave</code>命令，并将<code>.rdb</code>文件发送给从节点。</li>
<li><code>shutdown</code>触发：执行<code>shutdown</code>命令保证服务正常关闭时，自动执行RDB持久化，不会造成数据丢失</li>
</ul>
<blockquote>
<p><code>flushAll</code>操作后会清空RDB文件，数据库真正意义上清空了</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h4><ul>
<li><p>启动自动载入</p>
<p>RDB文件的载入工作是在服务器启动时自动执行的，并没有专门的命令。 服务器载入RDB文件期间处于阻塞状态，直到载入完成为止。</p>
<p>AOF的优先级更高，因此当AOF开启时，Redis会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会在Redis服务器启动时检测RDB文件，并自动载入。</p>
</li>
<li><p>载入校验</p>
<p>如果RDB文件的校验(<code>rdbchecksum</code>)开启，Redis载入RDB文件时，会对RDB文件进行校验，如果文件损坏，则日志中会打印错误，Redis启动失败。</p>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>RDB文件紧凑，体积小，网络传输快，适合全量复制。适合备份和灾难恢复</li>
<li>恢复速度比AOF快很多</li>
<li><code>bgsave</code>生成RDB文件的时候，redis主进程会<code>fork</code>复刻一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。</li>
</ul>
</li>
<li>缺点<ul>
<li>耗时、耗性能：通过bgsave命令进行持久化的的时候，需要<code>fork</code>一个子进程，如果数据量很大的话，需要的内存也会相应的变大，内存的占用会导致Redis性能降低。</li>
<li>不可控、丢失数据：RDB 持久化的最大不足之处在于，最后一次持久化的数据可能会出现丢失的情况。<ul>
<li>一是比如60秒备份一次(默认)，50秒时服务器宕机，则丢失0到这50秒的数据</li>
<li>二是比如60秒备份一次(默认)，60秒备份完成，但是主线程还未使用新的<code>rdb</code>文件覆盖旧的<code>rdb</code>文件，则丢失最后这一次持久化的数据</li>
</ul>
</li>
<li>兼容性差：RDB文件需要满足特定格式，兼容性差（如老版本的Redis不兼容新版本的RDB文件）。</li>
</ul>
</li>
</ul>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF(<code>append-only file</code>)，追加日志模式，将每一个Redis执行的写命令记录到AOF日志文件末尾，达到记录数据的目的。Redis重启时只要从头到尾重新执行一次AOF所有的命令就可以恢复数据。</p>
<blockquote>
<p>与RDB相比，AOF的实时性更好，因此已成为主流的持久化方案。</p>
</blockquote>
<h4 id="AOF配置"><a href="#AOF配置" class="headerlink" title="AOF配置"></a>AOF配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改配置文件，把no改为 yes</span></span><br><span class="line"><span class="string">appendonly</span> <span class="literal">yes</span></span><br><span class="line"><span class="comment"># 存储文件名</span></span><br><span class="line"><span class="string">appendfilename</span> <span class="string">&quot;appendonly.aof&quot;</span></span><br><span class="line"><span class="comment"># 如果AOF文件结尾损坏，Redis启动时是否仍载入AOF文件。</span></span><br><span class="line"><span class="string">aof-load-truncated</span> <span class="literal">yes</span>   </span><br><span class="line"><span class="comment"># AOF重写期间是否禁止fsync；如果开启该选项，可以减轻文件重写时CPU和硬盘的负载（尤其是硬盘），但是可能会丢失AOF重写期间的数据；需要在负载和安全性之间进行平衡</span></span><br><span class="line"><span class="literal">no</span><span class="string">-appendfsync-on-rewrite</span> <span class="literal">no</span></span><br></pre></td></tr></table></figure>

<h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/AOF%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B.png" alt="AOF执行过程"></p>
<h5 id="文件写入-命令追加"><a href="#文件写入-命令追加" class="headerlink" title="文件写入(命令追加)"></a>文件写入(命令追加)</h5><ul>
<li><p>使用内存缓存区</p>
<p>命令写入到AOF文件是一个IO操作， 为了提升写入效率，避免硬盘IO成为Redis负载的瓶颈，Redis不会将内容直接写入到磁盘中，而是将其放到一个内存缓存区（<code>aof_ buf</code>）中，然后根据文件同步策略将缓存区中的内容写入到磁盘里。</p>
</li>
<li><p>先追加在执行</p>
<p>Redis 在收到客户端修改命令后，先进行相应的校验，如果没问题，就立即将该命令存追加到缓冲区中，然后服务器再执行命令</p>
</li>
<li><p>采用文本协议格式</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">set</span> <span class="string">hello</span> <span class="string">world</span> </span><br><span class="line"><span class="comment"># 在AOF缓冲区会追加如下文本：</span></span><br><span class="line"><span class="string">*3\r\n$3\r\nset\r\n$5\r\nhello\r\n$5\r\nworld\r\n</span></span><br><span class="line"><span class="comment"># 如果看的不太清除，可以分隔以下</span></span><br><span class="line"><span class="string">*</span> <span class="number">3</span><span class="string">\r\n</span>  <span class="string">$3\r\nset</span>  <span class="string">\r\n</span> <span class="string">$5\r\nhello</span> <span class="string">\r\n</span> <span class="string">$5\r\nworld\r\n</span></span><br></pre></td></tr></table></figure>

<p>命令追加的格式是Redis命令请求的协议格式，它是一种纯文本格式</p>
<ul>
<li>文本协议具有很好的兼容性。</li>
<li>开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销。</li>
<li>可读性强、容易处理。</li>
</ul>
</li>
</ul>
<h5 id="文件同步策略"><a href="#文件同步策略" class="headerlink" title="文件同步策略"></a>文件同步策略</h5><ol>
<li><p>命令说明</p>
<p>Redis的同步策略涉及到了两个命令的使用，系统调用<code>write</code>和<code>fsync</code>说明：</p>
<ul>
<li><p><strong>write</strong>：操作会触发延迟写(<code>delayed write</code>)机制。Linux在内核提供页面缓冲区用来提高硬盘IO性能，<code>write</code>操作在写入系统缓存区后直接返回。同步硬盘操作依赖于系统调度机制。</p>
<blockquote>
<p>例如：缓冲区页空间写满或达到特定时间周期。同步文件之前，如果此时系统故障宕机，缓冲区数据将丢失。</p>
</blockquote>
</li>
<li><p><strong>fsync</strong>：针对单个文件操作（比如AOF文件），做强制硬盘同步，<code>fsync</code>将阻塞直到写入硬盘完成后返回，保证了数据持久化。</p>
</li>
</ul>
</li>
<li><p>同步策略</p>
<p>Redis提供了3种从AOF缓存区同步数据到<code>.aof</code>文件的策略。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">fsync持久化策略:</span><br><span class="line">appendfsync always：每条写命令写入缓冲区后都同步写入硬盘。</span><br><span class="line">appendfsync no：由操作系统决定何时同步。</span><br><span class="line">appendfsync everysec：每秒执行一次同步，将多个命令写入硬盘。</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>always</code>：命令写入<code>aof_buf</code>后立即调用系统<code>fsync</code>操作同步到AOF文件，<code>fsync</code>完成后线程返回。</p>
<p>这种情况下，每次有写命令都要同步到AOF文件，硬盘IO成为性能瓶颈，Redis只能支持大约几百TPS写入，严重降低了Redis的性能；即便是使用固态硬盘（SSD），每秒大约也只能处理几万个命令，而且会大大降低SSD的寿命。</p>
<p>总结就是：数据安全性高，性能低</p>
</li>
<li><p><code>no</code>：命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，不对AOF文件做<code>fsync</code>同步；同步由操作系统负责，通常同步周期为30秒。</p>
<p>这种情况下，文件同步的时间不可控，且缓冲区中堆积的数据会很多，数据安全性无法保证。</p>
<p>总结就是：性能高，数据安全性低</p>
</li>
<li><p><code>everysec</code>：命令写入<code>aof_buf</code>后调用系统<code>write</code>操作，<code>write</code>完成后线程返回；<code>fsync</code>同步文件操作由专门的线程每秒调用一次(默认1s一次，最多1s丢失)。</p>
<p><code>everysec</code>是前述两种策略的折中，是性能和数据安全性的平衡，因此是Redis的默认配置。</p>
</li>
</ul>
</li>
</ol>
<h5 id="重写机制"><a href="#重写机制" class="headerlink" title="重写机制"></a>重写机制</h5><p>文件重写是指定期重写AOF文件，减小AOF文件的体积</p>
<ul>
<li>Redis 在长期运行的过程中，<code>.aof</code> 文件会越来越大，占用大量硬盘空间</li>
<li><code>.aof</code>文件过大，也会导致Redis启动时数据恢复需要的时间过长。</li>
</ul>
<blockquote>
<p>值得注意的是</p>
<ol>
<li>AOF重写是<strong>把Redis进程内的数据</strong>转化为写命令，同步到新的AOF文件；不会对旧的AOF文件进行任何读取、写入操作</li>
<li>对于AOF持久化来说，文件重写虽然是强烈推荐的，但并不是必须的；即使没有文件重写，数据也可以被持久化并在Redis启动的时候导入；因此在一些实现中，会关闭自动的文件重写，然后通过定时任务在每天的某一时刻定时执行。</li>
</ol>
</blockquote>
<p>文件重写之所以可以压缩文件，原因在于：</p>
<ul>
<li>过期的数据不再写入文件</li>
<li>无效的命令不再写入文件：如有些数据被重复设值(<code>set mykey v1</code>, <code>set mykey v2)</code>、有些数据被删除了(<code>sadd myset v1</code>,<code> del myset</code>)等</li>
<li>多条命令可以合并为一个：如<code>sadd myset v1</code>,<code> sadd myset v2</code>, <code>sadd myset v3</code>可以合并为<code>sadd myset v1 v2 v3</code>。</li>
</ul>
<p>示例：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">select</span> <span class="number">0</span>	</span><br><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">Jack</span>	</span><br><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">Helen</span>	</span><br><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">JJ</span>	</span><br><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">Lisa</span>	 </span><br><span class="line"><span class="string">INCR</span> <span class="string">number</span>	 </span><br><span class="line"><span class="string">INCR</span> <span class="string">number</span>	 </span><br><span class="line"><span class="string">DEL</span> <span class="string">number</span>	 </span><br><span class="line"><span class="string">SET</span> <span class="string">message</span> <span class="string">&#x27;value1&#x27;</span>	 </span><br><span class="line"><span class="string">SET</span> <span class="string">message</span> <span class="string">&#x27;value2&#x27;</span>	 </span><br><span class="line"><span class="string">RPUSH</span> <span class="string">num</span> <span class="number">2</span> <span class="number">4</span> <span class="number">6</span>	 </span><br><span class="line"><span class="string">RPUSH</span> <span class="string">num</span> <span class="number">8</span>	 </span><br><span class="line"><span class="string">LPOP</span> <span class="string">num</span></span><br><span class="line"><span class="comment"># 可以重写为：</span></span><br><span class="line"><span class="string">select</span> <span class="number">0</span></span><br><span class="line"><span class="string">sadd</span> <span class="string">myset</span> <span class="string">Jack</span> <span class="string">Helen</span> <span class="string">JJ</span> <span class="string">Lisa</span></span><br><span class="line"><span class="string">set</span> <span class="string">message</span> <span class="string">&#x27;value2&#x27;</span></span><br><span class="line"><span class="string">rpush</span> <span class="string">num</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p><strong>重写触发机制</strong></p>
<ul>
<li><p>手动触发</p>
<p>调用<code>bgrewriteaof</code>命令，<code>bgrewriteaof</code>的执行和<code>bgsave</code>类似，都是<code>fork</code>子进程进行具体的工作，且都只有在<code>fork</code>时阻塞</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/AOF-bgrewiteaof.png" alt="bgrewriteaof"></p>
<p>重写期间Redis执行的写命令，需要追加到新的AOF文件中，为此Redis引入了<code>aof_rewrite_buf</code>重写缓存区。</p>
<p>将 AOF 重写缓冲区的内容追加到新 AOF 文件的工作是由主进程完成的，所以这一过程会导致主进程无法处理请求，如果内容过多，可能会使得阻塞时间过长，显然是无法接受的，Redis 中已经针对这种情况进行了优化：</p>
<ol>
<li>在进行 AOF 后台重写时，Redis 会创建一组用于父子进程间通信的管道，同时会新增一个文件事件，该文件事件会将写入 AOF 重写缓冲区的内容通过该管道发送到子进程。</li>
<li>在重写结束后，子进程会通过该管道尽量从父进程读取更多的数据，每次等待可读取事件1ms，如果一直能读取到数据，则这个过程最多执行1000次，也就是1秒。如果连续20次没有读取到数据，则结束这个过程。</li>
</ol>
<p>Redis 尽量让 AOF 重写缓冲区的内容更少，以减少主进程阻塞的时间。</p>
</li>
<li><p>自动触发</p>
<p>两个配置参数同时满足时，自动触发<code>bgrewriteaof</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 第一次触发：aof文件必须要达到64M才触发，后面的每次重写就不会在根据这个变量了</span></span><br><span class="line"><span class="string">auto-aof-rewrite-min-size</span> <span class="string">64mb</span></span><br><span class="line"><span class="comment"># 下一次触发的条件是 aof文件的大小(aof_current_size)跟上次压缩过的(aof_base_size)比，比如这次100M，下次要200M才会重写</span></span><br><span class="line"><span class="string">auto-aof-rewrite-percentage</span> <span class="number">100</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="加载机制-1"><a href="#加载机制-1" class="headerlink" title="加载机制"></a>加载机制</h4><ul>
<li><p>启动自动载入</p>
<ul>
<li>当AOF开启时，Redis启动时会优先载入AOF文件来恢复数据；只有当AOF关闭时，才会载入RDB文件恢复数据。</li>
<li>当AOF开启，但AOF文件不存在时，即使RDB文件存在也不会加载。</li>
</ul>
</li>
<li><p>载入校验</p>
<p>Redis载入AOF文件时，会对AOF文件进行校验</p>
<ul>
<li><p>如果文件损坏，则日志中会打印错误，Redis启动失败。</p>
</li>
<li><p>如果是AOF文件结尾不完整（机器突然宕机等容易导致文件尾部不完整），且<code>aof-load-truncated</code>参数开启，则日志中会输出警告，Redis忽略掉AOF文件的尾部，启动成功。</p>
<blockquote>
<p>aof-load-truncated参数默认是开启的。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>支持秒级持久化、实时性好、兼容性好</li>
<li>能最大限度的保证数据安全，就算用默认的配置everysec，也最多只会造成1s的数据丢失。</li>
</ul>
</li>
<li>缺点<ul>
<li>文件大、恢复速度慢</li>
<li>向硬盘写数据的频率大大提高（<code>everysec</code>策略下为秒级），IO压力更大，甚至可能造成AOF追加阻塞问题。</li>
<li>AOF文件的重写与RDB的<code>bgsave</code>类似，会有<code>fork</code>时的阻塞和子进程的IO压力问题。</li>
</ul>
</li>
</ul>
<h3 id="混合持久化"><a href="#混合持久化" class="headerlink" title="混合持久化"></a>混合持久化</h3><p>混合持久化并不是一种全新的持久化方式，而是对已有方式的优化。混合持久化<strong>只发生于 AOF 重写过程</strong>。使用了混合持久化，重写后的新AOF文件前半段是RDB格式的全量数据，后半段是AOF格式的增量数据。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">整体格式为：[RDB file][AOF tail]</span><br></pre></td></tr></table></figure>

<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 是否开始RDB和AOF混合模式进行AOF重写，</span></span><br><span class="line"><span class="comment"># 在redis4刚引入时，默认是关闭混合持久化的，但是在redis5中默认已经打开了。</span></span><br><span class="line"><span class="string">aof-use-rdb-preamble</span> <span class="literal">yes</span></span><br></pre></td></tr></table></figure>

<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>开启混合持久化时，<code>bgrewriteaof</code>命令<code>fork </code>出的子进程先将当前全量数据以 RDB 方式写入新的 AOF 文件，然后再将 AOF 重写缓冲区（<code>aof_rewrite_buf</code>）的增量命令以 AOF 方式写入到文件，写入完成后通知主进程将新的含有 RDB 格式和 AOF 格式的 AOF 文件替换旧的 AOF 文件。后续Redis的写操作在aof中仍然是以命令的方式追加。</p>
<h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点：结合 RDB 和 AOF 的优点, 更快的重写和恢复。</li>
<li>缺点：AOF 文件里面的 RDB 部分不再是 AOF 格式，可读性差。</li>
</ul>
<p>参考资料</p>
<p><a href="http://c.biancheng.net/redis/rdb.html">Redis RDB持久化详解（原理+配置策略）</a></p>
<p><a href="https://www.cnblogs.com/sgh1023/p/10404663.html">Redis持久化方式的选择</a></p>
<p><a href="https://juejin.cn/post/7108411642404143135">Redis 高可用之持久化</a></p>
<p><a href="https://www.cnblogs.com/kismetv/p/9137897.html">深入学习Redis（2）：持久化</a></p>
<p><a href="http://c.biancheng.net/redis/aof.html">Redis AOF持久化详解（含配置策略）</a></p>
<p><a href="https://www.cnblogs.com/yangmingxianshen/p/8373205.html">Redis持久化——AOF（二）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/340082703">Redis：RDB、AOF、混合持久化</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis高可用之部署方式</title>
    <url>/2022/07/13/Redis/Redis%E9%AB%98%E5%8F%AF%E7%94%A8%E4%B9%8B%E9%83%A8%E7%BD%B2%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<p>在Redis中高可用主要包含两个方面：</p>
<ol>
<li>数据尽量不丢失。通过<a href="https://zhangyuying.top/2022/07/12/Redis/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/#more">数据持久化</a>实现</li>
<li>保证服务尽可能可用。通过部署方式实现，本文主要是这部分</li>
</ol>
<p>Redis 支持多种部署模式：单机模式和实现高可用的三种部署模式：主从模式、哨兵模式、<code>Cluster</code>模式</p>
<span id="more"></span>

<h3 id="单机模式"><a href="#单机模式" class="headerlink" title="单机模式"></a>单机模式</h3><p>单机模式就是只部署一台Redis服务</p>
<p>优点：部署方便，可用于本地开发，或对数据要求不高的，开发环境等</p>
<p>缺点：</p>
<ul>
<li>不能保证数据的可靠性</li>
<li>性能瓶颈</li>
</ul>
<h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>主从复制，是指将一台Redis服务器的数据，冗余一份复制到其他的Redis服务器。前者称为主节点（<code>Master</code>），后者称为从节点（<code>Slave</code>）</p>
<ul>
<li>默认情况下，每台Redis服务器都是主节点；</li>
<li>一个主节点可以有多个从节点（或没有从节点），但一个从节点只能有一个主节点。</li>
<li>数据的复制是单向的，只能由主节点到从节点。</li>
<li><code>Master</code>，负责读写操作，<code>Slave</code>，只负责读操作。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E4%B8%BB%E4%BB%8E%E6%A8%A1%E5%BC%8F.png" alt="主从模式"></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 只需要在从节点配置主节点的ip和端口号。</span></span><br><span class="line"><span class="string">slaveof</span> <span class="string">&lt;masterip&gt;</span> <span class="string">&lt;masterport&gt;</span></span><br><span class="line"><span class="comment"># 例如</span></span><br><span class="line"><span class="comment"># slaveof 192.168.1.1 6379</span></span><br></pre></td></tr></table></figure>

<h4 id="数据复制"><a href="#数据复制" class="headerlink" title="数据复制"></a>数据复制</h4><p>主从模式采用了读写分离，所有数据的写操作只会在<code>Master</code> 库上进行，Master 库有了最新的数据后，会同步给<code> Slave</code> 库，这样，主从库的数据就是一致的。同步包括全量复制，增量复制、部分复制(<code>&gt;redis2.8</code>)。</p>
<ul>
<li><p>全量复制</p>
<p>一般当<code> Slave</code> 第一次启动连接 <code>Master</code>，认为是第一次连接，就采用全量复制</p>
<ol>
<li><p><code>Slave</code>像<code>Master</code>发送<code>psync</code>命令，请求同步</p>
</li>
<li><p><code>Master</code>执行<code>bgsave</code>生成<code>RDB</code>文件，缓存<code>RDB</code>生成时间后的写命令在缓存中</p>
</li>
<li><p><code>Master</code>向<code>Slave</code>发送<code>RDB</code>文件，<code>Slave</code>将<code>RDB</code>文件储存在硬盘后，将其加载到内存中</p>
</li>
<li><p><code>Master</code>将内存中缓存的写命令同步给<code>Slave</code>，<code>Slave</code>执行这些命令</p>
<blockquote>
<p>如果<code>Mater</code>同时收到多个<code>slave</code>发来的同步请求，则<code>Master</code>会在后台启动一个进程以保存数据文件，然后将其发送给所有的<code>slave</code>端机器，确保所有的<code>slave</code>端机器都正常。</p>
</blockquote>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E4%B8%BB%E4%BB%8E-%E5%85%A8%E9%87%8F%E5%A4%8D%E5%88%B6.png" alt="全量复制"></p>
</li>
<li><p>增量复制</p>
<p>Redis 增量复制是指 <code>Slave</code> 初始化后开始正常工作时，<code>Master</code> 服务器发生的写操作同步到 <code>Slave</code> 服务器的过程。</p>
<p>增量复制的过程主要是<code>Master</code>每执行一个写命令就会先写入缓存然后向<code>Slave</code>发送相同的写命令，<code>Slave</code>接收并执行收到的写命令。</p>
</li>
<li><p>部分复制</p>
<p>一般当<code> Slave</code> 连接丢失再次连接 <code>Master</code>时，如果满足部分复制条件则进行部分复制，否则进行全量复制</p>
<p>最终是否可以进行部分复制是取决于</p>
</li>
</ul>
<ol>
<li><p>从节点的运行<code>ID</code>是否和主节点一致</p>
</li>
<li><p>复制偏移量在复制积压缓存区范围中</p>
<p>进行部分复制的流程如下</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E4%B8%BB%E4%BB%8E-%E9%83%A8%E5%88%86%E5%A4%8D%E5%88%B6.png" alt="部分复制"></p>
</li>
</ol>
<blockquote>
<p>以上的复制方式中有几个概念需要理解</p>
<ul>
<li><p>复制偏移量(<code>offset</code>)</p>
<p>主从节点都维护着一个复制偏移量（<code>offset</code>），主节点表示接收客户端的字节数，从节点表示接收主节点的字节数，比如从节点接收主节点传来的<code> N</code> 个字节数据时，从节点的 <code>offset</code> 会增加 <code>N</code>。</p>
<p>偏移量是用来衡量主从节点数据是否一致的唯一标准，如果主从节点的 <code>offset</code> 相等，表明数据一致，否则表明数据不一致。在不一致的情况下，可以根据两个节点的 <code>offset</code> 找出从节点的缺少的那部分数据。比如，主节点的 <code>offset</code> 是 500，从节点的 <code>offset</code> 是 400，那么主节点在进行数据传输时只需要将 <code>401 ~ 500</code> 传递给从节点即可。</p>
<p>从节点通过心跳每秒都会将自身的偏移量告知主节点，所以主节点会保存从节点的偏移量。同时，主节点处理完命令后，会将命令的字节长度累加到自身的偏移量中</p>
</li>
<li><p>运行 <code>ID</code>（<code>runid</code>）</p>
<p>每个 Redis 节点在启动时都会生成一个运行 <code>ID</code>，即 <code>runid</code>，该 <code>ID</code> 用于唯一标识 Redis 节点，它是一个由 40 位随机的十六进制的字符组成的字符串，通过 <code>info server</code> 命令可以查看节点的 <code>runid</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1:6379&gt; info server</span><br><span class="line">...</span><br><span class="line">run_id:XXX</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>主从节点在初次建立连接进行全量复制时（从节点发送 <code>psync ? -1</code>），主节点会将自己的 <code>runid</code> 告知给从节点，从节点将其保存起来。当主从节点断开重连时，从节点会将这个 <code>runid</code> 发送给主节点，主节点会根据从节点发送的 <code>runid</code> 来判断选择何种复制：</p>
<ul>
<li>如果从节点发送的 <code>runid</code> 与当前主节点的<code> runid</code> 一致时，主节点则尝试进行部分复制，当然能不能进行部分复制还要看偏移量是否在复制积压缓冲区</li>
<li>如果从节点发送的 <code>runid </code>与当前主节点的 <code>runid </code>不一致时，则进行全量复制</li>
</ul>
</li>
<li><p>复制积压缓冲区</p>
<p>复制积压缓冲区是一个由主节点维护的缓存队列，它具有如下几个特点：</p>
<ul>
<li>由主节点维护</li>
<li>固定大小，默认为 <code>1MB</code>，配置参数为：<code>repl-backlog-size</code></li>
<li>是一个先进先出的队列</li>
</ul>
<p>在命令传播时，主节点除了将写命令传递给从节点，也会将写命令写入到复制积压缓冲区中，当做一个备份，用于在部分复制流程中。由于它是先进先出的队列，且大小固定，所以他只能保存主节点最近执行的写命令，当主从节点的<code>offset</code> 相差较大时，超出了复制积压缓冲区的范围，则无法进行部分复制，只能进行全量复制了，</p>
<p>为了能够减少网络中断引起的全量复制，需要认真评估复制积压缓冲区的大小，适当调整，比如网络中断时间是 <code>60s</code>,主节点每秒接收的写命令为 <code>100KB</code>，则复制积压缓冲区的平均大小应该为 <code>6MB</code>，所以我们可以将其大小设置为 <code>6MB</code>，甚至是 <code>10MB</code>，来保证绝大多数中断情况下都可以使用部分复制。</p>
</li>
</ul>
</blockquote>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>数据冗余：主从复制实现了数据的热备份，是持久化之外的一种数据冗余方式。</li>
<li>故障恢复：当主节点出现问题时，可以由从节点提供服务，实现故障恢复；实际上是一种服务的冗余。</li>
<li>负载均衡：在主从复制的基础上，配合读写分离，可以由主节点提供写服务，由从节点提供读服务（即写Redis数据时应用连接主节点，读Redis数据时应用连接从节点），分担服务器负载；尤其是在写少读多的场景下，通过多个从节点分担读负载，可以大大提高Redis服务器的并发量。</li>
</ul>
</li>
</ul>
<p><strong>高可用基石</strong>：除了上述作用以外，主从复制还是哨兵和集群能够实施的基础，因此说主从复制是Redis高可用的基础。</p>
<ul>
<li>缺点<ul>
<li>一旦主节点宕机，从节点晋升成主节点时，需要修改应用方的主节点地址，还需要所有从节点配置新的主节点然后去复制新的主节点，整个过程需要<strong>人工干预</strong>。</li>
<li>只有主节点可以写数据，写能力受到单机的限制。</li>
<li>每个服务器都保存全部数据，存储能力受到单机的限制。</li>
</ul>
</li>
</ul>
<h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>主从切换技术的方法是：当服务器宕机后，需要手动操作将一台从机切换为主机，这需要人工干预，不仅费时费力而且还会造成一段时间内服务不可用。为了解决主从复制的缺点，就有了哨兵机制。</p>
<p>哨兵模式：由一个或多个 <code>Sentinel</code> 实例组成的<code>Sentinel</code>系统，可以监视所有的 <code>Master</code> 节点和 <code>Slave</code> 节点。哨兵模式引入了主节点的自动故障转移，当哨兵监测到 <code>Master</code> 节点宕机，会自动将 <code>Slave</code> 节点切换成 <code>Master</code> 节点，然后通过发布订阅模式通知其他的 <code>Slave</code> 节点，修改配置文件，让它们切换<code>Master</code>节点；</p>
<ul>
<li><p><code>Sentinel</code> 是一种特殊的 Redis 实例，它不存储数据，只对集群进行监控</p>
<p><code>Sentinel</code>通过发送命令，等待 <code>Master</code> 服务器和 <code>Slave</code> 服务器返回监控其运行状态</p>
</li>
<li><p>一个哨兵进程对 <code>Redis </code>节点进行监控，就可能会出现问题(单点问题)，因此，最好使用多个哨兵来进行监控</p>
</li>
<li><p>各个哨兵之间也会互相进行监控</p>
</li>
</ul>
<p>哨兵模式由两个部分组成，哨兵节点和数据节点</p>
<ul>
<li>哨兵节点：哨兵系统由一个或多个哨兵节点组成，哨兵节点是特殊的Redis节点，不存储数据。</li>
<li>数据节点：主节点和从节点都是数据节点。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E5%93%A8%E5%85%B5%E6%A8%A1%E5%BC%8F.png" alt="img"></p>
<h4 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h4><p>哨兵机器配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 关闭保护模式</span></span><br><span class="line"><span class="string">protected-mode</span> <span class="literal">no</span>   </span><br><span class="line"><span class="comment"># 指定sentine1为后台启动</span></span><br><span class="line"><span class="string">daemonize</span> <span class="literal">yes</span>      </span><br><span class="line"><span class="comment"># 修改指定该哨兵节点监控192.168.0.1：6379这个主节点，该主节点的名称是mymaster，最后的2的含义与主节点的故障判定有关：至少需要2个哨兵节点同意，才能判定主节点故障并进行故障转移</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">monitor</span> <span class="string">mymaster</span> <span class="number">192.168</span><span class="number">.0</span><span class="number">.1</span> <span class="number">6379 </span><span class="number">2</span></span><br><span class="line"><span class="comment"># 定服务器down掉的时间周期，默认30000毫秒（30秒）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">down-after-milliseconds</span> <span class="string">mymaster</span> <span class="number">3000</span></span><br><span class="line"><span class="comment"># 一个sentine1对同一个master两次failover之间的间隔时间（180秒）</span></span><br><span class="line"><span class="string">sentinel</span> <span class="string">failover-timeout</span> <span class="string">mymaster</span> <span class="number">180000</span></span><br></pre></td></tr></table></figure>

<h4 id="发现和监控"><a href="#发现和监控" class="headerlink" title="发现和监控"></a>发现和监控</h4><p>哨兵主要有三个定时的发现和监控任务</p>
<ol>
<li><p>主从运行情况检测</p>
<p>每个哨兵节点<strong>每隔10 秒</strong>会向 <code>Master</code> 节点和 <code>Slave </code>节点发送<code>info</code> 命令获取最拓扑结构图，哨兵配置时只要配置对 <code>Master</code> 节点的监控即可，通过向 <code>Master</code> 节点发送 <code>info</code>，获取 <code>Slave</code> 节点的信息，并当有新的 <code>Slave</code> 节点加入时可以马上感知到</p>
</li>
<li><p>检测信息同步</p>
<p>每个哨兵节点<strong>每隔 2 秒</strong>会向 Redis 数据节点的指定频道上发送该哨兵节点对于 <code>Master</code> 节点的判断以及当前哨兵节点的信息，同时每个哨兵节点也会订阅该频道，来了解其它哨兵节点的信息及对 <code>Master</code> 节点的判断，其实就是通过消息 <code>publish</code> 和 <code>subscribe</code> 来完成的；</p>
</li>
<li><p>主从节点存活检测</p>
<p>每个哨兵<strong>每隔 1 秒</strong>会向 <code>Master</code> 节点、<code>Slave</code> 节点及其余哨兵节点发送一次 <code>ping</code> 命令做一次心跳检测，这个也是哨兵用来判断节点是否正常的重要依据</p>
</li>
</ol>
<h4 id="自动故障转移"><a href="#自动故障转移" class="headerlink" title="自动故障转移"></a>自动故障转移</h4><ul>
<li><p><code>Master</code>切换</p>
<ol>
<li><p><code>Master</code>的下线：<code>Master</code>的下线分为主观下线和客观下线</p>
<ul>
<li><p>主观下线</p>
<p>一个哨兵节点在主节点存活监测时，如果心跳检测返回时间超过<code>down-after-milliseconds</code>时，则当前哨兵节点则认为该节点下线，这就是主观下线</p>
<p>此时不能代表这个<code>Master</code>真的下线(可能网络波动，或者该哨兵与服务连接异常)</p>
</li>
<li><p>客观下线</p>
<p>当主观下线的节点是<code> Master</code> 节点时，此时该哨兵 节点会通过指令寻求其它哨兵节点对 <code>Master</code> 节点的判断，当超过 <code>quorum</code>（可配置）个数的哨兵节点都认为<code>Master</code>下线，则认为该 <code>Master</code> 节点确实有问题，这样就是客观下线</p>
<blockquote>
<p>当一个主服务器被 <code>Sentinel</code>标记为客观下线时，<code>Sentinel</code> 向 下线主服务器 的所有 从服务器 发送 <code>INFO</code> 命令的频率，会从<code>10</code>秒一次改为 每秒一次。</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>当没有足够数量的 <code>Sentinel</code> 同意 主服务器 下线时， 主服务器 的 <strong>客观下线状态</strong> 就会被移除。当 <strong>主服务器</strong> 重新向 <code>Sentinel</code>的<code>PING</code>命令返回有效回复时，主服务器 的 <strong>主观下线状态</strong> 就会被移除。</p>
</blockquote>
</li>
<li><p>自动故障转移</p>
<ul>
<li><p>哨兵领导者选择</p>
<p>如果哨兵客观下线<code> Master</code>,那么接下来就是进行故障转移和通知，这个工作只要一个哨兵完成即可，所以哨兵节点会根据<code>Raft</code>算法（选举算法）选举一个哨兵领导者。</p>
<p>（1）每个做主观下线的 <code>Sentinel </code>节点向其他 <code>Sentinel</code> 节点发送命令，要求将它设置为领导者</p>
<p>（2）收到命令的 <code>Sentinel</code> 节点如果没有同意通过其他 <code>Sentinel</code> 节点发送的命令，那么将同意该请求，否则拒绝</p>
<p>（3）如果该 <code>Sentinel</code> 节点发现自己的票数已经超过 <code>Sentinel</code> 集合半数且超过 <code>quorum</code>，则将成为领导者</p>
<p>（4）如果此过程有多个 <code>Sentinel</code> 节点成为了领导者，那么将等待一段时间重新选举</p>
</li>
<li><p>确定新的 <code>Master</code> 节点</p>
<p><code>Sentinel</code> 状态数据结构中保存了主服务的所有从服务信息，领头 <code>Sentinel</code> 从从服务列表中挑选出新的主服务</p>
<p>（1）过滤掉主观下线的节点</p>
<p>（2）选择配置文件中节点优先级配置(<code>replica-priority</code>，默认值为100) 最高的节点，如果有则返回没有则继续选择</p>
<p>（3）选择出复制偏移量最大的节点，因为复制偏移量越大则数据复制的越完整，如果有则返回没有则继续选择</p>
<p>（4）选择 <code>run_id</code> 最小的节点</p>
</li>
<li><p>更新主从状态</p>
<p>（1）通过<code>slaveof</code>命令 让其他节点成为新的<code>Master</code>的<code>Slave</code>节点</p>
<p>（2）将已下线的<code>Master</code>节点也设置成新的<code>Master</code>节点的<code>Slave</code>节点，当其恢复正常时，从新的<code>Master</code>节点复制数据，变成新的 <code>Master</code> 节点的 <code>Slave</code> 节点</p>
<p>（3）通知客户端主节点已经更换。</p>
</li>
</ul>
</li>
</ol>
</li>
<li><p><code>Sentinel</code>或<code>Slave</code>切换</p>
<p>客观下线是主节点才有的概念，从节点和哨兵节点发生故障，被哨兵主观下线后，直接下线，不会再有后续的客观下线和故障转移操作</p>
</li>
</ul>
<h4 id="脑裂"><a href="#脑裂" class="headerlink" title="脑裂"></a>脑裂</h4><p>脑裂：某个 <code>Master</code> 所在机器突然脱离了正常的网络，跟其他 <code>Slave</code> 机器不能连接，但是实际上 <code>Master</code> 还运行着。此时哨兵可能就会认为 <code>Master</code> 宕机了，然后开启选举，将其他 <code>Slave</code> 切换成了 <code>Master</code>。这个时候，集群里就会有<strong>两个 <code>Master</code></strong> ，也就是所谓的脑裂。</p>
<p><strong>数据丢失</strong></p>
<p>脑裂时虽然某个 <code>Slave</code> 被切换成了 <code>Master</code>，但是可能 <code>client</code> 还没来得及切换到新的 <code>Master</code>，还继续向旧 <code>Master</code> 写数据。但是旧 <code>Master</code> 再次恢复的时候，会被作为一个 <code>Slave</code> 挂到新的 <code>Master</code> 上去，自己的数据会清空，重新从新的 <code>Master</code> 复制数据。而新的 <code>Master</code> 并没有后来 <code>client</code> 写入的数据，因此，这部分数据也就丢失了。</p>
<p><strong>解决方案</strong></p>
<p>Redis 提供了两个配置项来限制 <code>Master</code> 库的请求处理</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># master 至少有 1 个Slave连接。</span></span><br><span class="line"><span class="string">min-replicas-to-write</span> <span class="number">1</span></span><br><span class="line"><span class="comment"># 数据复制和同步的延迟不能超过 10 秒。</span></span><br><span class="line"><span class="string">min-replicas-max-lag</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>按照配置要求至少有 1 个 <code>Slave</code> 数据复制和同步的延迟不能超过 <code>10</code> 秒，如果超过 1 个 <code>Slave</code>，数据复制和同步的延迟都超过了 10 秒钟，那么这个时候，<code>Master</code> 就不会再接收任何请求了。</p>
<p>通过这个配置，就算 <code>Master</code> 库是假故障，那它在假故障期间也无法响应哨兵心跳，也不能和 <code>Slave</code> 库进行同步，自然也就无法和 <code>Slave</code> 库进行 <code>ACK</code> 确认。原 <code>Master</code> 库就会被限制接收客户端请求，客户端也就不能在原 <code>Master</code> 库中写入新数据了。</p>
<p>不过这个配置做不到让数据一点也不丢失，而是让数据尽可能的少丢失。</p>
<h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><ul>
<li>优点<ul>
<li>哨兵模式是基于主从模式的，所有主从的优点，哨兵模式都具有。</li>
<li>实现主从自动切换，系统更健壮，可用性更高。</li>
</ul>
</li>
<li>缺点<ul>
<li>具有主从模式的缺点，每台机器上的数据是一样的，写能力和存储能力收到单机的限制</li>
<li>还要多维护一套哨兵模式，实现起来也变的更加复杂增加维护成本。</li>
<li>Redis 较难支持在线扩容，在集群容量达到上限时在线扩容会变得很复杂。</li>
</ul>
</li>
</ul>
<h3 id="Cluster模式"><a href="#Cluster模式" class="headerlink" title="Cluster模式"></a>Cluster模式</h3><p>Redis Cluster 是Redis3.0开始引入的高可用分布式存储方案，通过分片(<code>sharding</code>)来进行数据管理</p>
<ul>
<li><p>Redis Cluster 模式采用了无中心节点的方式来实现，其中包含多个<code>Maser</code>节点，以及每个<code>Master</code>节点对应的若干<code>Slave</code>节点</p>
</li>
<li><p>每个 <code>Master</code> 节点都会与其它 <code>Master</code> 节点保持连接。节点间通过 <code>gossip</code> 协议交换彼此的信息</p>
<p>每个节点会保存一份数据分布表，节点会将自己的 <code>slot</code> 信息发送给其他节点，节点间不停的传递数据分布表</p>
</li>
<li><p>数据分片的方式为将 Redis 集群分为 16384 个哈希槽。这些哈希槽分别存储于每个 <code>Master </code>节点中</p>
</li>
<li><p>客户端连接集群时，直接与 Redis 集群的每个 <code>Master</code> 节点连接，根据 <code>hash</code> 算法取模将 <code>key</code> 存储在不同的哈希槽上，假设集群存在3个<code>Master</code></p>
<ul>
<li><code>Master1</code> 负责 0~5460 号哈希槽</li>
<li><code>Master2</code> 负责 5461~10922 号哈希槽</li>
<li><code>Master3</code> 负责 10923~16383 号哈希槽</li>
</ul>
</li>
<li><p>一般一组集群至少要 6 个节点才能保证完整的高可用（3主3从）</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/RedisCluster.png" alt="Redis Cluster"></p>
<h4 id="数据分片"><a href="#数据分片" class="headerlink" title="数据分片"></a>数据分片</h4><p><code>Cluster</code>模式将数据分散到多个节点</p>
<ul>
<li>一方面突破了Redis单机内存大小的限制，存储容量大大增加</li>
<li>另一方面每个主节点都可以对外提供读服务和写服务，大大提高了集群的响应能力</li>
</ul>
<blockquote>
<p>Redis单机内存大小受限问题，在介绍持久化和主从复制时都有提及；例如，如果单机内存太大，<code>bgsave</code>和<code>bgrewriteaof</code>的<code>fork</code>操作可能导致主进程阻塞，主从环境下主机切换时可能导致从节点长时间无法提供服务，全量复制阶段主节点的复制缓冲区可能溢出。</p>
</blockquote>
<p>Redis Cluster 方案采用哈希槽（<code>Hash Slot</code>，接下来我会直接称之为 <code>Slot</code>），来处理数据和实例之间的映射关系。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/RedisCluster%E6%95%B0%E6%8D%AE%E5%88%86%E7%89%87.png" alt="数据分片"></p>
<ol>
<li><p>数据存储位置</p>
<p>每个数据的<code>Key</code>都属于这 16384 个槽的其中一个，<code>Key</code> 与哈希槽映射过程可以分为两大步骤：<br>1、根据键值对的 <code>Key</code>，使用 <code>CRC16</code> 算法，计算出一个 <code>16 bit</code> 的值；<br>2、将 <code>16 bit</code> 的值对 16384 执行取模，得到 0 ～ 16383 的数表示 <code>Key</code> 对应的哈希槽。</p>
</li>
<li><p>哈希槽与Redis集群的映射</p>
<p>Redis 会自动将 16384 个 哈希槽平均分布在集群实例上，比如 <code>N</code> 个节点，每个节点上的哈希槽数 = <code>16384 / N </code>个。假设集群存在3个<code>Master</code></p>
<ul>
<li><code>Master1</code> 负责 0~5460 号哈希槽</li>
<li><code>Master2</code> 负责 5461~10922 号哈希槽</li>
<li><code>Master3</code> 负责 10923~16383 号哈希槽</li>
</ul>
</li>
</ol>
<blockquote>
<p>Redis的哈希槽为什么是16384个：</p>
<ol>
<li>消息大小考虑：尽管<code>crc16</code>能得到65535个值，但Redis选择16384个<code>slot</code>，是因为16384的消息只占用了<code>2k</code>，而65535则需要<code>8k</code>。</li>
<li>集群规模设计考虑：集群设计最多支持1000个分片，16384是相对比较好的选择，需要保证在最大集群规模下，<code>slot</code>均匀分布场景下，每个分片平均分到的<code>slot</code>不至于太小。</li>
</ol>
<p>其中需要注意2个问题：</p>
<ol>
<li>为什么要传全量的<code>slot</code>状态？<br>因为分布式场景，基于状态的设计更合理，状态的传播具有幂等性</li>
<li>为什么不考虑压缩？<br>集群规模较小的场景下，每个分片负责大量的<code>slot</code>，很难压缩。</li>
</ol>
</blockquote>
<h4 id="节点通信"><a href="#节点通信" class="headerlink" title="节点通信"></a>节点通信</h4><p>RedisCluster中每个节点都需要知道其他节点的所有状态信息，包括：</p>
<ul>
<li>当前集群状态</li>
<li>集群中各节点负责的哈希槽</li>
<li>集群中各节点的<code>master-slave</code>状态</li>
<li>集群中各节点的存活状态等</li>
</ul>
<p><strong><code>gossip</code>协议</strong>：Redis集群中，节点之间通过建立TCP连接，使用<code>gossip</code>协议来传播集群的信息。<code>gossip</code>协议 也叫 <code>Epidemic Protocol</code>（流行病协议），别名很多比如：“流言算法”、“疫情传播算法”等。它的特点是，在节点数量有限的网络中，每个节点都会“随机”（不是真正随机，而是根据规则选择通信节点）与部分节点通信，经过一番杂乱无章的通信后，每个节点的状态在一定时间内会达成一致，</p>
<p><code>gossip</code>协议有4种常用的消息类型：<code>PING</code>、<code>PONG</code>、<code>MEET</code>、<code>FAIL</code>。</p>
<ul>
<li><code>MEET</code>：当需要向集群中加入新节点时，需要集群中的某个节点发送<code>MEET</code>消息到新节点，通知新节点加入集群。新节点收到<code>MEET</code>消息后，会回复<code>PONG</code>命令给发送者。</li>
<li><code>PING</code>：集群内每个节点每秒会向其他节点发送<code>PING</code>消息，用来检测其他节点是否正常工作，并交换彼此的状态信息。<code>PING</code>消息中会包括自身节点的状态数据和其他部分节点的状态数据。</li>
<li><code>PONG</code>：当接收到<code>PING</code>消息和<code>MEET</code>消息时，会向发送方回复<code>PONG</code>消息，<code>PONG</code>消息中包括自身节点的状态数据。节点也可以通过广播的方式发送自身的<code>PONG</code>消息来通知整个集群对自身状态的更新。</li>
<li><code>FAIL</code>：当一个节点判定另一个节点下线时，会向集群内广播一个<code>FAIL</code>消息，其他节点接收到<code>FAIL</code>消息之后，把对应节点更新为下线状态。</li>
</ul>
<p><strong>Redis 告知客户端重定向访问新实例</strong></p>
<p><strong><code>MOVED</code> 错误</strong></p>
<p>负载均衡，数据已经迁移到其他实例上：当客户端将一个键值对操作请求发送给某个实例，而这个键所在的槽并非由自己负责的时候，该实例会返回一个 <code>MOVED</code> 错误指引转向正在负责该槽的节点。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MOVED [哈希槽] [节点IP:端口]  &#x2F;&#x2F; 例如 MOVED 3999 127.0.0.1:6379</span><br></pre></td></tr></table></figure>

<p>同时，客户端还会更新本地缓存，将该 <code>slot</code> 与 Redis 实例对应关系更新正确。</p>
<p><strong>ASK 错误</strong></p>
<p>如果某个 <code>slot</code> 的数据比较多，部分迁移到新实例，还有一部分没有迁移：如果请求的 <code>key</code> 在当前节点找到就直接执行命令，否则时候就需要 <code>ASK</code> 错误响应了，槽部分迁移未完成的情况下，如果需要访问的 <code>key</code> 所在 <code>Slot</code> 正在从从 实例 1 迁移到 实例 2，实例 1 会返回客户端一条 <code>ASK</code> 报错信息：客户端请求的 <code>key</code> 所在的哈希槽正在迁移到实例 2 上，你先给实例 2 发送一个 <code>ASKING</code> 命令，接着发送操作命令。</p>
<h4 id="故障处理"><a href="#故障处理" class="headerlink" title="故障处理"></a>故障处理</h4><p>集群支持主节点的自动故障转移（与哨兵类似）；当任一节点发生故障时，集群仍然可以对外提供服务</p>
<p><strong>故障检测</strong></p>
<p>主动下线：当约定时间内某节点无法与集群中的另一个节点顺利完成 <code>ping</code> 消息通信时，则将这个节点标记为主观下线，同时将这个信息向整个集群广播。</p>
<p>客观下线：如果一个节点收到某个节点失联的数量达到了集群的大多数时，那么将该节点标记为客观下线状态，并向集群广播下线节点的 <code>fail</code> 消息。然后立即对该故障节点进行主从切换。</p>
<p><strong>故障转移</strong></p>
<p>跟哨兵类似，两者都是基于 <code>Raft</code> 算法来实现的</p>
<ol>
<li>从下线的 <code>Master</code> 节点下的 <code>Slave</code> 节点列表选择一个节点成为新主节点。</li>
<li>新主节点会撤销所有对已下线主节点的 <code>slot</code> 指派，并将这些 <code>slots</code> 指派给自己。</li>
<li>新的主节点向集群广播一条 <code>PONG</code> 消息，这条 <code>PONG</code> 消息可以让集群中的其他节点立即知道这个节点已经由从节点变成了主节点，并且这个主节点已经接管了原本由已下线节点负责处理的槽。</li>
<li>新的主节点开始接收处理槽有关的命令请求，故障转移完成。</li>
</ol>
<p>等到原来的 <code>Master</code> 节点恢复后，会自动成为新 <code>Master</code> 节点的 <code>Slave</code> 节点。<strong>如果 <code>Master</code> 节点没有 <code>Slave</code> 节点，那么当它发生故障时，集群就将处于不可用状态。</strong></p>
<h4 id="扩容处理"><a href="#扩容处理" class="headerlink" title="扩容处理"></a>扩容处理</h4><p>RedisCluster支持动态扩充，数据迁移由Redis内部自动完成。</p>
<blockquote>
<p>Redis集群的重新分片由Redis内部的管理软件<code>redis-trib</code>负责执行。Redis提供了进行重新分片的所有命令，<code>redis-trib</code>通过向节点发送命令来进行重新分片。</p>
</blockquote>
<p>RedisCluster也支持做缩容，当集群中要删除节点时，只需要将节点中的所有哈希槽移动到其它节点，然后再移除空白（不包含任何哈希槽）的节点。</p>
<hr>
<p>参考资料</p>
<p><a href="https://xie.infoq.cn/article/485668cd01ce4417324207540">8K 字详细解析实现 Redis 的高可用 (主从、哨兵、集群)</a></p>
<p><a href="https://www.cnblogs.com/zhonglongbo/p/13128955.html">一文读懂Redis的四种模式，单机、主从、哨兵、集群</a></p>
<p><a href="https://www.cnblogs.com/gengbo/p/16364853.html">Redis 高可用</a></p>
<p><a href="https://www.jianshu.com/p/fb23d50a385c">Redis集群模式高可用原理</a></p>
<p><a href="https://www.jianshu.com/p/95ac24da4441">redis主从之全量复制及增量复制</a></p>
<p><a href="https://blog.csdn.net/chenssy/article/details/118280134">主从复制（二）：全量复制和部分复制</a></p>
<p><a href="https://github.com/redis/redis/issues/2576">Redis的哈希槽为什么选择为16384个</a></p>
<p><a href="https://new.qq.com/omn/20220415/20220415A05N9800.html">Redis高可用架构—Redis集群（Redis Cluster）详细介绍</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>记redis锁的一次实践</title>
    <url>/2018/08/12/Redis/%E8%AE%B0redis%E9%94%81%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<ul>
<li><p>本次记录的实践主要是<code>可重入锁</code>和<code>联锁</code></p>
<h3 id="1-可重入锁（Reentrant-Lock）"><a href="#1-可重入锁（Reentrant-Lock）" class="headerlink" title="1. 可重入锁（Reentrant Lock）"></a>1. 可重入锁（Reentrant Lock）</h3><p>Redisson的分布式可重入锁RLock Java对象实现了java.util.concurrent.locks.Lock接口，同时还支持自动过期解锁。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReentrantLock</span><span class="params">(RedissonClient redisson)</span></span>&#123;</span><br><span class="line">	RLock lock = redisson.getLock(<span class="string">&quot;anyLock&quot;</span>);</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">		<span class="comment">// 1. 最常见的使用方法</span></span><br><span class="line">		<span class="comment">//lock.lock();</span></span><br><span class="line">		<span class="comment">// 2. 支持过期解锁功能,10秒钟以后自动解锁, 无需调用unlock方法手动解锁</span></span><br><span class="line">		<span class="comment">//lock.lock(10, TimeUnit.SECONDS);</span></span><br><span class="line">		<span class="comment">// 3. 尝试加锁，最多等待3秒，上锁以后10秒自动解锁</span></span><br><span class="line">		<span class="keyword">boolean</span> res = lock.tryLock(<span class="number">3</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">		<span class="keyword">if</span>(res)&#123; <span class="comment">//成功</span></span><br><span class="line">		<span class="comment">// do your business</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Redisson同时还为分布式锁提供了异步执行的相关方法(本次实践不涉及，在此不做介绍)</p>
<h3 id="2-联锁（MultiLock）"><a href="#2-联锁（MultiLock）" class="headerlink" title="2. 联锁（MultiLock）"></a>2. 联锁（MultiLock）</h3><p>Redisson的RedissonMultiLock对象可以将多个RLock对象关联为一个联锁，每个RLock对象实例可以来自于不同的Redisson实例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMultiLock</span><span class="params">(RedissonClient redisson1,RedissonClient redisson2, RedissonClient redisson3)</span></span>&#123;</span><br><span class="line">	RLock lock1 = redisson1.getLock(<span class="string">&quot;lock1&quot;</span>);</span><br><span class="line">	RLock lock2 = redisson2.getLock(<span class="string">&quot;lock2&quot;</span>);</span><br><span class="line">	RLock lock3 = redisson3.getLock(<span class="string">&quot;lock3&quot;</span>);</span><br><span class="line">	RedissonMultiLock lock = <span class="keyword">new</span> RedissonMultiLock(lock1, lock2, lock3);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 同时加锁：lock1 lock2 lock3, 所有的锁都上锁成功才算成功。</span></span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="comment">// 尝试加锁，最多等待100秒，上锁以后10秒自动解锁</span></span><br><span class="line">		<span class="keyword">boolean</span> res = lock.tryLock(<span class="number">100</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		lock.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>redis中的锁可参考：</p>
<p><a href="https://blog.csdn.net/l1028386804/article/details/73523810">https://blog.csdn.net/l1028386804/article/details/73523810</a></p>
<p><a href="https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8">https://github.com/redisson/redisson/wiki/8.-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%92%8C%E5%90%8C%E6%AD%A5%E5%99%A8</a></p>
</li>
</ul>
<h3 id="实践场景描述"><a href="#实践场景描述" class="headerlink" title="实践场景描述"></a>实践场景描述</h3><p>  现在需要redis可重入锁和联锁的场景是：</p>
<p>  在工作的业务中，有人员，有角色，可以对人员赋予角色的，针对当前业务现在有两种存储方式：redis（主要使用内存缓存）和DB</p>
<p>  redis中关于这部分有两块缓存存储：</p>
<ul>
<li><p>一块是角色缓存存储：roleStorage</p>
</li>
<li><p>另一块是人员角色存储：UserRoleStorage</p>
<p>操作：</p>
</li>
</ul>
<p>  1.在删除角色的时候，需要调用UserRoleStorage中的deleteUserRoleByRoleIds()方法将对应的缓存在redis中删除。</p>
<p>  删除的时操作顺序：是先删除redis数据，再删除db中的数据</p>
<p>  2.在查询方法中要查询人员是否有角色。</p>
<p>  查询的时操作顺序：先查询redis，redis中没有的时候再去db中查询。</p>
<h3 id="问题及解决"><a href="#问题及解决" class="headerlink" title="问题及解决"></a>问题及解决</h3><p>  问题1.因为删除和查询对redis和db的 <strong>操作顺序</strong>问题，在并发的情况下会导致redis和db数据不一致！</p>
<p>  例如：A线程在删除角色时，B线程在查询，A线程执行到删除了redis缓存之后，B线程来查询，因为此时redis缓存为空，B会去数据库查询，但是数据库还未被删除，此时从数据库中加载到缓存中的数据是错误的数据（里面存在需要删除的数据），之后再来查询因为redis中存在数据就不会在去数据库重新查询，致使redis和db数据不一致</p>
<h5 id="可重入锁解决问题1："><a href="#可重入锁解决问题1：" class="headerlink" title="可重入锁解决问题1："></a>可重入锁解决问题1：</h5><p>  使用<code>可重入锁</code>解决由于<em>删除和查找对redis和db操作顺序</em>产生的不一致问题：</p>
<ul>
<li><p>get方法,只有在需要查询db的时候在会进行加锁，【锁之中还是会在查询一边缓存，防止并发线程过来之后多次查询数据库】</p>
</li>
<li><p>查询方法（get）和删除方法（del）采用同一把锁。这样保证del和get是互斥性操作。不会导致数据不一致的问题</p>
<p>代码如下：</p>
<p>UserRoleStorage:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//查询方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getUserIdsByRoleId</span><span class="params">(String systemId, String roleId)</span> </span>&#123;</span><br><span class="line">        String redisKey = getUserRoleRedisKey(systemId, roleId, SYSTEMID_USER_ROLE_ROLEID);</span><br><span class="line">        <span class="keyword">if</span> (redisTemplate.hasKey(redisKey)) &#123;</span><br><span class="line">            <span class="keyword">return</span> redisTemplate.opsForSet().members(redisKey);</span><br><span class="line">        &#125;</span><br><span class="line">        RLock lock = redissonClient.getLock(<span class="string">&quot;人员角色的锁&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock(RedisLockConsts.LEASE_TIME, TimeUnit.SECONDS);</span><br><span class="line">            <span class="keyword">if</span> (redisTemplate.hasKey(redisKey)) &#123;</span><br><span class="line">                <span class="keyword">return</span> redisTemplate.opsForSet().members(redisKey);</span><br><span class="line">            &#125;</span><br><span class="line">            Set&lt;String&gt; userIdsFromDB = roleMapper.getUserIdByRoleId(roleId, systemId);</span><br><span class="line">            <span class="keyword">if</span> (CollectionUtils.isNotEmpty(userIdsFromDB)) &#123;</span><br><span class="line">                redisTemplate.opsForSet().add(redisKey, userIdsFromDB.toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> userIdsFromDB;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//删除方法：</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteUserRoles</span><span class="params">(List&lt;String&gt; roleIds)</span> </span>&#123;</span><br><span class="line">     RLock lock = redissonClient.getLock(<span class="string">&quot;人员角色的锁&quot;</span>);</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">         lock.lock(RedisLockConsts.LEASE_TIME, TimeUnit.SECONDS);</span><br><span class="line">         deleteInRedis(roleIds);</span><br><span class="line">         deleteUserRole2DB(roleIds);</span><br><span class="line">     &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">         lock.unlock();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>  问题2.上述1问题解决之后，在删除角色时调用人员角色的删除，并发情况下也会导致redis和db的数据不一致！</p>
<p>  例如：A线程在删除角色定义，即将要删除人员角色的时候，B线程来查询，此时A还未获取<code>&quot;人员角色的锁&quot;</code>,所以此时B还是可能获取锁并执行查库操作，导致redis和db数据不一致问题</p>
<h5 id="联锁解决问题2："><a href="#联锁解决问题2：" class="headerlink" title="联锁解决问题2："></a>联锁解决问题2：</h5><p>  使用<code>联锁</code>来解决删除角色中调用人员角色中的删除方法导致数据可不一致的问题</p>
<ul>
<li><p>在删除角色（delRole）的方法中，获取两把可重入锁:一个是保证角色的数据性一直问题（和人员角色一样：删除和查询的操作redis和db的顺序导致数据不一致），另一个是 **”人员角色的锁”**，然后将两个可重入锁，做成联锁。【此时在delRole方法中，A线程开始删除，查询线程是不能查询的，因为 **”人员角色的锁”**，已经被占用，从而保证数据一致性】</p>
<p>代码如下：</p>
<p>UserRoleStorage:参照第一个问题中的代码</p>
<p>RoleStorage:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteRole</span><span class="params">(List&lt;String&gt; roleIds)</span> </span>&#123;</span><br><span class="line">    RLock userRoleLock = redissonClient.getLock(<span class="string">&quot;人员角色的锁&quot;</span>);</span><br><span class="line">    RLock roleLock = redissonClient.getLock(<span class="string">&quot;角色的锁&quot;</span>);</span><br><span class="line">    RedissonMultiLock lock = <span class="keyword">new</span> RedissonMultiLock(userRoleLock,roleLock);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lock(RedisLockConsts.LEASE_TIME, TimeUnit.SECONDS);</span><br><span class="line">        deleteInRedis(roleIds);</span><br><span class="line">        deleteRoleInDB(roleIds);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h3 id="疑问排查"><a href="#疑问排查" class="headerlink" title="疑问排查"></a>疑问排查</h3><p>  在使用<code>联锁</code> 解决问题的时候：思考一个问题：</p>
<p>  我在删除角色中获取了<strong>“人员角色的锁”</strong>，然后这个方法又调用了人员角色中的删除方法，人员角色的删除会再次获取 <strong>“人员角色的锁”</strong>，</p>
<p>  那么会不会锁死？？？</p>
<p>  答案是不会。</p>
<p>  因为**”人员角色的锁”**是可重入锁！</p>
<p>  1.<code>可重入锁</code>在 <strong>同一个线程中</strong>是可以多次获取，并上锁的。</p>
<p>  代码示例如下：</p>
<p>  <img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E8%AE%B0redis%E9%94%81%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E4%BB%A3%E7%A0%81.png" alt="可重入锁代码"></p>
<p>  redis中锁存储：</p>
<p>  <img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E8%AE%B0redis%E9%94%81%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/redis%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81%E5%BA%93%E5%AD%98%E5%82%A8.png" alt="reids可重入锁库存储"></p>
<p>  分析：</p>
<ul>
<li>可以看到在代码实现中，同一个线程中，可重入锁是可以重复获取并上锁的，并且只要有一个被锁住，其余的状态显示的都是已经被锁住！</li>
<li>redis锁的存储中可以看到：锁在数据库中是key-value存储的<ul>
<li>key(对应图中：8bcef576-0e4a-4944-96ec-cd975c30e903:38)，是根据线程生成的，一个线程只会生成一个key</li>
<li>value:(对应图中：4)，是在当前线程中锁住了锁的次数，在代码中（lock、lock1、lock2、lock3）,上锁了4次，所以value为4</li>
</ul>
</li>
</ul>
<p>  2.<code>联锁</code>示例</p>
<p>  <img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E8%AE%B0redis%E9%94%81%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/%E8%81%94%E9%94%81%E4%BB%A3%E7%A0%81.png" alt="联锁代码"></p>
<p>  redis中锁存储：</p>
<p>  <img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E8%AE%B0redis%E9%94%81%E7%9A%84%E4%B8%80%E6%AC%A1%E5%AE%9E%E8%B7%B5/redis%E8%81%94%E9%94%81%E5%AD%98%E5%82%A8.png" alt="redisl联锁存储"></p>
<p>  分析：</p>
<ul>
<li>可以看到在代码实现中，联锁同时锁住了3个可重入锁（lock、lock1、lock2），lock3还是可以获取锁并上锁和解锁，因为联锁没有解锁，所以4把可重入锁的状态还是锁住的！</li>
<li>redis中，联锁锁住了3把可重入锁，lock3 上锁之后又解锁了，所以最后锁的次数是3（联锁锁住的可重入锁个数）</li>
<li>所以联锁中使用的可重入锁在同一个线程中是可重复获取的！不会锁死！</li>
<li>如果上述代码中的allLock.unlock()，注释去掉，那么redis中是没有锁的，因为所有锁已经全部都被解锁！</li>
</ul>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot</title>
    <url>/2021/04/12/Spring/Spring%20Boot/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can &quot;just run&quot;.</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>(Spring Boot使得创建独立的、生产级的、基于Spring的应用程序变得很容易，您可以“直接运行”。)</p>
<h4 id="一、Spring-Boot的理解"><a href="#一、Spring-Boot的理解" class="headerlink" title="一、Spring Boot的理解"></a>一、Spring Boot的理解</h4><h5 id="1-Spring-Boot-是什么"><a href="#1-Spring-Boot-是什么" class="headerlink" title="1.Spring Boot 是什么"></a>1.Spring Boot 是什么</h5><p>提供了快速构建Spring Framework 应用的框架，即 Spring Framwork是Spring Boot的内核</p>
<h5 id="2-Spring-Boot-是如何简化Spring配置的"><a href="#2-Spring-Boot-是如何简化Spring配置的" class="headerlink" title="2.Spring Boot 是如何简化Spring配置的"></a>2.Spring Boot 是如何简化Spring配置的</h5><p>主要思想就是 <strong>约定优于配置</strong>：通过约定的方式来减少配置，从而提升开发效率，具体体现：</p>
<p>（1）默认的Maven结构，以及默认的打包方式</p>
<p>（2）默认的配置文件<code>application.properties</code></p>
<p>（3）Starter的相关jar包依赖</p>
<p>（4）Web默认包含Spring-mvc以及内置tomcat容器</p>
<p>（5）部署到tomcat</p>
<h4 id="二、简化配置的原理"><a href="#二、简化配置的原理" class="headerlink" title="二、简化配置的原理"></a>二、简化配置的原理</h4><h5 id="1-Spring-注解驱动"><a href="#1-Spring-注解驱动" class="headerlink" title="1.Spring 注解驱动"></a>1.Spring 注解驱动</h5><p>由xml配置逐渐转变为注解驱动方式，通过注解实现Spring对Bean的管理</p>
<h5 id="2-Spring-Boot的自动装配"><a href="#2-Spring-Boot的自动装配" class="headerlink" title="2.Spring Boot的自动装配"></a>2.Spring Boot的自动装配</h5><p>SpringBoot starter机制（自动装配）：SpringBoot中的starter是一种非常重要的机制，starter遵循“约定大于配置”的理念，将繁杂的配置和需要的Bean统一集成进starter，应用者只需要在maven中引入starter依赖，Spring Boot 就能：1)自动扫描到要加载的信息并启动相应的默认配置 ，2)自动通过classpath路径下的类发现需要的Bean，并注册进IOC容器</p>
<p>SpringBoot提供了针对日常企业应用研发各种场景的spring-boot-starter依赖模块</p>
<p>（1）自定义starter原理：</p>
<p>也是约定优于配置：Spring Boot启动时自动加载<code>META-INF/spring.factories</code>文件的配置Bean</p>
<ul>
<li><p>官方starter：(比如<code>spring-boot-starter-data-redis</code>)由于官方需要加载的配置类都是已知的，所以官方的starter一般不需要在<code>META-INF/spring.factories</code>文件中配置的</p>
</li>
<li><p>自定义的starter：在starter中的<code>META-INF/spring.factories</code>配置当前starter中使用<code>@Configuration</code>的配置类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-------starter自动装配---------</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration&#x3D;com.demo.starter.config.DemoConfig</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>Spring Boot中加载<code>META-INF/spring.factories</code>中配置源码：</p>
<p>Spring Boot中是通过<code> EnableAutoConfiguration</code> 注解加载的<code> META-INF/spring.facteries</code>文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication ——&gt;  @EnableAutoConfiguration  ——&gt;  @Import(AutoConfigurationImportSelector.class) </span><br></pre></td></tr></table></figure>

<p><code>AutoConfigurationImportSelector.class</code>加载代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;</span><br><span class="line">    Assert.state(deferredImportSelector <span class="keyword">instanceof</span> AutoConfigurationImportSelector,</span><br><span class="line">            () -&gt; String.format(<span class="string">&quot;Only %s implementations are supported, got %s&quot;</span>,</span><br><span class="line">                    AutoConfigurationImportSelector.class.getSimpleName(),</span><br><span class="line">                    deferredImportSelector.getClass().getName()));</span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</span><br><span class="line">            .getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);</span><br><span class="line">    <span class="keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;</span><br><span class="line">        <span class="keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">//2</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),</span><br><span class="line">            getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">&quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;</span></span><br><span class="line">            + <span class="string">&quot;are using a custom packaging, make sure that file is correct.&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; getSpringFactoriesLoaderFactoryClass() &#123;</span><br><span class="line">    <span class="keyword">return</span> EnableAutoConfiguration.class;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//factoryClass 传入EnableAutoConfiguration.class;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">    String factoryClassName = factoryClass.getName();</span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(<span class="meta">@Nullable</span> ClassLoader classLoader) &#123;</span><br><span class="line">    MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 5</span></span><br><span class="line">        Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ?</span><br><span class="line">                classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">                ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">        result = <span class="keyword">new</span> LinkedMultiValueMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">            URL url = urls.nextElement();</span><br><span class="line">            UrlResource resource = <span class="keyword">new</span> UrlResource(url);</span><br><span class="line">            Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">                String factoryClassName = ((String) entry.getKey()).trim();</span><br><span class="line">                <span class="keyword">for</span> (String factoryName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">                    result.add(factoryClassName, factoryName.trim());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.put(classLoader, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">                FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）Spring Boot中的SPI机制实现</p>
<ul>
<li>SPI思想<ul>
<li>SPI的全名为Service Provider Interface.这个是针对厂商或者插件的。</li>
<li>SPI的思想：系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<strong>java spi就是提供这样的一个机制：为某个接口寻找服务实现的机制</strong></li>
</ul>
</li>
<li>在Spring Boot的自动装配过程中，最终加载META-INF/spring.factories文件的配置，即是SPI思想的一种实现方式</li>
</ul>
<p>参考资料</p>
<p><a href="https://www.jianshu.com/p/0d196ad23915">Spring Boot中的SPI机制-简书</a></p>
<p><a href="https://www.cnblogs.com/hello-shf/p/10864977.html#_label4">SpringBoot应用篇（一）：自定义starter</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>IoC容器</title>
    <url>/2020/03/12/Spring/IoC%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<p>IoC（<code>Inverse of Control</code>，控制反转）是Spring容器的内核，AOP、声明式事务等功能在此基础上开发结果。</p>
<span id="more"></span>

<p>本文目录说明：</p>
<ul>
<li>IoC概述</li>
<li>资源访问利器</li>
<li>BeanFactory和ApplicationContext</li>
<li>Bean的生命周期</li>
</ul>
<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>包括两个方面的内容：一是控制，二是反转。对于软件来说，即某一接口具体实现类的选择控制权从调用类中移除，转交给第三方决定，既由Spring容器借由Bean配置来进行控制</p>
<p>DI（<code>Dependency Injection</code>，依赖注入）是用来替代IoC的概念。即让调用类对某一接口实现类的依赖关系由第三方(容器或协助类)注入，以移除调用类对某一接口实现类的依赖</p>
<p><strong>IoC的类型</strong></p>
<p>从注入方法上看，IoC主要可以划分为3种类型：构造函数注入、属性注入和接口注入，Spring支持构造函数注入和属性注入</p>
<ol>
<li><p>构造函数注入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Work</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    user.say(user.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> ZhangSan();</span><br><span class="line">    Work work = <span class="keyword">new</span> Work(user);</span><br><span class="line">    work.goWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>属性注入</p>
<p>可以有选择的通过Setter方法完成调用类所需依赖的注入，不是必须注入，<strong>使用时才注入</strong>，更加灵活方便</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    user.say(user.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Work work = <span class="keyword">new</span> Work();</span><br><span class="line">    User user = <span class="keyword">new</span> ZhangSan();</span><br><span class="line">   </span><br><span class="line">    work.setUser(user);</span><br><span class="line">    work.goWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接口注入</p>
<p>将调用类所有依赖注入的方法抽取到一个接口中，调用类通过实现该接口提供相应的注入方法，所以为了采取接口注入，比如先声明一个接口</p>
<p>注：由于多声明一个额外的接口，增加了类的数目，而且效果和属性注入无区别，因为不提倡此种方式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWorkArrangable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">injectUser</span><span class="params">(User user)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Work</span> <span class="title">implement</span> <span class="title">IWorkArrangable</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> User user;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectUser</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goWork</span><span class="params">()</span></span>&#123;</span><br><span class="line">    user.say(user.getName)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Leader</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">direct</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Work work = <span class="keyword">new</span> Work();</span><br><span class="line">    User user = <span class="keyword">new</span> ZhangSan();</span><br><span class="line">    work.injectUser(user);</span><br><span class="line">    work.goWork();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>通过容器完成依赖关系的注入</strong></p>
<p>上述说明的IoC的三种注入方式，依赖关系都是第三方协助类完成的。即<code>Work</code>不关注工作的具体是那个人，交给<code>Leader</code>注入(协助类)。此时虽然<code>Work</code>不必关系依赖关系，但是此部分的代码依然存在（在<code>Leader</code>中）</p>
<p>使用第三方容器注入：帮助完成类的初始化与装配工作，让开发者从这些底层实现类的实例化、依赖关系装配等工作中解脱出来，专注业务逻辑开发</p>
<p>Spring就是这样一个容器，通过配置文件或注解描述类和类之间的依赖关系，自动完成类的初始化和依赖注入工作，如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.ioc.ZhangSan&quot;</span>/&gt;</span> <span class="comment">&lt;!--实现类实例化--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;work&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuuying.ioc.Work&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">p:user-ref</span>=<span class="string">&quot;user&quot;</span>/&gt;</span> <span class="comment">&lt;!--建立依赖关系--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring根据配置文件和注解进而实例化和装配Bean的底层原理：为Java语言本身的类反射功能</p>
<h4 id="资源访问利器"><a href="#资源访问利器" class="headerlink" title="资源访问利器"></a>资源访问利器</h4><p>Spring设计了一个<code>Resource</code>接口，为应用提供了比JDK更强的底层资源访问能力，该接口拥有不用资源类型的实现类</p>
<p><code>Resource</code>接口的主要方法：</p>
<ul>
<li><code>boolean exist()</code>：资源是否存在</li>
<li><code>boolean isOpen()</code>：资源是否打开</li>
<li><code>URL getURL() throws IOException</code>：如果底层资源可以表示成URL，则该方法返回对应的URL对象</li>
<li><code>File getFile() throws IOException</code>：如果底层资源对应一个文件，则该方法返回对应的File对象</li>
<li><code>InputStream getInputStream() throws IOException</code>：返回资源对应的输入流</li>
</ul>
<p><code>Resource</code>在Spring中起着不可或缺的作用，Spring框架使用<code>Resource</code>装载各种资源，包括配置文件、国际化属性文件资源等</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//使用类路径方式加载文件</span></span><br><span class="line">resource res = <span class="keyword">new</span> ClassPathResource(<span class="string">&quot;conf/file.test&quot;</span>);</span><br><span class="line">res.getInputStream();</span><br></pre></td></tr></table></figure>

<p><strong>资源加载</strong></p>
<p>为了访问不同类型的资源，必须使用相应的<code>Resource</code>实现类，是比较麻烦的，所以 Spring提供了一个强大的加载资源的机制（仅通过资源地址的特殊标识就可以访问响应的资源），不但能通过<code>“classpath:”</code>、<code>“file:”</code>等资源地址前缀识别不同的资源类型，还支持<code>Ant</code>风格带通配符的资源地址</p>
<ol>
<li><p>Spring支持的资源类型的地址前缀</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E8%B5%84%E6%BA%90%E7%B1%BB%E5%9E%8B%E5%9C%B0%E5%9D%80%E5%89%8D%E7%BC%80.jpg" alt="资源类型的地址前缀"></p>
<blockquote>
<p><code>&quot;classpath:&quot;</code> 和 <code>“classpath*:”</code>的区别：</p>
<p>假设有多个JAR包或文件系统类路径都拥有一个相同的包名(如<code>cn.zhangyuying</code>)</p>
<ul>
<li><code>&quot;classpath:&quot;</code> 只会在第一个加载的<code>cn.zhangyuying</code>包的类路径下查找<ul>
<li><code>“classpath*:”</code> 会扫描所有这些JAR包及类路径下出现的<code>cn.zhangyuying</code>类路径，这对于分模块打包比较友好</li>
</ul>
</li>
</ul>
</blockquote>
</li>
</ol>
<ol>
<li>Ant风格的资源地址支持3中匹配符<ul>
<li>? : 匹配文件名中的一个字符，如：<code>classpath:com/t?sr.xml</code></li>
<li>* : 匹配文件名中的任意字符，如：<code>file:D:/conf/*.xml </code>即匹配D:/conf下所有以.xml为后缀的文件</li>
<li>** : 匹配多层路径，如：<code>classpath:com/**/test.xml </code>匹配<code>com</code>类路径下（当前目录及其子孙目录）的<code>test.xml</code>文件</li>
</ul>
</li>
</ol>
<p><strong>资源加载器</strong></p>
<p>Spring定义了一套资源加载接口，并提供了实现类</p>
<ol>
<li><p><code>ResourceLoader</code>接口仅有一个<code>getResource(String location)</code>方法，可以根据一个资源地址加载文件资源，不过只支持带资源类型前缀的表达式，不支持Ant风格的资源路径表达式</p>
</li>
<li><p><code>ResourcePatternResolver</code>扩展<code>ResourceLoader</code>接口，定义了一个新的接口方法<code>getResources(String locationPattern)</code>,该方法支持带资源类型前缀及Ant风格的资源路径表达式</p>
</li>
<li><p><code>PathMatchingResourcePatternResolver</code>是spring提供的标准实现类，</p>
<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResourcePatternResolver resolver -<span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">Resource resources[] = resolver.getResource(<span class="string">&quot;classpath*:cn/zhangyuying/**/*.xml&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用<code>Resource</code>操作文件时，如果资源配置文件在项目发布时会被打包到JAR中，那么不能使用<code>Resource#getFile()</code>，否则会抛出<code>FileNotFoundException</code>，但是可以使用<code>Resource#getInputStream</code></p>
<p>错误读取：<code>(new DefaultResourceLoader()).getResource(&quot;classpath:conf/sys.properties&quot;).getFile()</code></p>
<p>正确读取：<code>(new DefaultResourceLoader()).getResource(&quot;classpath:conf/sys.properties&quot;).getInputStream()</code></p>
</blockquote>
</li>
</ol>
<h4 id="BeanFactory-和-ApplicationContext"><a href="#BeanFactory-和-ApplicationContext" class="headerlink" title="BeanFactory 和 ApplicationContext"></a>BeanFactory 和 ApplicationContext</h4><p>Bean工厂(<code>com.springframework.beans.factory.BeanFactory</code>)是Spring框架最核心的接口，他提供了高级IoC的配置机制，<code>BeanFactory</code>使管理不同类型的Java对象成为可能</p>
<p>应用上下文(<code>com.springframework.context.ApplicationContext</code>)建立在<code>BeanFactory</code>基础之上，提供了更多面向应用的功能，提供了国际化支持和框架事件体系，更易于创建实际应用，偶尔也称为Spring容器</p>
<blockquote>
<p>对于用途可以简单划分</p>
<p><code>BeanFactory</code>是Spring框架的基础设施，面向Spring本身</p>
<p><code>ApplicationContext</code>面向使用Spring框架的开发者，几乎所有应用场合都可以直接使用<code>ApplicationContext</code>而非底层的<code>BeanFactory</code></p>
</blockquote>
<h5 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h5><p>是类的通用工厂，可以创建并管理各种类的对象</p>
<p><code>BeanFactory</code>接口中最主要的方法就是<code>getBean(String beanName)</code>，该方法从容器中返回特定名称的<code>Bean</code>,<code>BeanFactory</code>的功能通过其他接口得到不断扩展，例如<code>DefaultListableBeanFactory</code></p>
<blockquote>
<p>Spring配置文件中每一个<code>&lt;bean&gt;</code>节点元素在Spring容器里都通过一个<code>BeanDefinition</code>对象表示，它描述了<code>Bean</code>的配置信息，<code>BeanDefinitionRegistry</code>接口提供了向容器手工注册<code>BeanDefinition</code>对象的方法，<code>DefaultListableBeanFactory</code>实现了这个接口</p>
</blockquote>
<p>Spring为<code>BeanFactory</code>提供了多种实现，建议使用<code>XmlBeanDefinitionReader</code>、<code>DefaultListableBeanFactory</code></p>
<p>初始化<code>BeanFactory</code>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanFactoryTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBean</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    ResourcePatternResolver resolver = <span class="keyword">new</span> PathMatchingResourcePatternResolver();</span><br><span class="line">    Resource res = resolver.getResource(<span class="string">&quot;classpatch:cn.zhangyuying/beans.xml&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    DefaultListableBeanFactory factory = <span class="keyword">new</span> DefaultListableBeanFactory();</span><br><span class="line">    XmlBeanDefinitionReader reader = <span class="keyword">new</span> XmlBeanDefinitionReader(factory);</span><br><span class="line">    reader.loadBeanDefinitions(res);</span><br><span class="line">    </span><br><span class="line">    User user = factory.getBean(<span class="string">&quot;user&quot;</span>,User.class);</span><br><span class="line">    user.getName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>通过<code>BeanFactory</code>启动IoC容器时，并不会初始化配置文件中定义的<code>Bean</code>，初始化动作发生在第一次调用时</strong></p>
<blockquote>
<p>对于单实例（<code>singletion</code>）的<code>Bean</code>来说，<code>BeanFactory</code>会缓存<code>Bean</code>实例，所以第二次调用<code>getBean()</code>获取<code>Bean</code>时，将直接从IoC容器的缓存中获取<code>Bean</code>实例（<code>DefaultSingletionBeanRegistry</code>类中提供了一个用于缓存单实例<code>Bean</code>的缓存器，<code>HashMap</code>实现，单例的<code>Bean</code>以<code>BeanName</code>为键保存在这个<code>HashMap</code>中）</p>
</blockquote>
<h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h5><p><code>ApplicationContext</code>由<code>BeanFactory</code>派生而来，提供了更多面向实际应用的功能</p>
<p><code>ApplicationContext</code>的主要实现类是<code>ClassPathXmlApplicationContext</code> 和<code>FileSystemXmlApplicationContext</code>，前者默认从类路径加载配置文件，后者默认从文件系统中装载配置文件</p>
<p><code>ApplicationContext</code>初始化示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置文件放在类路径下</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;cn/zhangyuying/beans.xml&quot;</span>); <span class="comment">//可省略classpath:前缀</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">&quot;conf/beans.xml&quot;</span>,<span class="string">&quot;conf/beans2.xml&quot;</span>&#125;);</span><br><span class="line"><span class="comment">// 配置文件放在文件系统的路径下</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">&quot;cn/zhangyuying/beans.xml&quot;</span>); <span class="comment">//可省略file:前缀</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//获取Bean</span></span><br><span class="line">ctx.getBean(<span class="string">&quot;user&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong><code>ApplicationContext</code>的初始化和<code>BeanFactory</code>有一个重大的区别</strong> ：<code>BeanFactory</code>在初始化容器时，并未实例化<code>Bean</code>，直到第一次访问某个<code>Bean</code>时才实例化目标<code>Bean</code>；而<code>ApplicationContext</code>则在初始化应用上下文时就实例化所有单实例的<code>Bean</code>，因此，<code>ApplicationContext</code>的初始化时间会比<code>BeanFactory</code>稍长一些</p>
<p><strong>基于类注解配置方式</strong></p>
<p>Spring支持基于类注解的配置方式，主要功能来自Spring的一个名为<code>JavaConfig</code>的子项目，<code>JavaCongfig</code>现已升级为Spring核心架构的一部分，一个标注<code>@Configuration</code>注解的POJO即可提供Spring所需的<code>Bean</code>配置信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Beans</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean(name = &quot;user&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> User <span class="title">CreateUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setName(<span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Spring为基于注解类配置提供了专门的<code>ApplicationContext</code>实现类：<code>AnnotationConfigApplicationContext</code>，使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Application ctx = <span class="keyword">new</span> AnnotationConfigApplicationContext(Beans.class);</span><br><span class="line">    User user = ctx.getBean(<span class="string">&quot;user&quot;</span>,User,<span class="class"><span class="keyword">class</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>webApplicationContext</strong></p>
<p><code>webApplicationContext</code>扩展了<code>ApplicationContext</code>，是专门为Web准备的，允许从相对于Web根目录的路径中装载配置文件完成初始化工作</p>
<p><code>webApplicationContext</code>可以获取<code>ServletContext</code>的引用,获取方法：<code>getServletContext()</code></p>
<p><code>servletContext</code>中也可以获取<code>webApplicationContext</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Spring提供方法</span></span><br><span class="line">WebApplicationContextUtils.getWebApplicationContext(ServletContext sc);</span><br><span class="line"><span class="comment">//内部实现</span></span><br><span class="line">WebApplicationContext wac = (WebApplicationContext)ServletContext.getAttribut(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE);</span><br></pre></td></tr></table></figure>

<p><code>WebApplicationContext</code>的初始化：<code>WebApplicationContext</code>的初始化需要<code>ServletContext</code>实例，也就是说，他必须在拥有Web容器的前台下才能完成启动工作</p>
<p>Spring分别提供了用于启动<code>WebApplicationContext</code>的Servlet和Web容器监听器：</p>
<ul>
<li><code>org.springframework.web.context.ContextLoaderServlet</code></li>
<li><code>org.springframework.web.context.ContextLoaderListener</code></li>
</ul>
<p>二者的内部都实现了启动<code>WebApplicationContext</code>实例的逻辑，只要根据Web容器的具体情况选择二者之一，并在web.xml中完成配置即可</p>
<p>配置示例</p>
<ol>
<li><p><code>ContextLoaderListener</code>使用示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--指定配置文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/test-dao.xml,/WEB-INF/test-server.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--声明web容器监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ContextLoaderServlet</code>使用示例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/test-dao.xml,/WEB-INF/test-server.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springContextLoaderServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.context.ContextLoaderservlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>如果使用标注<code>@Configuration</code>的Java类提供配置信息，则<code>web.xml</code>需要按一下方式配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--通过制定context参数，让Spring使用AnnotationConfigWebApplicationContext 而非XmlWebApplicationContext启动容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextClass<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>organ.springframework.web.context.support.AnnotationConfgiWebApplicationContext<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--制定标注了@Configuration的配置类，多个可以使用逗号或空格分隔--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>cn.zhangyuying.AppConfig1,cn.zhangyuying.AppConfig2<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--ContextLoaderListener监听器将根据上面的配置使用AnnotationConfigWebApplicationContext根据contextConfigLocation指定的配置类启动Spring容器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p><strong>父子容器</strong></p>
<p>通过<code>HierarchicalBeanFactory</code>接口，Spring的IoC容器可以建立父子层级关联的容器</p>
<ul>
<li>子容器可以访问父容器里面的<code>Bean</code>,但父容器不能访问子容器的<code>Bean</code></li>
<li>容器内，<code>Bean</code>的<code>id</code>必须是唯一的，但子容器可以拥有一个和父容器<code>id</code>相同的<code>Bean</code></li>
<li>父子容器体系增加了Spring容器架构的扩展性和灵活性，因为第三方可以通过编程的方式为一个已经存在的容器添加一个或多个特殊用途的子容器，以提供一些额外功能，Spring中的实现：Spring MVC中，展现层<code>Bean</code>位于一个子容器中，而业务层和持久成<code>Bean</code>位于父容器中</li>
</ul>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p><code>Bean</code>的声明周期由多个特定的生命阶段组成，每个生命阶段都开起了一扇门，允许外界对<code>Bean</code>施加控制</p>
<p><strong><code>BeanFactory</code>中<code>Bean</code>的生命周期</strong></p>
<p>图解：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/BeanFactory%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="BeanFactory中Bean生命周期图解"></p>
<p><code>Bean</code>的完整生命周期从Spring容器着手实例化<code>Bean</code>开始，直到最终销毁<code>Bean</code>，其中经过了许多关键点，每个关键点都涉及特定的方法调用，可以将这些方法大致划分为4类</p>
<ol>
<li><code>Bean</code>自身的方法：如调用<code>Bean</code>构造函数实例化<code>Bean</code>、调用<code>Setter</code>设置<code>Bean</code>的属性值及通过<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>所指定的方法</li>
<li><code>Bean</code>级生命周期接口方法：如<code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>InitializingBean</code>和<code>DisposableBean</code>，这些接口由Bean类直接实现</li>
<li>容器级生命周期接口方法：在图中带 ☆ 的步骤是由<code>InstantiationAwareBeanPostProcessor</code>和<code>BeanPostProcessor</code>这两个接口实现的，一般称他们的实现类为“后处理器”。<ul>
<li>后处理器接口一般不由<code>Bean</code>本身实现，他们独立于<code>Bean</code>，实现类以容器附加装置的形式注册到Spring容器中，并通过接口反射为Spring容器扫描识别。</li>
<li>当Spring容器创建任何<code>Bean</code>的时候，这些后处理器都会发生作用，所以这些后处理器的影响是全局性的，当然用户可以通过合理地编写后处理器，让其仅对感兴趣的<code>Bean</code>进行加工处理</li>
</ul>
</li>
<li>工厂后处理器接口方法：包括<code>AspectJWeavingEnabler</code>、<code>CustomAutowireConfigurer</code>、<code>ConfigurationClassPostProcessor</code>等方法(均实现自<code>BeanFactoryPostProcessor</code>)，工厂后处理器也是容器级的，在应用上下文装配配置文件后立即调用</li>
</ol>
<blockquote>
<ol>
<li><p><code>Bean</code>级生命周期方法和容器级生命周期接口，前者解决<code>Bean</code>个性化处理问题，后者解决容器中某些<code>Bean</code>共性化处理的问题</p>
</li>
<li><p>Spring容器中是可以注册多个后处理器的，只要都同时实现<code>org.springframework.core.Ordered</code>接口，容器将按特定的顺序依次调用这些后处理器，即上图中带☆的步骤，都可能调用多个后处理进行一系列加工操作</p>
</li>
<li><p><code>InstantiationAwareBeanPostProcessor</code>其实是<code>BeanPostProcessor</code>接口的子接口，Spring为其提供了一个适配器类<code>InstantiationAwareBeanPostProcessorAdapter</code>，一般情况下，可以方便的扩展该适配器覆盖感兴趣的方法以定义实现类</p>
</li>
<li><p><code>Bean</code>生命周期接口：虽然让<code>Bean</code>具有更细致的生命周期阶段，但是<code>Bean</code>和Spring框架紧密的绑定在一起了，所以更推荐使用<code>Bean</code>自身的方法，</p>
<ol>
<li><code>InitializingBean</code>和<code>DisposableBean</code>方法：更推荐<code>&lt;bean&gt;</code>的<code>init-method</code>和<code>destroy-method</code>方法，此外Spring还拥有一个<code>Bean</code>后置处理器<code>InitDestroyAnnotationBeanPostProcessor</code>，它负责对标注了<code>@PostConstruct</code>、<code>@PreDestroy</code>的<code>Bean</code>进行初始化和销毁处理</li>
<li><code>BeanFactoryAware</code>和<code>BeanNameAware</code>接口，一般情况不需要关心</li>
</ol>
<p>所以除非编写一个基于Spring之上的扩展插件或子项目之类的东西，否则完全可以抛开上述4个<code>Bean</code>生命周期的接口类</p>
</li>
<li><p><code>BeanPostProcessor</code>接口和<code>Bean</code>生命周期接口不同，完全像插件一样注册到Spring容器中，Spring容器充分利用了<code>BeanPostPricessor</code>对Bean进行加工处理</p>
</li>
</ol>
</blockquote>
<p><strong>ApplicationContext中Bean的生命周期</strong></p>
<p>和<code>BeanFactory</code>中的声明周期类似，不同的是：如果<code>Bean</code>实现了<code>org.springframework.context.ApplicationContextAware</code>接口，则会增加一个调用该接口方法<code>setApplicationContext()</code>的步骤，图解如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/ApplicationContext%E4%B8%ADBean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="ApplicationContext中Bean的生命周期"></p>
<blockquote>
<ol>
<li><p>如果在配置文件中声明了工厂后处理接口<code>BeanFactoryPostProcessor</code>的实现类，则应用上下文在装载配置文件之后、初始化<code>Bean</code>实例之前将调用这些<code>BeanFactoryPostProcess</code>对配置信息进行加工处理</p>
<p>如果在配置文件中定义了多个工厂后处理器，那么最好让他们实现<code>org.springframework.core.Ordered</code>接口,以便Spring以确定顺序调用他们</p>
<p>工厂后处理器是容器级的，仅在应用上下文初始化时调用一次，其目的是完成一些配置文件的加工处理工作</p>
</li>
<li><p><code>ApplicationContext</code>在启动时，将首先为配置文件中的每个<code>&lt;bean&gt;</code>生成一个<code>BeanDefinition</code>对象，<code>beanDefinition</code>是<code>&lt;bean&gt;</code>在Spring容器中的内部表示，当配置文件中的所有<code>&lt;bean&gt;</code>都被解析成<code>BeanDefinition</code>时，<code>ApplicationContext</code>将调用工厂后处理器的方法，因此我们有机会调整Bean的配置信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//实现BeanFactoryPostProcessor后，实现方法：</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory var1)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">  BeanDefinition bd = bf.getBeanDefinition(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</blockquote>
<p><strong><code>ApplicationContext</code>和<code>BeanFactory</code>另一个最大的不同之处在于</strong>：</p>
<ul>
<li><p>前者会利用Java反射机制自动识别出配置文件定义的<code>BeanPostProcessor</code>、<code>InstantiationAwareBeanPostProcessor</code>和<code>BeanFactoryPostProcessor</code>，并自动将它们注册到应用上下文中</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span> <span class="attr">p:name</span>=<span class="string">&quot;zhangsan&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--工厂后处理器,继承自BeanFactoryProcessor，可以对上面配置的属性值进行调整--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanFactoryPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.MyBeanFactoryPostProcessor&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--注册Bean后处理器，也可以对Bean的属性进行调整--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myBeanPostProcessor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.MyBeanPostProcessor&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>后者需要在代码中通过手工调用<code>addBeanPostProcessor()</code>方法进行注册</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//向容器中注册MyBeanPostProcessor后处理器</span></span><br><span class="line">((ConfigurableBeanFactory)beanFactory).addbeanPostProcessor(<span class="keyword">new</span> MyBeanPostProcessor());</span><br><span class="line"><span class="comment">//向容器中注册MyInstantiationAwareBeanPostProcessor后处理器</span></span><br><span class="line">((ConfigurableBeanFactory)beanFactory).addbeanPostProcessor(<span class="keyword">new</span> MyInstantiationAwareBeanPostProcessor());</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>这也是为什么在应用开发中普遍使用<code>ApplicationContext</code>的原因之一</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring AOP基础</title>
    <url>/2020/03/24/Spring/Spring-AOP%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>Spring AOP是AOP技术在Spring中的具体实现，构建于IoC之上，是构成Spring框架的另一个重要基石</p>
<span id="more"></span>

<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>AOP是OOP的有益补充，AOP是有特定的应用场合的，他只适合那些具有横切逻辑的应用场合，如性能检测、访问控制等</p>
<p>AOP是什么：</p>
<p>AOP是<code>Aspect Oriented Programing</code>的简称，译为：面向切面编程</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E6%A8%AA%E5%88%87%E9%80%BB%E8%BE%91%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt="横切逻辑示意图"></p>
<p>AOP术语：</p>
<ol>
<li><p>连接点（<code>Joinpoint</code>）</p>
<p>特定点是程序执行的某个特定位置，如类开始初始化前、类初始化后、类的某个方法调用前/调用后、方法抛出异常后，一个类或一段程序代码拥有一些具有边界性质的特定点，这些代码的特定点就被称为连接点</p>
<p>Spring仅支持方法的连接点，即仅能在方法的调用前、方法调用后、方法抛出异常及方法调用前后这些程序执行点织入增强</p>
<p>连接点由两个信息确定：一是用方法表示的程序执行点，二是用相对位置表示的方位，如Test.foo()方法执行前的连接点，执行点为Test.foo(),方位为该方法执行前的位置，</p>
<p>Spring中使用切点对执行点进行定位，而方位则在增强类型中定义</p>
</li>
<li><p>切点（<code>Pointcut</code>）</p>
<p>每个程序类都拥有许多连接点，即连接点是程序类中客观存在的事物。AOP通过切点定位特定的连接点，一个切点可以匹配多个连接点</p>
<p>在Spring中，切点通过<code>org.springframework.aop.Pointcut</code>接口进行描述，他是用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点(应该叫执行点，因为切点结合方位信息才是连接点)</p>
</li>
<li><p>增强（<code>Advice</code>）</p>
<p>增强是织入目标类连接点上的一段程序代码，在Spring中，增强除了用于描述一段程序代码外，还拥有另一个和连接点相关的信息，这便是执行点的方位，结合执行点的方位信息和切点信息，就可以找到特定的连接点</p>
<p>因为增强既包含用于添加到目标连接点上的一段执行逻辑，又包含用于定位连接点的方位信息，所以Spring所提供的增强接口都是带方位名的，如<code>BeforeAdvice</code>、<code>AfterReturningAdvice</code>、<code>ThrowsAdvice</code>等</p>
<p>只有结合切点和增强，才能确定特定的连接点并实施增强逻辑</p>
</li>
<li><p>目标对象（<code>Target</code>）</p>
<p>增强逻辑织入的目标类</p>
</li>
<li><p>引介（<code>Introduction</code>）</p>
<p>引介是一种特殊的增强，他为类添加了一些属性和方法，这样，即使一个业务类原本没有实现某个接口，通过AOP的引介功能，也可以动态地为该业务类添加接口的实现逻辑，让业务类成为这个接口的实现类</p>
</li>
<li><p>织入（<code>Weaving</code>）</p>
<p>织入是将增强添加到目标类的具体连接点上的过程，AOP有3中织入方式：</p>
<p>(1). 编译期织入，这要求使用特殊的Java编译器</p>
<p>(2).类装载期织入，这要求使用特殊的类加载器</p>
<p>(3).动态代理织入，在运行期为目标类添加增强生成子类的方式</p>
<p>Spring采用动态代理织入，而AspectJ采用编译器织入和类装载期织入</p>
</li>
<li><p>代理（<code>Proxy</code>）</p>
<p>一个类被AOP织入增强后，就产生了一个结果类，他是融合了原类和增强逻辑的代理类</p>
<p>根据不同的代理方式，代理类既可能是和原类具有相同接口的类，也可能就是原类的子类，所以可以采用与调用原类相同的方式调用代理类</p>
</li>
<li><p>切面（<code>Aspect</code>）</p>
<p>切面由切点和增强（引介）组成，它既包括横切逻辑的定义，也包括连接点的定义</p>
<p>Spring AOP就是负责实施切面的框架，它将切面所定义的横切逻辑织入切面所指定的连接点中</p>
</li>
</ol>
<p>AOP的实现者：</p>
<p>AOP工具的设计目标是把横切问题(如性能监视、事物管理)模块化，使用类似OOP的方式进行切面的编程工作，位于AOP工具核心的是连接点模型，他提供了一种机制，可以定位到需要在哪里发生横切</p>
<ol>
<li>AspectJ：是语言级的AOP实现，扩展了Java语言，定义了AOP语法，能够在编译期提供横切代码的织入（所以他有专门的编译期来生成最受Java字节码编码规范的Class文件）</li>
<li>AspectWerkz：是基于Java的简单、动态、轻量级的AOP框架，支持运行期或类装载期织入横切代码，所以它拥有一个特殊的类装载器，现已和AspectJ项目合并</li>
<li>JBoss AOP</li>
<li>Spring AOP：使用纯Java实现，不需要专门的编译过程，也不需要特殊的类装载器，他在运行期通过代理方式向目标类织入增强代码，Spring并不尝试提供最完整的AOP实现，相反，他侧重与提供一种和Spring IoC容器整合的AOP实现，在Spring中可以无缝地将Spring AOP、Io、AspectJ整合在一起</li>
</ol>
<h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><p>Spring AOP使用动态代理技术在运行期织入增强的代码，Spring AOP使用了两种代理机制：</p>
<ol>
<li><p>基于<strong>JDK的动态代理</strong> </p>
<p>JDK动态代理：Java 1.3之后，Java提供了动态代理技术，允许开发者在运行期创建接口的代理实例</p>
<p>JDK的动态代理主要涉及<code>java.lang.reflect</code>包中的两个类：<code>Proxy</code>和<code>InvocationHandler</code></p>
<ul>
<li><p><code>InvocationHandler</code>是一个接口，可以通过实现该接口定义横切逻辑，并通过反射机制调用目标类的代码，动态地将横切逻辑和业务逻辑编织在一起</p>
</li>
<li><p><code>Proxy</code>利用<code>InvocationHandler</code>动态创建一个符合某一接口的实例，生成目标类的代理对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Proxy.newProxy.newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler handler);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>JDk动态代理有一个限制，即它只能为接口创建代理实例(<code>Proxy</code>的第二个参数就是接口)</p>
</li>
<li><p>基于<strong>CGLib的动态代理</strong> </p>
<p>CGLib动态代理：JDK动态代理只能为接口创建代理，而CGLib填补了空缺</p>
<p>CGLib采用底层的字节码技术，可以为一个类创建子类，在子类中采用方法拦截的技术拦截所有父类方法的调用，并顺势织入横切逻辑</p>
<p>不过由于CGLib采用动态代理创建子类的方式生成代理对象，所以不能对目标类中的<code>final</code>或<code>private</code>方法进行代理</p>
</li>
</ol>
<p>之所以需要两种代理机制，很大程度上是因为JDK本身只提供接口的代码，而不支持类的代理</p>
<p>有研究表明CGLib所创建的动态代理对象的性能比JDK所创建对象的性能高不少（大概10倍），但CGLib在创建代理对象时所花费的时间却比JDK动态代理多（大概8倍），所以对于<code>singleton</code>的代理对象或者具有实例池的代理，因为无须频繁的创建代理对象，所以比较适合采用CGLib动态代理技术，反之则适合采用JDK动态代理技术</p>
<h4 id="增强的类型"><a href="#增强的类型" class="headerlink" title="增强的类型"></a>增强的类型</h4><p>AOP联盟为增强定义了<code>org.aopalliance.aop.Advice</code>接口， Spring支持五种类型的增强(注意Spring只支持方法级的增强)：</p>
<ul>
<li><p>前置增强：<code>BeforeAdvice</code>，现可用的是<code>MethodBeforeAdvice</code>，表示在目标方法执行前实施增强</p>
</li>
<li><p>后置增强：<code>AfterReturningAdvice</code>，表示在目标方法执行后实施增强</p>
</li>
<li><p>环绕增强：<code>MethodInterceptor</code>，表示在目标方法执行前后实施增强</p>
</li>
<li><p>异常抛出增强：<code>ThrowsAdvice</code>，表示在目标方法抛出异常后实施增强</p>
</li>
<li><p>引介增强：<code>IntroductionInterceptor</code>，表示在目标类型添加一些新的方法和属性，</p>
<p>引介增强的连接点是类级别的，而非方法级别的，通过引介增强，可以为目标类添加一个接口的实现，即原来目标类为实现某个接口，通过引介增强可以为目标类创建实现某接口的代理</p>
</li>
</ul>
<h4 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h4><p>Spring通过<code>Pointcut</code>接口描述切点，<code>Pointcut</code>由<code>ClassFilter</code>和<code>MethodMatcher</code>构成，通过<code>ClassFilter</code>定位到某些特定类上，通过<code>MethodMatcher</code>定位到某些方法上，这样<code>Pointcut</code>就拥有了描述某些类的某些特定方法的能力</p>
<p>切点类型</p>
<p>Spring提供了6种类型的切点</p>
<ul>
<li>静态方法切点，<code>StaticMethodMatcherPointcut</code></li>
<li>动态方法切点：<code>DynamicMethodMatcherPointcut</code></li>
<li>注解切点：<code>AnnotationMatchingPointcut</code></li>
<li>表达式切点：<code>ExpressionPointcut</code>，主要是为了支持AspectJ切点表达式语法而定义的接口</li>
<li>流程切点：<code>ControlFlowPointcut</code></li>
<li>复合切点：<code>ComposablePointcut</code></li>
</ul>
<p>切面类型</p>
<p>Spring使用<code>Advistor</code>接口表示切面的概念，一个切面同时包含横切代码和连接点信息，Spring中切面可分为3类：</p>
<ul>
<li>一般切面：<code>Advisor</code>，仅包含一个<code>Advice</code>，因为是所有目标类的所有方法,太广泛，所以一般不会直接使用</li>
<li>切点切面：<code>PointcutAdvisor</code>，具有切点的切面，包含<code>Advice</code>和<code>Pointcut</code>两个类，能提供更灵活，更适用的切面</li>
<li>引介切面：<code>IntroductionAdvisor</code>，引介切面是对应引介增强的特殊切面，他应用于类层面上，所以引介切点使用<code>ClassFilter</code>进行定义</li>
</ul>
<h4 id="AOP无法增强疑难问题剖析"><a href="#AOP无法增强疑难问题剖析" class="headerlink" title="AOP无法增强疑难问题剖析"></a>AOP无法增强疑难问题剖析</h4><p>使用Spring AOP的时，可能会碰到一些方法无法被增强的问题，有时同一个类里面的方法有的可以被增强，有的却无法增强，要分析原因，要从Spring AOP的实现机制入手：</p>
<ul>
<li><p>在JDk动态代理中通过接口来实现方法拦截，所以必须确保要拦截的目标方法在接口中有定义，否则将无法实现拦截</p>
</li>
<li><p>在CGLib动态代理中通过动态生成代理子类来实现方法拦截，所以必须确保要拦截的目标方法可被子类访问，也就是目标方法必须定义为非<code>final</code>，且非私有</p>
</li>
<li><p>除了以上两种情况，还有一种特殊情况：在方法内部之间调用的时候，不会使用被增强的代理类，而是直接调用未被增强原类的方法</p>
<p>可在调用的时候通过注入本类实例，然后通过本类实例来调用本类想要同样被增强的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeAopProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BeAopProxy beAopProxy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test1方法&quot;</span>);</span><br><span class="line">        <span class="comment">//通过注入的beAopProxy 调用test2()</span></span><br><span class="line">        beAopProxy.test2();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;test2方法&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring中的InitializingBean与DisposableBean</title>
    <url>/2019/10/17/Spring/Spring%E4%B8%AD%E7%9A%84InitializingBean%E4%B8%8EDisposableBean/</url>
    <content><![CDATA[<h3 id="InitializingBean"><a href="#InitializingBean" class="headerlink" title="InitializingBean"></a><code>InitializingBean</code></h3><p><code>InitializingBean</code> 接口为bean提供了初始化方法的方式，它只包括<code>afterPropertiesSet</code>方法，</p>
<p>凡是继承该接口的类，在初始化bean的时候都会执行<code>afterPropertiesSet</code>方法。<code>afterPropertiesSet</code>执行的时间点是所有的<code>properties</code>被注入后</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanTest</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init-afterPropertiesSet()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML方式配置初始化方法：在配置bean的时候使用<code>init-method</code>配置也可以为bean配置初始化方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;InitBeanTest&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.InitBeanTest&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initTest&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>那么以上两种方式那种优先级较高呢？</p>
<p><code>afterPropertiesSet()</code> 的优先级高于 <code>init-method</code></p>
<p>采用以上两种方式配置后，测试示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBeanTest</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init-afterPropertiesSet()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">输出结果:</span><br><span class="line">init-afterPropertiesSet()</span><br><span class="line">init-method</span><br></pre></td></tr></table></figure>

<p>从结果可以看出，在Spring初始化bean的时候，如果该bean实现了InitializingBean接口，并且同时在配置文件中指定了init-method，系统则是先调用afterPropertieSet()方法，然后再调用init-method中指定的方法。</p>
<p>那么这种优先级方式是如何实现的呢？</p>
<p>可以查看Spring加载Bean的源码类:<code>AbstractAutowireCapableBeanFactory</code>，其中的<code>invokeInitMethods</code> 方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">invokeInitMethods</span><span class="params">(String beanName, Object bean, <span class="meta">@Nullable</span> RootBeanDefinition mbd)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isInitializingBean = bean <span class="keyword">instanceof</span> InitializingBean;</span><br><span class="line">  <span class="comment">// 判断该Bean是否实现了InitializingBean接口，</span></span><br><span class="line">  <span class="comment">// 如果实现了InitializingBean接口，且bean中有afterPropertiesSet方法，则调用bean的afterPropertiesSet方法</span></span><br><span class="line">    <span class="keyword">if</span> (isInitializingBean &amp;&amp; (mbd == <span class="keyword">null</span> || !mbd.isExternallyManagedInitMethod(<span class="string">&quot;afterPropertiesSet&quot;</span>))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.logger.isTraceEnabled()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.logger.trace(<span class="string">&quot;Invoking afterPropertiesSet() on bean with name &#x27;&quot;</span> + beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                  <span class="comment">// 直接调用afterPropertiesSet</span></span><br><span class="line">                    ((InitializingBean)bean).afterPropertiesSet();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, <span class="keyword">this</span>.getAccessControlContext());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (PrivilegedActionException var6) &#123;</span><br><span class="line">                <span class="keyword">throw</span> var6.getException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 直接调用afterPropertiesSet</span></span><br><span class="line">            ((InitializingBean)bean).afterPropertiesSet();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mbd != <span class="keyword">null</span> &amp;&amp; bean.getClass() != NullBean.class) &#123;</span><br><span class="line">       <span class="comment">// 在判断Bean是否实现了InitializingBean接口之后，判断是否指定了init-method方法</span></span><br><span class="line">       <span class="comment">// 如果指定了init-method方法，则再调用制定的init-method，可以看到if条件中去掉了InitializingBean的afterPropertiesSet方法</span></span><br><span class="line">        String initMethodName = mbd.getInitMethodName();</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.hasLength(initMethodName) &amp;&amp; (!isInitializingBean || !<span class="string">&quot;afterPropertiesSet&quot;</span>.equals(initMethodName)) &amp;&amp; !mbd.isExternallyManagedInitMethod(initMethodName)) &#123;</span><br><span class="line">          <span class="comment">//进一步查看该方法的源码，可以发现init-method方法中指定的方法是通过反射实现</span></span><br><span class="line">            <span class="keyword">this</span>.invokeCustomInitMethod(beanName, bean, mbd);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="DisposableBean"><a href="#DisposableBean" class="headerlink" title="DisposableBean"></a><code>DisposableBean</code></h3><p><code>DisposableBean</code>接口的方法作用是在对象销毁时调用。它只包括<code>destroy</code>方法</p>
<p>在对象销毁的时候，会调用DisposableBean的destroy方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.springframework.beans.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBean</span> <span class="keyword">implements</span> <span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML方式配置初始化方法：在配置bean的时候使用<code>init-method</code>配置也可以为bean配置初始化方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;InitBeanTest&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.InitBeanTest&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destoryTest&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>那么以上两种方式那种优先级较高呢？</p>
<p>和init一样，<code>destroy()</code> 的优先级高于 <code>destroy-method</code></p>
<p>采用以上两种方式配置后，测试示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InitBean</span> <span class="keyword">implements</span> <span class="title">InitializingBean</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destoryTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy-method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">applicationContext.registerShutdownHook()后，输出结果:</span><br><span class="line">destroy()</span><br><span class="line">destroy-method</span><br></pre></td></tr></table></figure>

<p>同样，在对象销毁有一个参数配置<code>destroy-method</code>，和<code>init-method</code>相同，在调用销毁的时候，先执行 <code>DisposableBean</code>的<code>destroy</code>方法，后执行 <code>destroy-method</code>声明的方法。</p>
<p><code>AbstractAutowireCapableBeanFactory</code> 中的 <code>destroyBean</code>方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroyBean</span><span class="params">(Object existingBean)</span> </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> DisposableBeanAdapter(existingBean, <span class="keyword">this</span>.getBeanPostProcessors(), <span class="keyword">this</span>.getAccessControlContext())).destroy();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!CollectionUtils.isEmpty(<span class="keyword">this</span>.beanPostProcessors)) &#123;</span><br><span class="line">        Iterator var1 = <span class="keyword">this</span>.beanPostProcessors.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(var1.hasNext()) &#123;</span><br><span class="line">            DestructionAwareBeanPostProcessor processor = (DestructionAwareBeanPostProcessor)var1.next();</span><br><span class="line">            processor.postProcessBeforeDestruction(<span class="keyword">this</span>.bean, <span class="keyword">this</span>.beanName);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.invokeDisposableBean) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">            logger.trace(<span class="string">&quot;Invoking destroy() on bean with name &#x27;&quot;</span> + <span class="keyword">this</span>.beanName + <span class="string">&quot;&#x27;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                AccessController.doPrivileged(() -&gt; &#123;</span><br><span class="line">                  <span class="comment">//执行bean实现接口DisposableBean的destroy()</span></span><br><span class="line">                    ((DisposableBean)<span class="keyword">this</span>.bean).destroy();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;, <span class="keyword">this</span>.acc);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">//执行bean实现接口DisposableBean的destroy()</span></span><br><span class="line">                ((DisposableBean)<span class="keyword">this</span>.bean).destroy();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            String msg = <span class="string">&quot;Invocation of destroy method failed on bean with name &#x27;&quot;</span> + <span class="keyword">this</span>.beanName + <span class="string">&quot;&#x27;&quot;</span>;</span><br><span class="line">            <span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">                logger.warn(msg, var3);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.warn(msg + <span class="string">&quot;: &quot;</span> + var3);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//执行xml中配置的destroy-method方法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//反射调用</span></span><br><span class="line">        <span class="keyword">this</span>.invokeCustomDestroyMethod(<span class="keyword">this</span>.destroyMethod);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.destroyMethodName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Method methodToInvoke = <span class="keyword">this</span>.determineDestroyMethod(<span class="keyword">this</span>.destroyMethodName);</span><br><span class="line">        <span class="keyword">if</span> (methodToInvoke != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.invokeCustomDestroyMethod(ClassUtils.getInterfaceMethodIfPossible(methodToInvoke));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<p><a href="https://www.cnblogs.com/weiqihome/p/8922937.html">Spring中的InitializingBean接口的使用</a></p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis-Key命令</title>
    <url>/2022/07/01/Redis/Redis-Key%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<p><strong>Redis-key的操作命令</strong></p>
<span id="more"></span>

<h4 id="查找操作"><a href="#查找操作" class="headerlink" title="查找操作"></a>查找操作</h4><h5 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># keys pattern :此命令用于查找与指定pattern匹配的key。这个操作的时间复杂度是 O(N)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">mset</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span> <span class="string">key3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">keys</span> <span class="string">key*</span></span><br><span class="line"><span class="string">&quot;key3&quot;</span></span><br><span class="line"><span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">keys</span> <span class="string">*</span></span><br><span class="line"><span class="string">&quot;key3&quot;</span></span><br><span class="line"><span class="string">&quot;key2&quot;</span></span><br><span class="line"><span class="string">&quot;key1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">keys</span> <span class="string">*1*</span></span><br><span class="line"><span class="string">&quot;key1&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="randomkey"><a href="#randomkey" class="headerlink" title="randomkey"></a>randomkey</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># randomkey :从当前数据库中随机返回一个key,数据库为空是返回nil</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">mset</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span> <span class="string">key3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">randomkey</span></span><br><span class="line"><span class="string">&quot;key2&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># scan cursor [MATCH pattern] [COUNT count] :迭代数据库中存在的所有键</span></span><br><span class="line"><span class="comment"># 参数说明：cursor:游标，pattern:正则，count：数量</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">mset</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span> <span class="string">key3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">scan</span> <span class="number">0</span> <span class="string">MATCH</span> <span class="string">&quot;key*&quot;</span> <span class="string">COUNT</span> <span class="number">1</span></span><br><span class="line"><span class="string">&quot;0&quot;</span></span><br><span class="line"><span class="number">1</span><span class="string">)&quot;key1&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="修改操作"><a href="#修改操作" class="headerlink" title="修改操作"></a>修改操作</h4><h5 id="rename、renamenx"><a href="#rename、renamenx" class="headerlink" title="rename、renamenx"></a>rename、renamenx</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># rename key newkey :修改key的名称为newkey,key不存在则返回错误，如果newkey存在则会被覆盖</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rename</span> <span class="string">key1</span> <span class="string">key2</span> </span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key1</span></span><br><span class="line"><span class="string">(nil)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key2</span></span><br><span class="line"><span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">rename</span> <span class="string">key3</span> <span class="string">key4</span> </span><br><span class="line"><span class="string">ERR</span> <span class="string">ERR</span> <span class="literal">no</span> <span class="string">such</span> <span class="string">key</span></span><br><span class="line"><span class="comment"># rename key newkey :如果newkey不重复，则将key修改为newkey。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key4</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">renamenx</span> <span class="string">key3</span> <span class="string">key4</span> </span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">renamenx</span> <span class="string">key3</span> <span class="string">key5</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key3</span></span><br><span class="line"><span class="string">(nil)</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">get</span> <span class="string">key5</span></span><br><span class="line"><span class="string">&quot;value3&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="dump、restroe"><a href="#dump、restroe" class="headerlink" title="dump、restroe"></a>dump、restroe</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># dump key :用于序列化给定key，并返回被序列化的值。序列化的值不包括任何过期(expire)信息，如果key不存在，那么返回nil</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">dump</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;\u0000\u0006value1\t\u0000&gt;\r\u0015v\xF9q1\xE9&quot;</span></span><br><span class="line"><span class="comment"># restore key ttl serialized-value [REPLACE] [ABSTTL] [IDLETIME seconds] [FREQ frequency] :反序列化给定的序列化的值(由dump生成)，</span></span><br><span class="line"><span class="comment"># ttl: 参数ttl以毫秒为单位，设置key的过期时间；为0则不设置过期时间。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span>  <span class="string">restore</span> <span class="string">key2</span> <span class="number">0</span> <span class="string">&quot;\u0000\u0006value1\t\u0000&gt;\r\u0015v\xF9q1\xE9&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br></pre></td></tr></table></figure>

<h5 id="move"><a href="#move" class="headerlink" title="move"></a>move</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># move key db :将当前数据库中的key移动至指定的数据库中（默认存储为0库，可选 1-15中的任意库），如果key在目标数据库中已存在，或者key在源数据库中不存，则key不会被移动,返回0。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">select</span> <span class="number">0</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">select</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MOVE</span> <span class="string">key1</span> <span class="number">1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exists</span> <span class="string">key1</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">MOVE</span> <span class="string">key2</span> <span class="number">1</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h4 id="判断操作"><a href="#判断操作" class="headerlink" title="判断操作"></a>判断操作</h4><h5 id="exists"><a href="#exists" class="headerlink" title="exists"></a>exists</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># exists key	用于检查键是否存在，若存在则返回 1，否则返回 0。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exists</span> <span class="string">key1</span> </span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exists</span> <span class="string">key2</span></span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure>

<h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># type key :该命令用于获取key对应的value的数据类型。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">type</span> <span class="string">key1</span> </span><br><span class="line"><span class="string">&quot;string&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">sadd</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">type</span> <span class="string">key2</span> </span><br><span class="line"><span class="string">&quot;set&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="过期操作"><a href="#过期操作" class="headerlink" title="过期操作"></a>过期操作</h4><h5 id="expire、pexpire、expireat、pexpireat"><a href="#expire、pexpire、expireat、pexpireat" class="headerlink" title="expire、pexpire、expireat、pexpireat"></a>expire、pexpire、expireat、pexpireat</h5><blockquote>
<p>使用负值调用expire/pexpire或使用过去的时间调用expireat/pexpireat，那么<code>key</code>会被删除而不是过期。 (因为, 触发的<code>key event</code>将是<code>del</code>, 而不是<code>expired</code>).</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># expire key seconds:设置key的过期时间，以秒为单位。成功返回1，key不存在返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">expire</span> <span class="string">key1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ttl</span> <span class="string">key1</span></span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ttl</span> <span class="string">key2</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="comment"># pexpire key milliseconds :设置key的过期时间，以毫秒为单位。成功返回1，key不存在返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key3</span> <span class="string">&quot;value3&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">expire</span> <span class="string">key3</span> <span class="number">1500</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ttl</span> <span class="string">key3</span></span><br><span class="line"><span class="number">1490</span></span><br><span class="line"><span class="comment"># expireat key	timestamp :同expire，用于为key设置过期时间，不同在于，参数为以秒为单位的时间戳格式。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key4</span> <span class="string">&quot;value4&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">expireat</span> <span class="string">key4</span> <span class="number">1656684674</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exists</span> <span class="string">key4</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># pexpireat key	milliseconds-timestamp :同expireat，用于为key设置过期时间，不同在于，参数为以毫秒为单位的时间戳格式。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key5</span> <span class="string">&quot;value5&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">expireat</span> <span class="string">key5</span> <span class="number">1656684674000</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">exists</span> <span class="string">key5</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<h5 id="ttl、pttl"><a href="#ttl、pttl" class="headerlink" title="ttl、pttl"></a>ttl、pttl</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ttl key	:用于检查key还剩多长时间过期，以秒为单位。key不存在返回-2，key存在没有超时时间则返回-1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ttl</span> <span class="string">key1</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">expire</span> <span class="string">key1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">ttl</span> <span class="string">key1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="comment"># pttl key :用于检查key还剩多长时间过期，以毫秒为单位。key不存在返回-2，key存在没有超时时间则返回-1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key2</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">pttl</span> <span class="string">key2</span></span><br><span class="line"><span class="number">-1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">expire</span> <span class="string">key2</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">pttl</span> <span class="string">key2</span></span><br><span class="line"><span class="number">10000</span></span><br></pre></td></tr></table></figure>

<h5 id="persist"><a href="#persist" class="headerlink" title="persist"></a>persist</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># persist key :该命令用于删除key的过期时间，然后key将一直存在，不会过期。过期删除成功返回1，key不存在或者没有设置过期时间返回0</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="string">redis&gt;</span> <span class="string">expire</span> <span class="string">key1</span> <span class="number">10</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">redis&gt;</span> <span class="string">TTL</span> <span class="string">key1</span></span><br><span class="line"><span class="number">8</span></span><br><span class="line"><span class="string">redis&gt;</span> <span class="string">persist</span> <span class="string">key1</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="string">redis&gt;</span> <span class="string">TTL</span> <span class="string">key1</span></span><br><span class="line"><span class="number">-1</span></span><br></pre></td></tr></table></figure>

<h4 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h4><h5 id="del"><a href="#del" class="headerlink" title="del"></a>del</h5><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># del key :若键存在的情况下，该命令用于删除键。</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key1</span> <span class="string">&quot;value1&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">set</span> <span class="string">key2</span> <span class="string">&quot;value2&quot;</span></span><br><span class="line"><span class="string">&quot;OK&quot;</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">del</span> <span class="string">key1</span> <span class="string">key2</span> <span class="string">key3</span> </span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>参考资料</p>
<p><a href="https://www.redis.com.cn/commands/del.html">Redis-key操作命令</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring容器高级主题</title>
    <url>/2020/03/20/Spring/Spring%E5%AE%B9%E5%99%A8%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p>Spring容器是一部设计精妙的机器，其优异的外在表现是通过精密的内部设计实现的。本章内容：</p>
<span id="more"></span>

<ul>
<li>分析Spring的内部结构</li>
<li>Spring属性编辑器</li>
<li>使用外部属性文件</li>
<li>国际化信息</li>
<li>容器事件体系</li>
</ul>
<h4 id="Spring容器技术内幕"><a href="#Spring容器技术内幕" class="headerlink" title="Spring容器技术内幕"></a>Spring容器技术内幕</h4><p>Spring的<code>AbstractApplicationContext</code>是<code>ApplicationContext</code>的抽象实现类，其中的<code>refresh()</code>方法定义了Spring容器在加载配置文件后的各项处理过程，这些处理过程清晰的刻画了Spring启动时所执行的各项操作，</p>
<p><code>refresh()</code>内部代码大体逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1 初始化BeanFactory</span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line">...</span><br><span class="line"><span class="comment">// 2.调用工厂后处理器</span></span><br><span class="line">invokeBeanFactoryPostProcessors();</span><br><span class="line"><span class="comment">// 3.注册Bean后处理器</span></span><br><span class="line">registerBeanPostProcessors();</span><br><span class="line"><span class="comment">// 4.初始化消息源</span></span><br><span class="line">initMessageSource();</span><br><span class="line"><span class="comment">// 5.初始化应用上下文事件广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"><span class="comment">// 6.初始化其他特殊的Bean：由具体子类实现</span></span><br><span class="line">onRefresh();</span><br><span class="line"><span class="comment">// 7.注册事件监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"><span class="comment">// 8.初始化所有单实例的Bean，使用懒加载的Bean除外</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"><span class="comment">// 9.完成刷新并发布容器刷新事件</span></span><br><span class="line">finishRefesh();</span><br></pre></td></tr></table></figure>

<ol>
<li>初始化<code>BeanFactory</code>：根据配置文件实例化<code>BeanFactiry</code>，这一步中，Spring将配置文件的信息装入容器的Bean定义注册表(<code>BeanDefinitionRegistry</code>)中，但此时Bean还未初始化</li>
<li>调用工厂后处理器：根据反射机制从<code>BeanDefinitionRegistry</code>中找出所有实现了<code>BeanFactoryPostProcessor</code>接口的Bean，并调用其<code>postProcessBeanFactory</code>方法</li>
<li>注册Bean后处理器：根据反射机制从<code>BeanDefinitionRegister</code>中找出所有实现了<code>BeanPostProcessor</code>接口的Bean，并将他们注册到容器Bean后处理器的注册表中</li>
<li>初始化消息源：初始化容器的国际化消息资源</li>
<li>初始化应用上下文事件广播器</li>
<li>初始化其他特殊Bean：这事一个钩子方法，子类可以借助这个方法执行一些特殊的操作，如<code>AbstractRefreshableWebApplicationContext</code>就使用该方法执行初始化<code>ThemeSource</code>的操作</li>
<li>注册事件监听器</li>
<li>初始化所有单实例的Bean，使用懒加载的Bean除外：初始化Bean后，将他们放入Spring容器的缓存池中</li>
<li>发布上下文刷新事件：创建上下文刷新事件，事件广播器负责将这些事广播到每个注册的事件监听器中</li>
</ol>
<p>Bean从创建到销毁的生命历程(生命周期)，都可以在上面的流程中找到对应的步骤，Spring协调多个组件共同完成这个复杂的作业流程</p>
<p>Spring容器从加载配置文件到创建出一个完整Bean的作业流程及参与角色如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/IoC%E7%9A%84%E6%B5%81%E6%B0%B4%E7%BA%BF.jpg" alt="IoC流水线"></p>
<blockquote>
<p><code>BeanFactoryPostProcessor</code>对配置信息进行加工：容器扫描<code>BeanFactoryRegister</code>，使用Java反射机制识别出Bean工厂后处理器，然后调用<code>BeanFactoryPostProcessor</code>对<code>BeanDefinitionRegister</code>中的<code>BeanDefinition</code>进行加工处理，主要包括两个工作：</p>
<ol>
<li>对使用占位符(例如<code>$&#123;dataSource&#125;</code>)的<code>&lt;bean&gt;</code>元素标签进行解析，得到最终的配置值，这意味着对一些半成品式的<code>BeanDefinition</code>对象进行加工处理并得到成品的<code>BeanDefinition</code>对象</li>
<li>对<code>BeanDefinitionRegister</code>中的<code>BeanDefinition</code>进行扫描，通过Java反射机制找到所有属性编辑器的Bean(实现<code>java.beans.PropertyEditor</code>接口的Bean)，并自动将他们注册到Spring容器的属性编辑器注册表中(<code>PropertyEditorRegister</code>)</li>
</ol>
</blockquote>
<p>Spring组件按其承担的角色可以划分为两类：</p>
<ol>
<li>物料组件：<code>Resource</code>、<code>BeanDefinition</code>、<code>PropertyEditor</code>及最终的Bean等，他们是加工流程中被加工、被消费的组件，就像流水线上被加工的物料一样</li>
<li>设备组件：<code>ResourceLoader</code>、<code>BeanDefinitionReader</code>、<code>BeanFactoryPostProcessor</code>、<code>InstantiationStrategy</code>及<code>BeanWrapper</code>等，他们就像流水线上不同环节的加工设备，对物料组件进行处理</li>
</ol>
<p>之前已经学习过<code>Resource</code>和<code>ResourceLoader</code>，再来看一下部分其他组件：</p>
<ol>
<li><p><code>BeanDefinition</code></p>
<p>是配置文件<code>&lt;bean&gt;</code>元素标签在容器的内部表示。<code>&lt;bean&gt;</code>元素标签拥有<code>class</code>、<code>scope</code>、<code>lazy-init</code>等配置属性，<code>BeanDefinition</code>则提供了相应的<code>beanClass</code>、<code>scorp</code>、<code>lazyInit</code>类属性，<code>BeanDefinition</code>和<code>&lt;bean&gt;</code>是一一对应的</p>
<p>Spring是将<code>BeanDefinition</code>注册到<code>BeanDefinitionRegister</code>中的，后续操作直接从<code>BeanDefinitionRegister</code>中读取配置信息，一般情况下，<code>BeanDefinition</code>只在容器启动时加载并解析，除非容器刷新或重启，这些信息不会发生变化，当然如果有特殊需求，可以通过编程方式在运行期调整<code>BeanDefinition</code>的定义</p>
<p>创建最终的<code>BeanDefinition</code>主要包含两个步骤</p>
<ol>
<li>利用<code>BeanDefinitionReader</code>读取承载配置信息的<code>Resource</code>，通过XML解析器解析配置信息的DOM对象，简单的为每个<code>&lt;bean&gt;</code>生成对应的<code>BeanDefinition</code>对象，但是这里生成的<code>BeanDefinition</code>可能是半成品，因为在配置文件中，可能通过占位符变量引用外部属性文件的属性，这些占位符变量在这一步里还没有被解析出来</li>
<li>利用容器中注册的<code>BeanFactoryPostPorcessor</code>对半成品的<code>BeanDefinition</code>进行加工处理，将以占位符表示的配置解析为最终的实际值，这样半成品的<code>BeanDefinition</code>就成为成品的<code>BeanDefinition</code></li>
</ol>
</li>
<li><p><code>InstantiationStrategy</code></p>
<p>负责根据<code>BeanDefinition</code>对象创建一个Bean实例</p>
<p>Spring之所以将实例化Bean的工作通过一个策略接口进行描述，是为了更方便的采用不用的实例化策略</p>
<ul>
<li><code>SimpleInstantiationStrategy</code>实现了<code>InstantiationStrategy</code>，是最常用的实例化策略，该策略利用Bean实现类的默认构造函数、带参构造函数或工厂方法创建Bean的实例</li>
<li><code>CglibSubclassingInstantiationStrategy</code>扩展了<code>SimpleInstantiationStrategy</code>，为需要进行方法注入的Bean提供了支持，他利用CGLIB类库为Bean动态生成子类，在子类中生成方法注入的逻辑，然后使用这个动态生成的子类创建Bean的实例</li>
</ul>
<p><code>InstantiationStrategy</code>仅负责实例化Bean的操作，相当于执行Java语言中new的功能，他并不参与Bean属性设置的工作，所以由<code>InstantiationStrategy</code>返回的Bean实例实际上是一个半成品的Bean实例，属性填充的工作留待<code>BeanWrapper</code>来完成</p>
</li>
<li><p><code>BeanWrapper</code></p>
<p>是Spring框架中重要的组件类，<code>BeanWrapper</code>相当于一个代理器，Spring委托<code>BeanWrapper</code>完成Bean属性的填充工作</p>
<p>在Bean实例被<code>InstantiationStrategy</code>创建出来之后，容器主控程序将Bean实例通过<code>BeanWrapper</code>包装起来（通过调用<code>BeanWrapper#setWrappedInstance(Object obj)</code>方法完成的）</p>
<p><code>BeanWrapper</code>还有两个顶级接口：<code>propertyAccessor </code>和 <code>PropertyEditorRegistry</code></p>
<ul>
<li><code>propertyAccessor</code>接口定义了各种访问Bean属性的方法，如<code>setPropertyValue(String,Object)</code>等</li>
<li><code>PropertyEditorRegistry</code>是属性编辑器的注册表</li>
</ul>
<p>所以<code>BeanWrapper</code>的实现类<code>BeanWrapperImpl</code>有三重身份：</p>
<ol>
<li>Bean包裹器</li>
<li>属性访问器</li>
<li>属性编辑器注册表</li>
</ol>
<p>一个<code>BeanWrapperImpl</code>实例内封装了两类组件：被封装的待处理的Bean、一套用于设置Bean属性的属性编辑器</p>
<p>要顺利的填充 Bean的属性，还需要从<code>BeanDefinitionRegistry</code>中获取Bean对应的<code>BeanDefinition</code>，Spring从<code>BeanDefinition</code>中获取Bean属性的配置信息<code>PropertyValue</code>，并使用属性编辑器对<code>PropertyValue</code>进行转换以得到Bean的属性值，对Bean的其他属性重复这样的步骤，就可以完成Bean所有属性的注入工作（<code>BeanWrapperImpl</code>在内部使用Spring的<code>BeanUtils</code>工具类对Bean进行反射操作，设置属性）</p>
</li>
</ol>
<h4 id="属性编辑器"><a href="#属性编辑器" class="headerlink" title="属性编辑器"></a>属性编辑器</h4><p>在Spring配置文件里，往往通过字面值为Bean各种类型的属性提供设置值，不管是double类型还是int类型，在配置文件中都对应字符串类型的字面值，将这个字面值正确地转换为对应的double或int等内部类型的转换器就是属性编辑器</p>
<p>任何实现<code>java.beans.PropertyEditor</code>接口的类都是属性编辑器，属性编辑器的主要功能就是将外部的设置值转换为JVM内部的对应类型，所以属性编辑器其实就是一个类型转换器</p>
<p><code>PropertyEditor</code>是JavaBean规范定义的接口，JavaBean的编辑器很大程度是为了IDE的可视化程序提供的</p>
<p>Spring的属性编辑器仅负责将配置文件中的文本配置值转换为Bean属性的对应值</p>
<p>Spring为常见的属性类型提供了默认的属性编辑器，Spring在<code>PropertyEditorRegistrySupport</code>中为常见属性类型提供了默认的属性编辑器（<code>BeanWrapperImpl</code>类扩展了<code>PropertyEditorRegistrySupport</code>类），这些常见的类型共32个,可分为三大类，如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/Spring%E6%8F%90%E4%BE%9B%E7%9A%84%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7%E7%BC%96%E8%BE%91%E5%99%A8.jpg" alt="Spring提供的默认属性编辑器"></p>
<p><code>PropertyEditorRegistrySupport</code>中有两个用于保存属性编辑器的Map类型变量</p>
<ul>
<li><p><code>defaultEditors</code>：用于保存默认属性类型的编辑器，元素键为属性类型，值为对应的属性编辑器实例</p>
</li>
<li><p><code>customEditors</code>：用于保存用户自定义的属性编辑器，元素的键值和<code>defaultEditors</code>相同</p>
<p>如果希望在配置文件以子面值提供特殊的属性，可以自定义属性编辑器</p>
<ol>
<li><p>扩展<code>PropertyEditorSuppor</code>t类，仅需简单的覆盖其中的<code>setAsText()</code>方法即可</p>
</li>
<li><p>注册自定义的属性编辑器</p>
<ul>
<li><p>使用<code>BeanFactory</code>：用户需要手工调用<code>registerCustomEditor(Class requiredType,PropertyEditor propertyEditor)</code>方法注册自定义的属性编辑器</p>
</li>
<li><p>使用<code>ApplicationContext</code>，则需要在配置文件中通过<code>CustomEditorConfigurer</code>注册即可（<code>CustomEditorConfigurer</code>实现了<code>BeanFactoryPostProcessor</code>接口，所以是一个工厂后处理器）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.CustomEditorConfigurer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">customEditors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">      &lt;1--属性编辑器对应的属性类型--&gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;cn.zhangyuying.editor.CustomType&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">value</span>=<span class="string">&quot;cn.zhangyuying.editor.CustomTypeEditor&quot;</span>/&gt;</span>      </span><br><span class="line">    <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="使用外部属性文件"><a href="#使用外部属性文件" class="headerlink" title="使用外部属性文件"></a>使用外部属性文件</h4><p>Spring支持将配置信息对立到一个外部属性文件中，并在Spring配置文件中通过形如<code>$&#123;user&#125;</code>、<code>$&#123;password&#125;</code>的占位符引用属性文件中的属性项</p>
<p>Spring支持在Bean配置时引用外部属性文件的是：<code>PropertyPlaceholderConfigurer</code>类，<code>PropertyPlaceholderConfigurer</code>实现了<code>BeanFactoryPostProcessor</code>接口，因而也是一个Bean工厂后处理器</p>
<p>使用<code>PropertyPlaceholderConfigurer</code>属性文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.beans.factory.config.PropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">  p:location=&quot;classpath:cn/zhangyuying/placeholder/jdbc.properties&quot;</span><br><span class="line">  p:fileEncoding=&quot;utf-8&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>PropertyPlaceholderConfigurer</code>除了location外的其他常用属性：</p>
<ul>
<li><code>locations</code>：多个配置文件</li>
<li><code>fileEncoding</code>：属性文件的编码格式</li>
<li><code>order</code>：多个<code>PropertyPlaceholderConfigurer</code>的优先顺序</li>
<li><code>placeholderPrefix</code>：占位符前缀，默认为<code>&quot;$&#123;&quot;</code></li>
<li><code>placeholderPrefix</code>：占位符后缀，默认为<code>&quot;&#125;&quot;</code></li>
</ul>
<p>可以通过<code>context</code> 命名空间定义属性文件,比较简单，但是不支持自定义的高级属性</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:cn/zhangyuying/placeholder/jdbc.properties&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>Spring也允许在属性文件中使用<code>$&#123;propName&#125;</code>实现属性之间的相互引用，例如：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="attr">dbName</span>=<span class="string">sampledb</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">sa</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql//localhost:3306/$&#123;dbName&#125;</span></span><br></pre></td></tr></table></figure>

<p>Spring也允许在Bean定义中通过<code>$&#123;propName&#125;</code>引用属性值，基于注解和基于Java类的Bean中可以通过@Value注解为Bean的成员变量或方法入参自动注入容器已有属性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;$&#123;password&#125;&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String password;</span><br></pre></td></tr></table></figure>

<p><strong>配置文件属性加密</strong></p>
<p><code>PropertyPlaceholderConfigurer</code>继承自<code>PropertyResourceConfigurer</code>，后者有几个<code>protected</code>方法，用于在属性使用之前对属性列表中的属性进行转换</p>
<ul>
<li><code>void convertProperties(Properties props)</code>：属性文件中的所有属性值都封装在<code>props</code> 中，覆盖此方法，可以对所有的属性值进行转换</li>
<li><code>String convertProperty(String propertyName,String propertyValue)</code>：在加载属性文件并读取文件中的每个属性时，都会调用此方法进行转换处理</li>
<li><code>String convertProperty(String orginalValue)</code>：后上一个方法类似，只是没有传入属性名</li>
</ul>
<p>在默认情况下，这三个方法内部是空的，既不会对属性值进行任何转换。</p>
<p>可以通过扩展<code>PropertyPlaceholderConfigurer</code>，覆盖相应的属性转换方法，支持加密版的属性文件。</p>
<p>不过使用自定义的属性加载器后，就无法使用<code>&lt;context:property-placeholder&gt;</code>引用属性文件了，只能通过传统的配置方式引用加密版的属性文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.placeholder.EncryptPropertyPlaceholderConfigurer&quot;</span>&gt;</span></span><br><span class="line">  p:location=&quot;classpath:cn/zhangyuying/placeholder/jdbc.properties&quot;</span><br><span class="line">  p:fileEncoding=&quot;utf-8&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>引用Bean的属性值</strong></p>
<p>在Spring3.0中，可以通过类似<code>#&#123;beanName.beanProp&#125;</code>的方式方便的引用另一个Bean的值</p>
<ul>
<li><p>XML中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.Config&quot;</span>&gt;</span></span><br><span class="line">  init-method=&quot;init&quot;</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.Test&quot;</span>&gt;</span></span><br><span class="line">  p:maxNum=&quot;#&#123;config.maxNum&#125;&quot; /&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基于注解和基于Java类配置的Bean中：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Value(&quot;#&#123;config.maxNum&#125;&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> maxNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="国际化信息"><a href="#国际化信息" class="headerlink" title="国际化信息"></a>国际化信息</h4><p>国际化信息也被称为本地化信息，一般需要两个条件才可以确定一个特定类型的本地化信息，分别是：语言类型和国家/地区类型，例如<code>zh</code>和<code>CN</code>（中文和中国大陆）</p>
<p><code>java.util.Locale</code>是表示语言和国家/地区的本地化类，是创建国际化应用的基础</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Locale locale1 = <span class="keyword">new</span> Locale(<span class="string">&quot;zh&quot;</span>,<span class="string">&quot;CN&quot;</span>) <span class="comment">//CN可以省略</span></span><br><span class="line">Locale locale2 = Locale.CHINA</span><br><span class="line">Locale locale3 = Locale.getDefault()</span><br></pre></td></tr></table></figure>

<p>JDK的<code>java.util</code>包中提供了几个支持本地化的格式化操作工具类，如：<code>NumberFormat</code>、<code>DateFormat</code>、<code>MessageFormat</code>（这些工具类进行格式化时，都可传入<code>Locale</code>参数，不传使用系统默认的本地化对象）</p>
<p>如果应用系统中的某些信息需要支持国际化功能，则必须为期望支持的不同本地化类型分别提供对应的资源文件，并以规范的方式进行命名，命名规范如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;资源名&gt;_&lt;语言代码&gt;_&lt;国家&#x2F;地区代码&gt;_.properties </span><br></pre></td></tr></table></figure>

<p>语言代码和国家/地区代码都是可选的，例如：<code>rresourceTest_en_US.properties</code></p>
<p>Java 提供了用于加载Bean 化资源文件的方便类：<code>java.util.ResourceBoundle</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ResourceBoundle rb = ResourceBoundle.getBundle.getBundle(<span class="string">&quot;cn.zhangyuying/il8n/resourceTest_en_US.properties&quot;</span>,Locale.US);</span><br><span class="line"><span class="comment">//访问资源文件中的属性值</span></span><br><span class="line">rb.getString(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="comment">//在资源文件中使用格式化串,资源文件中name=How are you &#123;0&#125;</span></span><br><span class="line">Object[] params = [<span class="string">&quot;John&quot;</span>]</span><br><span class="line">String str = <span class="keyword">new</span> MessageFormat(rb.getString(<span class="string">&quot;name&quot;</span>),Locale.US).format(params)</span><br></pre></td></tr></table></figure>

<p><code>ResourceBoundle</code>在记载资源时，如果指定的本地化资源文件不存在，则按照一下顺序尝试加载其他资源：本地系统默认本地化对象对应的资源–》默认的资源，例如<code>resourceTest_en_CA.properties</code>–&gt;<code>resourceTest_zh_CN.properties</code>–&gt;<code>resourceTest.properties</code>,如果都不存在，则抛出<code>java.util.MissingResourceException</code>异常</p>
<p><strong>MessageSource</strong></p>
<p>Spring定义了访问国际化信息的<code>MessageSource</code>接口</p>
<ul>
<li><code>getMessage(String code, Object[] args, String defaultMessage, Locale locale)</code><ul>
<li><code>code</code>：国际化信息中的属性名</li>
<li><code>args</code>：用于传递格式化串占位符所用的运行期参数</li>
<li><code>defaultMessage</code>：当资源中找不到对应的属性名时，返回此参数指定的默认信息</li>
<li><code>locale</code>：本地化对象</li>
</ul>
</li>
<li><code>getMessage(String code, Object[] args, Locale locale)</code>：和上面类似，只不过找不到资源中对应的属性名时直接抛出<code>NoSuchMessageException</code>异常</li>
<li><code>getMessage(MessageSourceResolvable resolvable, Locale locale)</code>：将属性名、参数名及默认信息封装起来，功能和第一个方法相同</li>
</ul>
<p><code>MessageSource</code>分别被<code>HierarchicalMessageSource</code>和<code>ApplicationContext</code>扩展</p>
<ul>
<li><p><code>HierarchicalMessageSource</code>：可以建立父子层级的<code>MessageSource</code>，其下有两个比较重要的实现类：</p>
<ul>
<li><p><code>ResourceBundleMessageSource</code>：允许仅通过资源名加载国际化信息</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;myResource&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--通过基名制定资源，相当于类跟路径--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basenames&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/zhangyuying/il8n/fmt_resource<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>   </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>java：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MessageSource ms = ctx.getBean(<span class="string">&quot;myResource&quot;</span>);</span><br><span class="line">Object[] params = [<span class="string">&quot;John&quot;</span>]</span><br><span class="line">String str = ms.getMessage(<span class="string">&quot;name&quot;</span>,params,Locale.US);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>ReloadableResourceBundleMessageSource</code>：允许仅通过资源名加载国际化信息，还提供了定时刷新功能</p>
<p>和上面用法相同，多一个<code>property</code>配置：<code>&lt;property name=&quot;cacheSeconds&quot; value=&quot;5&quot;&gt;</code>(5秒,秒为单位)</p>
</li>
</ul>
</li>
<li><p>容器级的国际化信息资源</p>
<p><code>ApplicationContext</code>本身也是一个<code>MessageSource</code>对象</p>
<p>Spring启动时的<code>initMessageSource()</code>方法所执行的工作就是初始化容器中的国际化信息资源，它根据反射机制从<code>BeanDefinitionRegistry</code>中找出名为<code>messageSource</code>且类型为<code>org.springframework.context.MessageSource的Bean</code>，将这个Bean定义的信息资源加载为容器级的国际化信息资源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--注册资源Bean，其Bean名称只能为messageSource--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;messageSource&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;basenames&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">value</span>&gt;</span>cn/zhangyuying/il8n/fmt_resource<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>通过ApplicationContext直接访问国际化信息资源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;cn.zhangyuying/beans.xml&quot;</span>);</span><br><span class="line">Object[] params = [<span class="string">&quot;John&quot;</span>]</span><br><span class="line">String str = ctx.getMessage(<span class="string">&quot;name&quot;</span>,params,Locale.US);</span><br></pre></td></tr></table></figure>

<p>假如<code>MessageSource的Bean</code>没有命名为<code>messageSource</code>，那么以上代码将抛出<code>NoSuchMessageException</code>异常</p>
</li>
</ul>
<h4 id="容器事件"><a href="#容器事件" class="headerlink" title="容器事件"></a>容器事件</h4><p>Spring的<code>ApplicationContext</code>能够发布事件并且允许注册相应的事件监听器，因此他拥有一套完善的事件发布和监听机制</p>
<p>Java通过<code>java.util.EventObject</code>类和<code>java.util.EventListener</code>接口描述事件和监听器，在事件体系中，除了事件和监听器外，还有另外3个重要的概念</p>
<ul>
<li>事件源：事件的产生者，任何一个<code>EventObject</code>都必须拥有一个事件源</li>
<li>事件监听器注册表：保存事件监听器的地方，一个事件监听器注册到组件或框架中，其实就是保存在事件监听器注册表中，当组件和框架中的事件源产生事件时，就会通知这些位于时间监听器注册表中的监听器</li>
<li>事件广播器：是时间和事件监听器沟通的桥梁，负责把事件通知给事件监听器</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB.jpg" alt="事件体系"></p>
<p>事件源、事件监听器注册表和时间广播器这三个角色有时可以由同一个对象承担，例如<code>JButton</code></p>
<p>事件体系其实是观察者模式的一种具体实现方式</p>
<p><strong>Spring事件类结构</strong></p>
<ol>
<li><p>事件类</p>
<p><code>ApplicationEvent</code>继承自<code>EventObject</code></p>
<ul>
<li><p>唯一的一个构造函数是<code>ApplicationEvent(Object source)</code>，<code>source</code>指定数据源</p>
</li>
<li><p>有两个子类</p>
<ul>
<li><code>ApplicationContextEvent</code>：容器事件，有四个子类，分别表示容器启动、刷新、停止及关闭的事件</li>
<li><code>RequestHandleEvent</code>：与Web应用相关的事件，当一个HTTP请求被处理后，产生该事件，只有在<code>web.xml</code>中定义了<code>DispatcherServlet</code>时才会产生该事件，它拥有两个子类，分别代表Servlet及Porlet的请求事件</li>
</ul>
<p>也可以根据需要扩展<code>ApplicationEvent</code>定义自己的事件，完成其他特殊的功能</p>
</li>
</ul>
</li>
<li><p>事件监听器接口</p>
<p><code>ApplicationListener</code>继承自<code>EventListener</code></p>
<ul>
<li><p>只定义了一个方法：<code>onApplicationEvent(E event)</code>，该方法接受<code>ApplicationEvent</code>事件对象，在该方法中编写事件的响应处理逻辑</p>
</li>
<li><p>Spring 3.0增加了<code>SmartApplicationListener</code>接口，定义了支持哪种类型的容器事件和对何种事件源对象作出响应的方法</p>
</li>
<li><p>Spring4.2增加了<code>GenericApplicationListener</code>接口，他增强了对泛型的支持，其中定义了两个方法</p>
<ul>
<li><p><code>boolean supportsEventType(ResolvableType eventType)</code>：指定监听器响应的事件类型</p>
<p><code>ResolvableType</code>是Spring4.0提供的一个更加简单易用的泛型操作支持类，通过他可以很容器的获取到泛型的实际类型信息</p>
</li>
<li><p><code>boolean supportsSourceType(Class&lt;?&gt;  sourceType)</code>：指定监听器对何种事件源对象作出响应</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>事件广播器</p>
<p>当发生容器事件时，容器主控程序将调用事件广播器将事件通知给事件监听器注册表中的事件监听器，事件监听器在分别对事件进行响应</p>
<p>Spring中的时间广播器接口为：<code>ApplicationEventMulticaster</code>，默认使用的实现类为<code>SimpleApplicetionEventMulticaster</code></p>
</li>
</ol>
<p>Spring事件体系具体实现：</p>
<p>Spring在<code>ApplicationContext</code>接口的抽象实现类<code>AbstractApplicationContext</code>中完成了事件体系的搭建，</p>
<p><code>AbstractApplicationContext</code>中拥有一个<code>applicationEventMulticaster</code>成员变量，这个变量提供了容器监听器的注册表</p>
<p><code>AbstractApplicationContext</code>中关于事件的基础设施搭建在<code>refresh()</code>内部为以下步骤</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 5.初始化应用上下文事件广播器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"><span class="comment">// 7.注册事件监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"><span class="comment">// 9.完成刷新并发布容器刷新事件</span></span><br><span class="line">finishRefesh();</span><br></pre></td></tr></table></figure>

<p>5.初始化应用上下文事件广播器：用户可以在配置文件中为容器定义一个自定义的时间广播器，只要实现<code>ApplicationEventMulticaster</code>即可，Spring会通过反射机制将其注册成容器的时间广播器，如果没有，则Spring自动使用<code>SimpleApplicationEventMulticaster</code>作为事件广播器</p>
<p>7.Spring根据反射机制，从<code>BeanDefinitionRegistry</code>中找出所有实现<code>ApplicationListener</code>的Bean，将它们注册为容器的事件监听器，实际操作就是将其添加到事件广播器所提供的事件监听器注册表中</p>
<p>9.容器启动完成，调用事件发布接口向容器中所有的监听器发布事件</p>
<p>Spring事件实例：发送邮件实例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//事件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendEvent</span> <span class="keyword">extends</span> <span class="title">ApplicationContextEvent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> String to;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MailSendEvent</span><span class="params">(ApplicationContext source, String to)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(source);</span><br><span class="line">    <span class="keyword">this</span>.to = to;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getTo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.to;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//监听器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSendListener</span> <span class="keyword">implements</span> <span class="title">AppplicationListener</span>&lt;<span class="title">MailSendEvent</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">//对MailSendEnent事件进行处理</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(MailSendEvent event)</span></span>&#123;</span><br><span class="line">    MailSendEvent mse = (MailSendEvent) event;</span><br><span class="line">    System.out.println(<span class="string">&quot;MailSendListener:向&quot;</span>+mse.getTo()+<span class="string">&quot;发送完一封邮件&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//MailSender要拥有发布事件的能力，就必须实现ApplicationContextAware接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MailSender</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ApplicationContext ctx;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext ctx)</span> throw BeansException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMail</span><span class="params">(String to)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;MailSender:模拟发送邮件。。。&quot;</span>);</span><br><span class="line">    MailSendEvent mse = <span class="keyword">new</span> MailSendEvent(<span class="keyword">this</span>.ctx,to);</span><br><span class="line">    <span class="comment">//向容器的所有事件监听器发送事件</span></span><br><span class="line">    ctx.publishEvent(mse);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用MailSender发送邮件，（首先要注入MailSenderListener 和 MailSender）</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassXmlApplicationContext(<span class="string">&quot;cn/zhangyuying/beans.xml&quot;</span>)</span><br><span class="line">MailSender mailSender = (MailSender)ctx.getBean(<span class="string">&quot;mailSender&quot;</span>);</span><br><span class="line">mailSender.sendMail(<span class="string">&quot;aaa@bbb.com&quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring概述</title>
    <url>/2020/03/12/Spring/Spring%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>Spring是一个<code>full-stack</code> Java开源框架</p>
<span id="more"></span>

<p>Spring是分层的Java SE/EE应用一站式的轻量级开源框架，以 IOC（<code>Inverse of Control</code>,控制反转） 和 AOP（<code>Aspect Oriented Programming</code>,切面编程）为内核，提供了展现层Spring MVC、持久层Spring JDBC及业务层事物管理等一站式的企业级应用技术，此外，Spring以海纳百川的胸怀整合了开源世界里众多著名的第三方框架和类库，逐渐成为使用最多的轻量级Java EE企业应用开源框架</p>
<p>Spring体系结构，共五个模块：</p>
<ul>
<li><strong>IoC模块</strong>：主要有<code>Bean</code>,<code>Context</code>，<code>SpEL</code></li>
<li><strong>AOP模块</strong>：主要有<code>Spring AOP</code> 和 <code>Aspects</code></li>
<li><strong>Data模块</strong>：<code>JDBC</code>,<code>ORM</code>,<code>OXM</code>,<code>JMS</code>，事务管理等</li>
<li><strong>Web模块</strong>：<code>MVC</code>,<code>Portlet</code>,<code>Web Service</code>,<code>WebSocket</code>等</li>
<li><strong>Test模块</strong>：主要为测试框架</li>
</ul>
<p>具体学习目录：</p>
<ul>
<li>IoC模块<ol>
<li><a href="http://zhangyuying.cn/2020/03/12/Spring/IoC%E5%AE%B9%E5%99%A8/">IoC容器</a></li>
<li><a href="http://zhangyuying.cn/2020/03/12/Spring/%E5%9C%A8IoC%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%A3%85%E9%85%8DBean/">在IoC容器中装配置Bean</a></li>
<li><a href="http://zhangyuying.cn/2020/03/20/Spring/Spring%E5%AE%B9%E5%99%A8%E9%AB%98%E7%BA%A7%E4%B8%BB%E9%A2%98/">Spring容器高级主题</a></li>
</ol>
</li>
<li>AOP模块<ol>
<li><a href="http://zhangyuying.cn/2020/03/24/Spring/Spring-AOP%E5%9F%BA%E7%A1%80/">Spring AOP基础</a></li>
<li><a href="http://zhangyuying.cn/2020/03/26/Spring/%E5%9F%BA%E4%BA%8E@AspectJ%E7%9A%84AOP/">基于@AspectJ的AOP</a></li>
</ol>
</li>
<li>Data模块<ol>
<li><a href="http://zhangyuying.cn/2020/04/01/Spring/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/">Spring的事务管理</a></li>
<li><a href="http://zhangyuying.cn/2020/04/05/Spring/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E9%9A%BE%E7%82%B9%E5%89%96%E6%9E%90/">Spring的事务管理难点剖析</a></li>
</ol>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis的发布订阅</title>
    <url>/2022/08/23/Redis/Redis%E7%9A%84%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<p><code>Redis</code>提供了发布/订阅(<code>publish/subscribe</code>)模式。可以用于消息的传输。</p>
<p>Redis的发布订阅机制包括三个部分：发布者、<code>Channel</code>、订阅者，发送者(<code>publisher</code>)负责向频道(<code>Channel</code>)发送二进制的字符串消息，频道收到消息时，推送给订阅者(<code>subscriber</code>)。</p>
<span id="more"></span>

<ol>
<li>订阅的消费者需要一直执行，阻塞获取消息，如果断开则表示退订了。</li>
<li><code>channel</code> 只接收 <code>publish</code> 发送的消息，自身是不存储消息，假如 <code>channel</code> 没有被订阅，则消息会被丢弃掉。</li>
<li>生产者生成消息时，只需要向频道内丢入消息即可。</li>
</ol>
<p>消息传递大致如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="发布订阅示意图"></p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h4 id="基于频道订阅"><a href="#基于频道订阅" class="headerlink" title="基于频道订阅"></a>基于频道订阅</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span></span><br><span class="line">    <span class="comment">// 省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 就是保存客户端和订阅的频道信息</span></span><br><span class="line">    dict *pubsub_channels;  <span class="comment">/* Map channels to list of subscribed clients */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>pubsub_channels</code>是一个字典类型，保存着客户端和频道信息，<code>key</code> 是频道名，<code>value</code> 是客户端<code>Id</code>链表</p>
<p>基于频道订阅内部结构图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E8%AE%A2%E9%98%85-%E5%9F%BA%E4%BA%8E%E9%A2%91%E9%81%93%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="基于频道内部结构图"></p>
<h4 id="基于模式订阅-正则匹配"><a href="#基于模式订阅-正则匹配" class="headerlink" title="基于模式订阅(正则匹配)"></a>基于模式订阅(正则匹配)</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">redisServer</span> &#123;</span>  </span><br><span class="line">    <span class="comment">//省略...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储订阅模式的信息</span></span><br><span class="line">    <span class="built_in">list</span> *pubsub_patterns;  <span class="comment">/* A list of pubsub_patterns */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅模式列表结构：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">pubsubPattern</span> &#123;</span></span><br><span class="line">    client *client;  <span class="comment">// 订阅模式客户端</span></span><br><span class="line">    robj *pattern;   <span class="comment">// 被订阅的模式</span></span><br><span class="line">&#125; pubsubPattern;</span><br></pre></td></tr></table></figure>

<p>基于模式订阅内部结构图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Redis/%E8%AE%A2%E9%98%85-%E5%9F%BA%E4%BA%8E%E6%A8%A1%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="基于模式内部结构图"></p>
<h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 推送命令 </span></span><br><span class="line"><span class="attr">publish channel message :</span> <span class="string">把信息</span> <span class="string">message</span> <span class="string">发送到指定的频道</span> <span class="string">channel</span></span><br><span class="line"><span class="string">结果集返回是接收到</span> <span class="string">message</span> <span class="string">的订阅者数量，没有订阅者返回0。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 订阅命令</span></span><br><span class="line"><span class="number">1.</span><span class="string">subscribe</span> <span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>] <span class="string">:</span> <span class="string">订阅给定的一个或多个频道的信息</span></span><br><span class="line"><span class="number">2.</span><span class="string">psubscribe</span> <span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>] <span class="string">:</span> <span class="string">订阅一个或多个符合给定模式的频道</span></span><br><span class="line"><span class="string">模式支持glob风格的正则表达式。每个模式以*作为匹配符，比如it*</span> <span class="string">匹配所有以it开头的频道(it.news、it.blog等等)，news.*匹配所有以</span> <span class="string">news.开头的频道(news.it、news.global.today等等)，诸如此类。特殊字符使用</span> <span class="string">\</span> <span class="string">转义。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消订阅命令</span></span><br><span class="line"><span class="number">1.</span><span class="string">unsubscribe</span> [<span class="string">channel</span> [<span class="string">channel</span> <span class="string">...</span>]] <span class="string">:</span> <span class="string">指退订给定的频道</span></span><br><span class="line"><span class="string">若没有指定channel，则默认退订所有频道，在这种情况下，命令会返回一个信息，告知客户端所有被退订的频道。</span></span><br><span class="line"><span class="number">2.</span><span class="string">punsubscribe</span> [<span class="string">pattern</span> [<span class="string">pattern</span> <span class="string">...</span>]] <span class="string">:</span> <span class="string">退订所有给定模式的频道</span></span><br><span class="line"><span class="string">若没有指定pattern，则所有模式都会被退订，在这种情况下，命令会返回一个信息，告知客户端所有被退订的模式。</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看命令</span></span><br><span class="line"><span class="string">pubsub</span> <span class="string">&lt;subcommand&gt;</span> <span class="string">...</span> <span class="attr">args ... :</span> <span class="string">用于查看发布与订阅系统状态的命令,由数个不同格式的子命令组成</span></span><br><span class="line"><span class="string">(1)pubsub</span> <span class="string">channels</span> [<span class="string">pattern</span>] <span class="string">:</span> <span class="string">列出当前的活跃频道,活跃频道指的是那些至少有一个订阅者的频道，订阅模式的客户端不计算在内。pattern参数是可选的,如果不给出pattern参数，那么列出订阅与发布系统中的所有活跃频道。</span></span><br><span class="line"><span class="string">(2)pubsub</span> <span class="string">numsub</span> [<span class="string">channel-1</span> <span class="string">...</span> <span class="string">channel-N</span>] <span class="string">:</span> <span class="string">返回给定频道的订阅者数量，</span> <span class="string">订阅模式的客户端不计算在内。</span></span><br><span class="line"><span class="string">(3)pubsub</span> <span class="attr">numpat :</span> <span class="string">返回订阅模式的数量(</span> <span class="string">这个命令返回的不是订阅模式的客户端的数量，</span> <span class="string">而是客户端订阅的所有模式的数量总和)</span></span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ol>
<li><p>推送消息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 对没有订阅者的频道发送信息</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">publish</span> <span class="string">channel_1</span> <span class="string">&quot;message1&quot;</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有一个订阅者的频道发送信息</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">publish</span> <span class="string">channel_2</span> <span class="string">&quot;message2&quot;</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向有多个订阅者的频道发送信息</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">publish</span> <span class="string">channel_3</span> <span class="string">&quot;message3&quot;</span></span><br><span class="line"><span class="string">(integer)</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>订阅消息</p>
<p>（1）基于频道订阅</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.订阅</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">SUBSCRIBE</span> <span class="string">channel_1</span> <span class="string">channel_2</span></span><br><span class="line"><span class="string">Reading</span> <span class="string">messages...</span> <span class="string">(press</span> <span class="string">Ctrl-C</span> <span class="string">to</span> <span class="string">quit)</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;subscribe&quot;</span>    <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;channel_1&quot;</span>    <span class="comment"># 订阅的频道名字</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">(integer)</span> <span class="number">1</span>    <span class="comment"># 目前已订阅的频道数量</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;subscribe&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;channel_2&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">(integer)</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;message&quot;</span>    <span class="comment">#返回值的类型：信息</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;channel_1&quot;</span>  <span class="comment">#来源(从那个频道发送过来)</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;test1&quot;</span>      <span class="comment">#消息内容</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;message&quot;</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;channel_1&quot;</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;test2&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.查看</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">PUBSUB</span> <span class="string">numsub</span> <span class="string">channel_1</span> <span class="string">channel_2</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;channel_1&quot;</span>    <span class="comment"># 频道名称</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">(integer)</span> <span class="number">1</span>    <span class="comment"># 订阅该频道的客户端数量</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;channel_2&quot;</span></span><br><span class="line"><span class="number">4</span><span class="string">)</span> <span class="string">(integer)</span> <span class="number">1</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">pubsub</span> <span class="string">channels</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;channel_1&quot;</span>    <span class="comment"># 频道名称</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;channel_2&quot;</span>    <span class="comment"># 频道名称</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.退订</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">UNSUBSCRIBE</span> <span class="string">channel_1</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;unsubscribe&quot;</span>  <span class="comment"># 返回值的类型：显示取消订阅成功</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;channel_1&quot;</span>    <span class="comment"># 取消订阅的频道名字</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">(integer)</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>（2）基于频道订阅</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 1.订阅</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">PSUBSCRIBE</span> <span class="string">it.*</span></span><br><span class="line"><span class="string">Reading</span> <span class="string">messages...</span> <span class="string">(press</span> <span class="string">Ctrl-C</span> <span class="string">to</span> <span class="string">quit)</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;psubscribe&quot;</span>       <span class="comment"># 返回值的类型：显示订阅成功</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;it.*&quot;</span>             <span class="comment"># 订阅的模式</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">(integer)</span> <span class="number">1</span>        <span class="comment"># 目前已订阅的模式的数量</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;pmessage&quot;</span>         <span class="comment"># 返回值的类型：信息</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;it.*&quot;</span>             <span class="comment"># 信息匹配的模式</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">&quot;it.list&quot;</span>          <span class="comment"># 信息本身的目标频道</span></span><br><span class="line"><span class="number">4</span><span class="string">)</span> <span class="string">&quot;test msg&quot;</span>         <span class="comment"># 信息的内容</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.退订</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:6379&gt;</span> <span class="string">PUNSUBSCRIBE</span> <span class="string">it.*</span></span><br><span class="line"><span class="number">1</span><span class="string">)</span> <span class="string">&quot;punsubscribe&quot;</span>  <span class="comment"># 返回值的类型：显示退订成功</span></span><br><span class="line"><span class="number">2</span><span class="string">)</span> <span class="string">&quot;it.*&quot;</span>          <span class="comment"># 退订的模式</span></span><br><span class="line"><span class="number">3</span><span class="string">)</span> <span class="string">(integer)</span> <span class="number">1</span>     <span class="comment"># 目前已退订的模式的数量</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：轻量级，使用简单方便</p>
<p>缺点：不可保证准确性，Redis本身是不会存储发布订阅消息的，所以可能会存在消息丢失的情况（比如网络抖动，消费者挂掉一段时间）</p>
<hr>
<p>参考资料</p>
<p><a href="https://xie.infoq.cn/article/34a190ee13a3436ae20759723">通俗易懂的 redis 发布订阅原理实现！</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/136484218">Redis总结（五）redis发布订阅模式</a></p>
<p><a href="https://www.redis.com.cn/commands/pubsub.html">Redis发布订阅命令</a></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的事务管理</title>
    <url>/2020/04/01/Spring/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>Spring不但提供了和底层事务源无关的事务抽象，还提供了声明性事务的功能，可以让程序从事务代码中解放出来</p>
<span id="more"></span>

<h4 id="Spring对事务管理的支持"><a href="#Spring对事务管理的支持" class="headerlink" title="Spring对事务管理的支持"></a>Spring对事务管理的支持</h4><p>Spring为事务管理提供了一致的编程模板，在高层次建立了统一的事务抽象，也就是说，不管是选择什么ORM框架，Spring都可以让用户用统一的编程模型进行事务管理</p>
<p>Spring提供了事务模板类<code>TransactionTemplate</code>，通过<code>TransactionTemplate</code>并配合使用事务回调<code>TransactionCallback</code>指定具体的持久化操作，就可以通过编程方式实现事务管理</p>
<p>Spring事务管理的亮点在于声明式事务管理，Spring允许通过声明方式，在IoC配置中指定事务的边界和事务属性，Spring自动在指定的事物边界上应用事务属性。(Spring在单数据源的时候，直接使用底层的数据源管理事务)</p>
<h5 id="事物管理关键抽象："><a href="#事物管理关键抽象：" class="headerlink" title="事物管理关键抽象："></a>事物管理关键抽象：</h5><p>Spring事务的SPI(<code>Service Provider Interface</code>)的抽象层在<code>orga.springframework.transaction</code>包中，主要包括3个接口：<code>PlatformTransactionManager</code>、<code>TransactionDefinition</code>和<code>TransactionStatus</code></p>
<blockquote>
<p>SPI：在此可理解为：服务提供接口，给第三方服务实现类提供的接口实现要求)</p>
</blockquote>
<ul>
<li><p><code>TransactionDefinition</code></p>
<p>定义了Spring兼容的事务属性，这些属性对事物管理控制的若干方面进行配置</p>
<ul>
<li><p>事务隔离，当前事务和其他事务的隔离程度，定义了和<code>java.sql.Connection</code>接口中同名的4个隔离级别：</p>
<ul>
<li><code>ISOLATION_READ_UNCOMMITTED</code></li>
<li><code>ISOLATION_READ_COMMITTED</code></li>
<li><code>ISOLATION_REPEATABLE_READ</code></li>
<li><code>ISOLATION_SERIALIZABLE</code></li>
</ul>
<p>此外还定义了一个默认的隔离级别：<code>ISOLATION_DEFAULT</code>，表示使用底层数据库的默认隔离级别</p>
</li>
<li><p>事务传播：Spring提供了几个可选的事物传播类型，后续介绍</p>
</li>
<li><p>事务超时：事务在超时前能运行多久，超过时间后，事物被回滚，有些事务不支持事务过期的功能，这时，如果设置了<code>TIME_DEFAULT</code>之外的其他值，则将抛出异常</p>
</li>
<li><p>只读状态：只读事务不修改任何数据，资源事务管理者可以针对可读事务应用一些优化措施，提高运行性能，试图在只读事务中更改数据将引发异常</p>
</li>
</ul>
<p>Spring允许通过XML配置、注解元数据或手动编程的方式，为一个有事务要求的服务类方法配置事务属性，这些信息作为Spring事务管理框架的“输入”，Spring将自动按事务属性信息的指示，为目标方法提供相应的事物支持</p>
</li>
<li><p><code>TransactionStatus</code></p>
<p>代表一个事务的具体运行状态，事务管理器可以通过该接口获取事务运行期的状态信息，也可以通过该接口间接的回滚事务，相比于抛出异常时回滚事务的方式更具可控性</p>
<p>该接口继承于<code>SavepointManager</code>接口，<code>SavepointManager</code>接口提供了保存点相关的方法，在底层资源不支持保存点时，这些方法都将抛出<code>NestedTransactionNotSupportedException</code>异常</p>
<p><code>TransactionStatus</code>提供了一下几个方法：</p>
<ul>
<li><code>boolean hasSavepoint()</code>：判断当前事务是否在内部创建了一个保存点，该保存点是为了支持Spring的嵌套事务而创建的</li>
<li><code>boolean isNewTransaction()</code>：判断当前事务是否是一个新的事务，<code>false</code>代表当前事务是一个已经存在的事务，或者当前操作为运行在事务环境中</li>
<li><code>boolean isCompleted()</code>：判断当前事务是否已经结束（已经提交或回滚）</li>
<li><code>boolean isRollbackOnly()</code>：判断当前事务是否已经被标识为<code>rollbak-only</code></li>
<li><code>void setRollbackOnly()</code>：将当前事务设置为<code>rollback-only</code>，通过该标识通知事务管理器只能将事务回滚，事务管理器将通过显示调用回滚命令或抛出异常的方式回滚事务</li>
</ul>
</li>
<li><p><code>PlatformTransactionManager</code></p>
<p>通过JDBC的事物管理知识可知，事务只能被提交或回滚(或回滚到某个保存点后提交)，Spring高层事务抽象接口<code>PlatformTransactionManager</code>很好的描述了这个概念，其中只定义了3个接口方法，他们是SPI高层次的接口方法</p>
<ul>
<li><code>TransactionStatus getTransaction(TransactionDefinition definition)</code>：该方法根据事务定义信息从事务环境中返回一个已存在的事务，或者创建一个新的事务，并用<code>TransactionStatus</code>描述这个事务的状态</li>
<li><code>commit(TransactionStatus status)</code>：根据事务的状态提交事务。如果事务状态已经被标识为<code>rollback-only</code>，则该方法将执行一个回滚事务的操作</li>
<li><code>rollback(TransactionStatus status)</code>：将事务回滚，当<code>commit()</code>方法抛出异常时，<code>rollback()方</code>法会被隐式调用</li>
</ul>
</li>
</ul>
<h5 id="Spring事务管理器实现类："><a href="#Spring事务管理器实现类：" class="headerlink" title="Spring事务管理器实现类："></a>Spring事务管理器实现类：</h5><p>Spring将事务管理委托给底层具体的持久化实现框架来完成，因此Spring为不同的持久化框架提供了<code>PlatformTransactionManager</code>接口的实现类</p>
<ul>
<li><code>JpaTransactionManager</code></li>
<li><code>HibernateTransactionManager</code></li>
<li><code>JdoTransactionManager</code></li>
<li><code>DataSourceTransactionManager</code>：使用Spring JDBC 或Mybatis等基于<code>DataSource</code>数据源持久化技术时，选择该事务管理器</li>
<li><code>JtaTransactionManager</code>：具有多个数据源的全局事务使用该事务管理器（不管采用何种持久化技术）</li>
</ul>
<p>要实现事务管理，首先要在Spring中配置好相应的事务管理器，为事务管理器指定数据资源及一些其他事务管理控制属性，以<code>DataSourceTransactionManager</code>事务管理器配置为例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置一个数据源--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span>  </span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;org.apche.commons.dbcp.BasicDataSource&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">p:driverClassName</span>=<span class="string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">P:url</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">p:username</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">P:password</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--基于数据源的事务管理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span>   </span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:dataSource-ref</span>=<span class="string">&quot;dataSource&quot;</span>/&gt;</span>   <span class="comment">&lt;!--引用数据源--&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="事务同步管理器"><a href="#事务同步管理器" class="headerlink" title="事务同步管理器"></a>事务同步管理器</h5><p>Spring将JDBC的<code>Connection</code>、Hibernate的<code>session</code>等访问数据库连接或会话对象统称为资源，这些资源在同一时刻是不能多线程共享的，为了让Dao、Service类可能做到<code>singleton</code>：Spring事务同步管理器类<code>TransactionSynchronizationManager</code>使用<code>ThreadLocal</code>为不同的事务线程提供了独立的资源副本，同时维护事务的属性和状态信息</p>
<p>事务同步管理器是Spring事务管理的基石，不管是编程式事务还是声明式事务，都离不开事务同步管理器</p>
<p>Spring框架为不同的持久化技术提供了一套从<code>TransactionSynchronizationManager</code>中获取对应线程绑定资源的工具类：</p>
<ul>
<li>Spring JDBC或Mybatis：<code>DataSourceUtils</code></li>
<li>Hibernate：<code>SessionFactoryUtils</code></li>
<li>JPA：<code>EntityManagerFactoryUtils</code></li>
<li>JDO：<code>PersistenceManagerFactoryUtils</code></li>
</ul>
<p>这些类都提供了静态方法，通过这些方法可以获取和当前线程绑定的资源，如：<code>DataSourceUtils.getConnection(DataSource dataSource)</code>，可以从指定数据源中获取和当前线程绑定的<code>Connection</code></p>
<blockquote>
<p>这些工具类还有一个重要用途：将特定的异常转换为Spring的DAO异常</p>
</blockquote>
<p>Spring为不同的持久化技术提供的模版类，内部就是通过资源获取工具间接访问<code>TransactionSynchronizationManager</code>中线程绑定资源，所以如果Dao使用模版类进行持久化操作，这些Dao就可以配置成<code>singleton</code>，也可以直接通过资源获取工具访问线程相关的资源</p>
<p><code>TransactionSynchronizationManager</code>：将Dao、Service类中影响线程安全的所有“状态”统一抽取到该类中，并用<code>ThreadLocal</code>进行替换，从此Dao(必须是基于模版类或资源获取工具类创建的)和Service(必须采用Spring事务管理机制)不再是非线程安全的，其中部分“状态”如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionSynchronizationManager</span> </span>&#123;</span><br><span class="line">  <span class="comment">//(1)用于保存每个事务线程对应的Connection或session等类型的资源</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal resources = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">  <span class="comment">//(2)用于保存每个事务线程对应事务名称</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal currentTransactionName = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">  <span class="comment">//(3)用于保存每个事务线程对应事务的read-only状态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal currentTransactionReadOnly = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">  <span class="comment">//(4)用于保存每个事务线程对应事务的隔离级别</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal currentTransactionIsolationLevel = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">  <span class="comment">//(5)用于保存每个事务线程对应事务的激活态</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal actualTransactionActive = <span class="keyword">new</span> ThreadLocal();</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="事务传播行为"><a href="#事务传播行为" class="headerlink" title="事务传播行为"></a>事务传播行为</h5><p>Spring通过事务传播行为控制当前的事务如何传播到被嵌套调用的目标服务接口方法中（即方法嵌套调用）</p>
<p>Spring在<code>TransactionDefinition</code>接口中规定了7种类型的事务传播行为，他们规定了事务方法和事务和事务方法发生嵌套调用时事务如何进行传播</p>
<ul>
<li><p><code>PROPAGATION_REQUIRED</code>：如果当前没有事务，则新建一个事务；如果已存在一个事务，则加入到这个事务中，这是最常见的选择</p>
</li>
<li><p><code>PROPAGATION_SUPPORTS</code>：支持当前事务。如果当前没有事务，则以非事务方式执行</p>
</li>
<li><p><code>PROPAGATION_MANDATORY</code>：使用当前的事务。如果当前没有事务，则抛出异常</p>
</li>
<li><p><code>PROPAGATION_REQUIRES_NEW</code>：新建事务。如果当前存在事务，则把当前事务挂起</p>
</li>
<li><p><code>PROPAGATION_NOT_SUPPORTED</code>：以非事务方式执行操作。如果当前存在事务，则把当前事务挂起</p>
</li>
<li><p><code>PROPAGATION_NEVER</code>：以非事务方式执行。如果当前存在事务，则抛出异常</p>
</li>
<li><p><code>PROPAGATION_NESTED</code>：如果当前存在事务，则在嵌套事务内执行；如果当前没有事务，则执行与<code>PROPAGATION_REQUIRED</code>类似的操作</p>
<blockquote>
<p>在使用<code>PROPAGATION_NESTED</code>时，底层的数据源必须基于JDBC3.0，并且实现者需要支持保存点事务机制</p>
</blockquote>
</li>
</ul>
<h4 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h4><ul>
<li><p>编程式事务管理</p>
<p>很少使用，Spring为编程式事务管理提供了模版类：<code>TransactionTemplate</code>，以满足特殊场景的需要</p>
<p><code>TransactionTemplate</code>是线程安全的，有两个主要方法</p>
<ul>
<li><code>void setTransactionManager(PlatformTransactionManager transactionManager)</code>：设置事务管理器</li>
<li><code>Object execute(TransactionCallback action)</code>：在<code>TransactionCallback</code>回调接口中定义需要以事务方式组织的数据访问逻辑</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumService</span> </span>&#123;</span><br><span class="line">	<span class="keyword">public</span> ForumDao forumDao;</span><br><span class="line">  <span class="keyword">public</span> TransactionTemplate template;</span><br><span class="line">  <span class="meta">@Autowired</span>  <span class="comment">//自动注入模版类</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTemplate</span><span class="params">(TransactionTemplate template)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.template = template;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//TranscationCallbackWithoutResult是TransactionCallback的子接口</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addForum</span><span class="params">(<span class="keyword">final</span> Forum forum)</span></span>&#123;</span><br><span class="line">    template.execute(<span class="keyword">new</span> TranscationCallbackWithoutResult()&#123;</span><br><span class="line">      <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doInTransactionWithoutResult</span><span class="params">(TransactionStatus status)</span></span>&#123;</span><br><span class="line">        forumDao.addForum(forum);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果回调接口方法中需要显式访问底层数据库连接，则必须通过资源获取工具类得到线程绑定的数据连接</p>
</li>
<li><p>声明式事务管理</p>
<p>是Spring中的亮点。对代码侵入性小，让事务管理代码从业务代码中移除，<strong>Spring的声明式事务管理是通过Spring AOP实现的</strong>，通过事务的声明性信息，Spring负责将事务管理增强逻辑动态织入业务方法的相应连接点中</p>
<blockquote>
<p>值得提前说明的是，在Spring的事务管理中关于回滚：默认情况下，Spring的声明式事务只在遇到运行期异常时自动回滚，而发生检查型异常既不回滚也不提交，控制权交给外层调用</p>
</blockquote>
<ul>
<li><p>使用XML配置声明式事务</p>
<ul>
<li><p>使用原始的<code>TransactionProxyFactoryBean</code></p>
<p>低版本Spring使用，已经不被推荐，简单示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用事务代理工厂类为目标业务Bean提供事务增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bbtForum&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.transaction.interceptor.TransactionProxyFactoryBean&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:transactionManager-ref</span>=<span class="string">&quot;txManager&quot;</span>   //指定事务管理器</span></span><br><span class="line"><span class="tag">      <span class="attr">P:target-ref</span>=<span class="string">&quot;bbtForumTarget&quot;</span> &gt;</span>    //指定目标业务Bean</span><br><span class="line">      <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;transactionAttributes&quot;</span>&gt;</span>  //事务属性配置</span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;get*&quot;</span>&gt;</span>PROPAGATION_REQUIRED,readOnly<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> //只读事务</span><br><span class="line">          <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;*&quot;</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="name">prop</span>&gt;</span> //可写事务</span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>      </span><br></pre></td></tr></table></figure>
</li>
<li><p>基于<code>aop/tx</code>命名空间的配置</p>
<p>基于上述示例，使用基于aop/tx命名空间的配置修改如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--使用强大的切点表达式语言轻松定义目标方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--通过aop定义事务增强切面--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;serviceMethod&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">expression</span>=<span class="string">&quot;execution(* cn.zhangyuying.Service.*Forum.*(..))&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--引用事务增强--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;serviceMethod&quot;</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txAdvice&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--事务增强--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txAdvice&quot;</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--事务属性定义--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;get*&quot;</span> <span class="attr">read-only</span>=<span class="string">&quot;false&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;add*&quot;</span> <span class="attr">rollback-for</span>=<span class="string">&quot;Exception&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;update*&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>使用注解配置声明式事务</p>
<p>Spring提供了基于注解的事务配置，即通过<code>@Transactional</code>对需要增强的Bean接口、实现类或方法进行标注，在容器中配置基于注解的事务增强驱动，即可启用基于注解的声明式事务</p>
<ol>
<li><p>使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BbtForum</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addForum</span><span class="params">(Forum forum)</span></span>&#123;</span><br><span class="line">    forum.addForum(forum)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然注解只提供元数据，本身并不能完成事务切面织入的功能，因此还需要在Spring配置文件中通过配置“通知”Spring容器对标注<code>@Transactional</code>注解的Bean进行加工处理：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--对标注@Transactional注解的Bean进行加工处理，以织入事务管理切面--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;txManager&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>默认情况下，<code>&lt;tx:annotation-driven&gt;</code>会自动使用名为<code>“transactionManager”</code>的事务管理器，所以如果事务管理器的<code>id</code>为<code>transactionManager</code>就不用在额外配置<code>transaction-manager</code>属性</p>
<p><code>&lt;tx:annotation-driven&gt;</code>还有另外两个属性：</p>
<ul>
<li><code>Proxy-target-class</code>：如果为<code>true</code>，Spring通过创建子类来代理业务类，此时需要在类路径中添加CGLib.jar类库，如果为<code>false</code>，则使用基于接口的代理</li>
<li><code>order</code>：如果业务类除事务切面外，还需要织入其他的切面，则通过该属性可以控制事务切面在目标连接点的织入顺序</li>
</ul>
</li>
<li><p><code>@Transactional</code>的属性</p>
<p><code>@Transactional</code>拥有一些普适性很强的默认事务属性，往往可以使用这些属性的默认值</p>
<ul>
<li>事务传播行为（<code>propagation</code>）：默认<code>PROPAGATION_REQUIRED</code></li>
<li>事务隔离级别（<code>isolation</code>）：默认<code>ISOLATION_DEFAULT</code></li>
<li>读写事务属性（<code>readOnly</code>）：读/写事务</li>
<li>超时时间（<code>timeout</code>）：依赖于底层的事务系统的默认值</li>
<li>回滚设置：默认为任何运行期异常引发回滚，任何检查型异常不会引发回滚<ul>
<li><code>rollbackFor</code>：一组异常类，遇到时回滚</li>
<li><code>rollbackForClassName</code>：一组异常类名，遇到时回滚</li>
<li><code>noRollbackFor</code>：遇到时不回滚</li>
<li><code>noRollbackForClassName</code>：遇到时不回滚</li>
</ul>
</li>
</ul>
</li>
<li><p><code>@Transactional</code>在何处标注</p>
<p>可被应用于接口定义和接口方法、类定义和类的<code>public</code>方法上，方法处的注解会覆盖类定义处的注解</p>
<p>Spring建议在业务实现类上使用<code>@Transactional</code>注解（避免CGLib代理不到）</p>
</li>
<li><p>使用不同的事务管理器</p>
<p>如果希望在不同的地方使用不同的事务管理器，可以通过如下方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForumService</span> </span>&#123;</span><br><span class="line">  <span class="comment">//使用名为topic的事务管理器</span></span><br><span class="line">  <span class="meta">@Transactional(&quot;topic&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTopic</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//使用名为forum的事务管理器</span></span><br><span class="line">  <span class="meta">@Transactional(&quot;forum&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateForum</span><span class="params">()</span></span>&#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在XML中分别定义<code>topic</code>和<code>forum</code>的事务管理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;forumTxManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.spring.jdbc.datasource.DataSourceTransactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:datasource-ref</span>=<span class="string">&quot;forumDataSource&quot;</span>&gt;</span> //使用不同的数据源</span><br><span class="line">  <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;forum&quot;</span> /&gt;</span> //为事务管理器指定一个名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;topicTxManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.spring.jdbc.datasource.DataSourceTransactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:datasource-ref</span>=<span class="string">&quot;topicDataSource&quot;</span>&gt;</span> //使用不同的数据源</span><br><span class="line">  <span class="tag">&lt;<span class="name">qualifier</span> <span class="attr">value</span>=<span class="string">&quot;topic&quot;</span> /&gt;</span> //为事务管理器指定一个名字</span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过AspectJ LTW引入事务切面</p>
<p>Spring提供了对AspectJ切面的支持，在<code>org.springframework.aspects-&#123;version&#125;.jar</code>中有一个用AspectJ语法编写的<code>AnnotationTransactionAspect</code>切面类，用于为使用了<code>@Transactional</code>注解的业务类提供事务增强，通过一下三步进行使用</p>
<ol>
<li><p>JVM参数添加：<code>-javaagent:D:\spring\dist\org.springframework.aspects-&#123;version&#125;.jar</code></p>
</li>
<li><p>在类路径META-INF目录下提供如下AspectJ配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aspectj</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">aspects</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aspect</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework.transaction.aspectj.AnnotationTransactionAspect&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aspects</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">weaver</span> <span class="attr">options</span>=<span class="string">&quot;-showWeaveInfo -XmessageHandlerClass:org.springframework.aop.aspectj.AspectJWeaverMessageHandler&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">within</span>=<span class="string">&quot;cn.zhangyuying.service.impl.*&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">weaver</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aspectj</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>利用Spring IoC为切面类提供事务管理器的注入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionmanager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:dataSource-ref</span>=<span class="string">&quot;dataSource&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring的事务管理难点剖析</title>
    <url>/2020/04/05/Spring/Spring%E7%9A%84%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86%E9%9A%BE%E7%82%B9%E5%89%96%E6%9E%90/</url>
    <content><![CDATA[<p>Spring声明式事务时Spring最核心、最常用的功能，一般无需了解内部细节，但同时也会造成许多迷惑</p>
<span id="more"></span>

<p>本篇主要剖析解释一些常见的迷惑点</p>
<ol>
<li><p>Spring事务不是被必须使用的，在没有事务管理的情况下，DAO也是正常工作的</p>
</li>
<li><p>应用的三层结构（Web、Service、DAO）只是参考开发模式，不是事务管理工作的必要条件</p>
</li>
<li><p>对于事务控制的大多数属性，Spring都是借助底层资源的功能来完成的，但是事务的传播行为是凭借自身框架提供的功能，Spring通过事务传播行为可以很好的应对事务方法嵌套调用的情况，开发者无需为了事务管理而刻意改变方法的设计</p>
<blockquote>
<p>错误谣言：两个事务方法，不能嵌套调用，会产生两个事务</p>
</blockquote>
</li>
<li><p>由于单实例的对象(无状态的)不存在线程安全问题，所以经过Spring事务管理增强的单实例Bean可以很好的工作在多线程环境下</p>
<p>在相同线程中进行相互嵌套调用的事务方法工作在相同的事务中，如果这些相互嵌套调用的方法工作在不同的线程中，则不同线程下的事务方法工作在独立的事务中</p>
</li>
<li><p>混合使用多个数据访问技术框架的最佳组合是一个ORM技术框架（如Hibernate或JPA等）+一个JDBC技术框架（如Spring JDBC或MyBatis），直接使用ORM技术框架对应的缓存处理器就可以了，但是必须考虑ORM缓存同步的问题</p>
<blockquote>
<p>因为ORM框架的缓存同步问题，混合使用时建议只用JDBC框架进行读操作</p>
</blockquote>
</li>
<li><p>Spring AOP事务增强有两个方案，其一为基于接口的动态代理，其二为基于CGLib动态生成子类的代理，由于Java语法的特性，有些特殊方法不能被Spring AOP代理，所以也就无法享受AOP织入带来的事务增强</p>
<p>这些特殊方法为：</p>
<ul>
<li>基于接口的动态代理：除public外的其他所有方法，此外，public static 也不能被增强</li>
<li>基于CGLib的动态代理：private、static、final方法</li>
</ul>
<p>不过这些不能被Spring事务增强的特殊方法，并非就不工作在事务环境下，只要他们被外层的事务方法调用了，由于Spring事务管理的传播级别，内部方法也可以工作在外部方法所启动的事务上下文中</p>
<p>我们所说的不能被Spring进行AOP事务增强，是指这些方法不能启动事务，但是外层方法的事务上下文依旧可以顺利传播到这些方法中，区别是：是否可以主动启动一个事务</p>
</li>
<li><p>在使用Spring JDBC（其他数据技术访问框架可以类比）时如果直接获取<code>Connection</code>，则可能会造成连接泄漏，为了降低连接泄漏的可能性，尽量使用 <code>DataSourceUtils</code>获取数据连接，也可以对数据源进行代理，以便使数据源拥有感知事务上下文的能力</p>
<p>Spring承诺：只要程序都使用Spring DAO的模版（如<code>JDBCTemplate</code>）进行数据访问，就不会存在数据连接泄漏的问题</p>
<blockquote>
<p>Spring在提供的模版类中，对于数据连接，均在<code>finally</code>方法中进行了释放</p>
</blockquote>
<p>如果业务非要自己获取数据连接</p>
<ul>
<li><p>通过<code>DataSourceUtils</code>获取数据连接</p>
<p>事务环境下不会产生连接泄漏问题，但是非事务环境下，依然会存在连接泄漏的问题</p>
</li>
<li><p>可以使用<code>TransactionAwareDataSourceProxy</code>对数据源进行代理</p>
<p>数据源被代理后就具有了事务上下文感知能力，即如果对数据源进行了代理，而且方法存在事务上下文，那么也不会产生连接泄漏的问题</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>在IoC容器中装配Bean</title>
    <url>/2020/03/13/Spring/%E5%9C%A8IoC%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%A3%85%E9%85%8DBean/</url>
    <content><![CDATA[<p>Spring启动时读取应用程序提供的Bean配置信息，并在Spring容器生成一份相应的Bean配置注册表，然后根据这个张注册表实例化Bean，装配好Bean之间的依赖关系，为上层应用提供准备就绪的运行环境</p>
<span id="more"></span>

<p>Bean配置信息是Bean的元数据信息，由4方面组成</p>
<ul>
<li>Bean的实现类</li>
<li>Bean的属性信息，如数据源的连接数、用户名、密码等</li>
<li>Bean的依赖关系，Spring根据依赖关系配置完成Bean之间的装配</li>
<li>Bean的行为配置，如生命周期范围及生命周期各过程的回调函数</li>
</ul>
<p>Spring容器、Bean配置信息、Bean实现类及应用程序四者的相互关系，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/Spring%E5%AE%B9%E5%99%A8%E5%86%85%E9%83%A8%E5%8D%8F%E4%BD%9C%E8%A7%A3%E6%9E%84.jpg" alt="Spring容器内部协作解构"></p>
<p>Bean元数据信息在Spring容器中内部对应物是由一个个<code>BeanDefinition</code>形成的Bean注册表，Spring实现了Bean元数据信息内部表示和外部定义的解耦，Spring支持多种形式的Bean配置方式（不同的配置方式在“质”上是基本相同的，只是存在“形”的区别，他们不存在谁替代谁，他们都有自己适合的应用场景）：</p>
<ul>
<li>基于XML的配置</li>
<li>基于注解的配置</li>
<li>基于Java类的配置</li>
</ul>
<h4 id="Bean的作用域"><a href="#Bean的作用域" class="headerlink" title="Bean的作用域"></a>Bean的作用域</h4><p>在查看对应的配置之前，先了解一下Bean的作用域，Spring支持的Bean的作用域类型如下：</p>
<ul>
<li><p><code>singleton</code>：仅存在一个Bean实例，Bean以单实例的方式存在，默认即<code>singleton</code></p>
<p>Spring利用AOP和<code>LocalThread</code>功能，对非线程安全的变量(或称状态)进行了特殊处理，使非线程安全的类变成了线程安全的类，因为Spring这一超越，所以Spring的默认作用域为<code>singleton</code></p>
<p><code>lazy-init=&quot;true&quot;</code>属性可以控制在不被其他提前实例化的Bean引用时,Bean的延迟实例化</p>
</li>
<li><p><code>prototype</code>：每次从容器中调用Bean都返回一个新的实例</p>
</li>
<li><p><code>request</code>：每次HTTP请求都会创建一个新的Bean，该作用域仅适用于<code>WebApplicationContext</code>环境</p>
</li>
<li><p><code>session</code>：同一个HTTP Session共享一个Bean，不同的HTTP Session使用不同的Bean，该作用域仅适用于<code>WebApplicationContext</code>环境</p>
</li>
<li><p><code>globalSession</code>：同一个全局Session共享一个Bean，该作用域仅适用于<code>WebApplicationContext</code>环境</p>
<p>一般用于Porlet应用环境，不在Porlet Web环境下，<code>globalSession</code>作用域等价于<code>session</code>作用域</p>
</li>
</ul>
<p>除此之外用户也可以通过<code>org.springframework.beans.factory.config.Scope</code>接口自己定义作用域</p>
<p>Web应用环境相关Bean作用域：</p>
<p>在使用Web应用环境的单个作用之前，需要在Web容器中进行额外的配置，如下示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--Servlet 2.3之前--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.RequestContextFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>requestContextFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span> <span class="comment">&lt;!--对所有URL进行拦截--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--高版本--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">listener-class</span>&gt;</span></span><br><span class="line">    org.springframework.web.context.request.RequestContextListener</span><br><span class="line">  <span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Web初始化时，通过<code>ContextLoaderListener</code>（或<code>ContextLoaderServlet</code>）将Web容器和Spring容器进行了整合</p>
<p><code>ContextLoaderListener</code>实现了<code>ServletContextListener</code>监听器接口。负责监听Wrb容器启动和关闭的时间</p>
<p><code>RequestContextListener</code>实现了<code>ServletRequestListener</code>监听器接口，负责监听HTTP请求事件，Web服务器接收的每一次请求都会通知该监听器</p>
<p>即Spring容器Bean需要使用Web相关的作用域，其本身就必须获得Web容器的HTTP请求事件，所以需要额外配置<code>RequestContextListener</code></p>
<h4 id="基于XML的配置"><a href="#基于XML的配置" class="headerlink" title="基于XML的配置"></a>基于XML的配置</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--（1）id和name都可以指定多个名字，id是唯一的，name可以重复，重复后，存在覆盖情况getBean(name)获取的是后面声明的那个.如果两个属性都未指定，则Spring将自动将全限定类名作为Bean的名称--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user,#user,123&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--（2）属性注入，前提是Bean需要提供一个默认的构造函数，并为需要注入的属性提供对应的Setter方法</span></span><br><span class="line"><span class="comment">   Spring中必须满足：变量的前两个字母要么全部大写，要么全部小写--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--（3）构造函数注入，前提是Bean必须提供带参的构造函数</span></span><br><span class="line"><span class="comment">	找到构造函数对应参数的方式：1.通过类型：type 2.通过参数索引：index </span></span><br><span class="line"><span class="comment">							 3.通过类型和索引一起 4.通过自身类型反射匹配入参（非基础数据类型且入参类型各异）--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">index</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">index</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;niu&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--（4）工厂方法注入——一般不推荐使用，需要额外的类和代码，可以选择更优雅的方式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.UserFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;createUser&quot;</span>/&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--（5）注入参数详解--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.字面值，指可用字符串表示的值，可以通过&lt;value&gt;元素标签进行注入，</span></span><br><span class="line"><span class="comment">		默认情况下，基本数据类型及其封装类、String等类型都可以采取字面值注入的方式</span></span><br><span class="line"><span class="comment">		(Spring容器内部我字面值提供了编译器，可以将字符串标识的字面量转换为内部变量的相应类型)&gt;--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>&lt;![CDATA[zhang&amp;san]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span><span class="comment">&lt;!--&lt;![CDATA[zhang&amp;san]]&gt;可替换为：zhang&amp;amp;san--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;20&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.引用其他Bean:(1).定义bean,通过&lt;ref&gt;元素引用Bean </span></span><br><span class="line"><span class="comment">				(2).内部Bean，只被当前Bean使用，而不被任何其他的Bean引用,即使提供了id、name、scope也会被忽略,scope默认为prototype--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> =<span class="string">&quot;car&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;car&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> =<span class="string">&quot;city&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;beijing&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span> =<span class="string">&quot;car&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.Car&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;price&quot;</span> <span class="attr">vlaue</span>=<span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--3.设置null值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">null</span>/&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--4.级联属性,以圆点(.)的方式定义级别属性，此时要保证内部的car在定义时设置初始化对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car.price&quot;</span> <span class="attr">value</span>= <span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;car.factory.name&quot;</span> <span class="attr">value</span>= <span class="string">&quot;2000&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--5.集合类型属性，主要包括List、Set、Map、Properties--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--list--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--可以通过字符串字面量进行配置的属性类型的对应数组类型属性(String[]、int[])，也可采用&lt;list&gt;方式进行配置--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;city&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--set--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;favorites&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span>看书<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;city&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--map--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;jobs&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">value</span>&gt;</span>AM<span class="tag">&lt;/<span class="name">value</span>&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">value</span>&gt;</span>见客户<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;PM&quot;</span> <span class="attr">value</span>=<span class="string">&quot;会议&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">key</span>&gt;</span><span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;keyBean&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;valueBean&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">&quot;keyBean1&quot;</span> <span class="attr">value-ref</span>=<span class="string">&quot;valueBean1&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--properties,可以看成map类型的特例，properties属性的键和值都只能是字符串--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mails&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;jobMail&quot;</span>&gt;</span>xxx-office@xxx.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;lifeMail&quot;</span>&gt;</span>xxx-life@xxx.com<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"> </span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>配置说明：</p>
<ol>
<li><p>循环依赖问题：</p>
<p>Spring容器对构造函数配置Bean进行实例化的前提是Bean的构造函数入参引用的对象必须已经准备就绪，由于这个机制，如果两个Bean都采用构造函数注入，通过构造函数参数引用对方，就会发生类似于线程死锁的循环依赖问题</p>
<p>解决方式：将构造函数注入方式调整为属性注入方式即可</p>
</li>
<li><p>XML字面量特殊字符处理</p>
<p>XML中共有五中特殊字符：<code>&amp;</code>、<code>&lt;</code>、<code>&gt;</code>、<code>“</code>、<code>’</code>。让XML将特殊字符当做普通文本对待有两种方式：</p>
<ol>
<li><p>使用 <code>&lt;![CDATA[]]</code>&gt;特殊标签，将包含的特殊字符的字符串封装起来</p>
</li>
<li><p>使用XML转义序列表示这些特殊字符</p>
<p><code>&lt; ：&amp;lt;</code>  、<code>&gt; ：&amp;gt;</code>  、<code>&amp; ：&amp;amp;</code>  、<code>“：&amp;quot;</code>  、 <code>’：&amp;apos;</code></p>
</li>
</ol>
<p>如果是简化方式配置的xml，则对特殊字符的处理只能采用第二种方式</p>
</li>
<li><p><code>&lt;ref&gt;</code>元素属性说明</p>
<p><code>&lt;ref&gt;</code>元素可以通过以下三个属性引用容器中的其他Bean</p>
<ul>
<li><code>bean</code>：可以引用同一容器或父容器中的Bean，是最常见的形式</li>
<li><code>local</code>：只能引用同一配置文件中定义的Bean</li>
<li><code>parent</code>：引用父容器中的Bean，如<code>&lt;ref parant=&quot;car&quot;&gt;</code>的配置说明<code>car</code>的Bean是父容器中的Bean</li>
</ul>
<p><code>&lt;ref bean=&quot;xxx&quot;&gt;</code>简化形式为<code>&lt;ref&gt; </code>，<code>&lt;ref local=&quot;xxx&quot;&gt;</code>和<code>&lt;ref parent=&quot;xxx&quot;&gt;</code>没有对应的简化形式</p>
</li>
<li><p>集合配置补充</p>
<ul>
<li><p>集合合并</p>
<p>允许子<code>&lt;bean&gt;</code>集成父<code>&lt;bean&gt;</code>的同名属性集合元素，两个集合的和最为最终Bean的属性值</p>
</li>
<li><p>通过util命名空间配置集合类型的Bean</p>
<p>如果需要配置一个集合类型的Bean，而非一个集合类型的属性，则可以通过util命名空间进行配置(<code>&lt;util:list&gt;</code>)，此处不做详细说明</p>
</li>
</ul>
</li>
<li><p>使用<code>p</code> 命名空间简化配置</p>
<p>2.5版本后引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:name</span>=<span class="string">&quot;zhangsan&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:age</span>=<span class="string">&quot;18&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:car-ref</span>=<span class="string">&quot;car&quot;</span></span></span><br><span class="line"><span class="tag">      /&gt;</span> </span><br></pre></td></tr></table></figure>
</li>
<li><p>自动装配</p>
<p>Spring掌握了Bean的信息后(配置信息、类结构信息)，Spring IoC容器就可以按照某种规则对容器中的Bean进行自动装配</p>
<p><code>&lt;bean&gt;</code>元素提供了一个指定自动装配类型的属性：<code>autowire=&quot;&lt;自定装配类型&gt;&quot;</code>，<code>&lt;beans&gt;</code>元素提供<code>default-autowire</code>属性进行全局配置，此属性默认值为<code>no</code>，表示不启动自动装配(<code>ref=&quot;beanId&quot;</code>,根据beanId查找)，不过<code>&lt;bean&gt;</code>中定义的自动配置策略可以覆盖它</p>
<p>Spring中共有4中自动装配类型</p>
<ul>
<li><code>byName</code></li>
<li><code>byType</code></li>
<li><code>constructor</code>，与<code>byType</code>类似，针对构造函数注入而言，即找到一个类构造函数中的注入的Bean类型参数，并自动注入</li>
<li><code>autodetect</code>，根据Bean的自省机制决定<code>byType</code>还是<code>constructor</code>进行自动装配，如果Bean提供了默认的构造函数则采用<code>byType</code>，否则采用<code>constructor</code></li>
</ul>
<p>实际开发中，XML配置方式很少启用自动装配功能，基于注解的配置方式默认采用<code>byType</code>自动装配策略</p>
</li>
<li><p>通过一个<code>singleton Bean</code>获取一个<code> prototype Bean</code>：</p>
<p>使用<code>lookup-method</code>元素标签</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;car&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.Car&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:price</span>=<span class="string">&quot;2000&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">lookup-method</span> <span class="attr">name</span>=<span class="string">&quot;getCar&quot;</span> <span class="attr">bean</span>=<span class="string">car/</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>还有一个<code>replaced-method</code>元素标签，可以实现方法的替换，不详述</p>
</li>
<li><p>Bean的依赖关系</p>
<p>使用<code>depends-on</code>属性显示指定Bean前置依赖的Bean</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;carInit&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.CarInit&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">p:price</span>=<span class="string">&quot;2000&quot;</span> <span class="attr">scope</span>=<span class="string">&quot;prototype&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.User&quot;</span> <span class="attr">depends-on</span>=<span class="string">&quot;carInit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p> 除了依赖，<code>&lt;bean&gt;</code>之间可以建立继承(<code>parent</code>)和引用关系(<code>idref</code>)，不在此详述，合理引用这些关系可以简化配置，提高配置质量</p>
</li>
<li><p>整合多个配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;classpath:cn/zhangyuying/beans1.xml&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>容器启动时，只加载整合的配置文件即可</p>
</li>
</ol>
<h5 id="FactoryBean"><a href="#FactoryBean" class="headerlink" title="FactoryBean"></a>FactoryBean</h5><p>Spring提供了一个<code>org.springframework.beans.factory.FactoryBean</code>工厂类接口，用户可以通过实现该工厂类接口定制实例化Bean的逻辑</p>
<p><code>FactoryBean</code>接口在Spring框架来说占有重要地位，Spring自身就提供了70多个<code>FactoryBean</code>的实现类</p>
<p>Spring3.0开始，<code>FactoryBean</code>开始支持泛型，即<code>Factory&lt;T&gt;</code></p>
<p><code>FactoryBean</code>中定义了三个方法</p>
<ul>
<li><code>T getObject()</code>：返回由<code>FactoryBean</code>创建的Bean实例，如果<code>isSingleton()</code>返回<code>true</code>，则该实例会放到Spring容器的单实例缓存池中</li>
<li><code>boolean isSingleton()</code>：确定由<code>FactoryBean</code>创建的Bean的作用域是<code>singleton</code>还是<code>prototype</code></li>
<li><code>Class&lt;?&gt; getObjectType()</code>：返回<code>FactoryBean</code>创建Bean的类型</li>
</ul>
<p>配置文件中的<code>&lt;bean&gt;</code>的class属性配置的实现类是<code>FactoryBean</code>时，通过<code>getBean()</code>方法返回的不是<code>FactoryBean</code>本身，而是<code>FactoryBean#getObject()</code>方法所返回的对象，如果希望获取对应的<code>FactoryBean</code>实现类的实例，在<code>beanName</code>前加上<code>&amp;</code>，例如<code>getBean(&quot;&amp;user&quot;)</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.UserFactoryBean&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="基于注解的配置"><a href="#基于注解的配置" class="headerlink" title="基于注解的配置"></a>基于注解的配置</h4><ol>
<li><p>定义Bean：</p>
<p><code>@Component</code>，有三个继承自<code>@Component</code>的注解，标注了不同层的实现类，清晰的标注类的用途</p>
<ul>
<li><code>@Repository</code>：Dao实现类</li>
<li><code>@Service</code>：Service实现类</li>
<li><code>@Controller</code>：Controller实现类</li>
</ul>
<p>扫描注解定义的Bean：</p>
<p>Spring提供了一个<code>context</code>命名空间，提供了通过扫描类包以应用注解定义Bean的方式</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;cn.zhangyuying&quot;</span> <span class="attr">resource-pattern</span>=<span class="string">&quot;anno/*.class&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>resource-pattern</code>：过滤出需要扫描的特定的类</p>
<p><code>&lt;context:component-scan&gt;</code>还支持过滤子元素：<code>&lt;context:include-filter&gt;</code>和<code>&lt;context:exclude-filter&gt;</code>，使用时要注意<code>&lt;context:component-scan&gt;</code>的<code>use-default-filiters</code>属性，默认值为<code>true</code>,如果要使用过滤子元素需要设置为<code>false</code>， 不过在此不作具体说明</p>
</li>
<li><p>自动装配Bean</p>
<ol>
<li><p>使用<code>@Autowired</code>进行自动注入，默认为按类型(<code>byType</code>)匹配的方式查找Bean</p>
<p><code>@Autowired(required=false)</code>：可以找不到对应Bean也不抛出异常，<code>required</code>默认为<code>true</code></p>
</li>
<li><p><code>@Qualifier</code>：指定注入Bean的名称，例如：<code>@Qualifier(&quot;UserDao&quot;)</code>，<code>byType</code>找到多个时，会根据<code>byName</code>确定是哪一个</p>
</li>
<li><p><code>@Autowired</code>可以对类成员变量进行标注，也可以应用在类方法上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="meta">@Qualifier(&quot;userDao&quot;)</span> UserDao userdao,LogDao logDao)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>提倡注解标注在方法在，更面向对象，面向单元，且标注在私有属性上，也不利于单元测试</p>
</li>
<li><p>注入集合类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Spring将所有类型为Plugin的Bean注入到这个变量中</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Plugin&gt; plugins;</span><br><span class="line"><span class="comment">//将Plugin类型的Bean注入到map中，key是Bean的名字</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;String,Plugin&gt; pluginMaps;</span><br></pre></td></tr></table></figure>
</li>
<li><p>延迟依赖注入</p>
<p><code>@Lazy</code>：延迟依赖注入，直到调用此属性时才会注入属性值</p>
<p><code>@Lazy</code>的注解必须同时标注在属性即目标Bean上，二者缺一，则延迟注入无效</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Lazy</span> <span class="comment">//目标Bean</span></span><br><span class="line"><span class="meta">@Respository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogDao</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogService</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Lazy</span><span class="comment">//属性</span></span><br><span class="line">  <span class="meta">@Autowired(required=false)</span></span><br><span class="line">  <span class="keyword">private</span> LogDao logDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>对标准注解的支持</p>
<p>Spring中支持JSR-250中定义的<code>@Resource</code>(默认<code>byName</code>注入)和JSR-330中定义的<code>@Inject</code>(没有<code>required</code>属性)注解,和<code>@Autowired</code>作用一样</p>
</li>
</ol>
</li>
<li><p>Bean作用范围及生命过程方法</p>
<ul>
<li><p>Bean作用范围</p>
<p>Bean默认作用范围为<code>singleton</code>，<code>@Scope</code>注解可以指定Bean的作用范围，例如：<code>@Scope(&quot;prototype&quot;)</code></p>
</li>
<li><p>生命过程方法</p>
<p><code>@PostConstruct </code>和<code>@PreDestroy</code> 是JSR-250中定义的注解</p>
<ul>
<li><code>@PostConstruct </code>注解相当于 Xml中的<code>init-method </code> </li>
<li><code>@PreDestroy</code> 注解相当于 Xml中的<code>destory-method</code></li>
</ul>
</li>
</ul>
<p>可以在一个Bean中定义多个<code>@PostConstruct</code> 和<code>@PreDestroy</code> 方法</p>
</li>
</ol>
<h4 id="基于Java类的配置"><a href="#基于Java类的配置" class="headerlink" title="基于Java类的配置"></a>基于Java类的配置</h4><p><code>JavaConfig</code>是Spring的一个子项目，旨在通过Java类的方式提供Bean的定义信息</p>
<p>普通的POJO通过<code>@Configuration</code>注解，就可以为Spring容器提供Bean定义的信息，每个标注了<code>@Bean</code>的类方法都相当于提供了一个Bean的定义信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConf</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserDao <span class="title">userDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserDao();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span></span><br><span class="line">  <span class="meta">@Scope(&quot;prototype&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserTest <span class="title">userTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserTest();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>@Configuration</code>注解类本身已经标注了<code>@Component</code>注解，所以任何标注了<code>@Configuration</code>的类，也可以像普通的Bean一样被注入到其他的Bean中</p>
<p>使用基于Java类的配置信息启动Spring容器：</p>
<p>Spring提供了一个<code>AnnotationConfigApplicationContext</code>类，它能够直接通过标注<code>@Configuration</code>的Java类启动Spring容器，如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConfigTest</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    <span class="comment">//加载一个配置类</span></span><br><span class="line">    ApplicationContext ctx=<span class="keyword">new</span> AnnotationConfigApplicationContext(Appconf.class);</span><br><span class="line">    UserDao userDao=ctx.getBean(UserDao.class);</span><br><span class="line">  </span><br><span class="line">    <span class="comment">//加载多个配置类</span></span><br><span class="line">    ApplicationContext ctx=<span class="keyword">new</span> AnnotationConfigApplicationContext();</span><br><span class="line">    ctx.register(Appconf.class);</span><br><span class="line">    ctx.register(AppConf2.class);</span><br><span class="line">    ctx.refreash();</span><br><span class="line">    UserDao userDao=ctx.getBean(UserDao.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>加载多个配置类时，可以通过代码一个一个的注册配置类，也可以通过<code>@Import</code>将多个配置类组装到一个配置文件中，这样可以仅仅注入这个组装好的配置类就启动容器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Import(AppConf.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> UserServer <span class="title">userServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> UserServer();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>XML配置文件和<code>@Configuration</code>配置的互相引用：</p>
<ul>
<li><p>通过XML配置文件引用<code>@Configuration</code>的配置</p>
<p>因为<code>@Configuration</code>也是一个Bean，所以只要保证它被Spring的<code>&lt;context:component-scan&gt;</code>扫描到即可</p>
</li>
<li><p>通过<code>@Configuration</code>配置类引用XML配置信息</p>
<p><code>@Configuration</code>配置类可以通过<code>@ImportResource</code>引入XML配置文件，引入后即可使用XML中配置的Bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ImportResource(&quot;classpath:cn/zhangyuying/conf/beans.xml&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="通过编码方式动态添加Bean"><a href="#通过编码方式动态添加Bean" class="headerlink" title="通过编码方式动态添加Bean"></a>通过编码方式动态添加Bean</h4><p><code>DefaultListableBeanFactory</code>实现了<code>ConfigurableListableBeanFactory</code>接口，提供了可扩展配置、循环枚举的功能，可以通过此类实现Bean动态注入</p>
<p>为了实现在Spring容器启动阶段能动态注入自定义Bean，保证动态注入的Bean也能被AOP所增强，需要实现Bean工厂后置处理器接口<code>BeanFactoryPostProcessor</code>。(也可以拿到<code>ApplicationContext</code>，在拿到其中的<code>BeanFactory</code>，强转为<code>DefaultListableBeanFactory</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceFactoryBean</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory bf)</span> <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">    <span class="comment">//1.将ConfigurableListableBeanFactory 转化为DefaultListableBeanFactory</span></span><br><span class="line">    DefaultListableBeanFactory beanFactory = (DefaultListableBeanFactory) bf;</span><br><span class="line">    <span class="comment">//2.通过BeanDefinitionBuilder创建Bean定义.  genericBeanDefinition可以传入其他参数：genericBeanDefinition(beanName)</span></span><br><span class="line">    BeanDefinitionBuilder beanDefinitionBuilder = BeanDefinitionBuilder.genericBeanDefinition(UserService.class);</span><br><span class="line">    <span class="comment">//3.设置属性userDao,此属性引用已经定义的bean:userDao</span></span><br><span class="line">    beanDefinitionBuilder.addPropertyReference(<span class="string">&quot;userDao&quot;</span>,<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.以下两种方式都可以添加Bean</span></span><br><span class="line">    <span class="comment">// (1)注册Bean定义</span></span><br><span class="line">    beanFactory.registerBeanDefinition(<span class="string">&quot;userService&quot;</span>,BeanDefinitionBuilder.getBeanDefinition());</span><br><span class="line">    <span class="comment">// (2)直接注册一个Bean实例</span></span><br><span class="line">    beanFactory.registerSingleton(<span class="string">&quot;userServer&quot;</span>,<span class="keyword">new</span> UserService());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>时序图</title>
    <url>/2020/06/16/UML/%E6%97%B6%E5%BA%8F%E5%9B%BE/</url>
    <content><![CDATA[<p>时序图(<code>Sequence Diagram</code>)，又名序列图、循序图，是一种UML交互图。它描述了消息在生命线上按照约定顺序执行一种交互行为。它可以表示用例的行为顺序，当执行一个用例行为时，序列图中的每条消息对应了一个类操作或状态机中引起转换的触发事件。</p>
<span id="more"></span>

<blockquote>
<p>时序图的翻译，实际上是不准确的，sequence这个单词并无”时间”的意思，只有序列，顺序等意思。</p>
<p>UML规范中对<code>Sequence Diagram</code>的描述： <code>A sequence diagram describes an Interaction by focusing on the sequence of Messages that are exchanged, along with their corresponding Occurrence Specifications on the Lifelines. </code></p>
</blockquote>
<h4 id="包含元素"><a href="#包含元素" class="headerlink" title="包含元素"></a>包含元素</h4><ol>
<li><p><strong>角色（<code>Actor</code>）</strong>：系统角色，可以是人或者其他系统，子系统。以一个小人图标表示。</p>
</li>
<li><p><strong>对象（<code>Object</code>）</strong>：对象位于时序图的顶部,以一个矩形表示。对象的命名方式一般有三种：</p>
<ul>
<li>对象名和类名。例如：华为手机:手机、loginServiceObject:LoginService。</li>
<li>只显示类名，不显示对象，即为一个匿名类。例如：:手机、:LoginSservice。</li>
<li>只显示对象名，不显示类名。例如：华为手机:、loginServiceObject:。</li>
</ul>
</li>
<li><p><strong>生命线（<code>LifeLine</code>）</strong>：时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线(对象的时间线)。以一条垂直的虚线表示。</p>
</li>
<li><p><strong>控制焦点（<code>Activation</code>）</strong>：控制焦点代表时序图中在对象生命线上某段时期执行的操作。以一个很窄的矩形表示。</p>
</li>
<li><p><strong>消息（<code>Message</code>）</strong>：表现代表对象之间发送的信息。消息分为三种类型。</p>
<ul>
<li><p>同步消息(<code>Synchronous Message</code>)</p>
<p>消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。以一条实线+实心箭头表示。</p>
</li>
<li><p>异步消息(<code>Asynchronous Message</code>)</p>
<p>消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。以一条实线+大于号表示。</p>
</li>
<li><p>返回消息(<code>Return Message</code>)</p>
<p>返回消息表示从过程调用返回。以小于号+虚线表示。</p>
</li>
</ul>
</li>
<li><p><strong>自关联消息</strong>：表示方法的自身调用或者一个对象内的一个方法调用另外一个方法。以一个半闭合的长方形+下方实心剪头表示。</p>
</li>
<li><p><strong>组合片段</strong>：组合片段用来解决交互执行的条件和方式，它允许在序列图中直接表示逻辑组件，用于通过指定条件或子进程的应用区域，为任何生命线的任何部分定义特殊条件和子进程。组合片段共有13种，名称及含义如下：</p>
<ul>
<li><code>Opt</code>：选项。包含一个可能发生或可能不发生的序列，可以在临界中指定序列发生的条件，相当于if</li>
<li><code>Alt</code>：抉择。包含一个片段列表，这些片段包含备选消息序列，在任何场合下只发生一个序列，相当于if…else</li>
<li><code>Loop</code>：循环。片段重复一定次数，可以在临界中指示片段重复的条件。<code>Loop</code>组合片段具有<code>“Min”</code>和<code>“Max”</code>属性，它们指示片段可以重复的最小和最大次数，默认值是无限制</li>
<li><code>Break</code>：中断。如果执行此片段，则放弃序列的其余部分，可以使用临界来指示发生中断的条件</li>
<li><code>Par</code>：并行。并行处理，片段中的事件可以交错</li>
<li><code>Critical</code>：关键。用在<code>Par</code>或<code>Seq</code>片段中，指示此片段中的消息不得与其他消息交错</li>
<li><code>Seq</code>：弱顺序。有两个或者更多操作数片段，涉及同一生命线的消息必须以片段的顺序发生，如果消息涉及的生命线不同，来自不同的片段的消息可能会并行交错</li>
<li><code>Strict</code>：强顺序。有两个或更多操作数片段，这些片段必须按给定顺序发生</li>
<li><code>Consider</code>：考虑。指定此片段描述的消息列表，其他消息可发生在运行的系统中，但对此描述来说意义不大，在<code>“Message”</code>属性中键入该列表</li>
<li><code>Ignore</code>：忽略。此片段未描述的消息列表，这些消息可发生在运行的系统中，但对此描述来说意义不大，在<code>“Message”</code>属性中键入该列表</li>
<li><code>Assert</code>：断言。操作数片段指定唯一有效的序列，通常在<code>Consider</code>或<code>Ignore</code>片段中</li>
<li><code>Neg</code>：否定。此片段中显示的序列不得发生，通常在<code>Consider</code>或<code>Ingnore</code>片段中</li>
</ul>
</li>
</ol>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E6%97%B6%E5%BA%8F%E5%9B%BE%E7%A4%BA%E4%BE%8B.jpg" alt="时序图示例"></p>
<p>参考资料</p>
<p><a href="https://www.uml-diagrams.org/sequence-diagrams-combined-fragment.html#operator-opt">uml-sequence-diagrams</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%97%B6%E5%BA%8F%E5%9B%BE">时序图-维基百科</a></p>
<p><a href="https://blog.csdn.net/fly_zxy/article/details/80911942">UML时序图-CSDN</a></p>
<p><a href="https://www.cnblogs.com/whylaughing/p/5794693.html">时序图组合片段</a></p>
<p><a href="https://www.jianshu.com/p/c5209bde7287">时序图-简书</a></p>
]]></content>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的模块</title>
    <url>/2019/09/02/nginx/Nginx%E7%9A%84%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>Nginx的模块设计十分优良，Nginx从发布到现在，模块从来没有发生大的变化</p>
<span id="more"></span>

<h4 id="Nginx的模块"><a href="#Nginx的模块" class="headerlink" title="Nginx的模块"></a>Nginx的模块</h4><p>Nginx的模块是编译在我们的二进制文件中的，一般可以通过：安装目录的<code>objs</code>目录下面的<code>ngx_modules.c</code>  查看有哪些模块被编译到Nginx中。</p>
<p>Nginx的模块：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E6%A8%A1%E5%9D%97.png" alt="Nginx模块"></p>
<p><code>nginx_module_t</code> 是每一个模块用来说明自己的结构体</p>
<ul>
<li><code>nginx_module_t</code>是通用的模块，但是我们会有不用类型的应用，比如<code>http</code>、<code>stream</code>，所以模块又细分为子模块，</li>
<li><code>nginx_module_t</code>中的<code>index</code>会定义模块的顺序，<code>type</code>定义了模块的类型</li>
<li><code>nginx_module_t</code>中有一个<code>commands</code> 成员，<code>commans</code>是一个结构体：<code>nginx_command_t</code><ul>
<li><code>ngx_command_t</code>是Nginx中的每个模块都<strong>必须具备且唯一</strong>的结构体 ，它是个数组，数组中的每个成员是他支持的指令名，其中还包含了指令的使用方式</li>
</ul>
</li>
</ul>
<p>Nginx的模块设计：</p>
<ol>
<li>高内聚：相应独立的功能是在同一块代码中的，也就是在一个子模块中</li>
<li>抽象，体现在：<ul>
<li>所有模块命令的配置均在<code>nginx_module_t</code>中的<code>commands</code>中</li>
<li>启停回调方法：上图中nginx_module_t中最下面的7个方法，任何第三方模块都有机会在<code>master</code>或<code>worker</code>启停的时候加载自己的代码，实现定制化代码</li>
<li>子模块抽象：<code>http</code>、<code>event</code>、<code>mail</code>、<code>stream</code></li>
</ul>
</li>
</ol>
<p>Nginx的模块是Nginx诸多特性的一个基础</p>
<h4 id="Nginx模块分类"><a href="#Nginx模块分类" class="headerlink" title="Nginx模块分类"></a>Nginx模块分类</h4><p>Nginx模块的分类如下图：其中</p>
<ul>
<li><code>NGX_CONF_MODULE</code> 是负责解析配置文件的</li>
<li>Nginx的每个模块中都会有一个通用共性的模块：<code>_core</code>，例如<code>event_core</code></li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E6%A8%A1%E5%9D%97%E5%88%86%E7%B1%BB.png" alt="nginx模块分类"></p>
<p>Nginx模块所在的安装位置：</p>
<p>Nginx模块的位置一般在Nginx的安装目录下的<code>src</code>目录，<code>src</code>下面会有模块目录（注意其中的<code>core</code>不是<code>core</code>模块），如下图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx-src%E7%9B%AE%E5%BD%95.png" alt="http-src目录"></p>
<p>进入到具体的模块目录中(<code>http</code>目录为例)：进入到<code>http</code>目录后，所有Nginx提供的的框架模块都是直接在<code>http</code>目录下的，而提供的其他可有可无的都在<code>http</code>目录下的<code>modules</code>目录下，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx-src-http%E7%9B%AE%E5%BD%95.png" alt="nginx-src-http目录"></p>
<p>Nginx中有一些模块被定义为动态模块：Nginx中可以使用动态模块来提升运维的效率(升级、增加新模块等)，但是不是所有的模块 都支持动态编译的</p>
<h4 id="Nginx的连接池和内存池"><a href="#Nginx的连接池和内存池" class="headerlink" title="Nginx的连接池和内存池"></a>Nginx的连接池和内存池</h4><p>Nginx的每一个<code>worker</code>进程，里面都有一个独立的<code>ngx_cycle_t </code>结构体：其中有3个参数需要注意：<code>connections</code>、<code>read_events</code> 、<code>write_events</code></p>
<h5 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h5><ul>
<li>connections: 连接池数组， 默认值为 <code>worker_connections  = 512</code>，而且这个连接池不只是用于客户端的连接，还用于上游服务器的连接，所以当使用Nginx做反向代理的时候，相当于每个客户端消耗我们两个链接</li>
<li><code>read_events</code>和<code>write_events</code>：每个连接对一个读事件(<code>read_events</code> )和一个写事件( <code>write_events</code>)，这三个是通过序号对应的，意味着<code>read_events</code>和<code>write_events</code>的数组长度是和<code>connections</code>保持一致的</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E8%BF%9E%E6%8E%A5.png" alt="Nginx连接"></p>
<p><strong><code>worker_connections</code></strong> ：</p>
<p>设置更大的<code>worker_connections</code> 意味着Nginx使用更大的内存，那么每个连接到底使用多大的内存呢？</p>
<p>可以查看下图连接和事件的核心数据结构（字节数是64位操作系统）：</p>
<p>可以看出一个连接的内存消耗 = 一个连接 + 两个事件 (64为操作系统下相当于：232 + 2 * 96 字节)</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E8%BF%9E%E6%8E%A5%E5%92%8C%E4%BA%8B%E4%BB%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png" alt="Nginx连接和事件的核心数据结构"></p>
<h5 id="内存池"><a href="#内存池" class="headerlink" title="内存池"></a>内存池</h5><p>内存池：在上图连接的结构体中有个参数是<code>ngx_pool_t   *pool</code> ，这个就是这个连接使用的内存池，它使用配置项：<code>connection_pool_size</code>来定义，小块内存在内存池分配，减少内存碎片，大块内存还是会走到操作系统去分配，</p>
<p>内存池分为：连接内存池和请求内存池</p>
<ul>
<li>连接内存池（<code>default connection_pool_size = 256|512 字节</code>）</li>
<li>请求内存池（<code>default rquest_pool_size = 4k</code> ，因为有上下文和<code>url</code>等信息所以大一些）</li>
</ul>
<p>由于一个TCP连接可能会对应许多http请求（<code>keepalive</code>），存在请求内存可能已经释放但是连接内存还在使用的情况，所以自己开发nginx的第三方模块时，要注意是从那个内存池分配的内存</p>
<p>之前提过Nginx是一个多进程程序，不同的worker之间要进行数据通讯，只能通过共享内存(数据同步)</p>
<ul>
<li>锁：Nginx对共享内存的操作使用<strong>自旋锁</strong>，这就需要对共享内存快速使用快速释放</li>
<li>Slab内存管理器：是Nginx选择的内存分配机制</li>
</ul>
<p>Nginx中使用了共享内存的模块：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E4%BD%BF%E7%94%A8%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E7%9A%84%E6%A8%A1%E5%9D%97.png" alt="Nginx使用共享内存的模块"></p>
<h4 id="Nginx容器"><a href="#Nginx容器" class="headerlink" title="Nginx容器"></a>Nginx容器</h4><p>Nginx中的容器有：数组、链表、队列、基数树、哈希表、红黑树，其中Nginx使用的最多的是哈希表和红黑树</p>
<p>哈希表：Nginx中只有静态不变的内容使用</p>
<ul>
<li><code>Max size</code> :最大的哈希表Bucket的个数  </li>
<li><code>Bucket size</code>:向上和操作系统处理的字节数对齐，最好不要超过 64</li>
</ul>
<p>Nginx中使用哈希表的模块</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E4%B8%AD%E4%BD%BF%E7%94%A8hash%E8%A1%A8%E7%9A%84%E6%A8%A1%E5%9D%97.png" alt="Nginx中使用哈希表的模块"></p>
<p>红黑树：Nginx中使用红黑树的模块：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E4%B8%AD%E4%BD%BF%E7%94%A8%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E6%A8%A1%E5%9D%97.png" alt="Nginx中使用红黑树的模块"></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>类图</title>
    <url>/2020/08/27/UML/%E7%B1%BB%E5%9B%BE/</url>
    <content><![CDATA[<p>类图是一种静态的结构图，描述了系统的类的集合、类的属性和类之间的关系，简化对系统的理解，类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型</p>
<span id="more"></span>

<h4 id="类基本属性"><a href="#类基本属性" class="headerlink" title="类基本属性"></a>类基本属性</h4><p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">		Student</span><br><span class="line">————————————————————————</span><br><span class="line">- name : String </span><br><span class="line">- age  : int</span><br><span class="line">————————————————————————</span><br><span class="line">+ lean(Book book) : int</span><br><span class="line">+ goHome(Date time) : void</span><br></pre></td></tr></table></figure>

<p>说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-  :  private </span><br><span class="line">#  :  protected</span><br><span class="line">~  :  default,即包权限</span><br><span class="line">_  :  下划线表示static</span><br><span class="line">斜体表示抽象</span><br></pre></td></tr></table></figure>

<h4 id="类与类之间的关系"><a href="#类与类之间的关系" class="headerlink" title="类与类之间的关系"></a>类与类之间的关系</h4><ul>
<li><p>继承关系</p>
<p>表示类之间的集成关系，即一个类继承另一个类或者接口与接口之间的继承关系</p>
<p>表示方法：使用<strong>空心三角形+实线</strong>表示</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E7%BB%A7%E6%89%BF.jpg" alt="类图-继承"></p>
</li>
<li><p>实现关系</p>
<p>标识一个类实现一个/多个接口</p>
<p>表示方法：(1)使用<strong>空心三角形+虚线</strong>表示 (2)使用棒棒糖表示法(圆+实线)</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E5%AE%9E%E7%8E%B0.jpg" alt="类图-实现"></p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E5%AE%9E%E7%8E%B0-%E6%A3%92%E6%A3%92%E7%B3%96%E6%96%B9%E5%BC%8F.jpg" alt="类图-实现-棒棒糖方式"></p>
</li>
</ul>
<ul>
<li><p>依赖和关联：强调关系的强弱、稳定等</p>
<ul>
<li><p>依赖（<code>Dependency</code>）</p>
<p>说明：依赖关系是一种使用关系，特定事务的改变有可能会影响到使用该事物的其他事物，表示一个事物需要使用另一个事物时使用依赖关系，一般情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数</p>
<p>表示方法：使用<strong>箭头+虚线</strong>表示，由依赖的一方指向被依赖的一方，依赖关系通常通过三种方式来实现，第一种也是最常用的一种方式是将一个类的对象作为另一个类中方法的参数，第二种方式是在一个类的方法中将另一个类的对象作为其局部变量，第三种方式是在一个类的方法中调用另一个类的静态方法。</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E4%BE%9D%E8%B5%96.jpg" alt="类图-依赖"></p>
</li>
<li><p>关联（<code>Association</code>）</p>
<p>说明：关联关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，关联关系通常将一个类的对象作为另一个类的成员变量</p>
<p>表示方法：使用<strong>箭头+实线</strong>表示，在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词表示角色名，关系的两端代表两种不同的角色，因为在一个关联关系中可以包含两个角色名，角色名不是必须的，可以根据需要增加，其目的是使类之间的关系更加明确</p>
<p>在UML中关联关系又通常包含如下几种形式</p>
<ul>
<li><p>双向关联</p>
<p>默认情况下，关联关系是双向的，比如教师教导学生，学生向教师学习。双向关联使用一个实线表示，没有箭头</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E5%8F%8C%E5%90%91%E5%85%B3%E8%81%94.jpg" alt="类图-双向关联"></p>
</li>
<li><p>单向关联</p>
<p>单向关联表示为箭头+实线。比如学生有家庭住址，箭头指向住址类</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E5%8D%95%E5%90%91%E5%85%B3%E8%81%94.jpg" alt="类图-单向关联"></p>
</li>
<li><p>自关联</p>
<p>一些类的属性对象类型为该类本身，这种特殊的关联关系为自关联</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E8%87%AA%E5%85%B3%E8%81%94.jpg" alt="类图-自关联"></p>
</li>
<li><p>多重性关联</p>
<p>又称为重复性关联关系，表示两个对象在数量上的对应关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1..1  表示另一个类的一个对象只与该类的一个对象有关系</span><br><span class="line">0..*  表示另一个类的一个对象与该类的零个或多个对象有关系</span><br><span class="line">1..*  表示另一个类的一个对象与该类的一个或多个对象有关系</span><br><span class="line">0..1  表示另一个类的一个对象没有或只与该类的一个对象有关系</span><br><span class="line">m..n  表示另一个类的一个对象与该类最少m，最多n个对象有关系 (m≤n)</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E5%A4%9A%E9%87%8D%E6%80%A7%E5%85%B3%E8%81%94.jpg" alt="类图-多重性关联"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>聚合和组合：强调整体和部分的关系</p>
<ul>
<li><p>聚合（<code>Aggregation</code>）</p>
<p>表示整体和部分的关系，在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在</p>
<p>表示方法：空心菱形+直线，实现聚合关系时，成员对象通常作为构造方法、Setter方法或业务方法的参数注入到整体对象中</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E8%81%9A%E5%90%88.jpg" alt="类图-聚合"></p>
</li>
<li><p>组合（<code>Composition</code>）</p>
<p>也是表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象具有相同的生命周期</p>
<p>表示方法：实心菱形+直线，实现组合关系时，通常在类的构造方法中直接实例化成员类</p>
<p>示例：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE-%E7%BB%84%E5%90%88.jpg" alt="类图-组合"></p>
</li>
</ul>
</li>
</ul>
<h4 id="总体示例"><a href="#总体示例" class="headerlink" title="总体示例"></a>总体示例</h4><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/UML/%E7%B1%BB%E5%9B%BE%E7%A4%BA%E4%BE%8B.png" alt="类图示例"></p>
<p>参考资料</p>
<p><a href="https://www.jianshu.com/p/57620b762160">UML类图-简书</a></p>
<p><a href="http://www.uml.org.cn/oobject/201211231.asp">深入浅出类图</a></p>
]]></content>
      <tags>
        <tag>UML</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx目录</title>
    <url>/2019/09/05/nginx/Nginx%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p>Nginx学习目录</p>
<span id="more"></span>

<ol>
<li><p>初始Nginx</p>
<p>Nginx的基础语法，基本用法</p>
<ul>
<li><a href="http://zhangyuying.cn/2019/08/13/Nginx/Nginx%E7%AE%80%E4%BB%8B/">Nginx简介</a></li>
<li><a href="http://zhangyuying.cn/2019/08/19/Nginx/Nginx-conf/">Nginx.conf</a></li>
<li><a href="http://zhangyuying.cn/2019/08/19/Nginx/Nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90web%E6%9C%8D%E5%8A%A1%E5%99%A8/">Nginx搭建静态资源服务器</a></li>
<li><a href="http://zhangyuying.cn/2019/08/19/Nginx/Nginx%E6%94%AF%E6%8C%81https/">Nginx支持https</a></li>
</ul>
</li>
<li><p>Nginx架构基础</p>
<p>Nginx的进程架构，特别是基于网络事件来驱动Nginx的请求处理</p>
<ul>
<li><a href="http://zhangyuying.cn/2019/08/19/Nginx/Nginx%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84/">Nginx的进程结构</a></li>
<li><a href="http://zhangyuying.cn/2019/08/23/Nginx/Nginx%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">Nginx父子进程通信</a></li>
<li><a href="http://zhangyuying.cn/2019/08/29/Nginx/Nginx%E4%BA%8B%E4%BB%B6/">Nginx事件驱动</a></li>
<li><a href="http://zhangyuying.cn/2019/09/02/Nginx/Nginx%E7%9A%84%E6%A8%A1%E5%9D%97/">Nginx的模块</a></li>
</ul>
</li>
<li><p>详解HTTP模块</p>
</li>
<li><p>反向代理与负载均衡</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx.conf</title>
    <url>/2019/08/19/nginx/nginx-conf/</url>
    <content><![CDATA[<p>Nginx的行为都是由Nginx.conf决定的</p>
<p>Nginx.conf的配置语法：</p>
<span id="more"></span>

<ol>
<li>配置文件由指令与指令块构成</li>
<li>每条指令以<code>;</code>分号结尾，指令与参数间以空格符号分隔</li>
<li>指令块以<code>&#123;&#125;</code>大括号将多条指令组织在一起</li>
<li><code>include</code>语句允许组合多个配置文件以提升可维护性</li>
<li>使用<code>#</code>符号添加注释，提高可读性</li>
<li>使用<code>$</code>符号使用变量</li>
<li>部分指令的参数支持正则表达式</li>
</ol>
<p>Nginx.conf示例：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nobody;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log  <span class="literal">notice</span>;</span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log  <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#pid        logs/nginx.pid;</span></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">//指令块：例如http&#123;&#125;   指令：例如include</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#设定实际的服务器列表 </span></span><br><span class="line">    <span class="attribute">upstream</span> test &#123;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">172.16.34.923:1234</span> max_fails=<span class="number">10000</span> fail_timeout=<span class="number">1000s</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">172.16.34.933:2345</span> max_fails=<span class="number">10000</span> fail_timeout=<span class="number">1000s</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> test2 &#123;</span><br><span class="line">        ip_hash;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">172.16.34.933:1234</span>;</span><br><span class="line">        <span class="attribute">server</span> <span class="number">172.16.34.933:2345</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">        <span class="attribute">server_name</span>  <span class="number">0.0.0.0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">#代理配置参数</span></span><br><span class="line">        <span class="attribute">proxy_connect_timeout</span> <span class="number">3000</span>;</span><br><span class="line">        <span class="attribute">proxy_send_timeout</span> <span class="number">3000</span>;</span><br><span class="line">        <span class="attribute">proxy_read_timeout</span> <span class="number">3000</span>;</span><br><span class="line">	</span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">           <span class="attribute">proxy_pass</span> http://test;</span><br><span class="line">           <span class="attribute">proxy_set_header</span> Host $host;</span><br><span class="line">           <span class="attribute">proxy_set_header</span> X-Real-IP $remote_addr;</span><br><span class="line">           <span class="attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">        <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">            <span class="attribute">root</span>   html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>基于@AspectJ的AOP</title>
    <url>/2020/03/26/Spring/%E5%9F%BA%E4%BA%8E@AspectJ%E7%9A%84AOP/</url>
    <content><![CDATA[<p>基于Java5.0的注解，Spring AOP支持使用<code>@AspectJ</code>注解非常容易地定义一个切面</p>
<span id="more"></span>

<p><code>@AspectJ</code>是Aspect1.5新增的功能，通过Java注解技术，允许开发者在POJO中定义切面，Spring使用和<code>@AspectJ</code>相同风格的注解，并通过Aspect提供的注解库和解析库处理切点，不过由于Spring只支持方法级的切点，所以仅对<code>@AspectJ</code>提供了有限的支持</p>
<p>Spring可以集成Aspect，但AspectJ本身不属于Spring AOP的范畴</p>
<h4 id="着手使用-AspectJ"><a href="#着手使用-AspectJ" class="headerlink" title="着手使用@AspectJ"></a>着手使用<code>@AspectJ</code></h4><p>准备：</p>
<ol>
<li>需要将Spring的<code>asm</code>模块添加到类路径中，<code>asm</code>是轻量级的字节码处理框架，因为Java的反射机制无法获取入参名，Spring就利用<code>asm</code>处理<code>@AspectJ</code>中所描述的方法入参名</li>
<li>需要在<code>pom.xml</code>中添加<code>aspectj.weaver</code>和<code>aspectj.tools</code>类包的依赖</li>
</ol>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NaiveWaiter</span> <span class="keyword">implements</span> <span class="title">Waiter</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">greetTo</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;greet to &quot;</span>+ name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">serveTo</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;serving &quot;</span>+name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 切面，通过@AspectJ将PreGreetAspect标识为一个切面</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreGreetAspect</span></span>&#123;  </span><br><span class="line">  <span class="meta">@Before(&quot;execution(* greetTo(..))&quot;)</span>  <span class="comment">// 定义切点和增强类型</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeGreet</span><span class="params">()</span></span>&#123;   <span class="comment">// 增强的横切逻辑</span></span><br><span class="line">    System.out.println(<span class="string">&quot;How are you&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结合上述示例，切面的信息构成可通过下图来描述：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E5%88%87%E9%9D%A2%E7%9A%84%E4%BF%A1%E6%81%AF%E6%9E%84%E6%88%90.jpg" alt="切面的信息构成"></p>
<p>使用上述示例的切面：</p>
<ol>
<li><p>编程的方式使用切面：</p>
<p>通过<code>AspectJProxyFactory</code>为<code>NaiveWaiter</code>生成织入<code>PreGreetAspect</code>切面的代理，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectJProcyTest</span> </span>&#123;</span><br><span class="line">  Waiter target = <span class="keyword">new</span> NaiveWaiter();</span><br><span class="line">  AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory();</span><br><span class="line">  <span class="comment">//设置目标对象</span></span><br><span class="line">  factory.setTarget(target);</span><br><span class="line">  <span class="comment">//添加切面类</span></span><br><span class="line">  fatory.addAspect(PreGreetAspect.class);</span><br><span class="line">  <span class="comment">//生成织入切面的代理对象</span></span><br><span class="line">  Waiter proxy = factory.getProxy();</span><br><span class="line">  proxy.greetTo(<span class="string">&quot;John&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过配置使用<code>@Aspect</code>切面：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--目标Bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;waiter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.NaiveWaiter&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--使用了@AspectJ注解的切面类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.PreGreetAspect&quot;</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!--自动代理创建器，自动将@AspectJ注解切面类织入目标Bean中--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>AnnotationAwareAspectJAutoProxyCreator</code>是自动代理器的一个，能够将<code>@Aspect</code>注解切面类自动织入到目标Bean中，还可以使用基于Schema的<code>aop</code>命名空间进行配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--基于@AspectJ切面的驱动器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;waiter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.NaiveWaiter&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.PreGreetAspect&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>&lt;aop:aspectj-autoproxy /&gt;</code>自动为Spring容器中那些匹配<code>@AspectJ</code>切面的Bean创建代理，完成切面织入，当然Spring在内部依旧采用<code>AnnotationAwareAspectJAutoProxyCreator</code>进行代理的创建工作，只不过具体的实现细节被<code>&lt;aop:aspectj-autoproxy /&gt;</code>隐藏起来</p>
<p><code>&lt;aop:aspectj-autoproxy /&gt;</code>有一个<code>proxy-targe-class</code>属性，默认为<code>false</code>，表示使用JDK动态代理技术织入增强，如果为<code>true</code>，则表示使用CGLib动态代理技术织入增强，不过即使<code>proxy-targe-class</code>设置为<code>false</code>，如果目标类没有声明接口，则Spring将自动使用CGLib动态代理</p>
</li>
</ol>
<h4 id="AspectJ语法基础"><a href="#AspectJ语法基础" class="headerlink" title="@AspectJ语法基础"></a><code>@AspectJ</code>语法基础</h4><h5 id="切点表达式函数"><a href="#切点表达式函数" class="headerlink" title="切点表达式函数"></a>切点表达式函数</h5><p>切点表达式由关键字和操作参数组成，如<code>execution(* greetTo(..))</code>，<code>execution</code>为关键字，又称为函数，<code>* greetTo(..)</code>为操作参数，又称为函数的入参</p>
<p>Spring支持<code>9</code>个<code>@AspectJ</code>切点表达式函数，他们用不同的方式描述目标类的连接点，根据描述对象的不同，可以大致分为4种类型</p>
<ul>
<li>方法切点函数：通过描述目标类方法的信息定义连接点</li>
<li>方法入参切点函数：通过描述目标类方法的入参的信息定义连接点</li>
<li>目标类切点函数：通过描述目标类类型的信息定义连接点</li>
<li>代理类切点函数：通过描述目标类的代理类的信息定义连接点</li>
</ul>
<p>具体的切点函数如下表：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/%E5%88%87%E7%82%B9%E5%87%BD%E6%95%B0.jpg" alt="切点函数"></p>
<p><strong>在函数入参中使用通配符</strong></p>
<p>有些函数入参可以支持通配符，<code>@AspectJ</code> 支持三种通配符</p>
<ul>
<li><p><code>*</code> ：匹配任意字符，但是只能匹配一个元素</p>
</li>
<li><p><code>..</code> ：匹配任意字符，可以匹配上下文多个元素，表示入参时可以单独使用，但是在表示类的时候，必须和<code>*</code>联合使用</p>
</li>
<li><p><code>+</code> ：按类型匹配指定类的所有类，包括子类，同时还包括指定类本事，必须跟在类名后面</p>
</li>
</ul>
<p><code>@AspectJ</code>函数按照其是否支持通配符及支持的程度，可以分为如下三类</p>
<ul>
<li><p>支持所有通配符的：<code>execution()</code>和<code>within()</code></p>
</li>
<li><p>仅支持<code>+</code>通配符的有:<code>args()</code>,<code>this()</code>和<code>target()</code></p>
<p>这3个标注默认都有<code>+</code>，因此使用<code>+</code>和不使用<code>+</code>都是一样的</p>
<p>也就是说，按类型匹配的，默认都会把子类算为其类型</p>
</li>
<li><p>其余的都不支持通配符：<code>@args()</code>、<code>@within()</code>、<code>@target()</code>和<code>@annotation()</code></p>
</li>
</ul>
<p><strong>逻辑运算符</strong></p>
<p>切点函数之间可以进行逻辑运算，组成复合切点，Spring 支持与或非运算</p>
<ul>
<li><code>&amp;&amp;</code>：与运算符，相当于切点的交集，Spring提供了等效运算符：<code>and</code></li>
<li><code>||</code>：或操作符，相当于切点的并集，Spring提供了等效运算符：<code>or</code></li>
<li><code>!</code>：非操作符，相当于切点反集运算，Spring提供了等效运算符：<code>not</code></li>
</ul>
<h5 id="不同的增强类型"><a href="#不同的增强类型" class="headerlink" title="不同的增强类型"></a>不同的增强类型</h5><p><code>@AspectJ</code>为不同的增强提供了注解类，这些注解的存留期限都是<code>RetentionPolicy.RUNTIME</code>，标注目标都是<code>ElementType.METHOD</code></p>
<ul>
<li><p><code>@before</code>:</p>
<p>前置增强，相当于<code>BeforeAdvice</code>,包含两个成员：</p>
<ul>
<li><p><code> value</code>:定义切点</p>
</li>
<li><p><code>argNames</code>:<strong>由于无法通过<code>Java</code>反射机制获取方法入参名</strong>，所以可以通过此参数指定需要的引用表达式的参数名。可通过这个参数指定注解所标注增强方法的参数名（两者必须完全相同）获取参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(value = &quot;execution(* greetTo(..)) &amp;&amp; args(name,*,sex)&quot;,argNames = &quot;name,sex&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beforeGreeting</span><span class="params">(String name,String sex)</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">对于无法知道参数名的(没有argNames参数)，Spring会按顺序进行赋值,可参照<span class="meta">@Aspect</span>进阶，有详细描述</span><br><span class="line">知道参数名的，Sping会按名称匹配，配置时要注意配置顺序</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><code>@AfterReturning</code>:</p>
<p>后置增强，相当于<code>AfterReturningAdvice</code>,包含四个成员</p>
<ul>
<li><p><code>value</code>：定义切点</p>
</li>
<li><p><code>pointcut</code>:切点信息，如果指定<code>pointcut</code>，则它将覆盖<code>value</code></p>
</li>
<li><p><code>returning</code>:将目标对象方法的返回值绑定给增强的方法</p>
</li>
<li><p><code>argNames</code>:同上</p>
</li>
</ul>
<blockquote>
<p>注意：<code>argNames</code>和<code>returning</code>不能同时使用，如果需要同时使用可以使用<code>&amp;&amp; args()</code>绑定</p>
</blockquote>
</li>
<li><p><code>@around</code>:</p>
<p>环绕增强，相当于<code>MethodInterceptor</code>,包含两个成员</p>
<ul>
<li><p><code>value</code>:切点</p>
</li>
<li><p><code>argNames</code>:同上</p>
</li>
</ul>
</li>
<li><p><code>@AfterThrowing</code>:</p>
<p>异常增强，相当于<code>ThrowsAdvice</code>，包含四个成员</p>
<ul>
<li><p><code>value</code>:定义切点</p>
</li>
<li><p><code>pointcut</code>:切点信息，如果指定<code>pointcut</code>，则它将覆盖<code>value</code></p>
</li>
<li><p><code>throwing</code>：将抛出的信息绑定到增强中</p>
</li>
<li><p><code>argNames</code>:同上</p>
</li>
</ul>
</li>
<li><p><code>@after</code>:</p>
<p><code>Final</code>增强，不管是抛出异常还是正常退出，该增强都将得到执行，没有对应的接口，一般用于释放资源，相当于<code>try&#123;&#125;finally&#123;&#125;</code>的控制流，包含两个成员</p>
<ul>
<li><p><code>value</code>：切点</p>
</li>
<li><p><code>argNames</code>:同上</p>
</li>
</ul>
</li>
<li><p><code>@DeclareParents</code>:</p>
<p>引介增强，相当于<code>IntroductionInterceptor</code>，包含两个成员：</p>
<ul>
<li><p><code>value</code>:切点，表示在哪个目标类上添加引介增强</p>
</li>
<li><p><code>defaultImpl</code>:接口的默认实现类</p>
</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Declare</span> </span>&#123;</span><br><span class="line">    <span class="meta">@DeclareParents(value=&quot;cn.zhangyuying.demo.springaop.NativeWaiter&quot;,defaultImpl = SmartSeller.class)</span></span><br><span class="line">    <span class="keyword">private</span> Seller seller;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 有了以上引介增强的定义，Waiter 实例即可当作Seller接口实现类使用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  nativeWaiter.greet();</span><br><span class="line">  ((Seller)nativeWaiter).sell();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="切点函数详解"><a href="#切点函数详解" class="headerlink" title="切点函数详解"></a>切点函数详解</h4><p>切点函数是<code>AspectJ</code>表达式语言的核心，也是难点</p>
<ol>
<li><p><code>@annotation()</code></p>
<p>标注了某个注解的所有方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;@annotation(cn.zhangyuying.demo.pointcut.NeedTest)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">annotationTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;after return : annotation&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>execution()</code></p>
<p><code>execution()</code>是最常用的切点函数，其语法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">execution(&lt;修饰符&gt;？&lt;返回类型模式&gt; &lt;方法名模式&gt;(&lt;参数模式&gt;) &lt;异常模式&gt;?)</span><br><span class="line">&#x2F;&#x2F;修饰模式默认public</span><br></pre></td></tr></table></figure>

<p>其中，除了返回类型模式，方法名模式和参数模式外，其他项都是可选的。即：<code>返回类型 方法名(参数)</code></p>
<p>例如：</p>
<ul>
<li><p>通过方法签名定义切点：</p>
<p><code>execution(public * *(..))</code>：匹配所有<code>public</code>方法</p>
<p><code>execution(* *To(..))</code>：匹配所有目标类以<code>To</code>为后缀的方法</p>
</li>
<li><p>通过类定义切点</p>
<p><code>execution(* cn.zhangyuying.Waiter.*(..))</code>：匹配<code>Waiter</code>接口的所有方法</p>
<blockquote>
<p>注意:仅仅是这个接口的方法</p>
</blockquote>
<p><code>execution(* cn.zhangyuying.Waiter+.*(..))</code>：匹配<code>Waiter</code>接口及其实现类的所有方法</p>
<blockquote>
<p>注意：是匹配实现了这个接口的类的所有的方法</p>
</blockquote>
</li>
<li><p>通过类包定义切点</p>
<p><code>execution(* cn.zhangyuying.*(..))</code>：匹配<code>cn.zhangyuying</code>包下所有类的方法</p>
<p><code>execution(* cn.zhangyuying..*(..))</code>：匹配<code>cn.zhangyuying</code>包及其子包下所有类的方法</p>
<p><code>execution(* cn..*.*Dao.find(..))</code>：匹配包前缀为<code>cn</code>的任何包下类名后缀为<code>Dao</code>的方法，方法名必须以<code>find</code>为前缀</p>
</li>
<li><p>通过方法入参定义切点</p>
<p>入参可以使用<code>“*”</code>和<code>“..”</code>通配符，<code>“*”</code>：表示任意类型的参数，<code>“..”</code>：表示任意类型的参数且参数个数不限</p>
<p><code>execution(* joke(String,int))</code>：匹配所有<code>joke(String,int)</code>方法</p>
<p><code>execution(* joke(String,*))</code>：匹配所有两个参数，其中第一个参数为<code>String</code>的<code>joke</code>方法</p>
<p><code>execution(* joke(String,..))</code>：匹配第一个入参为<code>String</code>，后面可以有任意个入参且入参类型不限的<code>joke</code>方法</p>
<p><code>execution(* joke(Object+))</code>：匹配仅包含一个参数，这个参数是<code>Object</code>类或子类的<code>joke</code>方法</p>
</li>
</ul>
</li>
<li><p><code>args()</code></p>
<p>该函数接收一个类名，表示目标类方法<strong>入参对象</strong>是指定类(包含子类)时，切点匹配，即类名后面加不加<code>+</code>都一样</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">args(cn.zhangyuying.Waiter)  <span class="comment">//表示入参是Waiter类型的方法</span></span><br><span class="line"><span class="comment">//针对运行时入参而言，而execution(* *(cn.zhangyuying.Waiter))是针对类方法签名而言的，即等价于execution(* *(cn.zhangyuying.Waiter+))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>@args()</code></p>
<p>该函数接收一个注解类的类名，当方法的运行时入参对象标注了指定的注解时，匹配切点，也是类名后面加不加<code>+</code>都一样</p>
<blockquote>
<p>在继承关系中，注解所标注的类需得在<code>@args(M)</code>中M类的下方，这样注解所标注的类及其子类作为入参才会被匹配</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@args(cn.zhangyuying.demo.pointcut.NeedTest)</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>within()</code></p>
<p>该函数接收一个类名，最小范围也只能是类，表示目标类的所有方法匹配切点，<code>within()</code>函数定义的连接点是针对目标类而言的，而非针对运行期对象的类型而言，这一点和<code>execution</code>是相同的</p>
<blockquote>
<p>注意：<code>within(cn.zhangyuying.Waiter)</code>，匹配接口是没有意义的，因为<code>within</code>匹配的是确切的类名，并且不会传递子类</p>
<p>但是<code>execution</code>可以匹配子类和接口，回忆<code>exection(* cn.zhangyuying.Waiter.*(..))</code>：表示匹配所有实现了这个接口的接口方法</p>
<p><code>within(com.dengchengchao.Waiter+)</code>可以解决这个问题</p>
</blockquote>
<p><code>within(cn.zahngyuying.NativeWaiter)</code>：匹配目标类<code>NativeWaiter</code>的所有方法</p>
<p><code>within(cn.zhangyuying.*)</code>：匹配<code>cn.zhangyuying</code>包中的所有类，但不包括子孙包</p>
<p><code>within(cn.zhangyuying..*)</code>：匹配<code>cn.zhangyuying</code>包以及子孙包中所有类</p>
</li>
<li><p><code>@within()</code></p>
<p>只接受注解类名作为入参，<code>@within(M)</code>匹配标注了<code>@M</code>的目标类，表示这些类的所有方法匹配切点</p>
<blockquote>
<p>注意，<code>@within(M)</code>对于接口是无效的，如果是M标注在实现类上，且M上标注了<code>@Inherited</code>，那么可以匹配标注M的类和该类的实现类，但是如果M标注在接口上，那么接口的实现类不会被匹配</p>
</blockquote>
</li>
<li><p><code>@target()</code></p>
<p>只接受注解类名作为入参，<code>@target(M)</code>匹配任意标注了<code>@M</code>的目标类，表示这些类的所有方法匹配切点</p>
<blockquote>
<p>注意，<code>@target(M)</code>对于接口依然是无效的，如果是M标注在实现类上，且M上标注了<code>@Inherited</code>，那么可以匹配标注M的类和该类的实现类，但是如果M标注在接口上，那么接口的实现类不会被匹配</p>
</blockquote>
</li>
<li><p><code>target()</code></p>
<p>仅接受类名入参，通过判断目标类是否按类型匹配指定类来决定连接点是否匹配，是否使用<code>+</code>效果一样</p>
<p><code>target(M)</code>表示如果目标类按类型匹配于M，则目标类的所有方法都匹配切点</p>
<p><code>target(cn.zhangyuying.Waiter)</code>，则所有实现了这个接口的所有类以及类中的所有方法都会匹配(包括<code>Waiter</code>接口中未定义，但是实现类中定义的方法)。</p>
</li>
<li><p><code>this()</code></p>
<p>仅接受类名入参，通过判断代理类是否按类型匹配指定类来决定是否和切点匹配，是否使用<code>+</code>效果一样</p>
<p>一般来说使用<code>this()</code>和<code>target()</code>来匹配定义切点，二者是等效的</p>
<p>二者的区别体现在通过引介切面产生代理对象时的具体表现：</p>
<ul>
<li><code>this</code>(引介实现的接口)：匹配代理对象的所有方法，包括本身的方法和通过引介引入的方法</li>
<li><code>target</code>(引介引入的接口)：不匹配通过引介切面产生的代理对象</li>
</ul>
</li>
</ol>
<h4 id="AspectJ进阶"><a href="#AspectJ进阶" class="headerlink" title="@AspectJ进阶"></a><code>@AspectJ</code>进阶</h4><ol>
<li><p>切点复合运算</p>
<p>即切点之间使用逻辑运算符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;@within(cn.zhangyuying.demo.NeedTest) &amp;&amp; execution(* *.test2(..))&quot;)</span>  <span class="comment">// &amp;&amp; 可用 and代替</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pointcutTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">   System.out.println(<span class="string">&quot;after return&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>命名切点</p>
<p>在致此之前的举例，切点都是直接声明在增强方法处，这种切点声明方式成为匿名切点，匿名切点只能在声明处使用，如果希望在其他地方重用一个切点，则可以通过<code>@Pointcut</code>注解及切面类方法对切点进行命名</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointcutName</span> </span>&#123;</span><br><span class="line">  <span class="meta">@Pointcut(&quot;within(cn.zhangyuying.*)&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">inPackage</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Pointcut(&quot;inPackage() and execution(* greetTo(..))&quot;)</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inPackcgeGreetTo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用命名切点</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PointcutNameTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before(&quot;PointCutName.inPackcgeGreetTo()&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nameTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="meta">@Before(&quot;PointCutName.inPackcgeGreetTo() &amp;&amp; args(cn.zhangyuying.demo.ParamClass)&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nameTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>增强织入顺序</p>
<p>一个连接点可以同时匹配多个切点，切点对应的增强的顺序安排：</p>
<ul>
<li>如果增强在同一个切面中声明，则依照增强在切面类中定义的顺序织入</li>
<li>如果增强位于不同的类中，且这些类都实现了<code>Ordered</code>接口，则由顺序号决定，</li>
<li>如果没有实现<code>Ordered</code>接口，则顺序是不确定的</li>
</ul>
</li>
<li><p>访问连接点信息</p>
<p><code>AspectJ</code>使用<code>JoinPoint</code>接口表示目标类连接点对象，如果是环绕增强，则使用<code>JoinPoint</code>的子类<code>ProceedingJoinPoint</code>表示连接点对象，任何增强方法都可以通过将第一个入参声明为<code>JoinPoint</code>访问连接点上下文信息</p>
<p><code>JoinPoint中</code>的主要方法：</p>
<ul>
<li> <code>Object[] getArgs();</code> ：获取连接点方法运行时的入参列表</li>
<li> <code>Signature getSignature();</code>：获取连接点的方法签名对象</li>
<li> <code>Object getTarget();</code> ：获取连接点所在的目标对象</li>
<li> <code>Object getThis();</code> ：获取代理对象本身</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(&quot;@within(cn.zhangyuying.demo.NeedTest) &amp;&amp; execution(* *.test3(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">targetTest</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">    System.out.println(joinPoint.getArgs().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定连接点方法入参</p>
<p>对于：<code>args()</code>、<code>this()</code>、<code>target()</code>、<code>@args()</code>、<code>@within()</code>、<code>@target()</code>、<code>@annotation()</code>，除了指定类名，还可以指定参数名，将目标对象连接点上的方法入参绑定到增强的方法中，当指定参数名时，就同时具有匹配切点和绑定参数双重功能</p>
<p>其中<code>args()</code>用于绑定连接点方法的入参，<code>args()</code>绑定参数使用实例（其他函数同理）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;target(cn.zhangyuying.NativeWaiter) &amp;&amp; args(name,num,..)&quot;)</span>  <span class="comment">//(1) </span></span><br><span class="line"><span class="comment">//首先，根据(2)处的增强方法入参，找到name和num对应的类型，以得到真实的切点表达式：target(cn.zhangyuying.NativeWaiter) &amp;&amp; args(String,int,..)</span></span><br><span class="line"><span class="comment">//其次，在增强方法织入目标连接点时，增强方法可以通过num和name访问到连接点的方法入参</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindParams</span><span class="params">(<span class="keyword">int</span> num, String name)</span></span>&#123;  <span class="comment">//(2)</span></span><br><span class="line">  System.out.println(name+num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当<code>args()</code>函数入参为参数名时，共包括两方面的信息</p>
<ol>
<li>连接点匹配规则信息：连接点方法的第一个入参是<code>String</code>类型，第二个参数是<code>int</code>类型</li>
<li>连接点方法入参和增强方法入参的绑定信息：连接点方法的第一个入参绑定到增强方法的<code>name</code>参数上，第二个入参绑定到增强方法的<code>num</code>参数上（<code>args()</code>函数的参数顺序决定了匹配的切点的参数顺序）</li>
</ol>
<p>切点匹配和参数绑定的过程：首先，<code>args()</code>根据参数名称在增强方法中查到名称相同的入参并获知对应的类型，这样就知道了匹配连接点方法的入参类型，其次，连接点方法入参类型所在的位置则由参数名在<code>args()</code>函数中声明的位置决定</p>
</li>
<li><p>绑定连接点信息的函数</p>
<p>这些函数虽然绑定的信息不同，但是使用方法和原理都和args()函数相同</p>
<ul>
<li><p>绑定连接点方法入参：<code>args()</code></p>
</li>
<li><p>绑定连接点方法入参的注解：<code>@args()</code></p>
</li>
<li><p>绑定连接点方法的注解：<code>@annotation()</code></p>
</li>
<li><p>绑定被代理对象实例：<code>this()</code>、<code>target()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;this(waiter)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindThis</span><span class="params">(Waiter waiter)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定目标类的注解对象：<code>@within</code>和<code>@target</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Before(&quot;@within(nt)&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bindWithin</span><span class="params">(NeedTest nt)</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//测试可发现CGLib代理类时，其类的注解对象也被代理了</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定返回值</p>
<p>后置增强中，可以通过<code>returning</code>绑定连接点方法的返回值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterReturning(value=&quot;target(cn.zhangyuying.NativeWaiter)&quot;,returning=&quot;retVal&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">bindReturnValue</span><span class="params">(<span class="keyword">int</span> retVal)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>绑定抛出的异常</p>
<p><code>@AfterThrowin</code>g<code>解可以使用</code>throwing`成员绑定抛出的异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@AfterThrowing(value=&quot;target(cn.zhangyuying.NativeWaiter)&quot;,throwing=&quot;iae&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bingException</span><span class="params">(IllegalArgumentException iae)</span></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ol>
<h4 id="混合切面类型"><a href="#混合切面类型" class="headerlink" title="混合切面类型"></a>混合切面类型</h4><p>Spring提供了<code>4</code>中定义切面的方式：</p>
<ol>
<li>基于<code>@AspectJ</code>注解的方式：项目在Java5以上，优先考虑</li>
<li>基于<code>&lt;aop:aspect&gt;</code>的方式：JDK版本低，不支持注解，可以考虑这种方式</li>
<li>基于<code>&lt;aop:advisor&gt;</code>的方式：在升级一个基于低版本的Spring AOP开发的项目，可以使用它复用已经存在的<code>Advice</code>类</li>
<li>基于<code>Advisor</code>的方式：低版本的Spring只能使用这种方式</li>
</ol>
<p>我们只细致的学习了第一种，其他三种不在此详述</p>
<p>虽然提供了4种定义切面的方式，但其底层的实现技术却是一样的，那就是基于CGLib和JDk动态代理，所以在同一个Spring项目中可以混合使用Spring所提供的各种切面定义方式，但是一般不会同时使用，示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;controlFlowAdvisor&quot;</span>  //(<span class="attr">1</span>)使用<span class="attr">Advisor</span> <span class="attr">API</span>方式实现的流程控制切面</span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.support.DefaultPointcutAdvisor&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;pointcut&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.aop.support.ControlFlowPointcut&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.Class&quot;</span></span></span><br><span class="line"><span class="tag">                       <span class="attr">value</span>=<span class="string">&quot;com.smart.advisor.WaiterDelegate&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">&quot;java.lang.String&quot;</span> <span class="attr">value</span>=<span class="string">&quot;service&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;advice&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.advisor.GreetingBeforeAdvice&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span> /&gt;</span> //(2)使用@AspectJ方式定义的切面</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.aspectj.example.PreGreetingAspect&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-targe-class</span>=<span class="string">&quot;true&quot;</span>&gt;</span>  //(3)使用基于Schema配置方式定义的切面</span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;testAdvice&quot;</span> <span class="attr">pointcut</span>=<span class="string">&quot;execution(* com..*.Waiter.greetTo(..))&quot;</span> /&gt;</span>  //使用<span class="tag">&lt;<span class="name">aop:advisor</span>&gt;</span>配置方式定义的切面</span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;adviceMethods&quot;</span>&gt;</span>  //(5)使用<span class="tag">&lt;<span class="name">aop:aspect</span>&gt;</span>配置方式定义的切面</span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">pointcut</span>=<span class="string">&quot;target(com.smart.NaiveWaiter) and execution(* greetTo(..))&quot;</span></span></span><br><span class="line"><span class="tag">                <span class="attr">method</span>=<span class="string">&quot;preGreeting&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;adviceMethods&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.schema.AdviceMethods&quot;</span> /&gt;</span> //POJO的增强类</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;testAdvice&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.smart.schema.TestBeforeAdvice&quot;</span> /&gt;</span> //基于特定增强接口的增强类</span><br></pre></td></tr></table></figure>

<p>在内部Spring使用<code>AspectJExpressionPointcut</code>为<code>@Aspect</code>J、<code>&lt;aop:aspect&gt;</code>及<code>&lt;aop:advisor&gt;</code>提供具体的切点实现</p>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>除了在运行期织入切面的方式外，还可以在类加载期通过字节码编辑技术将切面织入目标类中，这种织入方式称为<code>LTW</code>（<code>Load Time Weaving</code>）</p>
<p>Java5.0提供了代理功能(<code>agent</code>)完成加载期切面织入工作，JDK的代理功能能够让代理期访问到JVM的底层部件，借此向JVM注册类文件转换器，在类加载时对类文件的字节码进行转换，具体如下：</p>
<p>JDK5.0新增了一个<code>java.lang.instrument</code>包，里面有两个能对JVM底层组件进行访问的类，具体的说就是通过JVM的<code>-javaagent</code>代理参数在启动时获取JVM内部组件的引用，一边在后续流程使用，借助JDK动态代理，可以在JVM启动时装配并应用<code>ClassTransformer</code>对类字节码进行转换，实现AOP功能</p>
<ul>
<li><code>ClassFileTransformer</code>：Class文件转换器接口</li>
<li><code>Instrumentation</code>：代表JVM内部的一个构件，可称其为组件，可通过<code>addTransformer(ClassFileTransformer transformer)</code>注册一些<code>ClassFileTransformer</code>，这样在JVM加载Class文件时，就会先使用<code>ClassFileTransformer </code>按顺序对Class文件的字节码进行转换实现增强</li>
</ul>
<p>AspectJ就是基于此技术工作的，但是这样的作用范围是整个JVM，对于单一JVM多个应用的情况不合适</p>
<p>Spring的<code>LTW</code></p>
<p>Spring为<code>LTW</code>提供了细粒度的控制，支持在单个<code>ClassLoader</code>范围内实施类文件转换，且配置更为简单，不过仅支持AspectJ定义的切面，即可以是直接采用AspectJ语法定义的切面，也可以是采用基于<code>@AspectJ</code>注解通过Java类定义的切面</p>
<p>Spring利用类路径下的<code>META-INF/aop.xm</code>l配置文件找到切面定义及切面所要实施的候选目标类信息，通过<code>LTW</code>在<code>ClassLoader</code>加载类文件时将切面织入目标类中，工作原理如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Spring/SpringLTW%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.jpg" alt="Spring LTW工作原理"></p>
<p>Spring利用特定的Web容器的<code>ClassLoader</code>，通过<code>LTW</code>将Spring提供的<code>ClassFileTransformer</code>注册到<code>ClassLoader</code>中，类加载的时候注册的<code>ClassFileTransformer</code>将读取配置文件(<code>aop.xml</code>)，获取切面,对加载到VM中的Bean类进行字节码转换，注入切面，Spring容器在初始化Bean实例时，采用的Bean类就是已经被织入了切面的类</p>
<p>Spring为Web应用服务器都提供了专门的<code>LoadTimeWeaver</code>：Spring的<code>LoadTimeWeaver</code>接口规定了类加载器织入器的高层协议，且Spring为<code>LoadTimeWeaver</code>提供了多个实现类，即各个Web服务器的专门<code>LoadTimeWeaver</code></p>
<p>Spring中配置<code>&lt;context:load-time-weaver&gt;</code>，负责向运行期的<code>ClassLoader</code>注册多个<code>ClassFileTransformer</code>，以便实施<code>LTW</code>的功能</p>
<blockquote>
<p> 大多数Web应用服务器无需通过<code>javaagent</code>而<code>ClassLoader</code>能支持直接访问<code>Instrument</code>的能力，称为为组件使能，上述说的“Spring为Web应用服务器都提供了专门的<code>LoadTimeWeaver</code>”都是指的这类有组件使能的Web服务器，而无这种能力的Web应用服务器要特殊处理，比如Tomcat，但是在此不详述</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx事件</title>
    <url>/2019/08/29/nginx/nginx%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>Nginx是一个事件驱动的框架(<code>Event Driven Architecture</code>，EDA)。</p>
<span id="more"></span>

<blockquote>
<p>什么是事件驱动框架呢？</p>
<p>一个事件驱动框架（EDA）定义了设计和实现一个应用系统的方法学，在这个系统里事件可传输于松散耦合的组件和服务之间。一个典型的事件驱动系统由事件消费者和事件产生者组成。</p>
<ul>
<li>事件消费者向事件管理器订阅事件，</li>
</ul>
<ul>
<li>事件产生者向事件管理器发布事件。</li>
</ul>
<p>当事件管理器从事件产生者那接收到一个事件时，事件管理把这个事件转送给相应的事件消费者。</p>
</blockquote>
<p>而Nginx中所谓事件，主要指的是网络事件，即事件可以理解为一次网络传输</p>
<p>Nginx的每一个连接会自然对应两个网络事件</p>
<ul>
<li>一个读事件：nginx读取到一个报文，即为一个读事件</li>
<li>一个写事件：nginx需要向浏览器发送一个响应时，需要把消息写到操作系统中，要求操作系统发到网络中，这样就是一个写事件</li>
</ul>
<blockquote>
<p>事件：在网络传输中，客户端和服务器通过三次握手连接后即可发送报文，产生事件</p>
<p>可以理解为网络中的一次传输(参照网络传输简介)，一次网络传输对于nginx来说就是一次事件，包括客户端到服务器的(Nginx的读事件)，也包括服务器到客户端的(Nginx的写事件)</p>
</blockquote>
<h4 id="网络传输简介："><a href="#网络传输简介：" class="headerlink" title="网络传输简介："></a>网络传输简介：</h4><p>网络五层模型：应用层—传输层—网络层—链路层—物理层</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93.png" alt="网络传输"></p>
<p>上述网络传输中的报文是什么格式呢？</p>
<p>报文是网络中交换与传输的数据单元，即站点一次性要发送的数据块，报文包含了将要发送的完整的数据信息，其长短很不一致，长度不限且可变，报文在传输过程中会不断地封装成包、帧等来传输，封装的方式就是添加一些控制信息组成的首部，那些就是报文头。</p>
<p>报文：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/%E7%BD%91%E7%BB%9C%E4%BC%A0%E8%BE%93%E6%8A%A5%E6%96%87.png" alt="报文"></p>
<h4 id="Nginx对事件的处理"><a href="#Nginx对事件的处理" class="headerlink" title="Nginx对事件的处理"></a>Nginx对事件的处理</h4><blockquote>
<p>个人理解Nginx中的事件处理大致流程为：</p>
<ol>
<li>从OS中遍历活跃连接链表获取连接(epoll)(连接即网络传输，即获取报文) </li>
<li>分析连接产生的事件后，放到红黑树中(epoll)</li>
<li>拿到事件进行循环，找到每个事件对应的消费者进行处理[对事件的处理是请求切换不是进程切换]  </li>
</ol>
</blockquote>
<p>Nginx是基于事件驱动的框架，在Nginx中是对事件队列进行循环处理的：在操作系统内核中取出事件队列，之后进行循环处理，如下图所示</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E5%BE%AA%E7%8E%AF%E5%A4%84%E7%90%86%E4%BA%8B%E4%BB%B6.png" alt="Nginx循环处理事件"></p>
<p>在上述事件循环处理中，有一个问题：Nginx如何快速的从操作系统中获取到等待处理的事件队列呢(即事件队列是如何生产的)？</p>
<p>Nginx为了解决这个问题，采用的是<code>epoll</code> 这个网络事件收集器的模型，<code>epoll</code>只维护活跃的连接，所以Nginx遍历的是活跃连接的链表，以此减少对不活跃连接处理的消耗，且建立连接之后，Nginx产生和删除事件使用的是红黑树，保证了增加和删除的复杂度均为<code>O(log n)</code></p>
<blockquote>
<p>epoll是Linux内核为处理大批量文件描述符而作了改进的poll，是Linux下多路复用IO接口select/poll的增强版本，</p>
<blockquote>
<p>poll是Linux中的字符设备驱动中的一个函数。Linux 2.5.44版本后，poll被epoll取代，poll的作用是把当前的文件指针挂到等待队列。</p>
</blockquote>
<p>它能显著提高程序在大量并发连接中只有少量活跃的情况下的系统CPU利用率。</p>
<p>最重要的就是获取事件的时候，它无须遍历整个被侦听的描述符集，只要遍历那些被内核IO事件异步唤醒而加入Ready队列的描述符集合就行了。</p>
<p>epoll除了提供select/poll那种IO事件的水平触发（Level Triggered）外，还提供了边缘触发（Edge Triggered），这就使得用户空间程序有可能缓存IO状态，减少epoll_wait/epoll_pwait的调用，提高应用程序效率。</p>
</blockquote>
<p>Nginx（或其他异步事件处理框架）对于每个事件的处理：都会存在一个事件收集分发器(EDA中的事件管理器)，来对事件进行分发处理</p>
<p>事件收集分发器：定义每类事件处理的消费者，网络将事件生产到Nginx中，而Nginx中的事件收集分发器建立事件对应的消费者，如下图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%B6%88%E8%B4%B9%E5%99%A8.png" alt="Nginx事件收集分发"></p>
<p>事件驱动框架带来的增益：</p>
<p>请求切换场景：基于事件驱动的服务器，无需为每一个请求创建额外的对应线程，减少线程切换的消耗</p>
<ul>
<li>传统的服务(比如apache、tomcat)对请求的处理为：一个进程一个请求，依赖OS的进程调度实现，当一个进程在处理请求的时候遇到阻碍，会在内核态切换成其它进程处理其他请求，此时就会产生很大的消耗</li>
<li>而Nginx是：一个进程同时处理多个请求，当进程上的一个请求遇到阻碍，则直接在用户态切换请求(不在切换进程)，继续处理，不会产生进程切换的消耗</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E8%AF%B7%E6%B1%82%E5%88%87%E6%8D%A2.png" alt="Nginx请求切换"></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx搭建静态资源web服务器</title>
    <url>/2019/08/19/nginx/nginx%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90web%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>Nginx的一个功能就是做静态资源web服务器</p>
<span id="more"></span>

<p>以下为Nginx作为静态静态资源web服务器的示例：</p>
<p><code>nginx.conf</code>所在目录，存在<code>dist</code>文件夹，内部含有入口文件<code>index.html</code></p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="attribute">user</span>  nobody;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log;</span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log  <span class="literal">info</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">pid</span>        logs/nginx.pid;</span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line">//指令块：例如http&#123;&#125;   指令：例如include</span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line">    <span class="attribute">gzip</span>  <span class="literal">on</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">       <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">       <span class="attribute">server_name</span>  <span class="number">0.0.0.0</span>;</span><br><span class="line">    </span><br><span class="line">       <span class="attribute">charset</span> utf-<span class="number">8</span>;</span><br><span class="line">       <span class="comment">#配置静态资源访问</span></span><br><span class="line">       <span class="attribute">location</span> / &#123;</span><br><span class="line">          <span class="attribute">alias</span> dist/;</span><br><span class="line">       &#125;	 </span><br><span class="line">    </span><br><span class="line">       <span class="attribute">error_page</span>   <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span>  /50x.html;</span><br><span class="line">       <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">           <span class="attribute">root</span>   html;</span><br><span class="line">       &#125;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx支持https</title>
    <url>/2019/08/19/nginx/nginx%E6%94%AF%E6%8C%81https/</url>
    <content><![CDATA[<p>大部分站点都是通过<code>https</code>来实现数据安全的，那么怎么将站点变成<code>https</code>的站点呢？</p>
<p>首先需要了解<code>https</code>使用的安全传输协议，了解<code>https</code>是如何保证数据安全的，在看<code>Nginx</code>修改<code>为https</code>的示例</p>
<span id="more"></span>

<h4 id="1-安全传输协议"><a href="#1-安全传输协议" class="headerlink" title="1.安全传输协议"></a>1.安全传输协议</h4><p><strong>简介</strong></p>
<p><code>https</code>使用的安全传输层协议为<code>TLS(Transport Latyer Security)</code> ，前身是<code>SSL(Secure Sockets Layer) </code></p>
<p>TLS/SSL通用模型如下</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/TLS%28SSL%29%E9%80%9A%E7%94%A8%E6%A8%A1%E5%9E%8B.png" alt="TLS/SSL的通用模型"></p>
<p>由上图可看出TLS的加密是发生在表示层，即TCP/IP层，http层是无感知的，其中加密时具体使用的安全加密套件包含以下部分：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/TLS%E5%AE%89%E5%85%A8%E5%8A%A0%E5%AF%86%E5%A5%97%E4%BB%B6.png" alt="TLS的安全加密套件"></p>
<p><strong>公信力</strong></p>
<p>作为一个安全传输协议，TLS如何保证公信力呢？</p>
<p>TLS会从CA机构申请证书，在<code>https</code>的请求过程会对证书进行验证</p>
<p>证书申请及验证流程如下</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/https%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E5%8F%8A%E9%AA%8C%E8%AF%81.png" alt="证书申请及验证流程"></p>
<p>其中申请的证书类型包含如下三种：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/https%E8%AF%81%E4%B9%A6%E7%B1%BB%E5%9E%8B.png" alt="证书类型"></p>
<p><strong>TLS的通讯过程</strong></p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/TLS%E9%80%9A%E8%AE%AF%E8%BF%87%E7%A8%8B.png" alt="TLS的通讯过程"></p>
<p>从TLS通讯过程可以看到主要在做两件事，一个是交换秘钥一个是加密数据，消耗性能的也是这两部分</p>
<p>所以在SSL协议握手是Nginx的性能优化方向为</p>
<ul>
<li>小文件较多时，优化非对称加密算法</li>
<li>大文件较多时，优化对称加密算法</li>
</ul>
<h4 id="2-Nginx改造成Https示例"><a href="#2-Nginx改造成Https示例" class="headerlink" title="2.Nginx改造成Https示例"></a>2.<code>Nginx</code>改造成<code>Https</code>示例</h4><p>将网站改为<code>https</code>示例：（可使用<code>cerbot</code>(会使用到<code>server_name</code>)：<code>yum install python2-certbot-nginx</code>  ）</p>
<p>注：当前示例中使用了两个<code>server</code>模块，也可使用一个模块</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attribute">user</span>  root;</span><br><span class="line"><span class="attribute">worker_processes</span>  <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">error_log</span>  /var/log/nginx/error.log <span class="literal">warn</span>;</span><br><span class="line"><span class="attribute">pid</span>        /var/run/nginx.pid;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">events</span> &#123;</span><br><span class="line">    <span class="attribute">worker_connections</span>  <span class="number">1024</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">http</span> &#123;</span><br><span class="line">    <span class="attribute">include</span>       /etc/nginx/mime.types;</span><br><span class="line">    <span class="attribute">default_type</span>  application/octet-stream;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">log_format</span>  main  <span class="string">&#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27;</span></span><br><span class="line">                      <span class="string">&#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">access_log</span>  /var/log/nginx/access.log  main;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">sendfile</span>        <span class="literal">on</span>;</span><br><span class="line">    <span class="comment">#tcp_nopush     on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">keepalive_timeout</span>  <span class="number">65</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">#gzip  on;</span></span><br><span class="line"></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/conf.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">upstream</span> test &#123;     </span><br><span class="line">        <span class="attribute">server</span> ip:port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">listen</span>       [::]:<span class="number">80</span> default_server;</span><br><span class="line">        <span class="attribute">server_name</span>  _;</span><br><span class="line">		<span class="attribute">client_max_body_size</span> <span class="number">10M</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">        <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">            <span class="attribute">proxy_pass</span> http://test;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host  $host:$server_port;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP  $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">			<span class="attribute">rewrite</span><span class="regexp"> ^(.*)$</span> https://$host<span class="variable">$1</span> <span class="literal">permanent</span>; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="comment"># HTTPS server</span></span><br><span class="line">    <span class="section">server</span> &#123;</span><br><span class="line">        <span class="attribute">listen</span>       <span class="number">443</span> ssl;</span><br><span class="line">        <span class="attribute">server_name</span>  localhost;</span><br><span class="line">        <span class="attribute">root</span>         /opt/nginx/html;</span><br><span class="line">		<span class="attribute">client_max_body_size</span> <span class="number">10M</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_certificate</span>      zyy-cn.pem;</span><br><span class="line">        <span class="attribute">ssl_certificate_key</span>  zyy-cn.key;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_session_cache</span>    shared:SSL:<span class="number">1m</span>;</span><br><span class="line">        <span class="attribute">ssl_session_timeout</span>  <span class="number">5m</span>;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;</span><br><span class="line">        <span class="attribute">ssl_prefer_server_ciphers</span>  <span class="literal">on</span>;</span><br><span class="line">		</span><br><span class="line">        <span class="attribute">location</span> /test &#123;</span><br><span class="line">           <span class="attribute">index</span> index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="attribute">location</span> / &#123;</span><br><span class="line">			<span class="comment"># 把ip为nginx所在机器的ip</span></span><br><span class="line">            <span class="attribute">proxy_pass</span> http://ip;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  Host  $host:<span class="number">80</span>;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Real-IP  $remote_addr;</span><br><span class="line">            <span class="attribute">proxy_set_header</span>  X-Forwarded-For  $proxy_add_x_forwarded_for;</span><br><span class="line">            <span class="attribute">proxy_next_upstream</span> <span class="literal">error</span> timeout invalid_header http_500 http_502 http_503 http_504;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx父子进程通信</title>
    <url>/2019/08/23/nginx/nginx%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<p>Nginx中进程进行通讯可以通过共享内存或者信号，但是进程间的管理通常只使用信号，命令行中的许多子命令，就是向Master进程中发送信号</p>
<span id="more"></span>

<h4 id="Nginx进程和信号介绍"><a href="#Nginx进程和信号介绍" class="headerlink" title="Nginx进程和信号介绍"></a>Nginx进程和信号介绍</h4><p>在Nginx中能够发送和处理信号的有三部分：</p>
<ul>
<li><p>Master进程</p>
<p>会启动Worker进程</p>
<ul>
<li>监控Worker进程<ul>
<li>CHLD：Worker进程非正常关闭的时候会给Master进程发送的信号</li>
</ul>
</li>
<li>管理Worker进程，通过接收信号，包括：<ul>
<li>TERM，INT：立刻停止Nginx进程</li>
<li>QUIT：优雅的停止Nginx进程：慢慢的停，不要对用户发出立刻停止连接的报文</li>
<li>HUP：重载配置文件</li>
<li>USER1：重新打开日志文件，做日志文件切割</li>
<li>USER2：只能通过命令行，直接向Master进程发送信号，热部署时使用</li>
<li>WINCH：只能通过命令行，直接向Master进程发送信号，热部署时使用</li>
</ul>
</li>
</ul>
</li>
<li><p>Worker进程</p>
<p>通常不直接对Worker进程发送信号。而是由Master进程来管理Worker，所以正常我们是发送信号给Master进程，再由Master进程向Worker进程发送信号</p>
<ul>
<li>TERM，INT：立刻停止Nginx进程</li>
<li>QUIT：优雅的停止Nginx进程：慢慢的停，不要对用户发出立刻停止链接的报文</li>
<li>USER1：重新打开日志文件，做日志文件切割</li>
<li>WINCH：只能通过命令行，直接向Master进程发送信号，热部署时使用</li>
</ul>
</li>
<li><p>Nginx命令行</p>
<p>当启动Nginx以后，Nginx会把他的pid记录到一个文件(nginx.pid)中，这个文件会记录Master的进程pid，所在在执行命令行的时候，就会在这个文件中找到Master进程的pid，并向其发送信号</p>
<ul>
<li>reload：HUP</li>
<li>reopen：USER1</li>
<li>stop：TERM</li>
<li>quit：QUIT</li>
</ul>
</li>
</ul>
<h4 id="Nginx进程和信号使用"><a href="#Nginx进程和信号使用" class="headerlink" title="Nginx进程和信号使用"></a>Nginx进程和信号使用</h4><p><strong><code>nginx -s reload</code> 流程解析</strong></p>
<p><code>nginx -s reload</code> 命令是平滑的升级配置文件，步骤如下：</p>
<ol>
<li><p>向master进程发送HUP信号(reload命令)</p>
</li>
<li><p>master进程校验配置语法是否正确</p>
</li>
<li><p>master进程打开新的监听端口</p>
<p>因为可能在新的配置文件中引入新的端口(例如443)，而子进程会继承父进程所有已经打开的端口(Linux操作系统定义)</p>
</li>
<li><p>master进程用新配置启动新的worker子进程</p>
</li>
<li><p>master进程向老worker子进程发送QUIT信号</p>
</li>
<li><p>老worker进程关闭监听句柄，处理完当前连接后结束进程</p>
</li>
</ol>
<p>不停机载入新配置，图示如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E7%9A%84reload%E6%B5%81%E7%A8%8B.png" alt="Nginx的reload流程"></p>
<p><strong>热升级流程</strong></p>
<p>不停止Nginx进程对Nginx进行升级</p>
<ol>
<li><p>将旧的Nginx文件换成新的Nginx文件</p>
<p>备份和升级的都是二进制文件(一般为sbin下的nginx)，并不需要更改其他文件</p>
</li>
<li><p>向master进程发送USER2信号</p>
</li>
<li><p>master进程修改pid文件名，加后缀<code>.oldbin</code></p>
</li>
<li><p>master进程用新Nginx文件启动新master进程</p>
<p>新的master进程是老的master进程的子进程</p>
</li>
<li><p>向老master进程发送WINCH信号，关闭老worker进程</p>
</li>
<li><p>回滚：向老master发送HUP，向新master发送QUIT</p>
</li>
</ol>
<p>不停机更新nginx二进制文件，图示如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E7%83%AD%E5%8D%87%E7%BA%A7%E6%B5%81%E7%A8%8B.png" alt="Nginx热升级流程"></p>
<h4 id="如何优雅"><a href="#如何优雅" class="headerlink" title="如何优雅"></a>如何优雅</h4><p>优雅的关闭就是对worker进程而言的，因为只有worker才会处理请求，到底如何算是优雅呢？</p>
<p>优雅的关闭就是指worker进程能够识别出当前的连接没有正在处理请求，这个时候再把连接进行关闭。但是对于webSocket和TCP/IP的请求Nginx是做不到的，不过对于Http请求Nginx是可以做到的，所以优雅的关闭主要是针对Http请求</p>
<p>优雅关闭worker进程的流程：</p>
<ol>
<li><p>设置定时器 <code>worker_shutdown_timeout</code></p>
</li>
<li><p>关闭监听句柄</p>
</li>
<li><p>关闭空闲连接</p>
</li>
<li><p>在循环中等待全部连接关闭</p>
<p>在此步骤中可能查过1中设置的时间，超过时间worker集成会立即退出，相当于优雅的关闭只进行了一半</p>
</li>
<li><p>退出进程</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx的进程结构</title>
    <url>/2019/08/19/nginx/nginx%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>要想更好的使用Nginx就要先对Nginx的工作机制有所了解</p>
<p>Nginx是运行在企业内网的最外层，处理的流量是其他企业应用的数百倍，甚至几个数量级，那么Nginx是如何应对如此大的数量的呢</p>
<span id="more"></span>

<h4 id="Nginx的请求处理流程"><a href="#Nginx的请求处理流程" class="headerlink" title="Nginx的请求处理流程"></a>Nginx的请求处理流程</h4><p>Nginx的核心使用的是非阻塞的事件驱动处理引擎(<code>epoll</code>),对于这种异步处理引擎，通常需要状态机正确识别和处理请求。</p>
<p>Nginx可以处理静态资源，也可以做反向代理。不过处理静态资源时，当整个内存不足以完全的缓存住文件和缓存信息的时候，像<code>sendfile</code>或者<code>nio</code>会退化成阻塞的磁盘调用，此时就需要线程池来处理，如下图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B.png" alt="Nginx请求处理流程"></p>
<h4 id="Nginx的进程结构"><a href="#Nginx的进程结构" class="headerlink" title="Nginx的进程结构"></a>Nginx的进程结构</h4><p>Nginx的进程架构有两种：</p>
<ul>
<li>单进程结构，一般为开发调试使用的</li>
<li>多进程结构，生产环境，足够健壮，可以利用多核CPU的特性</li>
</ul>
<p>那么为什么Nginx是多进程而不是多线程：</p>
<p>为了保证高可用性和高可靠性，若是使用多线程：线程是共享地址空间的，一个有问题导致共享的地址空间有问题，会导致Nginx进程全部挂掉。所以Nginx采用的是多进程</p>
<p>Nginx多进程下的进程架构</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/Nginx/Nginx%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BB%93%E6%9E%84.png" alt="Nginx的进程架构"></p>
<p>Nginx多进程包括，父进程和子进程，如下：</p>
<p>父进程：master进程是对子进程进行管理的，尤其Worker进程</p>
<p>子进程：</p>
<ul>
<li><p>Worker进程是处理真正的请求的 ，实际上一个请求处理时，使用的缓存还是在Worker上进行的，且缓存是在Worker进程间是共享的</p>
<p>Nginx采用事件驱动模型，希望一个Worker进程占用一个cpu，这样可以更好的使用每个cpu核上的cpu缓存，来减少缓存失效的命中率</p>
</li>
<li><p>Cache相关的进程，这部分进程也使用缓存</p>
<ul>
<li>CacheLoader作缓存的载入</li>
<li>CacheManager作缓存的管理</li>
</ul>
</li>
</ul>
<p>进程间的通讯使用共享内存或者信号</p>
<p>在Nginx中，父子进程之间的管理是通过信号的，具体请参照：<a href="http://zhangyuying.cn/2019/08/23/nginx/nginx%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/">Nginx父子进程通信</a></p>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx简介</title>
    <url>/2019/08/13/nginx/nginx%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Nginx是一个高性能的<code>HTTP</code>和反向代理<code>web</code>服务器，同时也提供了<code>IMAP/POP3/SMTP</code>服务。</p>
<p>本文主要介绍<code>Nginx</code>出现的原因、应用场景、优点以及组成</p>
<span id="more"></span>

<h4 id="Nginx出现的原因"><a href="#Nginx出现的原因" class="headerlink" title="Nginx出现的原因"></a><code>Nginx</code>出现的原因</h4><ul>
<li>互联网的数据量快速增长</li>
<li>低效的<code>Apache</code></li>
</ul>
<h4 id="Nginx的三个主要应用场景"><a href="#Nginx的三个主要应用场景" class="headerlink" title="Nginx的三个主要应用场景"></a><code>Nginx</code>的三个主要应用场景</h4><ul>
<li><p>静态资源服务器</p>
<p>通过本地文件系统提供服务</p>
</li>
<li><p>反向代理服务</p>
<ul>
<li><code>Nginx</code>的强大性能</li>
<li>缓存</li>
<li>负载均衡</li>
</ul>
</li>
<li><p><code>API</code>服务</p>
<p><code>OpenResty</code></p>
</li>
</ul>
<h4 id="Nginx的优点"><a href="#Nginx的优点" class="headerlink" title="Nginx的优点"></a><code>Nginx</code>的优点</h4><ul>
<li><p>高并发、高性能</p>
</li>
<li><p>可扩展性好</p>
</li>
<li><p>高可靠性</p>
</li>
<li><p>热部署</p>
</li>
<li><p><code>BSD</code>许可证</p>
<p><code>Nginx</code> 不只是开源的免费的，再有定制需求的时候，可以修改<code>Nginx</code>源码使用在商业用途</p>
</li>
</ul>
<h4 id="Nginx的组成"><a href="#Nginx的组成" class="headerlink" title="Nginx的组成"></a><code>Nginx</code>的组成</h4><ul>
<li><p><code>Nginx</code> 二进制可执行文件</p>
<p>有各模块源码编译出的一个文件</p>
</li>
<li><p><code>Nginx.conf</code>配置文件</p>
<p>控制<code>Nginx</code>的行为</p>
</li>
<li><p><code>access.log</code>访问日志</p>
<p>记录每一条<code>http</code>请求信息</p>
</li>
<li><p><code>error.log</code>错误日志</p>
<p>定位问题</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>Java synchronized</title>
    <url>/2019/11/05/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java-synchronized/</url>
    <content><![CDATA[<p>在Java中提到多线程同步，那一定会想到synchronized，这边文章我们就来了解一下synchronized的实现原理及其在JDK1.6以后的优化。</p>
<p>学习之前需要了解线程的生命周期，可参照<a href="http://zhangyuying.cn/2019/11/02/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B/">Java中的多线程</a>，其中有线程生命周期的介绍</p>
<span id="more"></span>

<p>能获得什么</p>
<ul>
<li>明确synchronized的使用方法及其背后的原理，帮助我们更好地使用synchronized关键字。</li>
<li>了解JDK1.6对synchronized的具体优化内容，对于我们优化自己的并发代码有很好的借鉴作用。 </li>
<li>能够帮助我们更好的理解并发编程机制，有助我们在不同的情况下选择更优的并发策略来完成任务。 </li>
<li>有助于我们学习Java中其他的锁相关的内容。</li>
</ul>
<h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>下面先简单介绍一下本文的介绍顺序：</p>
<ol>
<li>用法介绍：简单介绍synchronized的基本用法。</li>
<li>底层语义原理：将简单的synchronize使用类编译后，通过分析其对应的class文件，揭示synchronized关键字的底层语义原理并引出monitor相关内容。</li>
<li>Java对象头与Monitor：介绍Java对象头在堆栈中的结构、monitor在HotSpot源码中的数据结构。</li>
<li>重量级锁：介绍synchronized优化之前的实现流程，并从系统层面分析其效率低的原因。</li>
<li>Synchronized的优化：介绍了JDK1.6中synchronized的优化内容，并详细介绍“偏向锁”、“轻量级锁”的逻辑处理流程然以及各个锁之间的区别。</li>
<li>引申说明：Linux的内核态和用户态了解</li>
</ol>
<h3 id="用法介绍"><a href="#用法介绍" class="headerlink" title="用法介绍"></a>用法介绍</h3><p>相信大家都已经能够熟练的使用synchronized关键字。但是为了保证文章的连惯性，下面简单介绍一下synchronized的几种用法。</p>
<ol>
<li><p>synchronized修饰普通同步方法。此时锁的是当前实例的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized修饰静态同步方法。此时锁的是类的class对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>synchronized修饰同步代码块。此时锁的是括号内的对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod0</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="底层语义原理"><a href="#底层语义原理" class="headerlink" title="底层语义原理"></a>底层语义原理</h3><p>对于synchronized</p>
<p>修饰实例方法，相当于synchronized(this);</p>
<p>修饰静态方法，相当于synchronized(this.class);</p>
<p>修饰代码块的形式是synchronized(Object)。</p>
<p>可见synchronized相关的代码最后都可以归结为synchronized(Object)的形式。那么到底在JVM内部，是如何实现对一个对象加锁的呢？ 我们先来写一个synchronized的简单测试类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod0</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod1</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod2</span><span class="params">()</span></span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编写完成后，运行：javac SynchronizedTest.java 编译生成class文件，然后再运行：javap -v -p -s -sysinfo -constants SynchronizedTest.class ，使用javap 工具查看生成的class文件。具体信息如下所示：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span></span></span><br><span class="line">minor version: 0</span><br><span class="line">major version: <span class="number">52</span></span><br><span class="line">flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">Constant pool:</span><br><span class="line">#1 = Methodref #3.#17 // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#2 = Class #18 // SynchronizedTest</span><br><span class="line">#3 = Class #19 // java/lang/Object</span><br><span class="line">#4 = Utf8 &lt;init&gt;</span><br><span class="line">#5 = Utf8 ()V</span><br><span class="line">#6 = Utf8 Code</span><br><span class="line">#7 = Utf8 LineNumberTable</span><br><span class="line">#8 = Utf8 synMethod0</span><br><span class="line">#9 = Utf8 StackMapTable</span><br><span class="line">#10 = Class #18 // SynchronizedTest</span><br><span class="line">#11 = Class #19 // java/lang/Object</span><br><span class="line">#12 = Class #20 // java/lang/Throwable</span><br><span class="line">#13 = Utf8 synMethod1</span><br><span class="line">#14 = Utf8 synMethod2</span><br><span class="line">#15 = Utf8 SourceFile</span><br><span class="line">#16 = Utf8 SynchronizedTest.java</span><br><span class="line">#17 = NameAndType #4:#5 // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">#18 = Utf8 SynchronizedTest</span><br><span class="line">#19 = Utf8 java/lang/Object</span><br><span class="line">#20 = Utf8 java/lang/Throwable</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SynchronizedTest</span><span class="params">()</span></span>;</span><br><span class="line">  deor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">  stack=<span class="number">1</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">  <span class="number">0</span>: aload_0</span><br><span class="line">  1: invokespecial #1 // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  <span class="number">4</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">  line <span class="number">2</span>: <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">synMethod0</span><span class="params">()</span></span>;</span><br><span class="line">  deor: ()V</span><br><span class="line">  flags: ACC_PUBLIC</span><br><span class="line">  Code:</span><br><span class="line">  stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">  <span class="number">0</span>: aload_0</span><br><span class="line">  <span class="number">1</span>: dup</span><br><span class="line">  <span class="number">2</span>: astore_1</span><br><span class="line">  <span class="number">3</span>: monitorenter</span><br><span class="line">  <span class="number">4</span>: aload_1</span><br><span class="line">  <span class="number">5</span>: monitorexit</span><br><span class="line">  <span class="number">6</span>: goto <span class="number">14</span></span><br><span class="line">  <span class="number">9</span>: astore_2</span><br><span class="line">  <span class="number">10</span>: aload_1</span><br><span class="line">  <span class="number">11</span>: monitorexit</span><br><span class="line">  <span class="number">12</span>: aload_2</span><br><span class="line">  <span class="number">13</span>: athrow</span><br><span class="line">  <span class="number">14</span>: <span class="keyword">return</span></span><br><span class="line">  Exception table:</span><br><span class="line">  from to target type</span><br><span class="line">  <span class="number">4</span> <span class="number">6</span> <span class="number">9</span> any</span><br><span class="line">  <span class="number">9</span> <span class="number">12</span> <span class="number">9</span> any</span><br><span class="line">  LineNumberTable:</span><br><span class="line">  line <span class="number">5</span>: <span class="number">0</span></span><br><span class="line">  line <span class="number">7</span>: <span class="number">4</span></span><br><span class="line">  line <span class="number">8</span>: <span class="number">14</span></span><br><span class="line">  StackMapTable: number_of_entries = <span class="number">2</span></span><br><span class="line">  frame_type = <span class="number">255</span> <span class="comment">/* full_frame */</span></span><br><span class="line">  offset_delta = <span class="number">9</span></span><br><span class="line">  locals = [ class SynchronizedTest, class java/lang/Object ]</span><br><span class="line">  stack = [ class java/lang/Throwable ]</span><br><span class="line">  frame_type = <span class="number">250</span> <span class="comment">/* chop */</span></span><br><span class="line">  offset_delta = <span class="number">4</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod1</span><span class="params">()</span></span>;</span><br><span class="line">  deor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">  stack=<span class="number">0</span>, locals=<span class="number">1</span>, args_size=<span class="number">1</span></span><br><span class="line">  <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">  line <span class="number">13</span>: <span class="number">0</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">synMethod2</span><span class="params">()</span></span>;</span><br><span class="line">  deor: ()V</span><br><span class="line">  flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">  Code:</span><br><span class="line">  stack=<span class="number">0</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">  <span class="number">0</span>: <span class="keyword">return</span></span><br><span class="line">  LineNumberTable:</span><br><span class="line">  line <span class="number">17</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>SynchronizedTest.class文件主要包含了三部分信息：常量池、构造器方法、以及synMethod0、synMethod1、synMethod2三个方法。 方法由以下几部分组成：</p>
<ul>
<li>deor：用于对方法参数和返回值进行描述。 </li>
<li>flags：方法的访问权限标识。这里重点关注下ACCSYNCHRONIZED 标识。它用来标记方法是否是同步方法。 </li>
<li>Code：方法的编译后的字节码指令。<ul>
<li>字节码指令：这里重点关注下monitorenter和monitorexit指令。JVM就是通过将monitorenter指令插入同步代码块的开始位置，monitorexit指令插入同步代码块的结束位置来实现同步的。</li>
</ul>
</li>
<li>Exception table：列出了方法中抛出的受检异常。from to 两列表示指令的行号; target 表示出现异常后跳转的行号; type 表示异常类型。也就是说当指令抛出异常后，会到Exception table中查找。若指令的行在from to 之间，且抛出的类型与type 一致，那么指令就会跳转到target行执行。 </li>
<li>LineNumberTable：源码与字节码指令的对应关系。例如：line 5：0 表示字节码第五行与源码中第0行对应。 </li>
<li>StackMapTable：栈图。其作用是方便JVM进行类型推导和验证。由于篇幅有限，具体内容这里就不做过多解释了。</li>
</ul>
<p>常量池、构造器方法、字节码指令的解读，这里就不展开了。有兴趣的同学们可以查看JVM相关知识</p>
<blockquote>
<p>看到此处，不知道大家有没有一个疑问，那就是synMethod0方法中并没有显示地加入try catch代码块捕获异常，为什么在生成的class文件中却存在Exception table呢？</p>
<p>这是因为，JVM会自动在synchronized代码块中加入异常捕获，从而保证代码抛出异常时，仍能够释放当前线程占用的锁，避免出现死锁现象。</p>
</blockquote>
<p>通过上面的介绍，可以知道： </p>
<ul>
<li>同步代码块是使用monitorenter和monitorexit指令实现。 </li>
<li>同步方法则是通过在flag中加入ACCSYNCHRONIZED 标识实现的。 </li>
</ul>
<p>那么这些指令具体什么意思呢？</p>
<p>首先我们来看一下JVM规范中对于monitorenter、monitorexit和ACCSYNCHRONIZED的描述：</p>
<ul>
<li><p>monitorenter(参考：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorenter">monitorenter描述</a>）</p>
<p>Each object is associated with a monitor. A monitor is locked if and only if it has an owner. The thread that executes monitorenter attempts to gain ownership of the monitor associated with objectref, as follows:   </p>
<ul>
<li>If the entry count of the monitor associated with objectref is zero, the thread enters the monitor and sets its entry count to one. The thread is then the owner of the monitor.   </li>
<li>If the thread already owns the monitor associated with objectref, it reenters the monitor, incrementing its entry count.   </li>
<li>If another thread already owns the monitor associated with objectref, the thread blocks until the monitor’s entry count is zero, then tries again to gain ownership. </li>
</ul>
<p>每个对象有一个监视器锁（monitor）。当monitor被占用时就处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下： </p>
<ul>
<li>如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为monitor的所有者。</li>
<li>如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1。</li>
<li>如果其他线程已经占用monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再重新尝试获取monitor的所有权。</li>
</ul>
</li>
<li><p>monitorexit（参考：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-6.html#jvms-6.5.monitorexit">monitorexit描述</a>）</p>
<p>The thread that executes monitorexit must be the owner of the monitor associated with the instance referenced by objectref.•The thread decrements the entry count of the monitor associated with objectref. If as a result the value of the entry count is zero, the thread exits the monitor and is no longer its owner. Other threads that are blocking to enter the monitor are allowed to attempt to do so. </p>
<p>执行monitorexit的线程必须是object所对应的monitor的所有者。指令执行时，monitor的进入数减1，如果减1后进入数为0，则线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个monitor的所有权。</p>
</li>
<li><p>ACCSYNCHRONIZED（参考：<a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.11.10">ACCSYNCHRONIZED描述</a>） </p>
<p>当方法被调用时，调用指令将会检查方法的ACCSYNCHRONIZED访问标志是否被设置。如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完成后再释放monitor。在方法执行期间，其他任何线程都无法再获取同一个monitor对象。</p>
</li>
</ul>
<h3 id="Java对象头与Monitor"><a href="#Java对象头与Monitor" class="headerlink" title="Java对象头与Monitor"></a>Java对象头与Monitor</h3><p>上一章节我们说到，java中任何一个对象都有一个monitor对象与之关联，而synchronized语义底层都是通过获取和释放monitor对象来完成的。下面我们就来说一说monitor对象到底为何物。 在介绍monitor之前，我们先来了解一下Java对象头。这是因为monitor就存在于Java对象头里。</p>
<p>备注：下文均参考自HotSpot 源码，源码下载地址为：<a href="https://download.java.net/openjdk/jdk8/%E3%80%82">https://download.java.net/openjdk/jdk8/。</a></p>
<h4 id="Java-对象头"><a href="#Java-对象头" class="headerlink" title="Java 对象头"></a>Java 对象头</h4><p>（参考源码：hotspotsrcsharevmoopsmarkOop.hpp文件)</p>
<p>在JVM中，对象在内存中的布局分为三块区域：对象头、实例变量和填充数据。如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%AE%9E%E4%BE%8B%E5%AF%B9%E8%B1%A1%E7%BB%93%E6%9E%84.png" alt="内存中实例对象结构"></p>
<p>实例变量：存放类的属性数据信息。 </p>
<p>填充数据：用于保证对象8字节对齐。 </p>
<p>对象头：jvm采用2个字宽（Word）存储对象头，若对象为数组则采用3个字宽来存储。在32位虚拟机中1字宽等于4字节，64位虚拟机中1字宽等于8字节。</p>
<p>其结构说明如下表：</p>
<table>
<thead>
<tr>
<th><strong>长度</strong></th>
<th><strong>头对象结构</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>32/64bit</td>
<td>Mark Word</td>
<td>存储对象的hashCode、锁信息或分代年龄或GC标志等信息</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Class Metadata Address</td>
<td>类型指针指向对象的类元数据，JVM通过这个指针确定该对象是哪个类的实例。</td>
</tr>
<tr>
<td>32/32bit</td>
<td>Array length</td>
<td>数组的长度（若当前对象为数组）</td>
</tr>
</tbody></table>
<p>o 对象头中的Mark Word里，默认存储对象的HashCode、分代年龄和锁标记位。 o 32位JVM中，Mark Word的默认存储结构如下：</p>
<table>
<thead>
<tr>
<th><strong>25bit</strong></th>
<th><strong>4bit</strong></th>
<th><strong>1bit是否是偏向锁</strong></th>
<th><strong>2bit 锁标志位</strong></th>
</tr>
</thead>
<tbody><tr>
<td>对象HashCode</td>
<td>对象分代年龄</td>
<td>0</td>
<td>01</td>
</tr>
</tbody></table>
<p>o 在运行期间，根据Mark Word里锁标志位的变化，Mark Word的数据也会发生变化。下面列举了32位JVM下，4种锁状态时Mark Word的存储结构。</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/MarkWord%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.jpeg" alt="Mark Word存储结构"></p>
<p>其中轻量级锁和偏向锁是Java SE1.6 对synchronized的锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁，其中指向互斥量的指针指向的就是monitor对象的起始地址。</p>
<h4 id="Monitor对象"><a href="#Monitor对象" class="headerlink" title="Monitor对象"></a>Monitor对象</h4><p>在HotSpot中，monitor对象是由ObjectMonitor实现的（位于源码hotspotsrcsharevmruntimeobjectmonitor.hpp 文件），其数据结构如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">_header = NULL;</span><br><span class="line">_count = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">_waiters = <span class="number">0</span>, <span class="comment">//等待线程数</span></span><br><span class="line">_recursions = <span class="number">0</span>; <span class="comment">//重入次数</span></span><br><span class="line">_object = NULL; <span class="comment">//存储该monitor的对象</span></span><br><span class="line">_owner = NULL; <span class="comment">//指向获得monitor的ObjectWaiter对象</span></span><br><span class="line">WaitSet = NULL; <span class="comment">//处于wait状态的线程，会被加入到WaitSet</span></span><br><span class="line">_WaitSetLock = <span class="number">0</span> ;</span><br><span class="line">_Responsible = NULL ;</span><br><span class="line">_succ = NULL ;</span><br><span class="line">_cxq = NULL ; <span class="comment">//多线程竞争锁时的单向列表</span></span><br><span class="line">FreeNext = NULL ;</span><br><span class="line">_EntryList = NULL ; <span class="comment">//处于等待锁blocked状态的线程，会被加入到该列表</span></span><br><span class="line">_SpinFreq = <span class="number">0</span> ;</span><br><span class="line">_SpinClock = <span class="number">0</span> ;</span><br><span class="line">OwnerIsThread = <span class="number">0</span> ;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>到此处又产生了一个疑问。那就是Monitor对象本身结构如此复杂，若每一个对象都创建一个monitor对象是不是极大的浪费系统资源呢？</p>
<p> 事实就是，monitor并不是随着对象创建而创建的。而是每个线程都存在两个ObjectMonitor对象列表，分别为free和used列表;同时jvm中也维护着global locklist。当线程需要ObjectMonitor对象时，首先从自身的free表中申请，若存在则使用，若不存在则从global list中申请。</p>
</blockquote>
<p>这里重点介绍一下monitor中几个变量：</p>
<p>1） owner：指向一个持有当前monitor的ObjectWaiter对象（每个等待锁的线程都会被封装成ObjectWaiter对象）。</p>
<p>2） _cxq ：存储ObjectWaiter对象的单向列表。多线程竞争锁时，会先进入此队列中。</p>
<p>3） _EntryList：存储处于Blocked状态的ObjectWaiter对象列表。</p>
<p>4） _WaitSet：存储wait状态的ObjectWaiter对象列表。</p>
<p>注意：ObjectWaiter对象是双向链表结构，保存了thread（当前线程）以及当前的状态TState等数据。</p>
<p>队列之间的关系转换可以用下图简单表示：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/monotor%E4%B8%AD%E7%9A%84%E9%98%9F%E5%88%97%E8%BD%AC%E6%8D%A2.png" alt="monotor中的队列转换"></p>
<p>上图中的qmode和policy的说明：</p>
<ul>
<li>monitor中根据变量线程进入cxq队列后，根据qmode值的不同存在不同的策略：<ol>
<li>qmode =2：直接绕过EntryList队列，从cxq队列中获取线程用于竞争锁；</li>
<li>qmode =3：cxq队列插入EntryList尾部；</li>
<li>qmode =4：cxq队列插入到_EntryList头部；</li>
</ol>
</li>
</ul>
<ul>
<li>当对象调用notifyAll时，几种policy：<ol>
<li>policy = 0：waitset队列中的对象头插入EntryList队列中；</li>
<li>policy = 1：waitset队列中的对象尾插入EntryList队列中；</li>
<li>policy = 2：waitset队列中的对象头插入cxq队列中；</li>
<li>policy = 3：waitset队列中的对象尾插入cxq队列中；</li>
</ol>
</li>
</ul>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>说到这里各位读者对monitor有了一个大概的印象，下面我们抛开synchronized的优化，先来讨论下重量级锁的获取情况。 </p>
<p>我们知道synchronized关键字修饰的代码段或者方法，虽然编译时生成的指令不同，但是最终都是通过monitorenter、monitorexit指令来获取和释放互斥锁。下面就介绍一下monitorenter、monitorexit在jvm中的实现。</p>
<p>对于重量级锁(ObjectMonitor中实现的)，具体流程概括如下：</p>
<p>（此处省略锁的自旋优化等操作，统一放在后面synchronzied优化中说）</p>
<ol>
<li><p> 通过CAS尝试把monitor的owner字段设置为当前线程；</p>
</li>
<li><p> 如果设置之前的owner指向当前线程，说明当前线程再次进入monitor，即重入锁，执行recursions ++ ，记录重入的次数；</p>
</li>
<li><p> 如果当前线程是第一次进入该monitor，设置recursions为1，_owner为当前线程，该线程成功获得锁并返回；</p>
</li>
<li><p>如果获取锁失败，则等待锁的释放；</p>
<p>竞争锁失败时：</p>
<ol>
<li>当前线程被封装成ObjectWaiter对象node，状态设置成ObjectWaiter::TSCXQ； </li>
<li>在for循环中，通过CAS把node节点push到cxq列表中，同一时刻可能有多个线程把自己的node节点push到cxq列表中；</li>
<li>node节点push到cxq列表之后，通过自旋尝试获取锁，如果还是没有获取到锁，则通过park将当前线程挂起，等待被唤醒；</li>
</ol>
</li>
</ol>
<p>为重量级锁的原因：</p>
<p>ObjectMonitor的函数调用中会涉及到Mute lock等特权指令，这个时候就会存在操作系统用户态和内核态的转换，由于用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗，这就是在synchronized未优化之前，效率低的原因。</p>
<h3 id="Synchronized的优化"><a href="#Synchronized的优化" class="headerlink" title="Synchronized的优化"></a>Synchronized的优化</h3><p>下面就来介绍JVM为了提高synchronized的运行效率，所做的优化。</p>
<p>在synchronization优化之前，只有重量级锁一种。JDK1.6对其优化之后，增加了如下几个内容：</p>
<ul>
<li>偏向锁 </li>
<li>轻量级锁 </li>
<li>其他优化 <ul>
<li>适应性自旋 </li>
<li>锁粗化 </li>
<li>锁消除 </li>
</ul>
</li>
</ul>
<p>在具体介绍优化细节之前，我们先来回忆一下前文提到的对象头中Mark Word的结构。在优化之前Mark Word中只有重量级锁一种状态。JDK 1.6 之后，引入偏向锁、轻量锁两种新状态。 JDK以后线程首次获得对象时，将处于偏向锁状态，随着竞争的升级，锁可以逐渐升级。锁的升级流程为：</p>
<p>偏向锁–》轻量级锁–》重量级锁 （只能升级不能降级）</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>引入偏向锁的原因就是在大多数情况下锁不仅不存在多线程竞争，而且总是由同一个线程多次获得，为了让线程获取锁的代价更低，引入偏向锁，减少不必要的CAS操作。（可通过-XX:-UseBiasedLocking禁用偏向锁）</p>
<p>在Mark Word中存有thread id，这个字段初始为空。当线程第一次获取锁时，就将自身id写入到此字段中，并将Mark Word中的是否偏向锁的状态置为1。这样下次再获取锁时，直接检查thread id即可，提高了效率。 </p>
<p>具体过程如下：(源码位于：hotspotsrcsharevmruntimesynchronizer.cpp fast_enter方法中) </p>
<p>1） 检测Mark Word里面是不是存放自身的id，如果是，表示当前线程处于“偏向锁”，跳过轻量锁和重量锁，直接执行同步代码。 </p>
<p>2） 如果Mark Word不是自己的threadid，锁升级为轻量级锁。这时使用CAS来进行切换。新的线程根据Mark Word中的threadid，通知之前的线程暂停，之前的线程将Mark Word的内容置空。</p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>偏向锁升级为轻量级锁以后，Mark Word的结构也变为轻量级锁的结构。 </p>
<p>轻量级锁的运行流程如下：(源码位于：hotspotsrcsharevmruntimesynchronizer.cpp slow_enter方法中) </p>
<ol>
<li><p>两个线程都把对象的Mark Word复制到自己的线程栈中。 </p>
</li>
<li><p>线程通过CAS操作，把共享对象的Mark Word的内容修改为自己新建的记录空间的地址。 </p>
</li>
<li><p>若修改成功，则获取资源。若失败则进入自旋。 </p>
</li>
<li><p>自旋的线程在自旋过后，成功获取资源（即之前获取资源的线程执行完成释放了资源），则整个状态进入轻量级锁状态。</p>
</li>
</ol>
<p>如果自旋后获取资源失败，则进入重量级锁的状态。此时自旋的线程阻塞，等待之前线程执行完成并唤醒自己。</p>
<p>(在自旋的时候，检测到有其他线程的到来来获取锁，也会进入到重量级锁的状态)</p>
<h4 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h4><p>1 适应性自旋 </p>
<p>从轻量级锁获取的流程中我们知道，当线程在获取轻量级锁的过程中执行CAS操作失败时，是要通过自旋来获取重量级锁的。问题在于，自旋是需要消耗CPU的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费CPU资源。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环10次，如果还没获取到锁就进入阻塞状态。但是JDK采用了更聪明的方式——适应性自旋，简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。 </p>
<p>2 锁粗化 </p>
<p>锁粗化的概念应该比较好理解，就是将多次连接在一起的加锁、解锁操作合并为一次，将多个连续的锁扩展成一个范围更大的锁。</p>
<p>举个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringBufferTest</span> </span>&#123;</span><br><span class="line">	StringBuffer stringBuffer = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">()</span></span>&#123;</span><br><span class="line">	    stringBuffer.append(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">	    stringBuffer.append(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">	    stringBuffer.append(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">  	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里每次调用stringBuffer.append方法都需要加锁和解锁，如果虚拟机检测到有一系列连串的对同一个对象加锁和解锁操作，就会将其合并成一次范围更大的加锁和解锁操作，即在第一次append方法时进行加锁，最后一次append方法结束后进行解锁。 </p>
<p>3 锁消除 </p>
<p>锁消除即删除不必要的加锁操作。根据代码逃逸技术，如果判断到一段代码中，堆上的数据不会逃逸出当前线程，那么可以认为这段代码是线程安全的，不必要加锁。</p>
<h4 id="不同锁之间的比较："><a href="#不同锁之间的比较：" class="headerlink" title="不同锁之间的比较："></a>不同锁之间的比较：</h4><table>
<thead>
<tr>
<th><strong>锁</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适用场景</strong></th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td>
<td>适用于只有一个线程访问同步块场景（只有一个线程进入临界区）</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度</td>
<td>如果始终得不到索竞争的线程，使用自旋会消耗CPU</td>
<td>追求响应速度，同步块执行速度非常快（多个线程交替进入临界区）</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU</td>
<td>线程阻塞，响应时间缓慢</td>
<td>追求吞吐量，同步块执行速度较慢（多个线程同时进入临界区）</td>
</tr>
</tbody></table>
<h3 id="引申说明"><a href="#引申说明" class="headerlink" title="引申说明"></a>引申说明</h3><p>Linux的内核态和用户态了解</p>
<p>用户态和和内核态是什么东西呢？ 要想了解用户态和内核态还需要先了解一下Linux系统的体系架构：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/Linux%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="Linux的体系结构"></p>
<p>从上图可以看出，Linux操作系统的体系架构分为：用户空间（应用程序的活动空间）和内核。 </p>
<ul>
<li>内核：本质上可以理解为一种软件，控制计算机的硬件资源，并提供上层应用程序运行的环境</li>
<li>用户空间：上层应用程序活动的空间。应用程序的执行必须依托于内核提供的资源，包括CPU资源、存储资源、I/O资源等。</li>
<li>系统调用：为了使上层应用能够访问到这些资源，内核必须为上层应用提供访问的接口：即系统调用。</li>
<li>shell 公用函数库：上接应用程序，下接内核，起到一种“胶水”的作用。连接各个小功能程序，让不同程序能够以一个清晰的接口协同工作，从而增强各个程序的功能。</li>
</ul>
<p>所有进程初始都运行于用户空间，此时即为用户运行状态（简称：用户态）；但是当它调用系统调用执行某些操作时，例如 I/O调用，此时需要陷入内核中运行，我们就称进程处于内核运行态（或简称为内核态）。 系统调用的过程可以简单理解为：</p>
<ol>
<li>用户态程序将一些数据值放在寄存器中, 或者使用参数创建一个堆栈(stack frame), 以此表明需要操作系统提供的服务；</li>
<li>用户态程序执行系统调用；</li>
<li>CPU切换到内核态, 并跳到位于内存指定位置的指令（这些指令是操作系统的一部分, 他们具有内存保护, 不可被用户态程序访问）；</li>
<li>系统调用处理器(system call handler)会读取程序放入内存的数据参数, 并执行程序请求的服务；</li>
<li>系统调用完成后, 操作系统会重置CPU为用户态并返回系统调用的结果。</li>
</ol>
<p>对于synchronized是重量级锁时，操作ObjectMonitor中的部分方法调用了内核态的指令，由于用户态切换至内核态需要传递许多变量，同时内核还需要保护好用户态在切换时的一些寄存器值、变量等，以备内核态切换回用户态。这种切换就带来了大量的系统资源消耗。</p>
<p>参考资料：</p>
<p><a href="http://www.sohu.com/a/273749069_505779">http://www.sohu.com/a/273749069_505779</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程和进程</title>
    <url>/2019/10/30/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>进程和线程算是操作系统内两个很基本、很重要的概念了</p>
<span id="more"></span>

<ul>
<li><p>进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是操作系统进行<strong>资源分配</strong>和调度的基本单位，是操作系统结构的基础。</p>
<ul>
<li>在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；</li>
<li>在当代面向线程设计的计算机结构中，进程是线程的容器。</li>
</ul>
<p>注：程序是指令、数据及其组织形式的描述，进程是程序的实体</p>
</li>
<li><p>而线程是进程的组成部分，调度单位，它代表了一条顺序的执行流，是进程的最小的执行单元</p>
<ul>
<li>线程分为用户级线程和内核级线程，有些时候内核级线程叫做轻量级进程(LWP)</li>
</ul>
</li>
</ul>
<p>例如：打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>而一个进程，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，进程内的这些“子任务”称为线程（Thread）。</p>
<p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，</p>
<h3 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h3><p>系统中的进程线程模型是这样的：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E8%BF%9B%E7%A8%8B%E6%A8%A1%E5%9E%8B.png" alt="多线程进程模型"></p>
<p>进程从操作系统获得基本的内存空间，所有的线程共享着进程的内存地址空间。当然，每个线程也会拥有自己私有的内存地址范围，其他线程不能访问。</p>
<p>由于所有的线程共享进程的内存地址空间，所以线程间的通信就容易的多，通过共享进程级全局变量即可实现。</p>
<h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>调度问题即为：选择下一个要运行的进程或者线程是哪一个</p>
<p>所谓的多线程并行，从宏观上看，各个线程轮流获得CPU的使用权，分别执行各自的任务。</p>
<p><strong>进程</strong> ：是直接由CPU根据特定的调度算法进行调度，由于需要陷入内核、上下文切换、对内存高速缓存进行刷新，所以代价较大</p>
<p><strong>线程</strong> ：线程的调度，取决于支持的是内核级线程还是用户级线程。</p>
<p>对于内核级线程，操作系统所调度的，与所属的进程基本没有关系，</p>
<p>对于用户级线程，内核并不知道他们，允许每个进程定制自己的调度算法，线程管理比较灵活，且比较快捷</p>
<p>用户级线程和内核级线程的一个区别就是他们如何调度的。</p>
<p>在一些系统中，也会使用内核级线程和用户级线程组合方式的多线程实现 </p>
<p><strong>解疑</strong>：对于上文提到，在没有引入多线程概念之前，所谓的『并发』是发生在进程之间的，每一次的进程上下文切换都将导致系统调度算法的运行，以及各种 CPU 上下文的信息保存，非常耗时。而用户级线程级并发没有系统调度这一步骤，进程分配到 CPU 使用时间，并给其内部的各个线程使用。在分时系统中，进程中的每个线程都拥有一个时间片，时间片结束时保存 CPU 及寄存器中的线程上下文并交出 CPU，完成一次线程间切换。当然，当进程的 CPU 时间使用结束时，所有的线程必然被阻塞。</p>
<h3 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h3><p>我们研究进程和线程的原因就是为了多任务</p>
<p>多任务：就是操作系统可以同时运行多个任务。比如，一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着。</p>
<p>对于操作系统来说，一个任务就是一个进程（Process）</p>
<p>多任务是提升操作系统使用效率的方式，多进程和多线程是实现多任务的利器</p>
<p>那么如何实现多任务呢</p>
<ul>
<li>多进程模式</li>
<li>多线程模式</li>
<li>多进程+多线程模式</li>
</ul>
<p>同时执行多个任务通常各个任务之间并不是没有关联的，而是需要相互通信和协调，有时，任务1必须暂停等待任务2完成后才能继续执行，有时，任务3和任务4又不能同时执行，所以，多进程和多线程的程序的复杂度要远远高于单进程单线程的程序。</p>
<p>参考资料</p>
<p><a href="https://blog.csdn.net/lishanleilixin/article/details/88743973">线程和进程的调度</a></p>
<p><a href="https://www.cnblogs.com/feng9exe/p/7890934.html">线程调度</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/897692888725344/923056118147584">廖雪峰的官方网站</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>线程池</title>
    <url>/2020/01/14/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<p>在对多线程有了基础了解后，再来看一下线程池</p>
<span id="more"></span>

<h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>线程池是一种线程使用模式</p>
<h3 id="为什么需要线程池"><a href="#为什么需要线程池" class="headerlink" title="为什么需要线程池"></a>为什么需要线程池</h3><ol>
<li>线程频繁的创建和销毁开销非常大，以线程池的模式实现复用，提升性能</li>
<li>解耦作用；线程的创建于执行完全分开，方便维护。</li>
<li>可以提供定时执行、定期执行、并发数控制、最大并发线程数控制等功能，避免过多资源竞争，避免堵塞</li>
</ol>
<h3 id="Java中的线程池"><a href="#Java中的线程池" class="headerlink" title="Java中的线程池"></a>Java中的线程池</h3><h4 id="ThreadPoolExecutor类"><a href="#ThreadPoolExecutor类" class="headerlink" title="ThreadPoolExecutor类"></a><code>ThreadPoolExecutor</code>类</h4><p><code>java.uitl.concurrent.ThreadPoolExecutor</code>类是线程池中最核心的一个类，</p>
<ol>
<li><p>线程池的状态</p>
<p>在<code>ThreadPoolExecutor</code>中定义了线程池的四个状态</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">int</span> runState;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>

<p><code>runState</code> 表示当前线程池的状态，取值分别为：<code>RUNNING</code>、<code>SHUTDOWN</code>、<code>STOP</code>、<code>TERMINATED</code></p>
<ul>
<li>创建线程池后，处于<code>RUNNING</code>状态</li>
<li>调用<code>shutdown()</code>后处于<code>SHUTDOWN</code>状态，线程池不能接受新的任务，会等待缓冲队列的任务完成</li>
<li>调用<code>shutdownNow()</code>后处于<code>STOP</code>状态，线程池不能接受新的任务，并且尝试终止正在执行的任务</li>
<li>当线程池处于<code>SHUTDOWN</code>或<code>STOP</code>状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为<code>TERMINATED</code>状态。</li>
</ul>
</li>
<li><p>构造方法</p>
<p>一共提供了四个构造方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                          TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                          ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> || maximumPoolSize &lt;= <span class="number">0</span> || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ? <span class="keyword">null</span> : AccessController.getContext();</span><br><span class="line">    <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">    <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">    <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">    <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.handler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>构造器中各参数的含义如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0.jpg"></p>
<ul>
<li><code>corePoolSize</code>：核心池的大小，不可小于0，大于0时，初始创建的线程都是核心线程，线程池中正常情况下始终保留该大小的线程实例存活，哪怕没有任务空转也不会销毁该部分线程实例。</li>
<li><code>maxmumPoolSize</code>：线程池最大线程数，阻塞队列填满时，在增加的任务则会增加功能线程的数量，当工作线程数量超过该最大线程数量时，则线程池会采取对应的拒绝策略</li>
<li><code>keepAliveTime</code>：表示线程没有任务执行时最多保持多久时间会终止(这里说的没有任务的线程是：最大线程数-核心线程数的线程)</li>
<li><code>unit</code>：参数<code>keepAliveTime</code>的时间单位，取自<code>TimeUnit</code></li>
<li><code>workQueue</code>：一个阻塞队列，用来存储等待执行的任务，影响排队策略，当工作线程的数量增加到核心线程数量的时候，在增加的任务就会被存储到该队列中，一般来说阻塞队列会有以下几种选择，<ul>
<li><code>ArrayBlockingQueue</code>：基于数组的先进先出队列，此队列创建时必须指定大小</li>
<li><code>LinkedBlockingQueue</code>：基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为<code>Integer.MAX_VALUE</code>(有可能引发<code>OOM</code>)</li>
<li><code>SynchronousQueue</code>：这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</li>
</ul>
</li>
<li><code>threadFactory</code>：线程工厂，主要用来创建线程</li>
<li><code>handler</code>：表示当拒绝处理任务时的策略，有四种取值<ul>
<li><code>ThreadPoolExecutor.AbortPolicy</code>：丢弃任务并抛出<code>RejectedExecutionException</code>异常。 </li>
<li><code>ThreadPoolExecutor.DiscardPolicy</code>：也是丢弃任务，但是不抛出异常。 </li>
<li><code>ThreadPoolExecutor.DiscardOldestPolicy</code>：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）</li>
<li><code>ThreadPoolExecutor.CallerRunsPolicy</code>：由调用线程处理该任务</li>
</ul>
</li>
</ul>
</li>
<li><p>其他比较重要的方法</p>
<ul>
<li><p><code>execute(Runnable command)</code></p>
<p>核心方法，负责任务的执行，像线程池提交一个任务，交由线程池去执行这个任务，执行过程：</p>
<ol>
<li>如果当前线程池中的线程数目小于<code>corePoolSize</code>，则每来一个任务，就会创建一个线程去执行这个任务</li>
<li>如果当前线程池中的线程数目<code>&gt;= corePoolSize</code>，则每来一个任务，会尝试将其添加到任务缓存队列当中，若添加成功，则该任务会等待空闲线程将其取出去执行，若添加失败（一般来说是任务缓存队列已满），则会尝试创建新的线程去执行这个任务</li>
<li>如果当前线程池中的线程数目达到<code>maximumPoolSize</code>，则会采取任务拒绝策略进行处理</li>
<li>如果线程池中的线程数量大于<code>corePoolSize</code>，如果某线程空闲时间超过<code>keepAliveTime</code>，线程将被终止，直至线程池中的线程数目不大于<code>corePoolSize</code></li>
</ol>
</li>
<li><p><code>submit()</code></p>
<p><code>AbstractExecutorService</code>中实现的方法，没有重写，也是像线程池提交任务的，但是他能够返回任务执行的结果</p>
</li>
<li><p>关闭线程池</p>
<ul>
<li><p><code>shutdown()</code></p>
<p>关闭线程池，不会立即终止线程池，而是要等所有任务缓存队列中的任务都执行完后才终止，但再也不会接受新的任务</p>
</li>
<li><p><code>shutdownNow()</code></p>
<p>关闭线程池，立即终止线程池，并尝试打断正在执行的任务，并且清空任务缓存队列，返回尚未执行的任务 </p>
</li>
</ul>
</li>
<li><p>线程池中的线程初始换</p>
<p>默认情况下，创建线程池后，线程池中是没有线程的，需要提交任务之后才会创建线程，如何在创建线程池之后立即创建线程呢，有两个方法：</p>
<ul>
<li><code>prestartCoreThread()</code>：初始化一个核心线程</li>
<li><code>prestartAllCoreThreads()</code>：初始化所有核心线程</li>
</ul>
<p>这两个方法创建的线程会阻塞住，等待任务队列的任务</p>
</li>
<li><p>线程的容量调整</p>
<ul>
<li><code>setCorePoolSize</code>：设置核心池大小</li>
<li><code>setMaximumPoolSize</code>：设置线程池最大能创建的线程数目大小</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="线程池种类"><a href="#线程池种类" class="headerlink" title="线程池种类"></a>线程池种类</h4><p>JDK提供了<code>Executors</code>类方便创建线程池，其中提供了静态方法直接创建线程池(内部也是调用<code>ThreadPoolExecutor</code>)，JDK1.8中一共提供了五种线程池</p>
<ol>
<li><p><strong><code>newFixedThreadPool</code></strong></p>
<p>固定大小线程池，创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中，即正常的线程池工作流程</p>
<p>适用场景：定长线程池，适合任务量并发及执行耗时相对平稳的场景（生产和消费速度相对平稳且对等，仅平稳但不对等也不适合直接使用该方法）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>newWorkStealingPool</code></strong></p>
<p>偷窃线程池，还未深入，1.8中新加入的线程池</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newWorkStealingPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ForkJoinPool</span><br><span class="line">        (Runtime.getRuntime().availableProcessors(),</span><br><span class="line">         ForkJoinPool.defaultForkJoinWorkerThreadFactory,</span><br><span class="line">         <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>newSingleThreadExecutor </code></strong></p>
<p>单线程线程池，只有一个线程的线程池</p>
<p>适用场景：单个活跃线程线程池，适合长期固定循环执行的场景（不一定是相同的线程任务对象，只要这一组任务需要统一管理，且还不想不可控的创建N多线程来浪费系统资源，就可以使用该方法创建线程池）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">        (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>newCachedThreadPool</code></strong></p>
<p>缓存线程池，创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们。对于执行很多短期异步任务的程序而言，这些线程池通常可提高程序性能。调用 <code>execute</code> 将重用以前构造的线程（如果线程可用，即<code>keepAliveTime</code>时间内）。如果现有线程没有可用的，则创建一个新线程并添加到池中。终止并从缓存中移除那些已有 60 秒钟未被使用的线程。因此，长时间保持空闲的线程池不会使用任何资源。</p>
<p>适用场景：缓存线程池，适合任务量并发相对稳定且执行耗时较短的场景（因为该方法创建的线程池没有核心线程数，且线程的空闲活跃时间为60秒。如果并发和执行耗时波动都很大，个人感觉用这个方法也不太好，因为线程池同样会频繁的创建和销毁线程对象）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong><code>newScheduledThreadPool </code></strong></p>
<p>定时线程池，创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</p>
<p>适用场景：延迟线程池，适合需要循环延迟执行的场景。</p>
<p><code>ScheduledThreadPoolExecutor</code>继承自<code>ThreadPoolExecutor</code>,所以<code>super</code>还是<code>ThreadPoolExecutor</code>，<code>DelayedWorkQueue</code>为延时队列</p>
<p>还有个<code>Executors.newSingleThreadScheduledExecutor()</code>，单核心定时线程池，只是把核心线程数给了个默认值1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ScheduledThreadPoolExecutor</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadPoolExecutorTest</span> </span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledThreadPool= Executors.newScheduledThreadPool(<span class="number">3</span>);      </span><br><span class="line">        scheduledThreadPool.schedule(newRunnable()&#123;         </span><br><span class="line">            <span class="meta">@Override</span> </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;延迟三秒&quot;</span>);</span><br><span class="line">             &#125;</span><br><span class="line">      &#125;, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>阿里编码规约针对线程池的使用说明</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E9%98%BF%E9%87%8C%E8%A7%84%E7%BA%A6%E5%AF%B9%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AF%B4%E6%98%8E.jpg"></p>
</li>
</ol>
<p>参考资料</p>
<p><a href="https://blog.csdn.net/weixin_28760063/article/details/81266152">线程池原理</a></p>
<p><a href="https://www.cnblogs.com/zzuli/p/9386463.html">线程池的使用</a></p>
<p><a href="https://blog.csdn.net/aiengelangte/article/details/80394940">线程池类型</a></p>
<p><a href="https://www.jianshu.com/p/d1ba6a871df8">线程池类型</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>CompletableFuture入门</title>
    <url>/2023/01/31/%E5%A4%9A%E7%BA%BF%E7%A8%8B/CompletableFuture%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p><code>CompletableFuture</code> 作为是实现类同时实现了 <code>Future</code> 和 <code>CompletionStage</code> 接口。所以<code>CompletableFuture</code> 除了提供了更为好用和强大的 <code>Future</code> 特性之外，还提供了函数式编程的能力。</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompletableFuture</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Future</span>&lt;<span class="title">T</span>&gt;, <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="接口介绍"><a href="#接口介绍" class="headerlink" title="接口介绍"></a>接口介绍</h3><h4 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 尝试取消执行任务。</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">  <span class="comment">// 判断任务是否被取消。</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 判断任务是否已经被执行完成。</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 等待任务执行完成并获取运算结果</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">  <span class="comment">// 等待任务执行完成并获取运算结果,只是多了一个超时时间。</span></span><br><span class="line">  <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span>  <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CompletionStage"><a href="#CompletionStage" class="headerlink" title="CompletionStage"></a>CompletionStage<T></h4><p><code>CompletionStage&lt;T&gt;</code> 接口中的方法比较多，<code>CompletableFuture</code> 的函数式能力就是这个接口赋予的。其方法参数中大量使用了 Java8 引入的函数式编程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CompletionStage</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">thenApply</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">thenApplyAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T,? extends U&gt; fn, Executor executor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAccept</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenAcceptAsync</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action, Executor executor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenRun</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">thenRunAsync</span><span class="params">(Runnable action, Executor executor)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombine</span><span class="params">(CompletionStage&lt;? extends U&gt; other, BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U,V&gt; <span class="function">CompletionStage&lt;V&gt; <span class="title">thenCombineAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiFunction&lt;? <span class="keyword">super</span> T,? <span class="keyword">super</span> U,? extends V&gt; fn,Executor executor)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBoth</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;Void&gt; <span class="title">thenAcceptBothAsync</span><span class="params">(CompletionStage&lt;? extends U&gt; other,BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> U&gt; action,Executor executor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBoth</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterBothAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">applyToEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Function&lt;? <span class="keyword">super</span> T, U&gt; fn,Executor executor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEither</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">acceptEitherAsync</span><span class="params">(CompletionStage&lt;? extends T&gt; other,Consumer&lt;? <span class="keyword">super</span> T&gt; action,Executor executor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEither</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;Void&gt; <span class="title">runAfterEitherAsync</span><span class="params">(CompletionStage&lt;?&gt; other,Runnable action,Executor executor)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">thenCompose</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">thenComposeAsync</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends CompletionStage&lt;U&gt;&gt; fn,Executor executor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title">exceptionally</span><span class="params">(Function&lt;Throwable, ? extends T&gt; fn)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title">whenComplete</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletionStage&lt;T&gt; <span class="title">whenCompleteAsync</span><span class="params">(BiConsumer&lt;? <span class="keyword">super</span> T, ? <span class="keyword">super</span> Throwable&gt; action,Executor executor)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handle</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn)</span></span>;</span><br><span class="line">  <span class="keyword">public</span> &lt;U&gt; <span class="function">CompletionStage&lt;U&gt; <span class="title">handleAsync</span><span class="params">(BiFunction&lt;? <span class="keyword">super</span> T, Throwable, ? extends U&gt; fn,Executor executor)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> CompletableFuture&lt;T&gt; <span class="title">toCompletableFuture</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p> 可以使用<code>new</code>或者静态工厂方法创建 <code>CompletableFuture</code> 对象</p>
<ol>
<li><p>通过 new 关键字。</p>
<p>通过 new 关键字创建 <code>CompletableFuture</code> 对象的使用方式可以看作是将 <code>CompletableFuture</code> 当做 <code>Future</code> 来使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;String&gt; resultFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">String resultStr = completableFuture.get();</span><br></pre></td></tr></table></figure>

<p><code>completedFuture()</code> 方法底层调用的是带参数的 <code>new</code> 方法，只不过，这个方法不对外暴露。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;U&gt; <span class="function">CompletableFuture&lt;U&gt; <span class="title">completedFuture</span><span class="params">(U value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompletableFuture&lt;U&gt;((value == <span class="keyword">null</span>) ? NIL : value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态工厂方法</p>
<p>基于 <code>CompletableFuture</code> 自带的静态工厂方法：<code>runAsync()</code> 、<code>supplyAsync()</code> 可以创建<code>CompletableFuture</code> 对象。</p>
<ul>
<li><code>runAsync()</code> 方法接受的参数是 <code>Runnable</code> ，这是一个函数式接口，不允许返回值。需要异步操作且不关心返回结果的时候可以使用 <code>runAsync()</code> 方法。</li>
<li><code>supplyAsync()</code> 方法接受的参数是 <code>Supplier&lt;U&gt;</code> ，也是一个函数式接口，<code>U</code> 是返回结果值的类型。需要异步操作且关心返回结果的时候,可以使用 <code>supplyAsync()</code> 方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">CompletableFuture&lt;Void&gt; future = CompletableFuture.runAsync(() -&gt; System.out.println(<span class="string">&quot;hello!&quot;</span>));</span><br><span class="line">future.get();<span class="comment">// 输出 &quot;hello!&quot;</span></span><br><span class="line">CompletableFuture&lt;String&gt; future2 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">assertEquals(<span class="string">&quot;hello!&quot;</span>, future2.get());</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><p>方法分类</p>
<ul>
<li>处理异步结算的结果<ul>
<li><code>thenApply()</code>：能访问异步计算结果，且可从回调函数中获取结果</li>
<li><code>thenAccept()</code>：能访问异步计算的结果，不能从回调函数获取结果</li>
<li><code>thenRun()</code>：不能访问异步计算的结果，且不能从回调函数获取结果</li>
<li><code>whenComplete()</code>:接收 2 个输入对象然后进行结果处理</li>
</ul>
</li>
<li>异常处理<ul>
<li><code>handle()</code>：处理异常</li>
<li><code>exceptionally()</code>：处理异常</li>
<li><code>completeExceptionally()</code>:设置结果为异常</li>
</ul>
</li>
<li>组合 <code>CompletableFuture</code><ul>
<li><code>thenCompose()</code> ：按顺序链接两个 <code>CompletableFuture</code> 对象。链接两个<code>CompletableFuture</code> 对象，是将前一个任务的返回结果作为下一个任务的参数，它们之间存在着先后顺序。</li>
<li><code>thenCombine()</code>：链接两个<code>CompletableFuture</code> 对象，会在两个任务都执行完成后，把两个任务的结果合并。两个任务是并行执行的，它们之间并没有先后依赖顺序。</li>
</ul>
</li>
<li>并行运行多个 <code>CompletableFuture</code><ul>
<li><code>allOf()</code>：并行运行多个 <code>CompletableFuture</code> 。等到所有的 <code>CompletableFuture</code> 都运行完成之后再返回</li>
<li><code>anyOf()</code> ：并行运行多个 <code>CompletableFuture</code> 。不会等待所有的 <code>CompletableFuture</code> 都运行完成之后再返回，只要有一个执行完成即可！</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// thenApply</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenApply(s -&gt; s + <span class="string">&quot;nice!&quot;</span>);</span><br><span class="line"><span class="comment">// thenAccept</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenAccept(System.out::println);<span class="comment">//hello!world!</span></span><br><span class="line"><span class="comment">// thenRun</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.completedFuture(<span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenApply(s -&gt; s + <span class="string">&quot;world!&quot;</span>).thenRun(() -&gt; System.out.println(<span class="string">&quot;hello!&quot;</span>));<span class="comment">//hello!</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// handle</span></span><br><span class="line">CompletableFuture&lt;String&gt; future =  CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s + <span class="string">&quot;word!&quot;</span>;</span><br><span class="line">&#125;).handle((res, ex) -&gt; &#123;</span><br><span class="line">    <span class="comment">// res 代表返回的结果，ex 的类型为 Throwable ，代表抛出的异常</span></span><br><span class="line">    <span class="keyword">return</span> res != <span class="keyword">null</span> ? res : <span class="string">&quot;error!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(<span class="string">&quot;error!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// exceptionally</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Computation error!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hello!&quot;</span>;</span><br><span class="line">&#125;).exceptionally(ex -&gt; &#123;</span><br><span class="line">    System.out.println(ex.toString());<span class="comment">// CompletionException</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;error!&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line">assertEquals(<span class="string">&quot;error!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// completeExceptionally</span></span><br><span class="line">CompletableFuture&lt;String&gt; completableFuture = <span class="keyword">new</span> CompletableFuture&lt;&gt;();</span><br><span class="line">completableFuture.completeExceptionally(</span><br><span class="line">  <span class="keyword">new</span> RuntimeException(<span class="string">&quot;Calculation failed!&quot;</span>));</span><br><span class="line">completableFuture.get(); <span class="comment">// ExecutionException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// thenCompose</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;world!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!&quot;</span>, future.get());</span><br><span class="line"><span class="comment">// thenCombine</span></span><br><span class="line">CompletableFuture&lt;String&gt; future = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>)</span><br><span class="line">        .thenCombine(CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;world!&quot;</span>), (s1, s2) -&gt; s1 + s2)</span><br><span class="line">        .thenCompose(s -&gt; CompletableFuture.supplyAsync(() -&gt; s + <span class="string">&quot;nice!&quot;</span>));</span><br><span class="line">assertEquals(<span class="string">&quot;hello!world!nice!&quot;</span>, completableFuture.get());</span><br><span class="line"></span><br><span class="line"><span class="comment">// allOf</span></span><br><span class="line">CompletableFuture&lt;String&gt; task1 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;hello!&quot;</span>);</span><br><span class="line">CompletableFuture&lt;String&gt; task6 = CompletableFuture.supplyAsync(() -&gt; <span class="string">&quot;Word!&quot;</span>);</span><br><span class="line">CompletableFuture&lt;Void&gt; future=CompletableFuture.allOf(task1,.....,task6);</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  headerFuture.join();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;all done. &quot;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a href="https://javaguide.cn/java/concurrent/completablefuture-intro.html#%E5%B9%B6%E8%A1%8C%E8%BF%90%E8%A1%8C%E5%A4%9A%E4%B8%AA-completablefuture">CompletableFuture入门</a></p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>CompletableFuture</tag>
      </tags>
  </entry>
  <entry>
    <title>Dubbo入门</title>
    <url>/2020/11/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/Dubbo%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<p>Dubbo是分布式服务框架，Dubbo是一款高性能、轻量级的开源Java RPC框架，提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。本文只是Dubbo的基础使用入门。</p>
<span id="more"></span>

<p>目录</p>
<ul>
<li>Dubbo理解</li>
<li>为什么需要Dubbo</li>
<li>Dubbo入门配置示例</li>
<li>Dubbo其他使用特性</li>
</ul>
<h4 id="Dubbo理解"><a href="#Dubbo理解" class="headerlink" title="Dubbo理解"></a>Dubbo理解</h4><p>Dubbo是基于 Java 的高性能、轻量级的开源 RPC分布式服务框架，致力于提供高性能和透明化的RPC远程服务调用方案，以及SOA服务治理方案。</p>
<p>个人理解：</p>
<ol>
<li>首先，Dubbo的本身就是基于Java的RPC框架，主要实现思想还是RPC<a href="https://zhangyuying.top/2020/11/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/#more">点我了解RPC</a>，所以Dobbo最近的功能就是面向接口的远程方法调用</li>
<li>其次，Dubbo对RPC的部分思想在实现方式上进行了增强，比如对于RPC中客户端和服务端的互联，Dubbo提供点对点直连，也增加了服务的自动注册和发现</li>
<li>最后，Dubbo在高效的实现RPC的基础上实现了许多其他分布式框架需要的特性：比如智能容错和负载均衡</li>
</ol>
<h4 id="为什么需要Dubbo"><a href="#为什么需要Dubbo" class="headerlink" title="为什么需要Dubbo"></a>为什么需要Dubbo</h4><p>Dubbo是架构演变到分布式服务架构和流式计算架构时的服务管理框架，所以在说为什么需要Dubbo的时候从两方面思考</p>
<ol>
<li><p>架构演变的需要：</p>
<p>分布式架构中服务与服务的交互关系复杂、依赖关系复杂、负载均衡服务淡点压力大、甚至服务报错处理、服务之间的连接检查、服务运行状态监控等等问题</p>
<p>分布式框架就是为了解决这些问题的，而分布式框架中经过生产验证又轻量级、功能强大、效率高的框架，Dubbo就是其中之一</p>
</li>
<li><p>对比HTTP REST的优势：</p>
<p>大多数人总是有这个疑问，所以在这说一下，这个对比其实有问题，因为HTTP是一种通信方式，而Dubbo是RPC框架，并且也支持选择HTTP作为通信协议，所以我们的对比是在Dubbo选择的协议为默认Dubbo://协议基础上</p>
<ul>
<li>框架优势：Dubbo作为框架，服务注册、负载均衡、容器容错等功能相当于为了分布式而生的，而HTTP只是一个网络协议，这块更明确的应该是Dubbo和Spring Cloud(通信协议采用的HTTP REST)的对比，此处就不再延伸了</li>
<li>易用性：RPC的特性就是像本地调用一样调用远端服务，所以Dubbo更易用</li>
<li>效率：Dubbo大多选择是dubbo://(TCP)协议，所以Dubbo的数据传输采用的是字节流的方式进行数据的传输，更高效</li>
</ul>
<blockquote>
<p>dubbo协议: 采用单一长连接和NIO异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。不适合传送大数据量的服务，比如传文件，传视频等，除非请求量很低。</p>
<p><strong>特性</strong></p>
<ul>
<li>连接个数：单连接</li>
<li>连接方式：长连接</li>
<li>传输协议：TCP</li>
<li>传输方式：NIO异步传输</li>
<li>序列化：Hessian 二进制序列化</li>
<li>适用范围：传入传出参数数据包较小（建议小于100K），消费者比提供者个数多，单一消费者无法压满提供者，尽量不要用dubbo协议传输大文件或超大字符串。</li>
<li>适用场景：常规远程服务方法调用</li>
</ul>
</blockquote>
</li>
</ol>
<h4 id="Dubbo入门配置示例"><a href="#Dubbo入门配置示例" class="headerlink" title="Dubbo入门配置示例"></a>Dubbo入门配置示例</h4><p>在此只展示Xml的配置方式，这个demo只展示了最基础的配置，配置说明均在文件中，就不再重复叙述</p>
<p>服务端</p>
<p>服务端类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;provider=hello：&quot;</span> + name);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;result:  hello-&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProviderMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring/provider.xml&quot;</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务端配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    当前项目在整个分布式中的唯一名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;zyyDubbo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    dubbo整个服务所要报漏的服务地址所对应的注册中心--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      N/A表示点对点连接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;N/A&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      使用zk作为注册中心的配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; check=&quot;false&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    当前服务发布所依赖的协议--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">&quot;dubbo&quot;</span> <span class="attr">port</span>=<span class="string">&quot;20880&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    服务发布的配置，需要暴露的服务接口--&gt;</span></span><br><span class="line">    &lt;dubbo:service</span><br><span class="line">            interface=&quot;cn.zhangyuying.demo.demo.dubbo.provider.HelloService&quot;</span><br><span class="line">            ref=&quot;helloService&quot;/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;helloService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;cn.zhangyuying.demo.demo.dubbo.provider.HelloServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>消费端：</p>
<p>消费端类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerMain</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">&quot;spring/consumer.xml&quot;</span>);</span><br><span class="line">        context.start();</span><br><span class="line">        HelloService helloService = (HelloService) context.getBean(<span class="string">&quot;helloService&quot;</span>);</span><br><span class="line">        String result = helloService.hello(<span class="string">&quot;zyy&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;consumer= &quot;</span> + result);</span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费端配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="attr">xmlns:dubbo</span>=<span class="string">&quot;http://code.alibabatech.com/schema/dubbo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    当前项目在整个分布式中的唯一名称--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">&quot;zyyDubbo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:monitor</span> <span class="attr">protocol</span>=<span class="string">&quot;registry&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    dubbo整个服务所要报漏的服务地址所对应的注册中心 :点对点方式--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      N/A表示点对点连接--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">&quot;N/A&quot;</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--      使用zk作为注册中心的配置--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--    &lt;dubbo:registry address=&quot;zookeeper://127.0.0.1:2181&quot; check=&quot;false&quot;/&gt;--&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--    远程服务的调用代理（如果是zk不用url参数）--&gt;</span></span><br><span class="line">    &lt;dubbo:reference</span><br><span class="line">            id=&quot;helloService&quot;</span><br><span class="line">            interface=&quot;cn.zhangyuying.demo.demo.dubbo.provider.HelloService&quot;</span><br><span class="line">            url=&quot;dubbo://127.0.0.1:20880&quot;</span><br><span class="line">    /&gt;</span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Dubbo其他使用特性"><a href="#Dubbo其他使用特性" class="headerlink" title="Dubbo其他使用特性"></a>Dubbo其他使用特性</h4><p><a href="http://dubbo.apache.org/zh/docs/v2.7/user/examples/">官网</a>比较清晰，这里只说常用的接触的两个</p>
<ol>
<li><p>集群容错</p>
<p>在集群调用失败时，Dubbo 提供了多种容错方案，缺省为 failover 重试。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cluster&#x3D;&quot;failover&quot; </span><br><span class="line">retrier&#x3D;&quot;2&quot; &#x2F;&#x2F;设置重试次数</span><br></pre></td></tr></table></figure>
</li>
<li><p>在集群负载均衡时，Dubbo 提供了多种均衡策略，缺省为 <code>random</code> 随机调用。Dubbo可以自行扩展负载均衡策略，在此不多说</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">loadbalance&#x3D;&quot;random&quot;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>Dubbo还有很多其他配置功能，比如启动时检查、线程模型、只订阅、只注册、多注册中心等等等，但是官方文档已经非常详细，可以直接阅读，所以不再粘贴式叙述。</p>
<p>参考资料</p>
<p><a href="http://dubbo.apache.org/zh/docs/">dubbo文档</a></p>
<p><a href="https://segmentfault.com/a/1190000019896723">Dubbo从入门到实战</a></p>
<p><a href="https://blog.csdn.net/xiaojin21cen/article/details/79834222#1dubbo___8">Dubbo协议</a></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>Doubbo</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2020/11/29/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC/</url>
    <content><![CDATA[<p>RPC 是一种技术思想而非一种规范或协议</p>
<span id="more"></span>

<p>目录</p>
<ul>
<li>RPC是什么</li>
<li>为什么会有RPC</li>
<li>如何实现RPC，即RPC原理</li>
<li>RPC的简单实现demo</li>
<li>总结</li>
</ul>
<h4 id="RPC是什么"><a href="#RPC是什么" class="headerlink" title="RPC是什么"></a>RPC是什么</h4><p>RPC全称<code>Remote Procedure Call</code>，即远程过程调用。了解RPC之前要先明白IPC，RPC是IPC的一种</p>
<p>进程间通信（IPC，<code>Inter-Process Communication</code>），指至少两个进程或线程间传送数据或信号的一些技术或方法。进程是计算机系统分配资源的最小单位。每个进程都有自己的一部分独立的系统资源，彼此是隔离的。为了能使不同的进程互相访问资源并进行协调工作，才有了进程间通信。这些进程可以运行在同一计算机上或网络连接的不同计算机上。 进程间通信技术包括消息传递、同步、共享内存和远程过程调用。 IPC是一种标准的Unix通信机制。</p>
<p>有两种类型的进程间通信(IPC)。</p>
<ul>
<li>本地过程调用(LPC)：LPC用在多任务操作系统中，使得同时运行的任务能互相会话。这些任务共享内存空间使任务同步和互相发送信息。</li>
<li>远程过程调用(RPC)：RPC类似于LPC，只是在网上工作。RPC开始是出现在Sun微系统公司和HP公司的运行UNIX操作系统的计算机中。</li>
</ul>
<p>所以RPC可理解为网络上的进程通信</p>
<ul>
<li><p>RPC在使用形式上像调用本地方法一样去调用远程方法，而其实RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</p>
<blockquote>
<p>客户端发起请求，服务器返回响应：类似于Http的工作方式</p>
</blockquote>
</li>
<li><p>RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯），使用什么协议并不是RPC的核心，RPC 是一个请求响应模型。</p>
</li>
</ul>
<p>RPC的真正目的也是最大作用就是<strong>解耦</strong>服务</p>
<h4 id="为什么会有RPC"><a href="#为什么会有RPC" class="headerlink" title="为什么会有RPC"></a>为什么会有RPC</h4><p>项目架构在不断演变适应时代，RPC是针对变化出的新架构的技术思想</p>
<ol>
<li><p>以前项目均为垂直架构，项目中的调用都是在一个进程内，或者一个计算机内通过本地调用的方式完成的需求，随着需求的增加、并发的增高、数据量的增加。维护与部署一个项目的成本越来越高。所以现在会对项目进行划分(微服务)，导致项目中的调用不在一个计算机中，此时就涉及到跨机器、跨网络，也可能夸操作系统，RPC就是解决这种横向划分架构的技术思想，RPC保证了不同服务之间的相互调用，既做到了解耦也让构建分布式系统更加容易</p>
</li>
<li><p>当项目拆分后也可以用HTTP进行数据的交互和方法的调用，为什么还是会有RPC？</p>
<p>RPC可以用HTTP协议实现，并且用HTTP是建立在 TCP 之上最广泛使用的 RPC，</p>
<p>HTTP是一种通信协议，而RPC是一种思想，RPC中也需要用到通信协议，所以使用HTTP来实现RPC也是可以的，但是大多数时候说到RPC的时候，还是指的基于 TCP/IP 协议使用Socket进行通信的RPC，并且采用二进制字节码传输，更高效也更安全，且RPC在使用形式上是像调用本地方法一样去调用远程方法，不用像HTTP去自己维护请求头等信息，更易用</p>
</li>
</ol>
<h4 id="RPC的核心实现"><a href="#RPC的核心实现" class="headerlink" title="RPC的核心实现"></a>RPC的核心实现</h4><p>RPC的核心实现部分，其实就是解决调用服务不在当前进程、当前机器的问题。</p>
<p>主要问题包括：</p>
<ol>
<li><p>网络通信问题</p>
<p>在本地调用中，是不存在网络传输的</p>
<p>PRC需要选择传输层和传输协议，来做网络通信，实现客户段和服务端的“交流”</p>
</li>
<li><p>序列化和反序列化：方法参数传递、方法结果返回</p>
<p>在本地调用中，我们只需要把参数压到栈里，然后让函数自己去栈里读即可</p>
<p>而RPC中客户端跟服务端是不同的进程，不能通过内存来传递参数，甚至两端的语言都有可能不同，所以RPC需要解决方法参数的传递问题和方法结果的返回问题</p>
<p>RPC中客户端和服务端的信息传递是通过序列化和反序列化：</p>
<ul>
<li>客户端把参数先转成一个字节流(也可能其他形式)传给服务端，服务端服务端再把字节流转成自己能读取的格式，并进行方法调用。这个过程叫序列化和反序列化。</li>
<li>同理：从服务端返回的值也需要序列化反序列化的过程。</li>
</ul>
</li>
<li><p>消息分发：即服务端辨别需要执行的方法</p>
<p>在本地调用中，可以通过函数指针明确要调用的方法具体是哪个，但是在RPC中，函数指针是不行的，因为两个进程的地址空间是完全不一样的。</p>
<p>在RPC中，解决方法调用的方法为：Call ID 映射（也有别的方式，但是Call ID最常用），Call ID映射即所有的函数都必须有自己的一个ID。这个ID在所有进程中都是唯一确定的。客户端在做远程过程调用时，必须附上这个ID。然后我们还需要在客户端和服务端分别维护一个 {函数 &lt;–&gt; Call ID} 的对应表。两者的表不一定需要完全相同，但相同的函数对应的Call ID必须相同。当客户端需要进行远程调用时，它就查一下这个表，找出相应的Call ID，然后把它传给服务端，服务端也通过查表，来确定客户端需要调用的函数，然后执行相应函数的代码。</p>
<p>Call ID映射可以直接使用函数字符串，也可以使用整数ID。映射表一般就是一个哈希表。（在Java语言中使用反射即可找到对应方法，相当于Call ID为方法名）</p>
</li>
</ol>
<p>RPC过程：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E5%BE%AE%E6%9C%8D%E5%8A%A1/RPC%E8%BF%87%E7%A8%8B.png" alt="RPC过程"></p>
<h4 id="RPC的简单demo"><a href="#RPC的简单demo" class="headerlink" title="RPC的简单demo"></a>RPC的简单demo</h4><p>(当前例子也是借鉴博客：<a href="https://blog.csdn.net/u010900754/article/details/78081428">RPC实例</a>中的示例，已在本地成功运行)</p>
<p>RPC Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        HelloService helloService = getClient(HelloService.class, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="number">50001</span>);</span><br><span class="line">        System.out.println(helloService.hello(<span class="string">&quot;zyy&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">getClient</span><span class="params">(Class&lt;T&gt; clazz, String ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(RPCClient.class.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[]&#123;clazz&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object arg0, Method arg1, Object[] arg2)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Socket socket = <span class="keyword">new</span> Socket(ip, port);</span><br><span class="line">                ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                out.writeUTF(arg1.getName());</span><br><span class="line">                out.writeObject(arg1.getParameterTypes());</span><br><span class="line">                out.writeObject(arg2);</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                <span class="keyword">return</span> in.readObject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>RPC Server</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zhangyuying.demo.demo.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.ObjectOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RPCServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService threadPool = Executors.newFixedThreadPool(DEFAULT_THREAD_NUM);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_THREAD_NUM = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object service, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;server starts...&quot;</span>);</span><br><span class="line">            ServerSocket server = <span class="keyword">new</span> ServerSocket(port);</span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">while</span> ((socket = server.accept()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;client connected...&quot;</span>);</span><br><span class="line">                threadPool.execute(<span class="keyword">new</span> Processor(socket, service));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Processor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        Socket socket;</span><br><span class="line">        Object service;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Processor</span><span class="params">(Socket socket, Object service)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.socket = socket;</span><br><span class="line">            <span class="keyword">this</span>.service = service;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(socket.getInputStream());</span><br><span class="line">                String methodName = in.readUTF();</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = (Class&lt;?&gt;[]) in.readObject();</span><br><span class="line">                Object[] parameters = (Object[]) in.readObject();</span><br><span class="line">                Method method = service.getClass().getMethod(methodName, parameterTypes);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object result = method.invoke(service, parameters);</span><br><span class="line">                    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(socket.getOutputStream());</span><br><span class="line">                    out.writeObject(result);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e1) &#123;</span><br><span class="line">                e1.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server 启动主函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zhangyuying.demo.demo.rpc.provider;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerStartMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span>&#123;</span><br><span class="line">        HelloService helloService = <span class="keyword">new</span> HelloServiceImpl();</span><br><span class="line">        RPCServer server = <span class="keyword">new</span> RPCServer();</span><br><span class="line">        server.register(helloService, <span class="number">50001</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Server中的接口以及接口实现：HelloService和HelloServiceImpl</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.zhangyuying.demo.demo.rpc.provider;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">hello</span><span class="params">(String name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> cn.zhangyuying.demo.demo.rpc.provider;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServiceImpl</span> <span class="keyword">implements</span> <span class="title">HelloService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>还是要强调：RPC 是一种技术思想！了解RPC思想原理有助于更加深刻的理解RPC框架，文中实现的RPC demo是简陋的RPC实现，目的为了让我们了解RPC过程，并不能在实际中应用，真正基于RPC来进行项目开发还有许多问题，比如如何处理网络错误，如何防止攻击，如何做流量控制等等，不过这些现有的RPC框架已经帮我们做了，下一步就是去学习RPC框架了。</p>
<p>参考资料</p>
<p><a href="https://www.jianshu.com/p/b0343bfd216e">RPC简介及框架选择-简书</a></p>
<p><a href="https://www.jianshu.com/p/32ca4fd5a7e2">从一个简单的例子聊RPC-简书</a></p>
<p><a href="https://www.zhihu.com/question/25536695">RPC知乎相关回答</a></p>
<p><a href="https://developer.51cto.com/art/201906/597963.htm">RPC框架</a></p>
<p><a href="https://blog.csdn.net/u010900754/article/details/78081428">RPC简单实例</a></p>
]]></content>
      <categories>
        <category>微服务</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title>logback-spring.xml</title>
    <url>/2020/11/28/%E6%97%A5%E5%BF%97/logback-spring.xml/</url>
    <content><![CDATA[<p>logback和logback-spring.xml都可以用来配置logback。logback-spring.xml中日志输出的配置和logback.xml语法相同(<a href="https://zhangyuying.top/2020/11/22/%E6%97%A5%E5%BF%97/logback%E5%9F%BA%E7%A1%80/#more">logbook基础配置</a>)，但是有两点不同，现在项目多用logback-spring.xml</p>
<span id="more"></span>

<blockquote>
<p>springboot推荐使用logback-spring.xml而不是logback.xml</p>
</blockquote>
<ol>
<li><p>加载顺序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logback.xml---&gt;application.properties---&gt;logback-spring.xml</span><br></pre></td></tr></table></figure>
</li>
<li><p>Profile配置</p>
<p>logback.xml：是可以直接被日志框架识别的</p>
<p>logback-spring.xml：日志框架就不直接加载日志的配置项，由SpringBoot解析日志配置，其中可以使用SpringBoot 的Proﬁle功能，配置不同环境的日志输出</p>
<p>Proﬁle使用示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--生产环境--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;prod&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;cn.zhangyuying.demo.log1&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">springProfile</span> <span class="attr">name</span>=<span class="string">&quot;dev&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 日志输出级别 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;cn.zhangyuying.demo.log2&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;DEBUG&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;STDOUT&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;DEBUG_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">level</span> <span class="attr">value</span>=<span class="string">&quot;INFO&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;DEBUG_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;INFO_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;WARN_FILE&quot;</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">springProfile</span>&gt;</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>值得一提的是：spring boot初始化了日志的默认实现(<code>&quot;org/springframework/boot/logging/logback/base.xml&quot;</code> )， 而logback-spring.xml文件相当于我们自定义的日志配置,<br>我们可以在logback-spring.xml中使用spring boot自定义的实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;include resource&#x3D;&quot;org&#x2F;springframework&#x2F;boot&#x2F;logging&#x2F;logback&#x2F;base.xml&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<p>不过其中很多配置是不可覆盖的，一般情况下我们都是采用的自定义的即使用logback-spring.xml自己定义的日志配置</p>
<p>参考资料：</p>
<p><a href="https://www.cnblogs.com/sanxiao/p/11604341.html">logback.xml和logback-spring.xml的区别</a></p>
<p><a href="https://www.jianshu.com/p/6f093b0b0c8a">logback-spring.xml</a></p>
<p><a href="https://www.jianshu.com/p/077f437eaaca">设置spring-boot的logging</a></p>
<p><a href="https://www.cnblogs.com/woshimrf/p/springboot-logback-config.html">修改覆盖springboot默认日志策略logback</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title>logback基础</title>
    <url>/2020/11/22/%E6%97%A5%E5%BF%97/logback%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<p>本文只做到了对Logback的基本了解，用于日常的使用</p>
<span id="more"></span>

<p>目录</p>
<ul>
<li>日志框架的关系</li>
<li>日志级别</li>
<li>Logback配置文件解析</li>
</ul>
<h4 id="主流日志框架的关系"><a href="#主流日志框架的关系" class="headerlink" title="主流日志框架的关系"></a>主流日志框架的关系</h4><p>Java中常用的日志框架主要有：Log4j、JDK Logging、LogBack、tinylog等</p>
<p>SLF4J(<code>Simple Logging Facade for Java</code>)是这些日志框架的抽象层，方便各种日志框架的切换。</p>
<blockquote>
<p>Ceki Gülcü首先开发出Log4j并发布，但是并未被纳入到JDK中，之后是JDK发布Logging，后期Ceki Gülcü又开发了Logback，除此之外还有tinylog等可以选择，后为了方便日志框架的切换，Ceki Gülcü又开发出了SLF4J作为日志框架的抽象层</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%97%A5%E5%BF%97/%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6%E5%85%B3%E7%B3%BB.png" alt="日志框架关系图示"></p>
<h4 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">日志级别排序为： TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</span><br></pre></td></tr></table></figure>

<h4 id="Logback配置文件解析"><a href="#Logback配置文件解析" class="headerlink" title="Logback配置文件解析"></a>Logback配置文件解析</h4><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">scan：当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</span></span><br><span class="line"><span class="comment">scanPeriod：设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒，当scan为true时，此属性生效。默认的时间间隔为1分钟。</span></span><br><span class="line"><span class="comment">debug：当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">scan</span>=<span class="string">&quot;true&quot;</span> <span class="attr">scanPeriod</span>=<span class="string">&quot;60 seconds&quot;</span> <span class="attr">debug</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志的根目录 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;log.path&quot;</span> <span class="attr">value</span>=<span class="string">&quot;/data/demolog&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义日志文件名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;appName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;demo&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- ch.qos.logback.core.ConsoleAppender 表示控制台输出 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;stdout&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        日志输出格式：</span></span><br><span class="line"><span class="comment">            %d表示日期时间，</span></span><br><span class="line"><span class="comment">            %thread表示线程名，</span></span><br><span class="line"><span class="comment">            %-5level：级别从左显示5个字符宽度</span></span><br><span class="line"><span class="comment">            %logger&#123;50&#125; 表示logger名字最长50个字符，否则按照句点分割。</span></span><br><span class="line"><span class="comment">            %msg：日志消息，</span></span><br><span class="line"><span class="comment">            %n是换行符</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--ThresholdFilter： 临界值过滤器，过滤掉低于指定临界值的日志。 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.ThresholdFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 在日志配置级别的基础上过滤掉info级别以下的日志 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>info<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- level为 TRACE 和 WARN 日志，时间滚动输出  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;TRACE_WARN_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/demo_trace.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文档输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志归档 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/demo-trace-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文档保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文档只记录debug级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对日志的处理方式：</span></span><br><span class="line"><span class="comment">                   DENY：日志将立即被抛弃不再经过其他过滤器；</span></span><br><span class="line"><span class="comment">                   NEUTRAL：有序列表里的下个过滤器过接着处理日志；（该级别既不处理，也不抛弃，相当于没有任何处理，日志会被保存下来并在本appender被执行</span></span><br><span class="line"><span class="comment">                   ACCEPT：日志会被立即处理，不再经过剩余过滤器。--&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- level：日志级别。--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>trace<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- onMatch：对符合过滤级别的日志的操作。（DENY，NEUTRAL，ACCEPT）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- onMismatch：对不符合过滤级别的日志的操作。（DENY，NEUTRAL，ACCEPT）--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>NEUTRAL<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>warn<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- level为 ERROR 日志，时间滚动输出  --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;ERROR_FILE&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 正在记录的日志文档的路径及文档名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/demo_error.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--日志文档输出格式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">charset</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">charset</span>&gt;</span> <span class="comment">&lt;!-- 此处设置字符集 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志记录器的滚动策略，按日期，按大小记录 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/demo-error-%d&#123;yyyy-MM-dd&#125;.%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--日志文档保留天数--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">maxHistory</span>&gt;</span>15<span class="tag">&lt;/<span class="name">maxHistory</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此日志文档只记录ERROR级别的 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">filter</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.filter.LevelFilter&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">level</span>&gt;</span>ERROR<span class="tag">&lt;/<span class="name">level</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMatch</span>&gt;</span>ACCEPT<span class="tag">&lt;/<span class="name">onMatch</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">onMismatch</span>&gt;</span>DENY<span class="tag">&lt;/<span class="name">onMismatch</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 滚动记录文件，先将日志记录到指定文件，当符合某个条件时，将日志记录到其他文件 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 没有配置filter，将会打印出全部级别的日志--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">&quot;appLogAppender&quot;</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定日志文件的名称 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">file</span>&gt;</span>$&#123;log.path&#125;/demo_all.log<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        当发生滚动时，决定 RollingFileAppender 的行为，涉及文件移动和重命名</span></span><br><span class="line"><span class="comment">        TimeBasedRollingPolicy： 最常用的滚动策略，它根据时间来制定滚动策略，既负责滚动也负责出发滚动。</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">rollingPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            滚动时产生的文件的存放位置及文件名称 %d&#123;yyyy-MM-dd&#125;：按天进行日志滚动</span></span><br><span class="line"><span class="comment">            %i：当文件大小超过maxFileSize时，按照i进行文件滚动</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">fileNamePattern</span>&gt;</span>$&#123;log.path&#125;/$&#123;appName&#125;-%d&#123;yyyy-MM-dd&#125;-%i.log<span class="tag">&lt;/<span class="name">fileNamePattern</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            可选节点，控制保留的归档文件的最大数量，超出数量就删除旧文件。假设设置每天滚动，</span></span><br><span class="line"><span class="comment">            且maxHistory是365，则只保存最近365天的文件，删除之前的旧文件。注意，删除旧文件是，</span></span><br><span class="line"><span class="comment">            那些为了归档而创建的目录也会被删除。</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">MaxHistory</span>&gt;</span>10<span class="tag">&lt;/<span class="name">MaxHistory</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">            当日志文件超过maxFileSize指定的大小是，根据上面提到的%i进行日志文件滚动 注意此处配置SizeBasedTriggeringPolicy是无法实现按文件大小进行滚动的，必须配置timeBasedFileNamingAndTriggeringPolicy</span></span><br><span class="line"><span class="comment">            --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">timeBasedFileNamingAndTriggeringPolicy</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.core.rolling.SizeAndTimeBasedFNATP&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">maxFileSize</span>&gt;</span>100MB<span class="tag">&lt;/<span class="name">maxFileSize</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">timeBasedFileNamingAndTriggeringPolicy</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">rollingPolicy</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 日志输出格式： --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">layout</span> <span class="attr">class</span>=<span class="string">&quot;ch.qos.logback.classic.PatternLayout&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [ %thread ] - [ %-5level ] [ %logger&#123;50&#125; : %line ] - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">        logger主要用于存放日志对象，也可以定义日志类型、级别</span></span><br><span class="line"><span class="comment">        name：表示匹配的logger类型前缀，也就是包的前半部分</span></span><br><span class="line"><span class="comment">        level：要记录的日志级别，包括 TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR</span></span><br><span class="line"><span class="comment">        additivity：作用在于children-logger是否使用 rootLogger配置的appender进行输出，</span></span><br><span class="line"><span class="comment">        false：表示只用当前logger的appender-ref，true：</span></span><br><span class="line"><span class="comment">        表示当前logger的appender-ref和rootLogger的appender-ref都有效</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- hibernate logger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;cn.zhangyuying.demo.demo.log&quot;</span> <span class="attr">level</span>=<span class="string">&quot;trace&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;cn.zhangyuying.demo.demo.log2&quot;</span> <span class="attr">level</span>=<span class="string">&quot;warn&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Spring framework logger --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">&quot;org.springframework&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> <span class="attr">additivity</span>=<span class="string">&quot;false&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    root与logger是父子关系，没有特别定义则默认为root，任何一个类只会和一个logger对应，</span></span><br><span class="line"><span class="comment">    要么是定义的logger，要么是root，判断的关键在于找到这个logger，然后判断这个logger的appender和level。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">root</span> <span class="attr">level</span>=<span class="string">&quot;debug&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;stdout&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;appLogAppender&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;TRACE_WARN_FILE&quot;</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">&quot;ERROR_FILE&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>



<p>参考文件：<br><a href="https://www.cnblogs.com/suger43894/p/9543685.html">各种日志框架的关系</a></p>
<p><a href="https://www.jianshu.com/p/6f093b0b0c8a">Logback配置解析</a></p>
<p><a href="https://blog.csdn.net/xu_san_duo/article/details/80364600">Logback配置解析</a></p>
<p><a href="https://www.cnblogs.com/whalesea/p/10950628.html">日志级别的配置</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Logback</tag>
      </tags>
  </entry>
  <entry>
    <title>初识架构五视图</title>
    <url>/2020/06/16/%E6%9E%B6%E6%9E%84/%E5%88%9D%E8%AF%86%E6%9E%B6%E6%9E%84%E4%BA%94%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<p>架构是从整体看到局部，架构五视图是实现架构设计的方法</p>
<p>五视图方法论从不同的方面，不同视角，可以一次只围绕少数概念和技术展开，分别着重研究软件架构的不同方面，清晰、简化的描述架构</p>
<span id="more"></span>

<p>五视图具体说明：</p>
<p>设计源于需求，五视图对应于需求的关系如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%9E%B6%E6%9E%84/%E4%BA%94%E8%A7%86%E5%9B%BE%E4%B8%8E%E5%85%B6%E5%AF%B9%E5%BA%94%E7%9A%84%E9%9C%80%E6%B1%82.jpg" alt="五视图与其对应的需求"></p>
<p>在需求驱动下，五视图具体的设计含义：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%9E%B6%E6%9E%84/%E4%BA%94%E8%A7%86%E5%9B%BE.png"></p>
<ol>
<li><p>逻辑架构</p>
<p>解决问题：软件可以提供什么样的功能</p>
<p>主责：主要是业务设计，确定职责、模块的划分，并明确模块之间的协作与依赖关系</p>
<p>逻辑架构的设计着重考虑功能需求，系统应当向用户提供什么样的服务，关注点主要是行为或职责的划分。逻辑架构关注的功能，不仅包括用户可见的功能，还应当包括为实现用户功能而必须提供的辅助功能。逻辑架构的静态方面是抽象职责的划分，动态方面是承担不同职责的逻辑单元之间的交互与协作。</p>
<p>图示表达：</p>
<ul>
<li>逻辑视图：模块、功能的划分</li>
</ul>
</li>
</ol>
<ul>
<li>用例图：梳理清楚业务需求</li>
</ul>
<ol start="2">
<li><p>数据架构</p>
<p>解决问题：软件的数据结构</p>
<p>主责：数据的设计，确定要存储的数据以及数据存储格式</p>
<p>数据架构的设计着重考虑数据需求，关注点是持久化数据的存储方案，不仅包括实体及实体关系数据存储格式，还可能包括数据传递、数据复制、数据同步等策略。</p>
<p>图示表达：ER图</p>
</li>
<li><p>开发架构</p>
<p>解决问题：软件代码的层次结构</p>
<p>涉及到：技术选型、开发规范的确定等，确定程序单元以及程序单元的组织结构</p>
<p>开发架构的设计着重考虑开发期质量属性，关注点是在软件开发环境中软件模块（包）的实际组织方式，具体涉及源程序文件、配置文件、源程序包、编译打包后的目标文件、直接使用的第三方SDK/框架/类库、以及开发的系统将运行于其上的系统软件或中间件。</p>
</li>
<li><p>运行架构</p>
<p>解决问题：软件的性能特征</p>
<p>关注点在于：局部的关键点与难点，可能需要技术攻关和预研</p>
<p>运行架构的设计着重考虑运行期质量属性，关注点是系统的并发、同步、通信等问题，这势必涉及到进程、线程、对象等运行时概念，以及相关的并发、同步、通信等。运行架构的静态方面关注软件系统运行时的单元结构，动态方面关注运行时单元之间的交互机制。</p>
</li>
<li><p>物理架构</p>
<p>解决问题：软件的部署与网络结构，确定物理节点和物理节点的拓扑结构；</p>
<p>物理架构的设计着重考虑安装和部署需求，关注点是目标程序及其依赖的运行库和系统软件最终如何安装或部署到物理机器，以及如何部署机器和网络来配合软件系统的可靠性、可伸缩性、持续可用性、性能和安全性等要求。</p>
</li>
</ol>
<p>图示如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%9E%B6%E6%9E%84/%E4%BA%94%E8%A7%86%E5%9B%BE%E8%AF%B4%E6%98%8E.png"></p>
<p>参考资料</p>
<p><a href="https://blog.csdn.net/nnsword/article/details/78109126">五视图方法论</a></p>
<p><a href="https://www.cnblogs.com/one-gril/p/11272832.html">架构设计之大话五视图</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>Log中的锁</title>
    <url>/2023/01/09/%E6%97%A5%E5%BF%97/Log%E4%B8%AD%E7%9A%84%E9%94%81/</url>
    <content><![CDATA[<p>前言：最近在优化接口速度时，遇到一个问题：一段纯逻辑计算的代码，在循环调用中，每次时间耗时较长达到0.2s，即使使用多线程执行这段代码速度依然没有太大变化。最后定位是<code>Log</code>中使用的锁导致的上述现象。</p>
<span id="more"></span>

<h3 id="Log4j介绍"><a href="#Log4j介绍" class="headerlink" title="Log4j介绍"></a>Log4j介绍</h3><p><code>Log4j</code>主要分为三个部分</p>
<ol>
<li><p><code>Loggers</code>，记录器</p>
<p>用于对日志记录行为的抽象，提供记录不同级别日志的接口</p>
<ul>
<li><p><code>Level</code>是对日志级别的抽象，包括：<code>DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL</code></p>
</li>
<li><p><code>LoggerRepository</code>是<code>Logger</code>实例的容器，<code>ObjectRender</code>是对日志实例的解析接口，它们主要提供了一种扩展支持。</p>
</li>
</ul>
</li>
<li><p><code>Appenders</code>，输出源</p>
<p>是对记录日志形式的抽象，即允许把日志输出到不同的地方，如控制台(<code>Console</code>)、文件(<code>Files</code>）等，也可以根据天数或者文件大小产生新的文件，还可以以流的形式发送到其它地方等。常用类如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">org.apache.log4j.ConsoleAppender</span> <span class="comment">#控制台</span></span><br><span class="line"><span class="string">org.apache.log4j.FileAppender</span> <span class="comment">#日志文件</span></span><br><span class="line"><span class="string">org.apache.log4j.DailyRollingFileAppender</span> <span class="comment">#每天产生一个日志文件</span></span><br><span class="line"><span class="string">org.apache.log4j.RollingFileAppender</span> <span class="comment">#文件大小到达指定尺寸的时候产生一个新的文件</span></span><br><span class="line"><span class="string">org.apache.log4j.WriterAppender</span> <span class="comment">#将日志信息以流格式发送到任意指定的地方</span></span><br><span class="line"><span class="string">org.apache.log4j.jdbc.JDBCAppender</span> <span class="comment">#数据库</span></span><br><span class="line"><span class="string">org.apache.log4j.net.SocketAppender</span> <span class="comment">#Socket</span></span><br><span class="line"><span class="string">org.apache.log4j.net.SMTPAppender</span> <span class="comment">#邮件</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>Layouts</code>，布局</p>
<p>是对日志行格式的抽象，有时，用户希望根据自己的喜好格式化自己的日志输出，<code>Log4j</code>可以在<code>Appenders</code>的后面附加<code>Layouts</code>来完成这个功能。<code>Layouts</code>提供四种日志输出格式，如根据<code>HTML</code>样式、自由指定样式、包含日志级别与信息的样式、包含日志时间、线程、类别等信息的样式。常用类如下：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">org.apache.log4j.HTMLLayout</span> <span class="comment">#以HTML表格表式布局</span></span><br><span class="line"><span class="string">org.apache.log4j.PatternLayout</span> <span class="comment">#可以灵活指定布局模式</span></span><br><span class="line"><span class="string">org.apache.log4j.SimpleLayout</span> <span class="comment">#包含日志信息的级别和信息字符串</span></span><br><span class="line"><span class="string">org.apache.log4j.TTCCLayout</span> <span class="comment">#包含日志产生的时间、线程、类别等信息</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="Log4j中的锁"><a href="#Log4j中的锁" class="headerlink" title="Log4j中的锁"></a>Log4j中的锁</h3><p>在平时的编码中，下列两种代码优化场景可以考虑：代码中是否包含较多日志打印</p>
<ol>
<li>循环调用代码，改为使用多线程不能明显提速</li>
<li>循环一段纯逻辑计算的代码逻辑，耗时超出预期</li>
</ol>
<p><strong>定位Log中的锁</strong></p>
<p><code>log.info(&quot;Log Stack&quot;);</code> 中日志相关堆栈信息如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">write:<span class="number">56</span>, ResilientOutputStreamBase (ch.qos.logback.core.recovery)</span><br><span class="line">write:<span class="number">75</span>, OutputStream (java.io)</span><br><span class="line">writeBytes:<span class="number">199</span>, OutputStreamAppender (ch.qos.logback.core)</span><br><span class="line">subAppend:<span class="number">231</span>, OutputStreamAppender (ch.qos.logback.core)</span><br><span class="line">subAppend:<span class="number">229</span>, RollingFileAppender (ch.qos.logback.core.rolling)</span><br><span class="line">append:<span class="number">102</span>, OutputStreamAppender (ch.qos.logback.core)</span><br><span class="line">doAppend:<span class="number">84</span>, UnsynchronizedAppenderBase (ch.qos.logback.core)</span><br><span class="line">appendLoopOnAppenders:<span class="number">51</span>, AppenderAttachableImpl (ch.qos.logback.core.spi)</span><br><span class="line">appendLoopOnAppenders:<span class="number">270</span>, Logger (ch.qos.logback.classic)</span><br><span class="line">callAppenders:<span class="number">257</span>, Logger (ch.qos.logback.classic)</span><br><span class="line">buildLoggingEventAndAppend:<span class="number">421</span>, Logger (ch.qos.logback.classic)</span><br><span class="line">filterAndLog_0_Or3Plus:<span class="number">383</span>, Logger (ch.qos.logback.classic)</span><br><span class="line">log:<span class="number">765</span>, Logger (ch.qos.logback.classic)</span><br><span class="line">info:<span class="number">454</span>, LogAdapter$Slf4jLocationAwareLog (org.apache.commons.logging)</span><br><span class="line">logTest:<span class="number">328</span>, LogTestService (com.zhangyuying.log)</span><br></pre></td></tr></table></figure>

<p>其中<code>OutputStreamAppender.writeBytes</code> 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock(<span class="keyword">false</span>);</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeBytes</span><span class="params">(<span class="keyword">byte</span>[] byteArray)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (byteArray != <span class="keyword">null</span> &amp;&amp; byteArray.length != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.outputStream.write(byteArray);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.immediateFlush) &#123;</span><br><span class="line">                <span class="keyword">this</span>.outputStream.flush();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到其中使用了<code>ReentrantLock</code>对日志写入代码进行了控制。</p>
<p>参考资料</p>
<p><a href="http://www.blogjava.net/DLevin/archive/2012/06/28/381667.html">深入Log4J源码之Log4J Core</a></p>
<p><a href="https://blog.csdn.net/u011794238/article/details/50736331">Log4j源码解析–框架流程+核心解析</a></p>
<p><a href="https://blog.csdn.net/jssg_tzw/article/details/77678375">Log4j日志配置详解</a></p>
<p><a href="https://toutiao.io/posts/f5qwbr3/preview">漫话：应用程序被拖慢？罪魁祸首竟然是Log4j！</a></p>
]]></content>
      <categories>
        <category>日志</category>
      </categories>
      <tags>
        <tag>Log</tag>
      </tags>
  </entry>
  <entry>
    <title>架构概述</title>
    <url>/2020/12/08/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>我们学习架构，首先要明白什么是架构？而架构的概念和定义，一直有很多争论，似乎没有哪种定义能准确的表达架构的含义，这里说的也是本人比较理解的方式</p>
<span id="more"></span>

<h4 id="什么是架构"><a href="#什么是架构" class="headerlink" title="什么是架构"></a>什么是架构</h4><p>什么是架构？此处采取的是我个人觉得比较理解的一个表达(选自架构漫谈)：</p>
<ol>
<li>根据要解决的问题，对目标系统的边界进行界定。</li>
<li>并对目标系统按某个原则的进行切分。切分的原则，要便于不同的角色，对切分出来的部分，并行或串行开展工作，一般并行才能减少时间。</li>
<li>并对这些切分出来的部分，设立沟通机制。</li>
<li>根据3，使得这些部分之间能够进行有机的联系，合并组装成为一个整体，完成目标系统的所有工作。</li>
</ol>
<p>架构是比较宽泛的概念，什么算是<strong>软件架构</strong>呢(架构漫谈)？这里说的软件架构是在刚说的架构的基础上增加软件概念</p>
<ol>
<li>软件因为流量增大而分拆成不同的运行单元，在不同的机器上部署所形成的架构，属于软件架构。</li>
<li>每个运行单元为了让不同角色的人，比如前端，业务，数据存储等能够并行工作，所分成的代码架构，也属于软件架构。</li>
</ol>
<p>所以当我们说软件架构的时候，我们一定要讲清楚，究竟说的是部署的架构，还是代码的架构，（即可以理解为软件架构可以通过不同角度进行描述（架构的五视图），也可以理解为各个角度都是软件架构）。软件架构的落地，需要软件的组织架构和流程来保障，离开了这个，软件架构是一句空话。</p>
<p>有很多人讲，软件架构是进化出来的。软件架构实际上是在量不断的增大，超过了单台服务器的容量，逐渐的分拆，同时导致超过单个人员的能力，工作人员不断的增多，工作内容不断的分拆形成的。这本身就是架构的意义所在。不管怎么分拆，所达到的目标没有任何变化，就是完成业务在计算机中的虚拟化。</p>
<p>软件架构的其他理解方式？</p>
<p>软件架构(<code>Software Architecture</code>)指软件系统的顶层结构。</p>
<ul>
<li>首先，“系统是一群关联个体组成”，这些“个体”可以是“子系统”、“模块”、“组件”等；<strong>架构需要明确系统包含哪些“个体”</strong>。</li>
<li>其次，系统中的个体需要“根据某种规则”运作，<strong>架构需要明确个体运作和协作的规则</strong>。</li>
</ul>
<p>注：<a href="https://zhangyuying.top/2020/06/16/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/">理解架构的相关的其他基础概念，包括系统、模块、组件等</a></p>
<p><strong>架构其实就是为了应对软件系统复杂度而提出的解决方案。架构关键思维即为判断与取舍</strong>。</p>
<h4 id="软件架构解决什么问题"><a href="#软件架构解决什么问题" class="headerlink" title="软件架构解决什么问题"></a>软件架构解决什么问题</h4><p>软件架构出现的原因：<br>随着软件系统规模的增加，计算相关的算法和数据结构不再构成主要的设计问题，而是其他方面的问题，比如：</p>
<ol>
<li>系统规模庞大，内部耦合严重，开发效率低；</li>
<li>系统耦合严重，牵一发动全身，后续修改和扩展困难；</li>
<li>系统逻辑复杂，容易出问题，出问题后很难排查和修复；</li>
</ol>
<p>所以软件架构是在进化中产生并且不断变化的， 软件架构是顶层结构，即能解决的问题相当于整个软件系统的所有问题：技术人员的合作模块问题、业务需求的实现问题、组件之间的通信问题、数据的存储问题、系统的可扩展性、系统的容错处理、系统的性能问题、系统的扩展问题、系统能够承受的压力问题。所以其实是：根据软件系统可能遇到的问题选择合适的软件架构， 架构是灵活的，根据实际的问题来具体的选择和设计。</p>
<blockquote>
<p>正如，在一个有约束的盒子里去求解或接近最合适的解。这个约束的盒子可能会包含团队经验、成本、资源、时间、业务阶段等因素掺杂在一起的综合体，针对这个综合体，<strong>分析出系统架构的复杂度，进行合适的判断与取舍</strong>，从而设计出恰当的架构用在合适的软件系统中。</p>
</blockquote>
<h4 id="架构的演变"><a href="#架构的演变" class="headerlink" title="架构的演变"></a>架构的演变</h4><p>前面提到好多次，软件架构是进化出来的，所以看下到现在为止<a href="https://zhangyuying.top/2020/12/08/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/">架构的演变情况</a></p>
<h4 id="架构五视图"><a href="#架构五视图" class="headerlink" title="架构五视图"></a>架构五视图</h4><p>之前有提到过：可以理解为软件架构可以通过不同角度进行描述（架构的五视图），也可以理解为各个角度都是软件架构，这个不同的角度，一般指的就是架构的五视图，而五视图也是实现架构的具体方式。<a href="https://zhangyuying.top/2020/06/16/%E6%9E%B6%E6%9E%84/%E5%88%9D%E8%AF%86%E6%9E%B6%E6%9E%84%E4%BA%94%E8%A7%86%E5%9B%BE/#more">架构五视图具体内容</a></p>
<p>参考资料：</p>
<p><a href="https://www.cnblogs.com/gym333/p/8508012.html">架构漫谈-转</a></p>
<p><a href="https://www.jianshu.com/p/312af3e8b94a">浅谈架构-架构的缘起与目标</a></p>
<p><a href="https://www.jianshu.com/p/29a015e3bcf7">什么是架构</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构演变</title>
    <url>/2020/12/08/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<p>架构是思想，是不同需求和问题的解决方案</p>
<span id="more"></span>

<p>架构的演变主要为：单体架构 —&gt; 垂直架构 —&gt; 分布式架构 —&gt; 流动计算架构(SOA) —&gt; 微服务架构</p>
<blockquote>
<p>个人理解，架构也可以理解为一种思想，一种针对特定需求的设计思想，比如微服务，就是一种设计指导思想，而spring cloud 就是实现这个思想的具体框架，针对一个架构形成的框架可以理解为框架思想落地的快捷实现方式。但是并不是说想要微服务就要使用springcloud，反之使用springcloud也不一定就是微服务。</p>
</blockquote>
<p>如图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E6%BC%94%E5%8F%98.png" alt="架构演变图"></p>
<h4 id="各架构优缺点简要说明"><a href="#各架构优缺点简要说明" class="headerlink" title="各架构优缺点简要说明"></a>各架构优缺点简要说明</h4><p><strong>单体架构</strong></p>
<ul>
<li>特点：<br>1、所有的功能集成在一个项目工程中。<br>2、所有的功能打一个war包部署到服务器。<br>3、应用与数据库分开部署。<br>4、通过部署应用集群和数据库集群来提高系统的性能。</li>
<li>优点：<br>1、项目架构简单，前期开发成本低，周期短，小型项目的首选。</li>
<li>缺点：<br>1、全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。<br>2、系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。<br>3、技术栈受限。</li>
</ul>
<p><strong>垂直架构</strong></p>
<ul>
<li>特点<br>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。<br>此时，用于加速前端页面开发的 Web框架(MVC) 是关键。</li>
<li>优点：<br>1、项目架构简单，前期开发成本低，周期短，小型项目的首选。<br>2、通过垂直拆分，原来的单体项目不至于无限扩大。<br>3、不同的项目可采用不同的技术。</li>
<li>缺点：<br>1、全部功能集成在一个工程中，对于大型项目不易开发、扩展及维护。<br>2、系统性能扩展只能通过扩展集群结点，成本高、有瓶颈。</li>
</ul>
<p><strong>分布式架构</strong></p>
<p>分布式系统是一组计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。<strong>组件之间彼此进行交互以实现一个共同的目标</strong>。SOA 和 微服务都是分布式的进化，也都属于分布式</p>
<p><strong>SOA架构</strong></p>
<ul>
<li><p>特点</p>
<p>面向服务架构</p>
<p>比较有代表性的框架如dubbo</p>
</li>
<li><p>优点：<br>把模块拆分，使用接口通信，降低模块之间的耦合度<br>把项目拆分成若干个子项目，不同的团队负责不同的子项目<br>增加功能时只需要在增加一个子项目，调用其它系统的接口就可以<br>可以灵活的进行分布式部署</p>
</li>
<li><p>缺点：<br>系统之间交互需要使用远程通信，接口开发增加工作量</p>
</li>
</ul>
<p><strong>微服务架构</strong></p>
<ul>
<li>特点：<br>1、将系统服务层完全独立出来，并将服务层抽取为一个一个的微服务。<br>2、微服务遵循单一原则。<br>3、微服务之间采用RESTful等轻量协议传输。</li>
<li>优点：<br>1、服务拆分粒度更细，有利于资源重复利用，提高开发效率。<br>2、可以更加精准的制定每个服务的优化方案，提高系统可维护性。<br>3、微服务架构采用去中心化思想，服务之间采用RESTful等轻量协议通信，相比ESB更轻量。<br>4、适用于互联网时代，产品迭代周期更短。</li>
<li>缺点：<br>1、微服务过多，服务治理成本高，不利于系统维护。<br>2、分布式系统开发的技术成本高（容错、分布式事务等），对团队挑战大。</li>
</ul>
<h4 id="概念理解："><a href="#概念理解：" class="headerlink" title="概念理解："></a>概念理解：</h4><ol>
<li><p>微服务架构（microservices architecture）是服务导向架构（service-oriented architecture，缩写 SOA）的升级。</p>
<p>每一个服务就是一个独立的部署单元（separately deployed unit）。这些单元都是分布式的，互相解耦，通过远程通信协议（比如REST、SOAP）联系。</p>
</li>
<li><p>SOA和微服务的对比理解</p>
<ul>
<li>SOA架构强调的是异构系统之间的通信和解耦合</li>
<li>微服务架构强调的是系统按业务边界做细粒度的拆分和部署</li>
</ul>
</li>
<li><p>分布式系统是一组计算机，通过网络相互连接传递消息与通信后并协调它们的行为而形成的系统。<strong>组件之间彼此进行交互以实现一个共同的目标</strong>。</p>
<p>分布式是一个更宽泛的思想，SOA和微服务都是在分布式基础上的思想升级，所以SOA和微服务在概念上也都属于分布式（可以理解为圆和椭圆）</p>
</li>
</ol>
<p>参考资料</p>
<p><a href="https://www.cnblogs.com/doit8791/p/9343826.html">五种常见的软件架构</a></p>
<p><a href="https://www.cnblogs.com/linjiqin/p/10074004.html">软件架构演进</a></p>
<p><a href="https://www.cnblogs.com/kakaisgood/p/9541953.html">集群/分布式/微服务/SOA</a></p>
<p><a href="https://www.sohu.com/a/221400925_100039689">什么是微服务</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>架构相关基础概念</title>
    <url>/2020/06/16/%E6%9E%B6%E6%9E%84/%E6%9E%B6%E6%9E%84%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>架构中的一些其他有关系而又相似的概念，理解了这些概念更有助于我们理解架构</p>
<span id="more"></span>

<h4 id="系统和子系统"><a href="#系统和子系统" class="headerlink" title="系统和子系统"></a>系统和子系统</h4><p><strong>系统</strong>（<code>system</code>）:泛指由一群<strong>有关联</strong>的个体组成，根据<strong>某种规则</strong>运作，能完成个别元件不能单独完成的工作的群体。它的意思是“总体”、“整体”或“联盟”。</p>
<ul>
<li><strong>关联</strong>：系统是由一群有关联的个体组成的，没有关联的个体堆在一起不能成为一个系统，例如：把一个发动机和一台PC放在一起不能称之为一个系统，把发动机、底盘、轮胎、车架组合起来才能成为一台汽车。</li>
<li><strong>规则</strong>：系统内的个体需要按照指定的规则运作，而不是单个个体各自为政。规则规定了系统内个体分工和协作的方式。例如：汽车发动机负责产生动力，然后通过变速器和传动轴，将动力输出到轮胎上，从而驱动汽车前进。</li>
<li><strong>能力</strong>：系统能力和个体能力有本质的差别，系统能力也不是个体能力之和，而是产生了新的能力。例如：汽车能够载重前进，而发动机、变速器、传动轴、车轮本身都不具备这样的能力。</li>
</ul>
<p><strong>子系统</strong>也是由一群有关联的个体所组成的系统，多半会是更大系统中的一部分。</p>
<ul>
<li>其实子系统和系统的定义是一样的，<strong>只是观察的角度有差异</strong>，一个系统可能是另外一个更大系统的子系统。比如微信是一个系统，朋友圈就是一个子系统，朋友圈系统又包含评论子系统</li>
</ul>
<h4 id="模块和组件"><a href="#模块和组件" class="headerlink" title="模块和组件"></a>模块和组件</h4><p>模块（Module）：是一套一致而互相有紧密关连的软件组织。它分别包含了程序和数据结构两部分。<br>组件（Component）：自包含的、可编程的、可重用的、与语言无关的软件单元，软件组件可以很容易被用于组装应用程序中。</p>
<ul>
<li>模块和组件都是系统的组成部分，只是从不同的角度拆分系统而已。<ul>
<li>从逻辑的角度来拆分系统后，得到的单元就是“模块”；划分模块的<strong>主要目的是职责分离</strong>；模块偏业务。</li>
<li>从物理的角度来拆分系统后，得到的单元就是“组件”；划分组件的<strong>主要目的是单元复用</strong>；组件偏技术。</li>
</ul>
</li>
<li>模块是对系统进行横向拆分，为了便于分工协作；而组件是纵向切分，站在成本角度，目的是为了复用，具备独立可替换特点。</li>
</ul>
<h4 id="框架和架构"><a href="#框架和架构" class="headerlink" title="框架和架构"></a>框架和架构</h4><p><strong>单纯从定义的角度来看，框架关注的是“规范”，架构关注的是“结构”</strong>。</p>
<p>我们经常会说，比如：“工程采用的是MVC架构”、“工程使用的是SSH框架”等。所以，第一句话是站在结构的层面来说明(如果是以不同的角度来说明结构，会得出不同的架构描述(五视图))，第二句话是站在规范的层面来说明。</p>
<p>参考资料</p>
<p><a href="https://www.jianshu.com/p/312af3e8b94a">浅谈架构-架构的缘起和缘落</a></p>
<p><a href="https://www.jianshu.com/p/29a015e3bcf7">什么是架构</a></p>
]]></content>
      <categories>
        <category>架构</category>
      </categories>
      <tags>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title>正则元字符</title>
    <url>/2018/10/23/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E5%85%83%E5%AD%97%E7%AC%A6/</url>
    <content><![CDATA[<h4 id="正则中的元字符"><a href="#正则中的元字符" class="headerlink" title="正则中的元字符"></a>正则中的元字符</h4><span id="more"></span>

<p>非打印字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\cx 	匹配由x指明的控制字符。例如:\cM 匹配一个Control-M或回车符。x的值必须为A-Z 或a-z之一。否则，将c视为一个原义的 &#39;c&#39;字符。</span><br><span class="line">\f  	匹配一个换页符。等价于 \x0c 和 \cL。                 </span><br><span class="line">\n  	匹配一个换行符。等价于 \x0a 和 \cJ。                 </span><br><span class="line">\r  	匹配一个回车符。等价于 \x0d 和 \cM。                 </span><br><span class="line">\s  	匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。</span><br><span class="line">\S  	匹配任何非空白字符。等价于  \f\n\r\t\v。              </span><br><span class="line">\t  	匹配一个制表符。等价于 \x09 和 \cI。                 </span><br><span class="line">\v  	匹配一个垂直制表符。等价于 \x0b 和 \cK。</span><br></pre></td></tr></table></figure>

<p>特殊字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$   	匹配输入字符串的结尾位置                            </span><br><span class="line">( ) 	标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用          </span><br><span class="line">*   	匹配前面的子表达式零次或多次                          </span><br><span class="line">+   	匹配前面的子表达式一次或多次                          </span><br><span class="line">.   	匹配除换行符 \n 之外的任何单字符                      </span><br><span class="line">[   	标记一个中括号表达式的开始                           </span><br><span class="line">?   	匹配前面的子表达式零次或一次，或指明一个非贪婪限定符              </span><br><span class="line">^   	匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合 </span><br><span class="line">&#123;   	标记限定符表达式的开始                             </span><br><span class="line">|       指明两项之间的一个选择</span><br><span class="line">\   	将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如：&#39;n&#39; 匹配字符 &#39;n&#39;。&#39;\n&#39; 匹配换行符。序列 &#39;\\&#39;匹配 &quot;\&quot;（要匹配特殊字符，都要使用\进行转义）</span><br></pre></td></tr></table></figure>

<p>限定符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*    	匹配前面的子表达式零次或多次。例如，zo* 能匹配 &quot;z&quot; 以及 &quot;zoo&quot;。* 等价于&#123;0,&#125;。</span><br><span class="line">+    	匹配前面的子表达式一次或多次。例如，&#39;zo+&#39; 能匹配 &quot;zo&quot; 以及 &quot;zoo&quot;，但不能匹配 &quot;z&quot;。+ 等价于 &#123;1,&#125;。</span><br><span class="line">?    	匹配前面的子表达式零次或一次。例如，&quot;do(es)?&quot; 可以匹配 &quot;do&quot; 、 &quot;does&quot; 中的 &quot;does&quot; 、 &quot;doxy&quot; 中的 &quot;do&quot; 。? 等价于 &#123;0,1&#125;。</span><br><span class="line">&#123;n&#125;  	n 是一个非负整数。匹配确定的 n 次。例如，&#39;o&#123;2&#125;&#39; 不能匹配 &quot;Bob&quot; 中的 &#39;o&#39;，但是能匹配 &quot;food&quot; 中的两个 o。</span><br><span class="line">&#123;n,&#125; 	n 是一个非负整数。至少匹配n 次。例如，&#39;o&#123;2,&#125;&#39; 不能匹配 &quot;Bob&quot; 中的 &#39;o&#39;，但能匹配 &quot;foooood&quot; 中的所有 o。&#39;o&#123;1,&#125;&#39; 等价	于&#39;o+&#39;。&#39;o&#123;0,&#125;&#39; 则等价于 &#39;o*&#39;。</span><br><span class="line">&#123;n,m&#125;	m 和 n 均为非负整数，其中n &lt;&#x3D; m。最少匹配 n 次且最多匹配 m 次。例如，&quot;o&#123;1,3&#125;&quot; 将匹配 &quot;fooooood&quot; 中的前三个 o。&#39;o&#123;0,1&#125;&#39; 等价于 &#39;o?&#39;。请注意在逗号和两个数之间不能有空格。</span><br></pre></td></tr></table></figure>

<p>定位符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">^   	匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \n 或 \r 之后的位置匹配。</span><br><span class="line">$   	匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \n 或 \r 之前的位置匹配。</span><br><span class="line">\b  	匹配一个单词边界，即字与空格间的位置。                     </span><br><span class="line">\B  	非单词边界匹配。</span><br></pre></td></tr></table></figure>

<p>其他常用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x|y      匹配 x 或 y。例如，&#39;z|food&#39; 能匹配 &quot;z&quot; 或 &quot;food&quot;。&#39;(z|f)ood&#39; 则匹配 &quot;zood&quot; 或 &quot;food&quot;</span><br><span class="line">[xyz]    字符集合。匹配所包含的任意一个字符。例如， &#39;[abc]&#39; 可以匹配 &quot;plain&quot; 中的 &#39;a&#39;</span><br><span class="line">[^xyz]   负值字符集合。匹配未包含的任意字符。例如， &#39;abc&#39; 可以匹配 &quot;plain&quot; 中的&#39;p&#39;、&#39;l&#39;、&#39;i&#39;、&#39;n&#39;</span><br><span class="line">[a-z]    字符范围。匹配指定范围内的任意字符。例如，&#39;[a-z]&#39; 可以匹配 &#39;a&#39; 到 &#39;z&#39; 范围内的任意小写字母字符</span><br><span class="line">[^a-z]   负值字符范围。匹配任何不在指定范围内的任意字符。例如：&#39;a-z&#39;可以匹配任何不在&#39;a&#39;到&#39;z&#39;范围内的任意字符</span><br><span class="line">\d       匹配一个数字字符。等价于 [0-9]                     </span><br><span class="line">\D       匹配一个非数字字符。等价于 0-9                                 </span><br><span class="line">\w       匹配字母、数字、下划线。等价于&#39;[A-Za-z0-9_]&#39;         </span><br><span class="line">\W       匹配非字母、数字、下划线。等价于 &#39;A-Za-z0-9_&#39;</span><br></pre></td></tr></table></figure>

<p>断言相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(pattern)   	</span><br><span class="line">匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在	JScript 中则使用 0…属性。要匹配圆括号字符，请使用 &#39;(&#39; 或 &#39;)&#39;。</span><br><span class="line">(?:pattern) 	 </span><br><span class="line">匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 &quot;或&quot; 字符 (\|) 来组合一个模式的各个部分是很有用。例如， &#39;industr(?:y\|ies) 就是一个比 &#39;industry\|industries&#39; 更简略的表达式。</span><br><span class="line">(?&#x3D;pattern) 	</span><br><span class="line">正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，&quot;Windows(?&#x3D;95\|98\|NT\|2000)&quot;能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span><br><span class="line">(?!pattern) 	</span><br><span class="line">正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如&quot;Windows(?!95|98|NT|2000)&quot;能匹配&quot;Windows3.1&quot;中的&quot;Windows&quot;，但不能匹配&quot;Windows2000&quot;中的&quot;Windows&quot;。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span><br><span class="line">(?&lt;&#x3D;pattern)	</span><br><span class="line">反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，&quot;(?&lt;&#x3D;95|98|NT|2000)Windows&quot;能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;</span><br><span class="line">(?&lt;!pattern)	</span><br><span class="line">反向否定预查，与正向否定预查类似，只是方向相反。例如&quot;(?&lt;!95|98|NT|2000)Windows&quot;能匹配&quot;3.1Windows&quot;中的&quot;Windows&quot;，但不能匹配&quot;2000Windows&quot;中的&quot;Windows&quot;</span><br></pre></td></tr></table></figure>

<p>进制相关</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\xn        匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，&#39;\x41&#39; 匹配 &quot;A&quot;。&#39;\x041&#39; 则等价于&#39;\x04&#39; &amp; &quot;1&quot;。正则表达式中可以使用 ASCII 编码。</span><br><span class="line">\num       匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，&#39;(.)\1&#39; 匹配两个连续的相同字符。</span><br><span class="line">\n         标识一个八进制转义值或一个向后引用。如果 \n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字(0-7)，则 n 为一个八进制转义值。</span><br><span class="line">\nm        标识一个八进制转义值或一个向后引用。如果 \nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \nm 将匹配八进制转义值 nm。</span><br><span class="line">\nml       如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。</span><br><span class="line">\un        匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (?)</span><br></pre></td></tr></table></figure>



<h4 id="运算符的优先级："><a href="#运算符的优先级：" class="headerlink" title="运算符的优先级："></a>运算符的优先级：</h4><p>（从最高到最低）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">\							转义符</span><br><span class="line">(), (?:), (?=), []			圆括号和方括号</span><br><span class="line">*, +, ?, &#123;n&#125;, &#123;n,&#125;, &#123;n,m&#125;	限定符</span><br><span class="line">^, $, \任何元字符、任何字符	定位点和序列（即：位置和顺序）</span><br><span class="line">|							替换，<span class="string">&quot;或&quot;</span>操作.字符具有高于替换运算符的优先级，使得<span class="string">&quot;m|food&quot;</span>匹配<span class="string">&quot;m&quot;</span>或<span class="string">&quot;food&quot;</span>。若要匹配<span class="string">&quot;mood&quot;</span>或<span class="string">&quot;food&quot;</span>，							  请使用括号创建子表达式，从而产生<span class="string">&quot;(m|f)ood&quot;</span>。</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p><a href="http://www.runoob.com/regexp/regexp-metachar.html">http://www.runoob.com/regexp/regexp-metachar.html</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">https://zh.wikipedia.org/wiki/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F</a></p>
]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2018/10/23/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p><strong>正则表达式</strong>又称规则表达式（Regular Expression，在代码中常简写为regex、regexp或RE）。</p>
<p>正则表达式通常被用来检索、替换那些符合某个模式(规则)的文本。</p>
<span id="more"></span>

<h4 id="为什么使用正则："><a href="#为什么使用正则：" class="headerlink" title="为什么使用正则："></a>为什么使用正则：</h4><p>通过使用正则表达式，可以：</p>
<ul>
<li>测试字符串内的模式。<br>例如，可以测试输入字符串，以查看字符串内是否出现电话号码模式或信用卡号码模式。这称为数据验证。</li>
<li>替换文本。<br>可以使用正则表达式来识别文档中的特定文本，完全删除该文本或者用其他文本替换它。</li>
<li>基于模式匹配从字符串中提取子字符串。<br>可以查找文档内或输入域内特定的文本。</li>
</ul>
<h4 id="正则中的元字符"><a href="#正则中的元字符" class="headerlink" title="正则中的元字符"></a>正则中的元字符</h4><p>正则元字符列表可参照：<a href="http://zhangyuying.cn/2018/10/23/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E5%85%83%E5%AD%97%E7%AC%A6/">正则元字符</a></p>
<ul>
<li><p>普通字符</p>
<p>普通字符包括没有显式指定为元字符的所有可打印和不可打印字符，这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号</p>
</li>
<li><p>非打印字符               </p>
</li>
<li><p>特殊字符</p>
<p>所谓特殊字符，就是一些有特殊含义的字，许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\ 放在它们前面。下表列出了正则表达式中的特殊字符：</p>
</li>
<li><p>限定符</p>
<p>限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。正则表达式的限定符有：</p>
</li>
<li><p>定位符</p>
<p>定位符使能够将正则表达式固定到行首或行尾。它们还能创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。                                </p>
</li>
</ul>
<p><strong>注意</strong>：不能将限定符与定位符一起使用。由于在紧靠换行或者单词边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。</p>
<p>参考资料</p>
<p><a href="http://www.runoob.com/regexp/regexp-syntax.html">http://www.runoob.com/regexp/regexp-syntax.html</a></p>
<p><a href="http://dengchengchao.com/archives/134">http://dengchengchao.com/archives/134</a></p>
]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>正则的进阶</title>
    <url>/2018/10/26/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h2 id="正则的进阶"><a href="#正则的进阶" class="headerlink" title="正则的进阶"></a>正则的进阶</h2><ul>
<li>正则表达式引擎</li>
<li>正则中部分概念</li>
<li>断言（环视）区别举例</li>
</ul>
<span id="more"></span>

<h4 id="正则表达式引擎"><a href="#正则表达式引擎" class="headerlink" title="正则表达式引擎"></a>正则表达式引擎</h4><p>正则引擎大致分为两类：<code>DFA</code>和<code>NFA</code>,而<code>NFA</code>又基本上可以分为<code>传统型NFA</code>和<code>POSIX NFA</code></p>
<ul>
<li><p><code>DFA Deterministic finite automaton</code> 确定型有穷自动机</p>
<ul>
<li><code>DFA</code>引擎因为不需要回溯，所以匹配快速，但不支持捕获组，所以也就不支持反向引用和<code>$number</code>这种引用方式</li>
</ul>
</li>
<li><p><code>NFA Non-deterministic finite automaton</code>　非确定型有穷自动机</p>
<ul>
<li><p><code>POSIX NFA</code></p>
<ul>
<li><code>POSIX NFA</code>主要指符合<code>POSIX</code>标准的<code>NFA</code>引擎，它的特点主要是提供<code>longest-leftmost</code>匹配，也就是在找到最左侧最长匹配之前，它将继续回溯。同<code>DFA</code>一样，非贪婪模式或者说忽略优先量词对于<code>POSIX NFA</code>同样是没有意义的。</li>
</ul>
</li>
<li><p><code>Traditional NFA</code></p>
<ul>
<li><p>大多数语言和工具使用的是传统型的NFA引擎，它有一些<code>DFA</code>不支持的特性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">捕获组、反向引用和$number引用方式；</span><br><span class="line">环视(Lookaround，(?&lt;&#x3D;…)、(?&lt;!…)、(?&#x3D;…)、(?!…))，或者有的有文章叫做预搜索；</span><br><span class="line">忽略优化量词（??、*?、+?、&#123;m,n&#125;?、&#123;m,&#125;?），或者有的文章叫做非贪婪模式；</span><br><span class="line">占有优先量词（?+、*+、++、&#123;m,n&#125;+、&#123;m,&#125;+，目前仅Java和PCRE支持），固化分组(?&gt;…)。</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="正则中部分概念"><a href="#正则中部分概念" class="headerlink" title="正则中部分概念"></a>正则中部分概念</h4><p><strong>贪婪</strong>：默认情况下，* 、?、+ 和 {min,max} 是贪婪的，因为它们消耗到<em>最后一个</em>能满足整个模式的可能的所有字符。要让它们停在 <em>首个</em> 可能的字符, 请在它们后面加上问号. 例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">贪婪： 模式 &lt;.+&gt; (其中没有问号) 表示: &quot;搜索一个 &lt;, 接着一个或多个任意字符, 然后是一个 &gt;&quot;</span><br><span class="line"> 要在匹配 整个字符串 &lt;em&gt;text&lt;&#x2F;em &gt;时停止,</span><br><span class="line">非贪婪： 请在加号后加上问号: &lt;.+?&gt;. 这样会让匹配在第一个 &#39;&gt;&#39; 处停止, 因此它只匹配第一个标签 &lt;em&gt;</span><br></pre></td></tr></table></figure>

<p><strong>回溯</strong> ：NFA引擎的正则表达式会依次处理各个子表达式或者组成元素，遇到需要在两个都可能进行成功匹配的子表达式或者组成元素之间进行选择的时候，会首先选择其一，同时会记录另一个的状态，以备后面使用。<br>注意:这里所说的子表达式并非只有用小括号括起来的表达式，而是正则表达式中的任意匹配单元。</p>
<p>需要回溯的情况：无论是哪一种选择，如果本身匹配成功，而且正则表达式余下的部分也能够成功匹配的话，那么整个匹配就成功了，如果正则表达式当前选择或者后面的部分无法匹配成功，那么正则表达式引擎会回溯到之前作出选择的地方，然后选择其他备用的分支继续匹配。</p>
<p><strong>预测和回顾断言</strong>：这组 (?=…)、(?!…)、(?&lt;=…) 和 (?&lt;!…) 被称为<em>断言</em>，因为它们要求符合某个条件但不消耗任何字符。</p>
<p>例如, </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abc(?&#x3D;.*xyz) 中含有预测断言, 它要求在字符串 abc 右边的某个位置存在字符串 xyz (如果不存在, 则匹配失败).</span><br></pre></td></tr></table></figure>

<ul>
<li>(?=…) 被称为 正预测断言, 因为它要求指定的模式存在. </li>
<li>相反地, (?!…) 是 负预测断言, 因为它要求指定的模式 不存在. </li>
<li>同样地, (?&lt;=…) 和 (?&lt;!…) 分别是正的和负的 回顾 断言, 因为它们检查当前位置的 左边 而不是右边. </li>
</ul>
<p>回顾比预测受到更多的限制, 因为它们不支持可变大小的限定符, 例如 *, ? 和 +. 转义序列 \K 类似于回顾断言, 因为它会让前一个匹配的字符在最后的匹配字符串中省略. 例如, foo\Kbar 可以匹配 “foobar” 但报告匹配的结果为 “bar”.</p>
<h4 id="具体举例"><a href="#具体举例" class="headerlink" title="具体举例"></a>具体举例</h4><p>(?:pattern)与(?=pattern)的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(pattern) ： 匹配 pattern 并获取这一匹配，所获取的匹配可以从产生的 Matches 集合得到。 </span><br><span class="line">(?:pattern) ：匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。 </span><br><span class="line">(?&#x3D;pattern) ：正向预查，在任何匹配 pattern 的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。</span><br></pre></td></tr></table></figure>

<p>共同点： <code>(?:pattern)</code> 与 <code>(?=pattern)</code>都匹配pattern，但不会把pattern结果放到Matches的集合中。</p>
<p>区别：</p>
<ul>
<li><p><code>(?:pattern)</code> 匹配得到的结果包含pattern，<code>(?=pattern)</code> 则不包含。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对字符串：&quot;industry abc&quot;的匹配结果：</span><br><span class="line">industr(?:y|ies) ---&gt; &quot;industry&quot;</span><br><span class="line">industr(?&#x3D;y|ies) ---&gt; &quot;industr&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>是否消耗字符 </p>
<p><code>(?:pattern)</code> 消耗字符，下一字符匹配会从已匹配后的位置开始。<br><code>(?=pattern)</code> 不消耗字符，下一字符匹配会从预查之前的位置开始。<br>即后者只预查，不移动匹配指针。如：</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%AD%A3%E5%88%99/%E6%AD%A3%E5%88%99%E4%B8%AD%E6%96%AD%E8%A8%80%E5%8C%B9%E9%85%8D%E7%A4%BA%E4%BE%8B.png" alt="正则中断言的匹配示例"></p>
<p>参考资料</p>
<p><a href="https://blog.csdn.net/lxcnn/article/details/4304651">https://blog.csdn.net/lxcnn/article/details/4304651</a></p>
<p><a href="https://blog.csdn.net/shashagcsdn/article/details/80017678">https://blog.csdn.net/shashagcsdn/article/details/80017678</a></p>
<p><a href="https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm">https://ahkcn.github.io/docs/misc/RegEx-QuickRef.htm</a></p>
<p><a href="https://www.cnblogs.com/h5monkey/p/5902137.html">https://www.cnblogs.com/h5monkey/p/5902137.html</a></p>
]]></content>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建</title>
    <url>/2018/08/01/%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<p>2018.08.01</p>
<p>搭建此博客。</p>
<p>参考：<a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html</a></p>
]]></content>
      <tags>
        <tag>博客记录</tag>
      </tags>
  </entry>
  <entry>
    <title>博客记录</title>
    <url>/2018/10/26/%E8%AE%B0%E5%BD%95/%E5%8D%9A%E5%AE%A2%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>2018.10.26 更换博客主题：</p>
<p><code>yilia</code>  —换为—&gt; <code>indigo</code></p>
<p><code>indigo</code>主题的 <code> git</code>地址：<a href="https://github.com/yscoder">https://github.com/yscoder</a></p>
<p>更换主题后：标签和分类也无效，后 解决。参照：<a href="https://my.oschina.net/liuyuantao/blog/845364">https://my.oschina.net/liuyuantao/blog/845364</a></p>
<p>主题中其他配置也可参照这篇文章</p>
<p>2018.12.13 在一次更换博客主题：</p>
<p><code>indigo</code>  —换为—&gt; <code>maupassant</code></p>
<p><code>maupassant</code>主题的 <code> git</code>地址：<a href="https://github.com/tufu9441/maupassant-hexo/">https://github.com/tufu9441/maupassant-hexo/</a></p>
<p>更换主题后：因为使用的样式问题，导致访问报错。参照：<a href="https://www.haomwei.com/technology/maupassant-hexo.html">https://www.haomwei.com/technology/maupassant-hexo.html</a></p>
<p>主题中其他配置也可参照这篇文章</p>
<p><a href="https://www.jianshu.com/p/bcdbe7347c8d%EF%BC%9A%E8%BF%99%E4%B8%AA%E6%96%87%E7%AB%A0%E4%B8%AD%E6%8E%A8%E8%8D%90%E4%BA%86%E4%B8%80%E4%BA%9B%E4%B8%BB%E9%A2%98">https://www.jianshu.com/p/bcdbe7347c8d：这个文章中推荐了一些主题</a></p>
<p>2020.11.19 更换主题<br><code>maupassant</code> 换为 <code>next</code><br>windows上的主题(maupassant)在mac上提交报错，所以更换主题next；<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a><br>next内部具体设置参照：<br>    <a href="https://www.cnblogs.com/syd192/p/6074323.html">https://www.cnblogs.com/syd192/p/6074323.html</a><br>    <a href="https://www.jianshu.com/p/3a05351a37dc">https://www.jianshu.com/p/3a05351a37dc</a><br>    <a href="http://theme-next.iissnan.com/theme-settings.html">http://theme-next.iissnan.com/theme-settings.html</a><br>next中使用的图标地址：<a href="https://fontawesome.com/icons?from=io">https://fontawesome.com/icons?from=io</a></p>
]]></content>
      <tags>
        <tag>博客记录</tag>
      </tags>
  </entry>
  <entry>
    <title>Cron表达式</title>
    <url>/2021/05/12/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<p>Cron表达式是一个具有时间含义的字符串</p>
<span id="more"></span>

<p>cron表达式是一个字符串，字符串以5或6个空格隔开，分开共6或7个域，每一个域代表一个含义。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">X X X X X X</span><br><span class="line">[秒] [分] [小时] [日] [月] [周] [年]</span><br><span class="line"></span><br><span class="line">注：[年]不是必须的域，可以省略[年]，则一共6个域</span><br></pre></td></tr></table></figure>

<h4 id="域取值"><a href="#域取值" class="headerlink" title="域取值"></a>域取值</h4><p>单个域有多个取值时，使用半角逗号<code>,</code>隔开取值。每个域可以是确定的取值，也可以是具有逻辑意义的特殊字符。</p>
<table>
<thead>
<tr>
<th>域</th>
<th>是否必需</th>
<th>支持的取值范围</th>
<th>支持的特殊字符</th>
</tr>
</thead>
<tbody><tr>
<td>秒</td>
<td>是</td>
<td>[0, 59]</td>
<td>* , - /</td>
</tr>
<tr>
<td>分</td>
<td>是</td>
<td>[0, 59]</td>
<td>* , - /</td>
</tr>
<tr>
<td>时</td>
<td>是</td>
<td>[0, 23]</td>
<td>* , - /</td>
</tr>
<tr>
<td>日</td>
<td>是</td>
<td>[1, 31]</td>
<td>* , - / ? L W</td>
</tr>
<tr>
<td>月</td>
<td>是</td>
<td>[1, 12]或[JAN, DEC]</td>
<td>* , - /</td>
</tr>
<tr>
<td>周</td>
<td>是</td>
<td>[1, 7]或[MON, SUN]。若您使用[1, 7]表达方式，<code>1</code>代表星期一，<code>7</code>代表星期日</td>
<td>* , - / ? L #</td>
</tr>
<tr>
<td>年</td>
<td>否</td>
<td>[1970-2099]</td>
<td>* , - /</td>
</tr>
</tbody></table>
<h4 id="特殊字符说明"><a href="#特殊字符说明" class="headerlink" title="特殊字符说明"></a>特殊字符说明</h4><p>Cron表达式中的每个域都支持一定数量的特殊字符，每个特殊字符有其特殊含义。</p>
<table>
<thead>
<tr>
<th>特殊字符</th>
<th>含义</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>*</td>
<td>所有可能的值。</td>
<td>在月域中，<code>*</code>表示每个月；在星期域中，<code>*</code>表示星期的每一天。</td>
</tr>
<tr>
<td>,</td>
<td>列出枚举值。</td>
<td>在分钟域中，<code>5,20</code>表示分别在5分钟和20分钟触发一次。</td>
</tr>
<tr>
<td>-</td>
<td>范围。</td>
<td>在分钟域中，<code>5-20</code>表示从5分钟到20分钟之间每隔一分钟触发一次。</td>
</tr>
<tr>
<td>/</td>
<td>指定数值的增量。</td>
<td>在分钟域中，<code>0/15</code>表示从第0分钟开始，每15分钟。在分钟域中<code>3/20</code>表示从第3分钟开始，每20分钟。</td>
</tr>
<tr>
<td>?</td>
<td>不指定值，仅日期和星期域支持该字符。</td>
<td>当日期或星期域其中之一被指定了值以后，为了避免冲突，需要将另一个域的值设为<code>?</code>。</td>
</tr>
<tr>
<td>L</td>
<td>单词Last的首字母，表示最后一天，仅日期和星期域支持该字符。 注：指定<code>L</code>字符时，避免指定列表或者范围，否则，会导致逻辑问题。</td>
<td>在日期域中，<code>L</code>表示某个月的最后一天。在星期域中，<code>L</code>表示一个星期的最后一天，也就是星期日（<code>SUN</code>）。如果在<code>L</code>前有具体的内容，例如，在星期域中的<code>6L</code>表示这个月的最后一个星期六。</td>
</tr>
<tr>
<td>W</td>
<td>除周末以外的有效工作日，在离指定日期的最近的有效工作日触发事件。<code>W</code>字符寻找最近有效工作日时不会跨过当前月份，连用字符<code>LW</code>时表示为指定月份的最后一个工作日。</td>
<td>在日期域中<code>5W</code>，如果5日是星期六，则将在最近的工作日星期五，即4日触发。如果5日是星期天，则将在最近的工作日星期一，即6日触发；如果5日在星期一到星期五中的一天，则就在5日触发</td>
</tr>
<tr>
<td>#</td>
<td>确定每个月第几个星期几，仅星期域支持该字符。</td>
<td>在星期域中，<code>4#2</code>表示某月的第二个星期四。</td>
</tr>
</tbody></table>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>每隔5秒执行一次：*/5 * * * * ?</li>
<li>每隔1分钟执行一次：0 */1 * * * ?</li>
<li>每天23点执行一次：0 0 23 * * ?</li>
<li>每天凌晨1点执行一次：0 0 1 * * ?</li>
<li>每月1号凌晨1点执行一次：0 0 1 1 * ?</li>
<li>每月最后一天23点执行一次：0 0 23 L * ?</li>
<li>每月第三个星期六上午10:15执行一次：0 15 10 ? * 6#3</li>
<li>每周星期六凌晨1点实行一次：0 0 1 ? * L</li>
<li>在26分、29分、33分执行一次：0 26,29,33 * * * ?</li>
<li>每天的0点、13点、18点、21点都执行一次：0 0 0,13,18,21 * * ?</li>
<li>每年3月的每个星期三下午14:10和14:44执行一次：0 10,44 14 ? 3 WED</li>
</ul>
<p>参考资料</p>
<p><a href="https://help.aliyun.com/document_detail/64769.html">Cron表达式</a></p>
<p><a href="https://blog.csdn.net/weixin_39997300/article/details/110724611">java定时器</a></p>
]]></content>
      <categories>
        <category>通用技术</category>
      </categories>
      <tags>
        <tag>Cron</tag>
      </tags>
  </entry>
  <entry>
    <title>设计原则</title>
    <url>/2018/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>设计模式：</p>
<ul>
<li>某类特定问题的代码设计解决方案</li>
<li>是一套代码设计的经验总结</li>
</ul>
<p>设计模式的设计原则：</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99.png" alt="设计原则"></p>
<p>原则介绍：</p>
<ul>
<li><p><strong>单一职责原则  SRP</strong>  (Single Responsibility Principle)</p>
<p>  一个类只做一件事 即：一个类=只有一个引起它变化的原因。</p>
<blockquote>
<p>如果一个类承担的职责过多，即耦合性太高=一个职责的变化可能会影响到其他的职责</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>开放封闭原则  OCP</strong> (Open Close Principle)</p>
<p>软件实体（类、模块、函数）可以拓展，但是不可修改</p>
<blockquote>
<ol>
<li>即每次发生变化时，要通过添加新的代码来增强现有类型的行为，而不是修改原有的代码。</li>
<li>符合开放封闭原则的最好方式是提供一个固有的接口，然后让所有可能发生变化的类实现该接口，让固定的接口与相关对象进行交互。</li>
</ol>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>里氏代替原则  LSP</strong>  (Liskov Substitution Principle)</p>
<p>子类型必须能够替换掉它们的父类型</p>
<blockquote>
<ol>
<li>在软件开发过程中，子类替换父类后，程序的行为是一样的。</li>
<li>只有当子类替换掉父类后软件的功能不受影响时，父类才能真正地被复用，而子类也可以在父类的基础上添加新的行为。</li>
</ol>
<p>细化一些就是：</p>
<p>（1）子类的能力必须大于等于父类，即父类可以使用的方法，子类都可以使用。</p>
<p>（2）返回值也是同样的道理。假设一个父类方法返回一个List，子类返回一个ArrayList，这当然可以。如果父类方法返回一个ArrayList，子类返回一个List，就说不通了。这里子类返回值的能力是比父类小的。</p>
<p>（3）还有抛出异常的情况。任何子类方法可以声明抛出父类方法声明异常的子类。而不能声明抛出父类没有声明的异常。</p>
</blockquote>
<blockquote>
<p>这个个人看的时候就有疑问，这个在java中不是已经被编译器限制好了么，你要继承这个基类,在子类中就已经存在这个基类的所有除private的方法，自然是可以替换掉子类的，这是面向对象语言实现多态的关键（这个这个原则也是面向对象语言所必须遵守的）</p>
<p>可以这样理解：例如鸵鸟属于鸟类（在现实世界中），但是程序设计中鸟类都会飞，那么鸵鸟不能对鸟类进行里氏替换原则，即使鸵鸟继承了鸟类也不符合里氏替换原则，因为鸵鸟不会飞（多态时不会关注具体某一子类，而是面向基类）。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>依赖倒置原则  DIP</strong> (Dependence Inversion Principle)</p>
<p>A.高层模块不应该依赖底层，两个都应该依赖抽。</p>
<p>B.抽象不应该依赖细节，细节应该依赖抽象</p>
<blockquote>
<p>是开闭原则的基础，面向接口编程，依赖于抽象而不依赖于具体。</p>
<p>所谓的的 “面向接口编程，而不是面向实现编程”。这样可以降低客户与具体实现的耦合。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>接口隔离原则  ISP</strong>  (Interface Segregation Principle)</p>
<p>使用多个专门功能的接口，而不是使用单一的总接口。</p>
<blockquote>
<p>不要让一个单一的接口承担过多的职责，而应把每个职责分离到多个专门的接口中，进行接口分离。</p>
<p>使用多个隔离的接口，比使用单个接口要好。降低依赖，降低耦合。</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>合成复用原则  CRP</strong>  (Composite Reuse Principle)</p>
<p>合成复用原则又称为组合/聚合复用原则(Composition/Aggregate Reuse Principle, CARP)</p>
<p>尽量使用合成/聚合，尽量不要使用类继承</p>
<blockquote>
<p>组合/聚合可以使系统更加灵活,降低类与类之间的耦合度,一个类的变化对其他类造成的影响相对较少</p>
</blockquote>
</li>
</ul>
<ul>
<li><p><strong>最小知道原则（迪米特法则）LoD</strong>  (Law Of Demeter)</p>
<p>一个模块或对象应尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立，这样当一个模块修改时，影响的模块就会越少，扩展起来更加容易。</p>
<blockquote>
<ol>
<li>关于迪米特法则的其他描述：只与你直接的朋友们通信；不要跟“陌生人”说话。</li>
<li>外观模式（Facade Pattern)和中介者模式（Mediator Pattern）就使用了迪米特法则。</li>
</ol>
</blockquote>
</li>
</ul>
<p>参考资料</p>
<p>《大话设计模式》</p>
<p><a href="https://www.jianshu.com/p/6e5eda3a51af">https://www.jianshu.com/p/6e5eda3a51af</a></p>
<p><a href="http://www.importnew.com/18390.html">http://www.importnew.com/18390.html</a></p>
<p><a href="https://www.cnblogs.com/shuigu/p/6908520.html">https://www.cnblogs.com/shuigu/p/6908520.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式总结</title>
    <url>/2019/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h3 id="设计模式总结"><a href="#设计模式总结" class="headerlink" title="设计模式总结"></a>设计模式总结</h3><h4 id="什么是设计模式："><a href="#什么是设计模式：" class="headerlink" title="什么是设计模式："></a>什么是设计模式：</h4><ul>
<li>某类特定问题的代码设计解决方案</li>
<li>是一套代码设计的经验总结<span id="more"></span>

</li>
</ul>
<h4 id="设计模式的作用"><a href="#设计模式的作用" class="headerlink" title="设计模式的作用"></a>设计模式的作用</h4><ul>
<li>提高代码的复用率，降低开发成本和周期</li>
<li>提高代码的可维护性、可扩展性</li>
<li>使代码更优雅</li>
<li>让代码更容易被他人理解</li>
</ul>
<p>为什么会有设计模式：因为我们想要编写出可扩展、可复用、灵活、易维护的代码</p>
<h4 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h4><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%88%86%E7%B1%BB.jpg" alt="设计模式图片"></p>
<h4 id="正确的使用设计模式"><a href="#正确的使用设计模式" class="headerlink" title="正确的使用设计模式"></a>正确的使用设计模式</h4><ul>
<li><p>需求驱动</p>
<p>设计模式针对软件设计，软件设计针对需求，所以不要为了使用设计模式而使用设计模式，在不合适的场景生搬硬套的使用只会让设计更复杂，软件更难调试和维护</p>
</li>
<li><p>分析成功的模式应用</p>
<p>对现有的应用实例进行分析和学习，不只是学习设计模式如何实现，更重要是在何种场合使用的设计模式</p>
</li>
<li><p>在编程中领悟模式</p>
<p>多思考、多实践、灵活应用</p>
</li>
<li><p>避免过度设计</p>
<p>设计模式是为了让设计简单而不是更复杂，针对一个需求有稳定部分有可变部分，需要判断可能发生变化的程度来确定设计策略和设计风险，过度设计和设计不足同样对项目有害</p>
</li>
</ul>
<p>引用《设计模式解析》书中的一句话：设计模式体现的是一种思想，而思想是指导行为的一切，理解和掌握了设计模式，并不是说记住了23种（或更多）设计场景和解决策略（实际上这也是很重要的一笔财富），实际上接受的是一种思想的熏陶和洗礼，等这种思想融入到了你的思想中后，你就会不自觉的使用这种思想去进行你的设计和开发，这才是最重要的</p>
<p><a href="http://zhangyuying.cn/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式详细信息</a></p>
<p>参考资料</p>
<p><a href="https://www.jianshu.com/p/6e5eda3a51af">https://www.jianshu.com/p/6e5eda3a51af</a></p>
<p><a href="https://blog.csdn.net/YANG_Gang2017/article/details/78690267">https://blog.csdn.net/YANG_Gang2017/article/details/78690267</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>RESTful</title>
    <url>/2019/05/14/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/RESTful/</url>
    <content><![CDATA[<ul>
<li><p><strong>RESTful</strong>：REST(Representational state transfer)，表述性状态转移，是Roy Fielding在2000年提出的一种架构<strong>风格</strong>、设计<strong>风格</strong>。</p>
<p>它主要用于客户端和服务器交互类的软件。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>满足REST**<a href="#REST%E7%9A%84%E7%BA%A6%E6%9D%9F%E6%9D%A1%E4%BB%B6">约束条件</a>**和原则的应用程序或设计就是 RESTful。</p>
<span id="more"></span>


</li>
</ul>
<ul>
<li><p><strong>HATEOAS</strong> : 全称是Hypertext As The Engine Of Application State，是REST架构的一种约束，通过在返回值中带有操作资源的链接信息，进一步将客户端和服务器解耦。</p>
<blockquote>
<p>中文翻译为“将超媒体格式作为应用状态的引擎”，核心思想就是每个资源都有它的状态，不同状态下，可对它进行的操作不一样。理解了这一层，再来看看REST的全称，Representational State Transfer，中文翻译为“表述性状态转移”，是不是好理解多了？</p>
</blockquote>
</li>
<li><p><strong>Richardson成熟度模型</strong> : 根据REST的约束对API进行评级的一种方法，分为四级（Level0到Level3）</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/RESTful/RichardsonMaturityModel.jpg" alt="RichardsonMaturityModel"></p>
<ul>
<li>Level 0 : 仅将HTTP（或其它协议）当成传输方式，实际上只是RPC的一种方式，没有资源的概念。</li>
<li>Level 1 : 引入了<strong>资源</strong>的概念，不过通常只用到GET或POST，而且可能将二者等价使用。</li>
<li>Level 2 : 使用HTTP的方法（POST , DELETE , PUT , GET）来代表资源的增删改查，并使用HTTP状态码来代表不同的结果。</li>
<li>Level 3 : 使用HATEOAS方式，在资源的返回值中包含操作资源的链接信息。</li>
</ul>
<p><strong>这个模型并不是一种规范，只是用来理解Restful的工具</strong></p>
</li>
</ul>
<h4 id="REST的约束条件"><a href="#REST的约束条件" class="headerlink" title="REST的约束条件"></a>REST的约束条件</h4><p>REST架构风格最重要的架构约束有6个：</p>
<ul>
<li><p>客户端-服务器（Client-Server）</p>
<p>客户端-服务器结构约束的目的是将客户端和服务器端的关注点分离. 将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来有助于提高用户界面的跨平台的可移植性.通过简化服务器模块也有助于服务器模块的可扩展性.</p>
</li>
</ul>
<ul>
<li><p>无状态（Stateless）</p>
<p>服务器不能保存客户端的信息, 每一次从客户端发送的请求中, 要包含所有的必须的状态信息, 会话信息由客户端保存, 服务器端根据这些状态信息来处理请求. 服务器可以将会话状态信息传递给其他服务, 比如数据库服务, 这样可以保持一段时间的状态信息, 从而实现认证功能. 当客户端可以切换到一个新状态的时候发送请求信息. 当一个或者多个请求被发送之后, 客户端就处于一个状态变迁过程中. 每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁.</p>
</li>
</ul>
<ul>
<li><p>缓存（Cacheability）</p>
<p>如同万维网一样, 客户端和中间的通讯传递者可以将响应缓存起来. 响应必须明确的或者间接的表明本身是否可以进行缓存,这可以预防客户端在将来进行请求的时候得到陈旧的或者不恰当的数据. 管理良好的缓存机制可以 减少客户端-服务器之间的交互, 甚至完全避免客户端-服务器交互, 这进一步提了高性能和可扩展性。</p>
</li>
</ul>
<ul>
<li><p>统一接口（Uniform Interface）</p>
<p>统一接口是 RESTful 系统设计的基本出发点. 它基于资源, 简化了系统的架构, 减少了耦合性, 可以让所有模块各自独立的进行改进. 对于统一接口的四个约束是:</p>
</li>
</ul>
<ul>
<li><p>请求中包含资源的 ID (Resource identification in requests )</p>
<p>请求中包含了各种<strong>独立资源</strong>的标识, 例如, 在 Web 服务中的 URIs. 资源本身和发送给客户端的标识是独立. 例如, 服务器可以将自身的数据库信息以 HTML XML 或者 JSON 的方式发送给客户端, 但是这些可能都不是服务器的内部记录方式.</p>
</li>
<li><p>资源通过标识来操作(Resource manipulation through representations)</p>
<p>当客户端拥有一个资源的标识, 包括附带的元数据, 则它就有足够的信息来删除这个资源.</p>
</li>
<li><p>消息的自我描述性(Self-descriptive messages)</p>
<p>每一个返回消息都包含足够的信息来描述如何来处理这个信息. 例如, 媒体类型 (midia-type) 就可以确定需要什么样的分析器来分析媒体数据.</p>
</li>
<li><p>用超媒体驱动应用状态 ( Hypermedia as the engine of application state (HATEOAS))</p>
<p>同用户访问 Web 服务器的 Home 页面相似,当一个 REST 客户端访问了最初的 REST 应用的 URI 之后, REST 客户端应该可以使用服务器端提供的链接,动态的发现所有的可用的资源和可执行的操作.随着访问的进行, 服务器在响应中提供文字超链接, 以便客户端可以得到当前可用的操作. 客户端无需用确定的编码的方式记录下服务器端所提供的动态应用的结构信息.</p>
</li>
</ul>
<ul>
<li><p>分层系统（Layered System）</p>
<p>客户端一般不知道是否直接连接到了最终的服务器, 或者是路径上的中间服务器. 中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性,这样可也便于安全策略的部署.</p>
</li>
<li><p>按需代码（Code-On-Demand，可选）</p>
<p>服务器可以通过发送可执行代码给客户端的方式临时性的扩展功能或者定制功能.例如Java Applet、Flash或JavaScript。</p>
</li>
</ul>
<h3 id="RESTful最常见应用—web服务"><a href="#RESTful最常见应用—web服务" class="headerlink" title="RESTful最常见应用—web服务"></a>RESTful最常见应用—web服务</h3><p>匹配REST设计风格的Web API称为<strong>RESTful API</strong> ，它从以下三个方面资源进行定义：</p>
<ul>
<li>直观简短的资源地址：URI，比如：<code>http://example.com/resources/</code>。</li>
<li>传输的资源：Web服务接受与返回的互联网媒体类型，比如：<a href="https://zh.wikipedia.org/wiki/JSON">JSON</a>，<a href="https://zh.wikipedia.org/wiki/XML">XML</a>，<a href="https://zh.wikipedia.org/wiki/YAML">YAML</a>等。</li>
<li>对资源的操作：Web服务在该资源上所支持的一系列<a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95">请求方法</a>（比如：POST，GET，PUT或DELETE）。</li>
</ul>
<p>下表列出了在实现RESTful API时HTTP请求方法的典型用途。</p>
<table>
<thead>
<tr>
<th>资源</th>
<th>GET</th>
<th>PUT</th>
<th>POST</th>
<th>DELETE</th>
</tr>
</thead>
<tbody><tr>
<td>一组资源的URI，比如<code>https://example.com/resources/</code></td>
<td><strong>列出</strong>URI，以及该资源组中每个资源的详细信息（后者可选）。</td>
<td>使用给定的一组资源<strong>替换</strong>当前整组资源。</td>
<td>在本组资源中<strong>创建/追加</strong>一个新的资源。该操作往往返回新资源的URL。</td>
<td><strong>删除</strong>整组资源。</td>
</tr>
<tr>
<td>单个资源的URI，比如<code>https://example.com/resources/142</code></td>
<td><strong>获取</strong>指定的资源的详细信息，格式可以自选一个合适的网络媒体类型（比如：XML、JSON等）</td>
<td><strong>替换/创建</strong>指定的资源。并将其追加到相应的资源组中。</td>
<td>把指定的资源当做一个资源组，并在其下<strong>创建/追加</strong>一个新的元素，使其隶属于当前资源。</td>
<td><strong>删除</strong>指定的元素。</td>
</tr>
</tbody></table>
<p>PUT(PATCH)和DELETE方法是幂等方法。GET方法是安全方法（不会对服务器端有修改，因此当然也是幂等的）。</p>
<p>参考资料</p>
<p><a href="https://zhuanlan.zhihu.com/p/30396391">https://zhuanlan.zhihu.com/p/30396391</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2</a></p>
]]></content>
      <categories>
        <category>通用技术</category>
      </categories>
      <tags>
        <tag>RESTful</tag>
      </tags>
  </entry>
  <entry>
    <title>网络基本概念</title>
    <url>/2021/05/27/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<p>网络知识中的基本概念：IP、端口、DNS、网关</p>
<span id="more"></span>

<h3 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h3><p>IP协议的作用主要有两个，一个是为每一台计算机分配IP地址，另一个是确定哪些地址在同一个子网络。</p>
<p>IP地址共32位，IP地址范围：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">00000000.00000000.00000000.00000000  -&gt;  0.0.0.0</span><br><span class="line">11111111.11111111.11111111.11111111  -&gt;  255.255.255.255</span><br></pre></td></tr></table></figure>

<p>IP地址分类：</p>
<p>IP地址分为 A、B、C、D、E五类，后两类不对民用组织开放</p>
<table>
<thead>
<tr>
<th>类别</th>
<th>最大网络数</th>
<th>IP地址范围</th>
<th>最大主机数</th>
<th>私有IP地址范围</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>126(2^7-2)</td>
<td>1.0.0.0 – 126.255.255.255</td>
<td>2^24-2</td>
<td>10.0.0.0 – 10.255.255.255</td>
</tr>
<tr>
<td>B</td>
<td>16384(2^14)</td>
<td>128.0.0.0 – 191.255.255.255</td>
<td>2^16-2</td>
<td>172.16.0.0 – 172.31.255.255</td>
</tr>
<tr>
<td>C</td>
<td>2097152(2^21)</td>
<td>192.0.0.0 – 223.255.255.255</td>
<td>2^8-2</td>
<td>192.168.0.0 – 192.168.255.255</td>
</tr>
</tbody></table>
<ol>
<li><p>IP地址=网络号+主机号，即网段+主机 ,针对标准的子网掩码：</p>
<ul>
<li>A类IP前8位是网段，后24位是主机位（标准子网掩码：255.0.0.0）</li>
<li>B类IP前16位是网段，后16位是主机位（标准子网掩码：255.255.0.0）</li>
<li>C类IP前24位是网段，后8位是主机位（标准子网掩码：255.255.255.0）</li>
</ul>
</li>
<li><p>每个网段地址的特殊地址，</p>
<ul>
<li>第一个地址代表网络本身(网络地址)，不能分配。比如1.0.0.0</li>
<li>最后一个地址代表当前网络的广播地址，也不能分配，比如1.255.255.255</li>
</ul>
<p>因为这两类特殊地址不能分配所以每个网段的最大主机数都 -2</p>
</li>
<li><p>使用私有IP为了节约有限的IP资源，公网不能访问私有IP</p>
</li>
</ol>
<blockquote>
<p>同网段中使用二层交换机(mac地址)即可实现通信，跨网段需要使用路由器进行通信(IP)</p>
</blockquote>
<h4 id="子网掩码"><a href="#子网掩码" class="headerlink" title="子网掩码"></a>子网掩码</h4><p>IP和子网掩码不能单独使用，必须同时使用</p>
<p>子网掩码决定了IP中的网段个数和主机位个数。</p>
<p>例如</p>
<ul>
<li>A类IP的标准子网掩码：255.0.0.0</li>
<li>B类标准子网掩码：255.255.0.0，</li>
<li>C类标准子网掩码： 255.255.255.0</li>
</ul>
<p>和255匹配的IP代表不同网络，和0匹配的IP代表同一个网络中的不同主机</p>
<blockquote>
<p>子网掩码中：1必须是连续的</p>
<p>即使是B类IP，子网掩码配置成 255.255.255.0，那么也是前三段是网段，后一段是主机</p>
</blockquote>
<h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>在网络通信中IP确定了服务器的位置，但是服务器上开启了许多服务，端口的作用就是为了定位服务</p>
<p>端口共16位，端口范围:<code>0-65535</code>，<code>0-1023</code>为系统占用端口</p>
<p>常见端口号</p>
<table>
<thead>
<tr>
<th>服务/协议</th>
<th>端口号</th>
</tr>
</thead>
<tbody><tr>
<td>FTP(文本传输协议)</td>
<td>20、21</td>
</tr>
<tr>
<td>SSH(安全shell协议)</td>
<td>22</td>
</tr>
<tr>
<td>telnet(远程登录协议)</td>
<td>23(因为明文传输，一般禁止开启)</td>
</tr>
<tr>
<td>DNS(域名系统)</td>
<td>53</td>
</tr>
<tr>
<td>http(超文本传输协议)</td>
<td>80</td>
</tr>
<tr>
<td>SMTP(简单邮件传输协议)</td>
<td>25</td>
</tr>
<tr>
<td>POP3(邮局协议3代)</td>
<td>110</td>
</tr>
</tbody></table>
<p>查看本机启用的端口号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">netstat -an</span><br></pre></td></tr></table></figure>

<ul>
<li><code>-a</code> 查看所有连接和监听端口</li>
<li><code>-n</code> 显示IP地址和端口号，而不显示域名和服务名</li>
</ul>
<h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p><code>Domain Name System</code>，域名系统，也叫做名称解析</p>
<p>DNS负责把域名翻译成IP（互相翻译）</p>
<h4 id="hosts文件"><a href="#hosts文件" class="headerlink" title="hosts文件"></a>hosts文件</h4><p>在未使用DNS之前可以使用本机的hosts文件来做静态IP和域名的对应</p>
<p>hosts文件的优先级高于DNS解析</p>
<h4 id="DNS域名解析"><a href="#DNS域名解析" class="headerlink" title="DNS域名解析"></a>DNS域名解析</h4><ol>
<li><p>域名空间结构：（域名使用.分隔，便于分级管理）</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E7%BD%91%E7%BB%9C/%E5%9F%9F%E5%90%8D%E7%A9%BA%E9%97%B4%E7%BB%93%E6%9E%84.jpeg" alt="域名空间结构"></p>
<ul>
<li>图中”.”表示根域名，根域名的服务器目前全球只有13台</li>
<li>顶级域（一级域）：ISO规定的</li>
</ul>
</li>
<li><p>DNS根据域名查询IP过程：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E7%BD%91%E7%BB%9C/DNS%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B.png" alt="DNS查询过程"></p>
<ul>
<li>DNS服务器是有本地缓存的</li>
<li>递归查询和迭代查询<ul>
<li>客户机像本地域名服务器发起的查询是递归查询（得到最后结果）</li>
<li>DNS服务器检查的查询：本地域名服务器像其他域名服务器发起的查询是迭代查询（得到结果或者最优解）</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h3><p>具有路由功能的设备，路由器就是网关设备</p>
<blockquote>
<p>路由器（Router）是连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。</p>
<p>它能够理解不同的协议，例如某个局域网使用的以太网协议，因特网使用的TCP/IP协议。这样，路由器可以分析各种不同类型网络传来的数据包的目的地址，把非TCP/IP网络的地址转换成TCP/IP地址，或者反之；再根据选定的路由算法把各数据包按最佳路线传送到指定位置。</p>
</blockquote>
<p>网关的功能：</p>
<ol>
<li><p>不同网段的信息交互</p>
<p>网关在所有内网计算机访问的不是本网段的数据报使用</p>
</li>
<li><p>内网IP和公网IP互相转换</p>
<p>网关负责将内网IP转换为公网IP,公网IP转换为内网IP</p>
</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>想实现公网网络通信，每台主机需具备四要素</p>
<ul>
<li>本机的IP地址</li>
<li>子网掩码</li>
<li>网关的IP地址</li>
<li>DNS的IP地址</li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/2019/06/28/Java/java%E9%9B%86%E5%90%88/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>ArrayList源码学习目录：</p>
<span id="more"></span>

<ul>
<li>概述</li>
<li>源码分析<ul>
<li>构造方法</li>
<li>增加</li>
<li>扩容</li>
<li>获取</li>
<li>更新</li>
<li>删除</li>
<li>其他方法</li>
</ul>
</li>
</ul>
<ul>
<li>总结</li>
</ul>
<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ArrayList 是一种变长的集合类，基于定长数组实现</p>
<p>ArrayList 是无序的</p>
<p>ArrayList 中允许空值和重复元素</p>
<p>ArrayList 不是线程安全的</p>
<p>ArrayList 继承于<code>AbstractList</code>，实现了<code>List</code>、<code>Cloneable</code>、<code>java.io.Serializable</code>、<code>RandomAccess</code> 接口。类图结构如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/ArrayList%E7%B1%BB%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="ArrayList类图结构"></p>
<h3 id="System-arraycopy"><a href="#System-arraycopy" class="headerlink" title="System.arraycopy()"></a><code>System.arraycopy()</code></h3><p>在分析ArrayList之前，有必要先了解一下<code>System.arraycopy()</code>方法。因为ArrayList里面大量的用到了这个方法</p>
<p>方法签名和参数如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span></span><br><span class="line"><span class="function">参数解释:</span></span><br><span class="line"><span class="function">	Object src : 原数组</span></span><br><span class="line"><span class="function">    <span class="keyword">int</span> srcPos : 从元数据的起始位置开始</span></span><br><span class="line"><span class="function">　　Object dest : 目标数组</span></span><br><span class="line"><span class="function">　　<span class="keyword">int</span> destPos : 目标数组的开始起始位置</span></span><br><span class="line"><span class="function">　　<span class="keyword">int</span> length  : 要copy的数组的长度</span></span><br></pre></td></tr></table></figure>

<p>关于性能：<code>System.arraycopy()</code>是高效可靠的。其性能一定是比其他复制数组的方式好得多，具体参照<a href="https://www.zhihu.com/question/53749473/answer/136701254?utm_source=wechat_session&utm_medium=social&utm_oi=761368182563807232">System.arraycopy()-R大回答</a></p>
<h3 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p>ArrayList一共有3个构造方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"><span class="comment">//空的数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"><span class="comment">//默认容量的空数组，当时这个空数组时，说明需要初始化容量，否则不初始化容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ArrayList的核心：底层维护的数组</span></span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.传入初始容量的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="comment">//传入容量为零是，将底层数组设置为空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.无参的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//无参构造器时，将底层数组设置为默认容量的空数组（在增加数据时，初始化容量）</span></span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入Collection的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">        <span class="keyword">if</span> (elementData.getClass() != Object[].class)</span><br><span class="line">          <span class="comment">//内部使用 System.arraycopy 实现</span></span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// replace with empty array.若是传入的Collection为空，则设置为空数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h4><p>ArrayList有两个增加方法</p>
<p><code>add(e)</code>：相当于直接在数组的尾部增加一个元素，步骤为：</p>
<ol>
<li>判断是否需要扩容</li>
<li>在尾部增加元素</li>
</ol>
<p><code>add(index,element)</code>：在指定的位置增加元素，步骤为：</p>
<ol>
<li>检查传入的<code>index</code>是否在正确范围内</li>
<li>判断是否需要扩容</li>
<li>在数组中移动<code>index</code>之后的数据</li>
<li>设置<code>index</code>处的元素为当前传入的元素</li>
<li><code>size</code> 加<code>1</code></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//确定ArrayList容量，对比是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">  	<span class="comment">//在数组的最后追加一个元素</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查传入index是否在0到size之间</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="comment">//确定ArrayList容量，对比是否需要扩容</span></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    <span class="comment">//向后移动数组，空出index的位置</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    <span class="comment">//将index的位置设置为当前元素</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">//将全局变量size加1</span></span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对传入index的检查</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>在上面增加元素的逻辑中，有一步是判断是否需要扩容，在此看一下具体是怎么扩容的，步骤：</p>
<ol>
<li>对比是否需要扩容</li>
<li>计算扩容时使用的新的容量<code>newCapacity</code></li>
<li>根据新的容量扩容数组</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//扩容方法，参数为最小需要的容量：在add()的时候传入的是size+1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算扩容最小需要的容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果条件为真，说明是空的构造方法，此时比较传入的需要的最小容量和默认初始化容量，取最大值</span></span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果不是空的构造方法，直接返回传入的需要的最小的容量</span></span><br><span class="line">    <span class="keyword">return</span> minCapacity;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code，最小需要的容量大于现在的数组长度进行扩容</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//具体的扩容方法</span></span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组的最大长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"><span class="comment">//具体的扩容方法(传入的是需要的最小容量)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="comment">//设置新的容量是旧的容量的1.5倍</span></span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//如果新的容量小于最小需要的容量，则设置新的容量为最小需要的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="comment">//如果新的容量大于最大的数组容量，hugeCapacity返回int的最大值作为新的容量</span></span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">//根据新的容量扩容数组</span></span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">    <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">        Integer.MAX_VALUE :</span><br><span class="line">        MAX_ARRAY_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h4><p>ArrayList里面提供了一个根据索引获取元素的方法，步骤：</p>
<ol>
<li>检查传入的索引</li>
<li>数组中取出元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断传入的索引是否超出大小</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//返回数组中对应元素</span></span><br><span class="line">    <span class="keyword">return</span> elementData(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h4><p>ArrayList中提供了一个更新方法：<code>set(index,element)</code></p>
<ol>
<li>检查传入的<code>index</code></li>
<li>得到旧的值，用于最后返回</li>
<li>设置传入的值到传入的位置</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line">    <span class="comment">//得到当前index对应的原来的值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//设置当前的值为传入的新值</span></span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    <span class="comment">//返回原来的值</span></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//检查传入的index,是否在可更新的范围内</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p>ArrayList中提供了两个删除方法</p>
<p><code>remove(o)</code>：在数组中删除传入的元素，步骤：</p>
<ol>
<li>循环查找到当前元素的索引位置</li>
<li>根据1中索引位置删除元素</li>
</ol>
<p><code>remove(index)</code>：删除指定位置的元素，步骤</p>
<ol>
<li>对传入的<code>index</code>进行检查</li>
<li>根据传入索引删除元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果传入的元素是null，则遍历数组查找是null的元素，找到位置后删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//根据索引删除元素</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//如果传入的元素不是null，则遍历数组根据equals进行比较，找到元素的位置进行删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                <span class="comment">//根据索引删除元素</span></span><br><span class="line">                fastRemove(index);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//numMove是移动的数量，最后的 -1 是因为index是从0开始计算,size是个数(1开始)，所以 -1</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//需要移动的元素个数大于0，则进行移动</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    <span class="comment">//数组移动完成后，设置最后一个元素为null</span></span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查index是否在正确的范围内</span></span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//得到当前位置原来的值</span></span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line">    <span class="comment">//计算需要移动的元素数量，同上面的fastRemove(index)方法</span></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><ul>
<li><p><code>indexOf()</code> 、<code>lastIndexOf()</code> 和<code>contains()</code>方法</p>
<p><code>indexOf(o)</code>：循环ArrayList判断其中是否包含传入元素，如果包含则返回所在位置索引，否则返回<code>-1</code>,因为存在循环所以这个方法的时间复杂度为<code>O(n-x)</code></p>
<p><code>lastIndexOf(o)</code>：和<code>indexOf(o)</code>的区别就是遍历是倒叙的</p>
<p><code>contains(o)</code>：内部调用的是<code>indexOf(o)</code>方法，即时间复杂度也为<code>O(n-x)</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexOf(o) &gt;= <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//传入的元素是null和不是null分成两个分支，都是循环判断</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>clear()</code>、<code>trimToSize() </code>和 <code>ensureCapacity()</code> 方法</p>
<p><code>clear()</code>：<code>clear</code>方法是把ArrayList里面的数组中的元素都设置为null，并设置<code>size</code>为<code>0</code>（注意此时数组的长度是不变的）</p>
<p><code>trimToSize()</code>：设置当前的数组的长度为<code>size</code>的值（即当前元素的数量）</p>
<blockquote>
<p>这个方法解决了数组长度较大，但是内部存储的数据其实较少，即此时十分浪费空间（既浪费内存），即可调用这个方法，设置数组的长度为当前的size</p>
</blockquote>
<p><code>ensureCapacity(minCapacity)</code>：确定数组的容量,即根据传入的容量对数组进行扩容</p>
<blockquote>
<p>这个方法可解决的是一直放入数据多次扩容浪费性能的问题，此时如果能确定当前ArrayList中大约需要放入多少元素，可调用此方法进行一次性扩容</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">    size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="comment">//如果size的数量小于数组的长度，则设置数组长度为size</span></span><br><span class="line">    <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">        <span class="comment">//如果size为0，则设置数组为EMPTY_ELEMENTDATA，否则按照size设置</span></span><br><span class="line">        elementData = (size == <span class="number">0</span>)</span><br><span class="line">          ? EMPTY_ELEMENTDATA</span><br><span class="line">          : Arrays.copyOf(elementData, size);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最小需要的长度，如果不是设定为空数组的话那么最小长度为默认的数组长度</span></span><br><span class="line">    <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">        <span class="comment">// any size if not default element table</span></span><br><span class="line">        ? <span class="number">0</span></span><br><span class="line">        <span class="comment">// larger than default for default empty table. It&#x27;s already</span></span><br><span class="line">        <span class="comment">// supposed to be at default size.</span></span><br><span class="line">        : DEFAULT_CAPACITY;</span><br><span class="line">    <span class="comment">//如果传入的最小容量 &gt; 最小需要扩容的容量,才调用扩容方法</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">        ensureExplicitCapacity(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>toArray()</code></p>
<p>ArrayList中包含两个toArray()方法，均是返回当前ArrayList的数组形式，区别是一个返回泛型类型，一个返回<code>Object[]</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object[] toArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> Arrays.copyOf(elementData, size);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; T[] toArray(T[] a) &#123;</span><br><span class="line">    <span class="comment">//传入数组a的长度小于size,只将ArrayList中的0--a.length范围的数据</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &lt; size)</span><br><span class="line">        <span class="comment">// Make a new array of a&#x27;s runtime type, but my contents:</span></span><br><span class="line">        <span class="keyword">return</span> (T[]) Arrays.copyOf(elementData, size, a.getClass());</span><br><span class="line">    <span class="comment">//复制ArrayList中的数组</span></span><br><span class="line">    System.arraycopy(elementData, <span class="number">0</span>, a, <span class="number">0</span>, size);</span><br><span class="line">    <span class="comment">//传入数组的长度大于size，设置返回数组的size索引对应的元素为null</span></span><br><span class="line">    <span class="keyword">if</span> (a.length &gt; size)</span><br><span class="line">        a[size] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>size()</code>和<code>isEmpty()</code> 方法</p>
<p>这两个方法都是直接使用的全局变量 <code>size </code>，<code>size</code>是ArrayList中元素的数量(注意不是ArrayList的长度)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>clone()</code> 方法</p>
<p>ArrayList中<code>clone()</code>方法内部也是调用<code>System.arraycopy()</code>方法，实现的是一层的深拷贝。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="comment">//进行拷贝数据</span></span><br><span class="line">        v.elementData = Arrays.copyOf(elementData, size);</span><br><span class="line">        v.modCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> v;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CloneNotSupportedException e) &#123;</span><br><span class="line">        <span class="comment">// this shouldn&#x27;t happen, since we are Cloneable</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>addAll()</code> 方法</p>
<p>ArrayList中有两个<code>addAll()</code>：</p>
<p><code>addAll(c)</code>：在数组的最后增加元素：先扩容，在数组最后增加</p>
<p><code>addAll(index,c)</code>：在指定的位置增加元素：检查<code>index</code>，扩容，在指定位置增加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">    <span class="comment">//在最后增加传入的集合中的元素</span></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//对传入的index进行检查</span></span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    Object[] a = c.toArray();</span><br><span class="line">    <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">    <span class="comment">//扩容</span></span><br><span class="line">    ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">    <span class="comment">//在指定位置增加元素</span></span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                         numMoved);</span><br><span class="line"></span><br><span class="line">    System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">    size += numNew;</span><br><span class="line">    <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>retainAll()</code> 和<code>removeAll()</code> 方法</p>
<p><code>removeAll</code> ：删除传入的集合中的元素</p>
<p><code>retainAll</code> ：求和传入集合的交集</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(c);</span><br><span class="line">    <span class="keyword">return</span> batchRemove(c, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">batchRemove</span><span class="params">(Collection&lt;?&gt; c, <span class="keyword">boolean</span> complement)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用这个方法的ArrayList里面的数组</span></span><br><span class="line">    <span class="keyword">final</span> Object[] elementData = <span class="keyword">this</span>.elementData;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">0</span>, w = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; r &lt; size; r++)</span><br><span class="line">            <span class="comment">//删除complement=false 求交集complement=true</span></span><br><span class="line">            <span class="keyword">if</span> (c.contains(elementData[r]) == complement)</span><br><span class="line">                elementData[w++] = elementData[r];</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//contains抛出异常的时候，会走第一个if，把从报错开始没有判断的元素增加到当前数组中</span></span><br><span class="line">        <span class="comment">// Preserve behavioral compatibility with AbstractCollection,</span></span><br><span class="line">        <span class="comment">// even if c.contains() throws.</span></span><br><span class="line">        <span class="keyword">if</span> (r != size) &#123;</span><br><span class="line">            System.arraycopy(elementData, r,</span><br><span class="line">                             elementData, w,</span><br><span class="line">                             size - r);</span><br><span class="line">            w += size - r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//元素有被删除或者有交集时w!=size，把 w--size的元素设置为null</span></span><br><span class="line">        <span class="keyword">if</span> (w != size) &#123;</span><br><span class="line">            <span class="comment">// clear to let GC do its work</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &lt; size; i++)</span><br><span class="line">                elementData[i] = <span class="keyword">null</span>;</span><br><span class="line">            modCount += size - w;</span><br><span class="line">            size = w;</span><br><span class="line">            modified = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ArrayList 是一个常用且比较基础的集合类，它的结构简单，本质上是一个变长的数组，本文就分析到这里</p>
<p>参考资料</p>
<p><a href="https://www.zhihu.com/question/53749473/answer/136701254?utm_source=wechat_session&utm_medium=social&utm_oi=761368182563807232">System.arraycopy()-R大回答</a></p>
<p><a href="http://www.tianxiaobo.com/2018/01/28/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">ArrayList源码分析-田小波的博客</a></p>
<p><a href="https://stackoverflow.com/questions/35756277/why-the-maximum-array-size-of-arraylist-is-integer-max-value-8">数组的最大长度为什么是int的最大值减8</a></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap源码分析</title>
    <url>/2019/06/20/Java/java%E9%9B%86%E5%90%88/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>HashMap的学习整体目录结构为：</p>
<span id="more"></span>

<ul>
<li>HashMap概述</li>
<li>HashMap的数据结构</li>
<li>HashMap的源码解析(基于Jdk1.8.0_171)<ul>
<li>HashMap的构造方法</li>
<li>HashMap的put方法</li>
<li>HashMap的主要参数和扩容机制</li>
<li>HashMap的get方法</li>
<li>HashMap的remove方法</li>
<li>HashMap的其他方法</li>
</ul>
</li>
<li>HashMap和多线程</li>
<li>HashMap总结</li>
</ul>
<h3 id="HashMap概述"><a href="#HashMap概述" class="headerlink" title="HashMap概述"></a>HashMap概述</h3><p>HashMap 是一个长度可动态改变的散列表，它存储的内容是键值对(key-value)映射。</p>
<p>HashMap 的key、value都可以为<code>null</code></p>
<p>HashMap 不是有序的</p>
<p>HashMap 不是线程安全的</p>
<p>HashMap 继承于<code>AbstractMap</code>，实现了<code>Map</code>、<code>Cloneable</code>、<code>java.io.Serializable</code>接口。类图结构如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/HashMap%E7%B1%BB%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="HashMap类图结构"></p>
<h3 id="HashMap的数据结构"><a href="#HashMap的数据结构" class="headerlink" title="HashMap的数据结构"></a>HashMap的数据结构</h3><p>HashMap 底层是基于散列算法实现（散列算法分为散列再探测和拉链式。HashMap 则使用了拉链式的散列算法），并在 JDK 1.8 中引入了红黑树优化过长的链表。数据结构示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/HashMap%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.jpg" alt="HashMap的数据结构"></p>
<p>拉链式的散列算法：其数据结构是由数组和链表（或树形结构）组成。在进行增删查等操作时，首先要定位到元素的所在桶的位置，之后再从链表中定位该元素。比如我们要查询上图结构中是否包含元素<code>35</code>，步骤如下：</p>
<ol>
<li>定位元素<code>35</code>所处桶的位置，<code>index = 35 % 16 = 3</code></li>
<li>在<code>3</code>号桶所指向的链表中继续查找，发现35在链表中。</li>
</ol>
<p>上面就是 HashMap 底层数据结构的原理，HashMap 基本操作就是对拉链式散列算法基本操作的一层包装。不同的地方在于 JDK 1.8 中引入了红黑树，底层数据结构由<code>数组+链表</code>变为了<code>数组+链表+红黑树</code>，不过本质并未变。</p>
<h3 id="HashMap源码分析（基于Jdk1-8-0-171）"><a href="#HashMap源码分析（基于Jdk1-8-0-171）" class="headerlink" title="HashMap源码分析（基于Jdk1.8.0_171）"></a>HashMap源码分析（基于Jdk1.8.0_171）</h3><h4 id="HashMap的构造方法"><a href="#HashMap的构造方法" class="headerlink" title="HashMap的构造方法"></a>HashMap的构造方法</h4><p>HashMap的构造方法共有四个，其中参数含义为：</p>
<ul>
<li><code>initialCapacity</code>：初始容量  ，默认为16 (1&lt;&lt;4) </li>
<li><code>loadFactor</code>：负载因子  ，默认为0.75f，一般无需传入，使用默认值即可</li>
</ul>
<p>HashMap的构造函数一般都是初始化一些重要变量，而底层数据结构则是延迟到插入键值对时在进行初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认的负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1.无参构造器，此时只设置HashMap负载因子为默认值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.传入初始容量的构造器，此时设置HashMap的初始容量和默认的负载因子，内部调用的3构造器</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.传入初始容量和负载因子的构造器，</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal initial capacity: &quot;</span> +</span><br><span class="line">                initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal load factor: &quot;</span> +</span><br><span class="line">                loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//设置阈值：为 比传入的初始容量大且最接近初始容量的 2的幂次方的整数 </span></span><br><span class="line">    <span class="comment">//后面的put()源码中会提到，在table(桶)为null的时候，初始容量会被设置为threshold的值(putVal方法中)</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//找到比给定整数大且最接近当前整数的 2的幂次方的整数（原理是2^n-1的有效比特位全是1）</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">  n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">  <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.传入Map的构造器，内部包含一个O(n)的for循环，将传入map的数据循环放入到当前的HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会先设置table的大小，这样在putVal()中就不需要在扩容了</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">putMapEntries</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s = m.size();</span><br><span class="line">    <span class="keyword">if</span> (s &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//table为null时，设置不需要在扩容的容量（设置threshold的值，在resize()会被设置为初始容量）</span></span><br><span class="line">        <span class="keyword">if</span> (table == <span class="keyword">null</span>) &#123; <span class="comment">// pre-size</span></span><br><span class="line">            <span class="keyword">float</span> ft = ((<span class="keyword">float</span>)s / loadFactor) + <span class="number">1.0F</span>;</span><br><span class="line">            <span class="keyword">int</span> t = ((ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY) ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : MAXIMUM_CAPACITY);</span><br><span class="line">            <span class="keyword">if</span> (t &gt; threshold)</span><br><span class="line">                threshold = tableSizeFor(t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//传入的数据量大于当前的阈值，进行扩容</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">       <span class="comment">//遍历传入的map，put值到当前的map中</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet()) &#123;</span><br><span class="line">            K key = e.getKey();</span><br><span class="line">            V value = e.getValue();</span><br><span class="line">            putVal(hash(key), key, value, <span class="keyword">false</span>, evict);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="HashMap的put方法"><a href="#HashMap的put方法" class="headerlink" title="HashMap的put方法"></a>HashMap的put方法</h4><p>HashMap的<code>put</code>方法中计算<code>hash</code>后便调用的<code>putVal()</code>方法，<code>putVal()</code>方法中主要做了：</p>
<ol>
<li>当桶数组 <code>table</code> 为空时，通过扩容的方式初始化 <code>table</code></li>
<li>查找要插入的键值对是否已经存在，存在的话根据条件判断是否用新值替换旧值</li>
<li>如果不存在，则将键值对链入链表中，并根据链表长度决定是否将链表转为红黑树</li>
<li>判断键值对数量是否大于阈值，大于的话则进行扩容操作</li>
</ol>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//HashMap的增加key-value的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//hash(key):计算hash</span></span><br><span class="line">    <span class="comment">//key:传入的key</span></span><br><span class="line">    <span class="comment">//value:传入的value</span></span><br><span class="line">    <span class="comment">//onlyIfAbsent：如果为真，则不要更改现有值，在put方法中为false，即传入的value会覆盖旧的value</span></span><br><span class="line">    <span class="comment">//evict:为了LinkedHashMap类服务的方法中需要,但是此方法在HashMap中是空实现</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tab: 指向table的引用</span></span><br><span class="line">    <span class="comment">// p: 当前的key在桶中对应的节点 </span></span><br><span class="line">    <span class="comment">// n：桶数组的长度</span></span><br><span class="line">    <span class="comment">// i: 当前的key在桶数组中的下标</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">    <span class="comment">//table为null或者长度为0的时候，初始化桶数组 table，table 被延迟到插入新数据时再进行初始化</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">        <span class="comment">//resize(),扩容方法，返回的是一个桶数组</span></span><br><span class="line">        n = (tab = resize()).length;</span><br><span class="line">    <span class="comment">//如果桶中不包含键值对节点引用，则将新键值对节点的引用存入桶中即可</span></span><br><span class="line">    <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">        tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//进入此分支说明，出现了hash碰撞</span></span><br><span class="line">      	<span class="comment">//e:当前key在桶中对应的节点引用</span></span><br><span class="line">      	<span class="comment">//k:当前的key在桶中对应的节点的key</span></span><br><span class="line">        Node&lt;K,V&gt; e; K k;</span><br><span class="line">        <span class="comment">//桶中已有值，且链表中的第一个节点的hash和key和传入的hash和key相同</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            e = p;</span><br><span class="line">        <span class="comment">//如果原来是TreeNode节点，则继续在红黑树上增加</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="comment">//若是树上已有和传入key相同的节点，怎返回节点，否则新增之后，返回null</span></span><br><span class="line">            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//如果原来是Node节点，循环现在已有的链表，增加一个节点，过长时树化</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                      <span class="comment">//当链表的程度大于等于8的时候，树化</span></span><br><span class="line">                        treeifyBin(tab, hash);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="comment">//在链表上有和传入的key一样的key的节点，表示当前链表包含要插入的键值对，则停止循环（最后更新当前节点的value）</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                p = e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果e（e是相同的key已经存在的节点）不为null（说明不是新增节点，是已有节点）,</span></span><br><span class="line">        <span class="comment">//则判断是否使用传入的value覆盖旧的value（put方法传入的参数导致是默认覆盖的）</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">            V oldValue = e.value;</span><br><span class="line">            <span class="comment">//onlyIfAbsent true:不更改现有值,false:更改现有值，覆盖原来的值</span></span><br><span class="line">            <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                e.value = value;</span><br><span class="line">            <span class="comment">//为了LinkedHashMap类服务的方法,在HashMap中是空实现</span></span><br><span class="line">            afterNodeAccess(e);</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保证迭代的同时HashMap没有被修改，否则会抛出异常： throw new ConcurrentModificationException();</span></span><br><span class="line">    ++modCount;</span><br><span class="line">    <span class="comment">//增加了一个键值对之后，size+1如果大于阈值，说明下次增加时要扩容，所以在此处直接扩容，省去上面的繁琐判断</span></span><br><span class="line">    <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">        resize();</span><br><span class="line">    <span class="comment">//为了LinkedHashMap类服务的方法,在HashMap中是空实现</span></span><br><span class="line">    afterNodeInsertion(evict);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//hash值的计算</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//链表树化的阈值</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>确定桶位置：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tab[i = (n - <span class="number">1</span>) &amp; hash]</span><br></pre></td></tr></table></figure>

<p>这里通过<code>(n - 1)&amp; hash</code>即可算出桶的在桶数组中的位置，</p>
<p>HashMap 中桶数组的大小 <code>length</code> 总是2的幂，那么<code>length-1</code>换算成二进制的话肯定所有位都为1，所以，<code>(n - 1) &amp; hash</code> 从数值上来讲等价于对 <code>length</code> 取余(<code>hash%length</code>)。但取余的计算效率没有位运算高，所以<code>(n - 1) &amp; hash</code> 是一个速度的优化。</p>
</li>
<li><p>hash的计算</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hash使用如上方法计算有两个好处：</p>
<p>(1).上面求余的计算中，计算余数时，由于 n 比较小，hash 只有低位参与了计算，高位的计算可以认为是无效的。这样导致了计算结果只与低位信息有关，高位数据没发挥作用。为了处理这个缺陷，我们可以将 hash 高位数据与低位数据进行异或运算，即 <code>hash ^ (hash &gt;&gt; 16)</code>（在 Java 中，hashCode 方法产生的 hash 是 int 类型，32 位宽。前16位为高位，后16位为低位，所以要右移16位）。通过这种方式，让高位数据与低位数据进行异或，以此加大低位信息的随机性，变相的让高位数据参与到计算中。即：让hash均匀一些,碰撞少一些</p>
<p>(2).重新计算 hash 的另一个好处是可以增加 hash 的复杂度。当我们覆写 hashCode 方法时，可能会写出分布性不佳的 hashCode 方法，进而导致 hash 的冲突率比较高。通过移位和异或运算，可以让 hash 变得更复杂，进而影响 hash 的分布性。</p>
<p>这也就是为什么 HashMap 不直接使用键对象原始 hash 的原因了。</p>
</li>
</ol>
<h4 id="HashMap的主要参数和扩容机制"><a href="#HashMap的主要参数和扩容机制" class="headerlink" title="HashMap的主要参数和扩容机制"></a>HashMap的主要参数和扩容机制</h4><p>上面的put()方法中涉及到扩容，那么HashMap是如何进行扩容的呢？</p>
<p><strong>HashMap中扩容相关的主要参数</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table; <span class="comment">//核心的数据结构，即所谓的数组+链表+红黑树的部分。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16 //不提供有参构造时，桶数组默认的初始化容量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>; <span class="comment">//桶数组的最大容量，（2的30次方），超过这个容量将不再扩容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>; <span class="comment">//默认的负载因子值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor; <span class="comment">//负载因子</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;<span class="comment">//HashMap内键值对的个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> threshold;<span class="comment">//阈值，原因是阈值可由容量乘上负载因子计算而来（注释中有说明），即threshold = capacity * loadFactor</span></span><br><span class="line">			  <span class="comment">//size大于阈值时，进行扩容</span></span><br></pre></td></tr></table></figure>

<p>关于负载因子：</p>
<p>对于 HashMap 来说，负载因子是一个很重要的参数，该参数反应了 HashMap 桶数组的使用情况（假设键值对节点均匀分布在桶数组中）。通过调节负载因子，可使 HashMap 时间和空间复杂度上有不同的表现。</p>
<ul>
<li>当我们调低负载因子时，HashMap 所能容纳的键值对数量变少。扩容时，重新将键值对存储新的桶数组里，键与键之间产生的碰撞会下降，链表长度变短。此时，HashMap 的增删改查等操作的效率将会变高，这里是典型的拿空间换时间。</li>
<li>相反，如果增加负载因子（负载因子可以大于1），HashMap 所能容纳的键值对数量变多，空间利用率高，但碰撞率也高。这意味着链表长度变长，效率也随之降低，这种情况是拿时间换空间。至于负载因子怎么调节，这个看使用场景了。一般情况下，使用默认值就可以了。</li>
</ul>
<p><strong>HashMap的扩容</strong> ：</p>
<p>HashMap 的扩容机制与其他变长集合的套路不太一样，HashMap 按当前桶数组长度的2倍进行扩容，阈值也变为原来的2倍（如果计算过程中，阈值溢出归零，则按阈值公式重新计算）。扩容之后，要重新计算键值对的位置，并把它们移动到合适的位置上去。以上就是 HashMap 的扩容大致过程，</p>
<ol>
<li>计算新桶数组的容量 <code>newCap</code>和新阈值 <code>newThr</code></li>
<li>根据计算出的<code> newCap</code> 创建新的桶数组，桶数组 <code>table</code> 也是在这里进行初始化的</li>
<li>将键值对节点重新映射到新的桶数组里。如果节点是 <code>TreeNode</code> 类型，则需要拆分红黑树。如果是普通节点，则节点按原顺序进行分组。</li>
</ol>
<p>具体扩容的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">    Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">    <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">    <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//如果原来的table不是null</span></span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//如果原来的table容量已经是最大容量，则设置阈值为最大值后返回原来的table，不在扩容</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">            threshold = Integer.MAX_VALUE;</span><br><span class="line">            <span class="keyword">return</span> oldTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//进行扩容：容量和阈值均扩容为原来的2倍</span></span><br><span class="line">        <span class="comment">//新桶数组容量小于最大值，且旧桶数组容量大于 16</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY) <span class="comment">//若是原来的容量不大于等于16，即这个条件不满足，则不会设置newThr,则是在下面设置</span></span><br><span class="line">            <span class="comment">//该种情况下新阈值 newThr = oldThr &lt;&lt; 1，移位可能会导致溢出,若是溢出归零，则在下面设置</span></span><br><span class="line">            <span class="comment">//当 loadFactor小数位为 0，整数位可被2整除且大于等于8时，在某次计算中就可能会导致 newThr 溢出归零。</span></span><br><span class="line">            newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold  </span></span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//table是null或者没有数据，初始容量设置为阈值（传入初始容量计算阈值的构造器，最后会走这个分支）</span></span><br><span class="line">   <span class="comment">//newThr会在下边的代码中设置</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">        newCap = oldThr;</span><br><span class="line">  <span class="comment">//oldCap==0且oldThr==0，即桶数组未被初始化，oldThr==0（调用空的构造器时会走这个分支）</span></span><br><span class="line">    <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">        newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">        newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//newThr 为0时（上面未计算 newThr 或嵌套分支在计算过程中导致 newThr 溢出归零），按照阈值计算公式进行计算</span></span><br><span class="line">    <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                  (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    threshold = newThr;</span><br><span class="line">    <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">    table = newTab;</span><br><span class="line">    <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// 如果旧的桶数组不为空，则遍历桶数组，并将键值对映射到新的桶数组中</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">            Node&lt;K,V&gt; e;</span><br><span class="line">            <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                    newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">// 重新映射时，需要对红黑树进行拆分</span></span><br><span class="line">                    ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                    Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                    Node&lt;K,V&gt; next;</span><br><span class="line">                    <span class="comment">// 遍历链表，并将链表节点按原顺序进行分组</span></span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        next = e.next;</span><br><span class="line">                        <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                loHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                loTail.next = e;</span><br><span class="line">                            loTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                hiHead = e;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                hiTail.next = e;</span><br><span class="line">                            hiTail = e;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j] = loHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                        newTab[j + oldCap] = hiHead;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于重新映射节点：</p>
<ul>
<li><p>对于树形节点，需先拆分红黑树再映射。</p>
</li>
<li><p>对于链表类型节点，则需先对链表进行分组，然后再映射。需要的注意的是，分组后，组内节点相对位置保持不变。</p>
<p>(之所以可以分成两组是因为：扩容是2倍扩容，原来的元素要么在原位置，要么在原位置+原容量的位置)</p>
<p>链表分组后在映射即：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/%E9%93%BE%E8%A1%A8%E5%88%86%E7%BB%84%E5%90%8E%E5%9C%A8%E6%98%A0%E5%B0%84.png" alt="链表分组后在映射"></p>
</li>
</ul>
<p>关于扩容效率：</p>
<p>​    JDK 1.8 版本下 HashMap 扩容效率要高于之前版本。如果大家看过 JDK 1.7 的源码会发现，JDK 1.7 为了防止因 hash 碰撞引发的拒绝服务攻击，在计算 hash 过程中引入随机种子。以增强 hash 的随机性，使得键值对均匀分布在桶数组中。在扩容过程中，相关方法会根据容量判断是否需要生成新的随机种子，并重新计算所有节点的 hash。而在 JDK 1.8 中，则通过引入红黑树替代了该种方式。从而避免了多次计算 hash 的操作，提高了扩容效率。</p>
<h5 id="链表树化、红黑树拆分、链化"><a href="#链表树化、红黑树拆分、链化" class="headerlink" title="链表树化、红黑树拆分、链化"></a>链表树化、红黑树拆分、链化</h5><p>（不做深入分析，简单了解）</p>
<p>用到的常量参数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br></pre></td></tr></table></figure>

<p>在扩容的过程中，链表树化需要满足两个条件：</p>
<ol>
<li><p>链表的长度大于等于<code>TREEIFY_THRESHOLD</code></p>
</li>
<li><p>桶数组容量大于等于<code>MIN_TREEIFY_CAPACITY</code></p>
<p>当桶数组容量比较小时，键值对节点 hash 的碰撞率可能会比较高，进而导致链表长度较长。这个时候应该优先扩容，而不是立马树化。毕竟高碰撞率是因为桶数组容量较小引起的，这个是主因。容量小时，优先扩容可以避免一些列的不必要的树化过程。</p>
<p>同时，桶容量较小时，扩容会比较频繁，扩容时需要拆分红黑树并重新映射。所以在桶容量比较小的情况下，将长链表转成红黑树是一件吃力不讨好的事。</p>
</li>
</ol>
<p>红黑树拆分：</p>
<p>​    重新映射后，会将红黑树拆分成两条由 TreeNode 组成的链表。如果链表长度小于 <code>UNTREEIFY_THRESHOLD</code>，则将链表转换成普通链表。否则根据条件重新将 <code>TreeNode</code> 链表树化。</p>
<p>红黑树链化：</p>
<p>​    红黑树中仍然保留了原链表节点顺序。有了这个前提，再将红黑树转成链表就简单多了，仅需将 <code>TreeNode</code> 链表转成 <code>Node</code> 类型的链表即可。</p>
<h4 id="HashMap的get方法"><a href="#HashMap的get方法" class="headerlink" title="HashMap的get方法"></a>HashMap的get方法</h4><p>HashMap中的查找步骤：</p>
<ol>
<li>先定位键值对所在的桶的位置</li>
<li>在对链表或红黑树进行查找</li>
</ol>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="comment">//查找的节点为null，则返回null，不然返回节点的value</span></span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">    <span class="comment">//table不为null且包含数据、key对应的桶取值不为null的时候，进入分支，否则返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点就是当前查找的节点，直接返回第一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">            ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点不是当前查找的节点，开始在链表或者红黑树上查找</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果当前桶中存储的是红黑树，正在红黑树中进行查找</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果是链表，则循环查找</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                    ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">              <span class="comment">//若是上面没有rentun，直到链表的下一个节点为null时遍历终止</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<p>关于计算桶位置（<code>first = tab[(n - 1) &amp; hash]</code>）和<code>hash</code>的计算，已经在分析put方法的时候分析过，再次不在赘述。</p>
<h4 id="HashMap的remove方法"><a href="#HashMap的remove方法" class="headerlink" title="HashMap的remove方法"></a>HashMap的remove方法</h4><p>HashMap的删除操作步骤：</p>
<ol>
<li>定位桶位置</li>
<li>遍历链表并找到键值相等的节点</li>
<li>删除节点</li>
</ol>
<p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//matchValue:是否匹配value删除，remove(key)是不匹配的，即：只是根据key来删除</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">     <span class="comment">//table不为null且包含数据、key对应的桶取值不为null的时候，进入分支，否则返回null</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">       <span class="comment">//桶中第一个节点即为传入的key，则将第一个节点赋值给Node</span></span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">       <span class="comment">//桶中的第一个节点，不是传入的key，则继续在链表或红黑树中判断</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是红黑树节点，则在红黑树中查找对应的节点，没有则返回null</span></span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="comment">//如果是链表则循环链表寻找节点</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//node为上面逻辑查找到的节点，如果不为null：则不匹配value或者匹配value且value相等时，进入分支进行删除</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">           <span class="comment">//如果是红黑树节点，则在红黑树中删除</span></span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">           <span class="comment">//如果是链表的第一个节点，则将当前桶上的第一个节点直接指定为第一个的下一个（可能为null）</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">           <span class="comment">//如果是链表，且不是链表上的第一个节点，在链表上删除</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            <span class="comment">//HashMap中的键值对数量减一</span></span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：</p>
<ol>
<li><p>关于计算桶位置（<code>first = tab[(n - 1) &amp; hash]</code>）和<code>hash</code>的计算，已经在分析put方法的时候分析过，再次不在赘述。</p>
</li>
<li><p>在HashMap中还提供了一个<code>remove(Object key, Object valu)</code>的重载方法，内部同样是调用<code>removeNode()</code>方法，</p>
<p>不同的是<code>value</code>是有值的，且<code>matchValue</code>参数为<code>true</code> ，源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> removeNode(hash(key), key, value, <span class="keyword">true</span>, <span class="keyword">true</span>) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="HashMap的其他方法"><a href="#HashMap的其他方法" class="headerlink" title="HashMap的其他方法"></a>HashMap的其他方法</h4><ul>
<li><p>HashMap的遍历</p>
<p>即根据HashMap的数据结构，遍历即从上至下遍历桶数组即内部链表</p>
<p>所以即使HashMap的存储是无序的，但是每次取出元素的顺序是固定的，遍历如图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/HashMap%E9%81%8D%E5%8E%86.jpg" alt="HashMap的遍历"></p>
</li>
<li><p>HashMap的clear()方法</p>
<ol>
<li>将全局变量size设置为0</li>
<li>循环将HashMap中的节点设置为Null</li>
</ol>
<p>即HashMap的长度是不变的，只是内部元素被设置为null，源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt;[] tab;</span><br><span class="line">    modCount++;</span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tab.length; ++i)</span><br><span class="line">            tab[i] = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap的size()、isEmpty方法</p>
<p>size()：返回的是全局变量size，值的注意的是size是当前HashMap中元素的个数，而不是HashMap的长度</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>isEmpty：返回的是<code>size==0</code>，注意调用改方法时的空指针问题，确保对象不为null，才可调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap的containsKey()方法</p>
<p>和get()方法一样，调用的getNode()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getNode(hash(key), key) != <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashMap的putAll()方法</p>
<p>和传入一个Map的构造方法调用的同一个方法,可参照HashMap的构造函数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putAll</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    putMapEntries(m, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="HashMap和多线程"><a href="#HashMap和多线程" class="headerlink" title="HashMap和多线程"></a>HashMap和多线程</h3><p>HashMap是不支持多线程的，那么为什么呢？</p>
<ul>
<li><p>java 1.8之前在并发使用HashMap时可能发生死循环，导致cpu100%</p>
<p><code>HashMap</code>在resize()扩容在多线程情况下可能会生成一个<strong>死循环</strong>链表：<br>主要在于扩容时链表的重新排列。由于hash()与扩容带来的链表位置的不确定，<code>HashMap</code>为了保证性能，通过倒置排列链表的方法将原本复制一个链表需要O(n)的时间复杂度降低到了O(1)。这样带来的问题就是多线程可能会生成一个死循环链表。</p>
<p>但是这个问题已经在JDK1.8时解决：对原有造成死锁的关键原因点（新table复制在头端添加元素）改进为依次在末端添加新的元素，此时不会再产生死循环</p>
</li>
<li><p>多线程put的时候可能导致元素丢失</p>
<p>比如两个线程同时取得了同一个链表上的节点e1,并且同时增加e1.next=e2和e1.next=e3，此时便会一个成功一个丢失，造成元素的丢失</p>
</li>
</ul>
<p>由以上两点可知，JDK8中虽然解决了多线程向HashMap中增加数据的死循环问题，但是还是会有数据丢失的问题，所以说HashMap依然是不支持多线程的。</p>
<p>在多线程的情况下，有两个解决方案：</p>
<ol>
<li><p>使用<code>Collections.synchronizedMap(Map map)</code>方法，可以将HashMap变成一个同步的容器（拥有锁限制的同步机制）</p>
<p>但是性能不是很好，因为是阻塞的方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> Map&lt;String,String &gt; map = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;String, String&gt;());</span><br></pre></td></tr></table></figure>
</li>
<li><p>推荐：使用<code>concurrentHashMap</code></p>
</li>
</ol>
<h3 id="HashMap总结"><a href="#HashMap总结" class="headerlink" title="HashMap总结"></a>HashMap总结</h3><p>此篇博客对HashMap的数据结构、构造方法、增删改、扩容等操作进行了分析。但是还有很多地方没有细化，比如链表树化、红黑树链化、JDK8新增的方法等等。</p>
<p>总体来说看完源码觉得HashMap中许多的编码是非常精巧的。受益匪浅。</p>
<p>参考资料</p>
<p><a href="https://segmentfault.com/a/1190000012926722?utm_source=tag-newest#articleHeader8">HashMap源码详细分析(JDK1.8)-segmentfault</a></p>
<p><a href="https://blog.csdn.net/j1231230/article/details/78072115">indexFor分析</a></p>
<p><a href="https://tech.meituan.com/2016/06/24/java-hashmap.html">java8系列之重新认识HashMap-美团</a></p>
<p><a href="https://juejin.im/post/5a66a08d5188253dc3321da0">java 7HashMap并发的死循环问题</a></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>HashSet源码分析</title>
    <url>/2019/06/27/Java/java%E9%9B%86%E5%90%88/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>HashSet是Set接口的典型实现，实现了Set接口中的所有方法。</p>
<span id="more"></span>

<p>HashSet 是无序的。</p>
<p>HashSet 不是线程安全的。</p>
<p>HashSet 中元素值可以是null。</p>
<p>HashSet继承于<code>AbstractSet</code>，实现了<code>Set</code>, <code>Cloneable</code>,<code> java.io.Serializable</code> 接口。类图结构如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/HashSet%E7%B1%BB%E5%9B%BE%E7%BB%93%E6%9E%84.png" alt="HashSet类图结构"></p>
<h4 id="HashSet源码分析"><a href="#HashSet源码分析" class="headerlink" title="HashSet源码分析"></a>HashSet源码分析</h4><p>HashSet的底层使用的也是HashMap。即HashSet保证元素唯一不重复的方式是将元素作为HashMap的key。</p>
<p>HashSet一共有4个构造函数，也是对应HashMap的，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.空构造方法，直接调用HashMap的空构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.传入一个Collection的构造方法，直接调用HashMap传入初始容量的构造方法，然后调用addAll增加元素(O(n):内部循环了c)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(Math.max((<span class="keyword">int</span>) (c.size()/<span class="number">.75f</span>) + <span class="number">1</span>, <span class="number">16</span>));</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3.传入初始容量和负载因子的构造方法，直接调用对应的HashMap的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity, loadFactor);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4.传入初始容量的构造方法，直接调用对应HashMap的构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashSet</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    map = <span class="keyword">new</span> HashMap&lt;&gt;(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>HashSet中有一个常量<code>PRESENT</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object PRESENT = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure>

<p>使用add()方法增加元素时调用map的put方法，常量PRESENT作为value站位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.put(e, PRESENT)==<span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用iterator()方法同样是调用map中的方法,源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样HashSet的其他方法也是调用的map中的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">size()           ===》 map.size()</span><br><span class="line">isEmpty()        ===》 map.isEmpty()</span><br><span class="line">contains(Object) ===》 map.containsKey(o)</span><br><span class="line">remove(Object)   ===》 map.remove(o)==PRESENT</span><br><span class="line">clear()          ===》 map.clear()</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>List实现类介绍</title>
    <url>/2019/07/04/Java/java%E9%9B%86%E5%90%88/List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本文主要是对java中的List实现类进行简单的对比了解。基于<code>Jdk1.8.0_171</code><br>List 具有与 Collection 完全一样的接口，只是行为上不同，List 中元素可重复。List 接口对象是有序的</p>
<span id="more"></span>

<p>List实现类的框架图(List实现类大多数都直接实现了List接口(Stack除外)，图中未体现)：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/List%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="List实现类框架图"></p>
<p>List实现类简单对比：</p>
<ul>
<li><p>ArrayList</p>
<ul>
<li>有序</li>
<li>元素可重复</li>
<li>非线程安全的</li>
<li>内部基于数组</li>
<li>使用频率最高的List实现类，关于ArrayList更详细的源码分析，可以<a href="http://zhangyuying.cn/2019/06/28/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/ArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">点击查看</a></li>
</ul>
</li>
<li><p>LinkedList</p>
<ul>
<li>有序</li>
<li>元素可重复</li>
</ul>
<ul>
<li>非线程安全的</li>
<li>内部基于环形双向链表，也可作为栈、队列、双端口队列使用</li>
</ul>
</li>
<li><p>Vector</p>
<ul>
<li>功能和ArrayList差不多</li>
<li>线程安全</li>
</ul>
</li>
<li><p>Stack</p>
<ul>
<li>线程安全</li>
<li>效率低下，建议不要使用，可使用LinkedList或者Deque取代</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Set实现类介绍</title>
    <url>/2019/06/27/Java/java%E9%9B%86%E5%90%88/Set%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本文主要是对java中的Set实现类进行简单的对比了解。基于<code>Jdk1.8.0_171</code><br>Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。Set 接口存储一组唯一，无序的对象。</p>
<span id="more"></span>

<p>Set实现类的框架图(Set实现类大多数都直接实现了Set接口(treeSet、EnumSet、JumboEnumSet除外)，图中未体现)：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/Set%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Set实现类框架图"></p>
<p>Set实现类简单对比：</p>
<ul>
<li>HashSet<ul>
<li>无序</li>
<li>非线程安全的</li>
<li>内部其实是维护了一个HashMap</li>
<li>使用频率最高的Set实现类，关于HashSet更详细的源码分析，可以<a href="http://zhangyuying.cn/2019/06/27/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/HashSet%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">点击查看</a></li>
</ul>
</li>
<li>LinkedHashSet<ul>
<li>有序的Set：实现基于插入顺序排序</li>
<li>继承自HashSet，实际上是通过调用HashSet的构造LinkedHashMap的构造方法，内部维护一个LinkedHashMap</li>
</ul>
</li>
<li>TreeSet<ul>
<li>有序的Set：基于元素的自然排序</li>
<li>内部其实是维护了一个TreeMap</li>
</ul>
</li>
<li>EnumSet<ul>
<li>该类是专门针对枚举类设计的一个集合类，集合中的所有键必须是同一个枚举类的实例。</li>
<li>EnumSet的顺序，由枚举类实例的定义顺序决定。</li>
<li>不允许空键</li>
<li>线程不安全</li>
<li>EnumSet.noneOf()：内部当EnumSet的容量大于64的时候，创建的是JumboEnumSet，否则创建的是RegularEnumSet。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 Streams API</title>
    <url>/2019/11/06/Java/java8%E6%96%B0%E7%89%B9%E6%80%A7/Java8-Streams-API/</url>
    <content><![CDATA[<blockquote>
<p>建议首先阅读<a href="http://zhangyuying.cn/2019/11/06/%E6%8A%80%E6%9C%AF/java8%E6%96%B0%E7%89%B9%E6%80%A7/Java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%BD%92%E7%BA%B3/">Java 8 函数式接口归纳</a></p>
</blockquote>
<p>流式编程作为Java 8的亮点之一，是继<code>Java 5</code>之后对集合的再一次升级，可以说<code>Java 8</code>几大特性中，<code>Streams API</code> 是作为Java 函数式的主角来设计的,夸张的说，有了<code>Streams API</code>之后，万物皆可一行代码。</p>
<span id="more"></span>

<h3 id="什么是Stream"><a href="#什么是Stream" class="headerlink" title="什么是Stream"></a>什么是Stream</h3><p><code>Stream</code>被翻译为流，它的工作过程像将一瓶水导入有很多过滤阀的管道一样，水每经过一个过滤阀，便被操作一次，比如过滤，转换等，最后管道的另外一头有一个容器负责接收剩下的水。</p>
<p>示意图如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java8%E6%96%B0%E7%89%B9%E6%80%A7/stream.png" alt="stream"></p>
<p>首先通过<code>source</code>产生流，然后依次通过一些中间操作，比如过滤，转换，限制等，最后结束对流的操作。</p>
<p><code>Stream</code>也可以理解为一个更加高级的迭代器，主要的作用便是遍历其中每一个元素。</p>
<h3 id="为什么需要Stream"><a href="#为什么需要Stream" class="headerlink" title="为什么需要Stream"></a>为什么需要Stream</h3><p><code>Stream</code>作为Java 8的一大亮点，它专门针对集合的各种操作提供各种非常便利，简单，高效的API,<code>Stream API</code>主要是通过<code>Lambda</code>表达式完成，极大的提高了程序的效率和可读性，同时<code>Stram API</code>中自带的并行流使得并发处理集合的门槛再次降低，使用<code>Stream API</code>编程无需多写一行多线程的大门就可以非常方便的写出高性能的并发程序。使用<code>Stream API</code>能够使你的代码更加优雅。</p>
<p>流的另一特点是可无限性，使用<code>Stream</code>，你的数据源可以是无限大的。</p>
<p>在没有<code>Stream</code>之前，我们想提取出所有年龄大于18的学生，我们需要这样做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Student&gt; result=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(student.getAge()&gt;<span class="number">18</span>)&#123;</span><br><span class="line">        result.add(student);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br></pre></td></tr></table></figure>

<p>使用<code>Stream</code>,我们可以参照上面的流程示意图来做，首先产生<code>Stream</code>,然后<code>filter</code>过滤，最后归并到容器中。</p>
<p>转换为代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> students.stream().filter(s-&gt;s.getAge()&gt;<span class="number">18</span>).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<ul>
<li>首先<code>stream()</code>获得流</li>
<li>然后<code>filter(s-&gt;s.getAge()&gt;18)</code>过滤</li>
<li>最后<code>collect(Collectors.toList())</code>归并到容器中</li>
</ul>
<p>是不是很像在写<code>sql</code>?</p>
<h3 id="如何使用Stream"><a href="#如何使用Stream" class="headerlink" title="如何使用Stream"></a>如何使用Stream</h3><p>我们可以发现，当我们使用一个流的时候，主要包括三个步骤：</p>
<ul>
<li>获取流</li>
<li>对流进行操作</li>
<li>结束对流的操作</li>
</ul>
<h4 id="获取流"><a href="#获取流" class="headerlink" title="获取流"></a>获取流</h4><p>获取流的方式有多种，对于常见的容器(<code>Collection</code>)可以直接<code>.stream()</code>获取<br>例如：</p>
<ul>
<li><code>Collection.stream()</code></li>
<li><code>Collection.parallelStream()</code></li>
<li><code>Arrays.stream(T array) or Stream.of()</code></li>
</ul>
<p>对于<code>IO</code>，我们也可以通过<code>lines()</code>方法获取流：</p>
<ul>
<li><code>java.nio.file.Files.walk()</code></li>
<li><code>java.io.BufferedReader.lines()</code></li>
</ul>
<p>最后，我们还可以从无限大的数据源中产生流：</p>
<ul>
<li><code>Random.ints()</code></li>
</ul>
<p>值得注意的是，<code>JDK</code>中针对基本数据类型的昂贵的装箱和拆箱操作，提供了基本数据类型的流：</p>
<ul>
<li><code>IntStream</code></li>
<li><code>LongStream</code></li>
<li><code>DoubleStream</code></li>
</ul>
<p>这三种基本数据类型和普通流差不多，不过他们流里面的数据都是指定的基本数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Intstream.of(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">Intstream.rang(<span class="number">1</span>,<span class="number">3</span>);</span><br></pre></td></tr></table></figure>



<h4 id="对流进行操作"><a href="#对流进行操作" class="headerlink" title="对流进行操作"></a>对流进行操作</h4><p>这是本章的重点，产生流比较容易，但是不同的业务系统的需求会涉及到很多不同的要求，明白我们能对流做什么，怎么做，才能更好的利用<code>Stream API</code>的特点。</p>
<p><strong>流的操作类型分为两种:</strong></p>
<ul>
<li><p><strong>Intermediate</strong>：中间操作，一个流可以后面跟随零个或多个<code>intermediate</code>操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后会返回一个新的流，交给下一个操作使用。这类操作都是<strong>惰性化的（lazy）</strong>，就是说，仅仅调用到这类方法，并没有真正开始流的遍历。</p>
<blockquote>
<p><code>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered</code></p>
</blockquote>
</li>
<li><p><strong>Terminal</strong>：终结操作，一个流只能有一个<code>terminal</code>操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。<code>Terminal </code>操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。</p>
<blockquote>
<p><code>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</code></p>
</blockquote>
</li>
</ul>
<blockquote>
<p><code>Intermediate</code>和<code>Terminal</code>完全可以按照上图的流程图理解，<code>Intermediate</code>表示在管道中间的过滤器，水会流入过滤器，然后再流出去，而<code>Terminal</code>操作便是最后一个过滤器，它在管道的最后面，流入<code>Terminal</code>的水，最后便会流出管道。</p>
</blockquote>
<p>下面依次详细的解读下每一个操作所能产生的效果：</p>
<h4 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h4><p>对于中间操作，所有的<code>API</code>的返回值基本都是<code>Stream&lt;T&gt;</code>,因此以后看见一个陌生的<code>API</code>也能通过返回值判断它的所属类型。</p>
<p><strong>map/flatMap</strong></p>
<p><code>map</code>顾名思义，就是映射，<code>map</code>操作能够将流中的每一个元素映射为另外的元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>map</code>接受的是一个<code>Function</code>,也就是接收参数，并返回一个值。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//提取 List&lt;Student&gt;  所有student 的名字 </span></span><br><span class="line">List&lt;String&gt; studentNames = students.stream().map(Student::getName)</span><br><span class="line">                                             .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>上面的代码等同于以前的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; studentNames=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    studentNames.add(student.getName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>再比如：将List中所有字母转换为大写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; words=Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>);</span><br><span class="line">List&lt;String&gt; upperWords=words.stream().map(String::toUpperCase)</span><br><span class="line">                                      .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<hr>
<p><code>flatMap</code>顾名思义就是扁平化映射，它具体的操作是将多个<code>stream</code>连接成一个<code>stream</code>，这个操作是针对类似多维数组的，比如容器里面包含容器等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;List&lt;Integer&gt;&gt; ints=<span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(Arrays.asList(<span class="number">1</span>,<span class="number">2</span>),</span><br><span class="line">                                          Arrays.asList(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)));</span><br><span class="line">List&lt;Integer&gt; flatInts=ints.stream().flatMap(Collection::stream).</span><br><span class="line">                                       collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>可以看到，相当于降维。</p>
<hr>
<p><strong>filter</strong></p>
<p><code>filter</code>顾名思义，就是过滤，通过测试的元素会被留下来并生成一个新的<code>Stream</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<p>同理，我们可以<code>filter</code>接收的参数是<code>Predicate</code>，也就是推断型函数式接口，接收参数，并返回<code>boolean</code>值。</p>
<p>比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取所有大于18岁的学生</span></span><br><span class="line">List&lt;Student&gt; studentNames = students.stream().filter(s-&gt;s.getAge()&gt;<span class="number">18</span>)</span><br><span class="line">                                              .collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>distinct</strong></p>
<p><code>distinct</code>是去重操作,它没有参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">distinct</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>sorted</strong></p>
<p><code>sorted</code>排序操作，默认是从小到大排列，<code>sorted</code>方法包含一个重载，使用<code>sorted</code>方法，如果没有传递参数，那么流中的元素就需要实现<code>Comparable&lt;T&gt;</code>方法，也可以在使用<code>sorted</code>方法的时候传入一个<code>Comparator&lt;T&gt;</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">sorted</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>值得一说的是这个<code>Comparator</code>在<code>Java 8</code>之后被打上了<code>@FunctionalInterface</code>,其他方法都提供了<code>default</code>实现，因此我们可以在<code>sort</code>中使用<code>Lambda</code>表达式</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以年龄排序</span></span><br><span class="line">students.stream().sorted((s,o)-&gt;Integer.compare(s.getAge(),o.getAge()))</span><br><span class="line">                                  .forEach(System.out::println);;</span><br></pre></td></tr></table></figure>

<p>然而还有更方便的，<code>Comparator</code>默认也提供了实现好的方法引用，使得我们更加方便的使用：</p>
<p>例如上面的代码可以改成如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以年龄排序 </span></span><br><span class="line">students.stream().sorted(Comparator.comparingInt(Student::getAge))</span><br><span class="line">                            .forEach(System.out::println);;</span><br></pre></td></tr></table></figure>

<p>或者：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//以姓名排序</span></span><br><span class="line">students.stream().sorted(Comparator.comparing(Student::getName)).</span><br><span class="line">                          forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>是不是更加简洁。</p>
<hr>
<p><strong>peek</strong></p>
<p><code>peek</code>有遍历的意思，和<code>forEach</code>一样，但是它是一个中间操作。</p>
<p><code>peek</code>接受一个消费型的函数式接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">peek</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//去重以后打印出来，然后再归并为List</span></span><br><span class="line">List&lt;Student&gt; sortedStudents= students.stream().distinct().peek(System.out::println).</span><br><span class="line">                                                collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>limit</strong></p>
<p><code>limit</code>裁剪操作，和<code>String::subString(0,x)</code>有点先沟通，<code>limit</code>接受一个<code>long</code>类型参数，通过<code>limit</code>之后的元素只会剩下<code>min(n,size)</code>个元素，<code>n</code>表示参数，<code>size</code>表示流中元素个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只留下前6个元素并打印</span></span><br><span class="line">students.stream().limit(<span class="number">6</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>skip</strong></p>
<p><code>skip</code>表示跳过多少个元素，和<code>limit</code>比较像，不过<code>limit</code>是保留前面的元素，<code>skip</code>是保留后面的元素</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//跳过前3个元素并打印 </span></span><br><span class="line">students.stream().skip(<span class="number">3</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<h4 id="终结操作"><a href="#终结操作" class="headerlink" title="终结操作"></a>终结操作</h4><p>一个流处理中，有且只能有一个终结操作，通过终结操作之后，流才真正被处理，终结操作一般都返回其他的类型而不再是一个流,一般来说，终结操作都是将其转换为一个容器。</p>
<p><strong>forEach</strong></p>
<p><code>forEach</code>是终结操作的遍历，操作和<code>peek</code>一样，但是<code>forEach</code>之后就不会再返回流</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历打印</span></span><br><span class="line">students.stream().forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<p>上面的代码和一下代码效果相同：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(Student student:students)&#123;</span><br><span class="line">    System.out.println(sudents);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>toArray</strong></p>
<p><code>toArray</code>和<code>List##toArray()</code>用法差不多，包含一个重载。</p>
<p>默认的<code>toArray()</code>返回一个<code>Object[]</code>，</p>
<p>也可以传入一个<code>IntFunction&lt;A[]&gt; generator</code>指定数据类型</p>
<p>一般建议第二种方式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object[] toArray();</span><br><span class="line"></span><br><span class="line">&lt;A&gt; A[] toArray(IntFunction&lt;A[]&gt; generator);</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student[] studentArray = students.stream().skip(<span class="number">3</span>).toArray(Student[]::<span class="keyword">new</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>max/min</strong></p>
<p><code>max/min</code>即使找出最大或者最小的元素。<code>max/min</code>必须传入一个<code>Comparator</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">min</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">max</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> T&gt; comparator)</span></span>;</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>count</strong></p>
<p><code>count</code>返回流中的元素数量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span>  count = students.stream().skip(<span class="number">3</span>).count();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>reduce</strong></p>
<p><code>reduce</code>为归纳操作，主要是将流中各个元素结合起来，它需要提供一个起始值，然后按一定规则进行运算，比如相加等，它接收一个二元操作 <code>BinaryOperator</code>函数式接口。从某种意义上来说，<code>sum,min,max,average</code>都是特殊的<code>reduce</code></p>
<p><code>reduce</code>包含三个重载：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">T <span class="title">reduce</span><span class="params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">reduce</span><span class="params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;</span><br><span class="line"></span><br><span class="line"> &lt;U&gt; <span class="function">U <span class="title">reduce</span><span class="params">(U identity,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BiFunction&lt;U, ? <span class="keyword">super</span> T, U&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                 BinaryOperator&lt;U&gt; combiner)</span></span>;</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; integers = <span class="keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>));</span><br><span class="line">        </span><br><span class="line"><span class="keyword">long</span> count = integers.stream().reduce(<span class="number">0</span>,(x,y)-&gt;x+y);</span><br></pre></td></tr></table></figure>

<p>以上代码等同于：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> count = integers.stream().reduce(Integer::sum).get();</span><br></pre></td></tr></table></figure>

<p><code>reduce</code>两个参数和一个参数的区别在于有没有提供一个起始值，</p>
<p>如果提供了起始值，则可以返回一个确定的值，如果没有提供起始值，则返回<code>Opeational</code>防止流中没有足够的元素。</p>
<hr>
<p><strong>anyMatch\ allMatch\ noneMatch</strong></p>
<p>测试是否有任意元素\所有元素\没有元素匹配表达式</p>
<p>他们都接收一个推断类型的函数式接口：<code>Predicate</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">anyMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">allMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">noneMatch</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span></span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> test = integers.stream().anyMatch(x-&gt;x&gt;<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>findFirst、 findAny</strong></p>
<p>获取元素，这两个<code>API</code>都不接受任何参数，<code>findFirt</code>返回流中第一个元素，<code>findAny</code>返回流中任意一个元素。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findFirst</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Optional&lt;T&gt; <span class="title">findAny</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>也有有人会问<code>findAny()</code>这么奇怪的操作谁会用？这个<code>API</code>主要是为了在并行条件下想要获取任意元素，以最大性能获取任意元素</p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> foo = integers.stream().findAny().get();</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>collect</strong></p>
<p><code>collect</code>收集操作，这个<code>API</code>放在后面将是因为它太重要了，基本上所有的流操作最后都会使用它。</p>
<p>我们先看<code>collect</code>的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> &lt;R&gt; <span class="function">R <span class="title">collect</span><span class="params">(Supplier&lt;R&gt; supplier,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, ? <span class="keyword">super</span> T&gt; accumulator,</span></span></span><br><span class="line"><span class="function"><span class="params">                  BiConsumer&lt;R, R&gt; combiner)</span></span>;</span><br><span class="line"></span><br><span class="line">&lt;R, A&gt; <span class="function">R <span class="title">collect</span><span class="params">(Collector&lt;? <span class="keyword">super</span> T, A, R&gt; collector)</span></span>;</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>collect</code>包含两个重载：</p>
<p>一个参数和三个参数，</p>
<p>三个参数我们很少使用，因为<code>JDK</code>提供了足够我们使用的<code>Collector</code>供我们直接使用,我们可以简单了解下这三个参数什么意思：</p>
<ul>
<li><code>Supplier</code>:用于产生最后存放元素的容器的生产者</li>
<li><code>accumulator</code>:将元素添加到容器中的方法</li>
<li><code>combiner</code>：将分段元素全部添加到容器中的方法</li>
</ul>
<p>前两个元素我们都很好理解，第三个元素是干嘛的呢？因为流提供了并行操作，因此有可能一个流被多个线程分别添加，然后再将各个子列表依次添加到最终的容器中。</p>
<p>↓      - - - - - - - - -</p>
<p>↓   —       —       —</p>
<p>↓         ———</p>
<p>如上图，分而治之。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; result = stream.collect(ArrayList::<span class="keyword">new</span>, List::add, List::addAll);</span><br></pre></td></tr></table></figure>

<hr>
<p>接下来看只有一个参数的<code>collect</code></p>
<p>一般来说，只有一个参数的<code>collect</code>，我们都直接传入<code>Collectors</code>中的方法引用即可：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; = integers.stream().collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p><code>Collectors</code>中包含很多常用的转换器。<code>toList()</code>,<code>toSet()</code>等。</p>
<p><code>Collectors</code>中还包括一个<code>groupBy()</code>，他和<code>Sql</code>中的<code>groupBy</code>一样都是分组，返回一个<code>Map</code></p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//按学生年龄分组</span></span><br><span class="line">Map&lt;Integer,List&lt;Student&gt;&gt; map= students.stream().</span><br><span class="line">                                collect(Collectors.groupingBy(Student::getAge));</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>groupingBy</code>可以接受3个参数，分别是</p>
<ol>
<li>第一个参数：分组按照什么分类</li>
<li>第二个参数：分组最后用什么容器保存返回（当只有两个参数是，此参数默认为<code>HashMap</code>）</li>
<li>第三个参数：按照第一个参数分类后，对应的分类的结果如何收集</li>
</ol>
<p>有时候单参数的<code>groupingBy</code>不满足我们需求的时候，我们可以使用多个参数的<code>groupingBy</code></p>
</blockquote>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将学生以年龄分组，每组中只存学生的名字而不是对象</span></span><br><span class="line">Map&lt;Integer,List&lt;String&gt;&gt; map =  students.stream().</span><br><span class="line">  collect(Collectors.groupingBy(Student::getAge,Collectors.mapping(Student::getName,Collectors.toList())));</span><br></pre></td></tr></table></figure>

<p><code>toList</code>默认生成的是<code>ArrayList</code>,<code>toSet</code>默认生成的是<code>HashSet</code>，如果想要指定其他容器，可以如下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().collect(Collectors.toCollection(TreeSet::<span class="keyword">new</span>));</span><br></pre></td></tr></table></figure>

<p><code>Collectors</code>还包含一个<code>toMap</code>，利用这个<code>API</code>我们可以将<code>List</code>转换为<code>Map</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;Integer,Student&gt; map=students.stream().</span><br><span class="line">                         collect(Collectors.toMap(Student::getAge,s-&gt;s));</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<blockquote>
<p>值得注意的一点是，<code>IntStream</code>，<code>LongStream</code>,<code>DoubleStream</code>是没有<code>collect()</code>方法的，因为对于基本数据类型，要进行装箱，拆箱操作，SDK并没有将它放入流中，对于基本数据类型流，我们只能将其<code>toArray()</code></p>
</blockquote>
<hr>
<h3 id="优雅的使用Stream"><a href="#优雅的使用Stream" class="headerlink" title="优雅的使用Stream"></a>优雅的使用Stream</h3><p>了解了<code>Stream API</code>，下面详细介绍一下如果优雅的使用<code>Steam</code></p>
<ul>
<li><p>了解流的惰性操作</p>
<p>前面说到，流的中间操作是惰性的，如果一个流操作流程中只有中间操作，没有终结操作，那么这个流什么都不会做，整个流程中会一直等到遇到终结操作操作才会真正的开始执行。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().peek(System.out::println);</span><br></pre></td></tr></table></figure>

<p>这样的流操作只有中间操作，没有终结操作，那么不管流里面包含多少元素，他都不会执行任何操作。</p>
</li>
<li><p>明白流操作的顺序的重要性</p>
<p>在<code>Stream API</code>中，还包括一类<code>Short-circuiting</code>,它能够改变流中元素的数量，一般这类<code>API</code>如果是中间操作，最好写在靠前位置：</p>
<p>考虑下面两行代码：</p>
<p>1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().sorted(Comparator.comparingInt(Student::getAge)).</span><br><span class="line">                  peek(System.out::println).</span><br><span class="line">                  limit(<span class="number">3</span>).              </span><br><span class="line">                  collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>2.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().limit(<span class="number">3</span>).</span><br><span class="line">                  sorted(Comparator.comparingInt(Student::getAge)).</span><br><span class="line">                  peek(System.out::println).</span><br><span class="line">                  collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>两段代码所使用的<code>API</code>都是相同的，但是由于顺序不同，带来的结果都非常不一样的，</p>
<p>第一段代码会先排序所有的元素，再依次打印一遍，最后获取前三个最小的放入<code>list</code>中,</p>
<p>第二段代码会先截取前3个元素，在对这三个元素排序，然后遍历打印，最后放入<code>list</code>中。</p>
</li>
<li><p>明白<code>Lambda</code>的局限性</p>
<p>由于<code>Java</code>目前只能<code>Pass-by-value</code>，因此对于<code>Lambda</code>也和有匿名类一样的<code>final</code>的局限性。</p>
<p>具体原因可以参考<a href="http://dengchengchao.com/?p=914">Java 干货之深人理解内部类</a></p>
<p>因此我们无法再<code>lambda</code>表达式中修改外部元素的值。</p>
<p>同时，在<code>Stream</code>中，我们无法使用<code>break</code>提前返回。</p>
</li>
<li><p>合理编排<code>Stream</code>的代码格式</p>
<p>由于可能在使用流式编程的时候会处理很多的业务逻辑，导致<code>API</code>非常长，此时最后使用换行将各个操作分离开来，使得代码更加易读。</p>
<p>例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().limit(<span class="number">3</span>).</span><br><span class="line">                  sorted(Comparator.comparingInt(Student::getAge)).</span><br><span class="line">                  peek(System.out::println).</span><br><span class="line">                  collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>而不是:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">students.stream().limit(<span class="number">3</span>).sorted(Comparator.comparingInt(Student::getAge)).peek(System.out::println).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>

<p>同时由于<code>Lambda</code>表达式省略了参数类型，因此对于变量，尽量使用完成的名词，比如<code>student</code>而不是<code>s</code>，增加代码的可读性。</p>
<blockquote>
<p>尽量写出敢在代码注释上留下你的名字的代码！</p>
</blockquote>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，<code>Stream</code>是Java 8 提供的简化代码的神器，合理使用它，能让你的代码更加优雅。</p>
<p>参考资料：</p>
<p>《Effective Java》3th</p>
<p><a href="https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html">Java 8 中的 Streams API 详解</a></p>
<p><a href="https://www.cnblogs.com/CarpenterLee/p/6550212.html">Java Stream API进阶篇</a></p>
<p><a href="https://segmentfault.com/q/1010000007288770">java8 stream groupby后的数据结构是否可以重构</a></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8 函数式接口归纳</title>
    <url>/2019/11/06/Java/java8%E6%96%B0%E7%89%B9%E6%80%A7/Java8-%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8E%A5%E5%8F%A3%E5%BD%92%E7%BA%B3/</url>
    <content><![CDATA[<p>函数式接口：为了支持将<code>lambda</code>表达式作为参数传入接口中，Java 8 定义了函数式接口的概念，函数式接口一般只有一个抽象的方法，并且通过<code>@FunctionalInterface</code>标记。</p>
<span id="more"></span>

<p>在日常开发中，如果我们想让自己定义的方法支持传入一个<code>lambda</code>表达式，有两种方法可以做到：</p>
<ul>
<li>自己定义一个函数式接口</li>
<li>使用<code>JDK</code>自带的函数式接口</li>
</ul>
<p>一般来说，都推荐第二种，因为<code>JDK</code>自带函数式接口基本都能满足日常所用。并且使用通用的接口能让你的API更加通俗，减少其他人阅读源码时的不必要的学习。并且<code>JDK</code>自带的函数式接口提供了很多通用的的默认方法。</p>
<p><code>JDK</code>一共提供了43个函数式接口，不过分类来看差不多有4类，记住这4类中每一类最通用的接口便能理解其他的接口，他们分别为：</p>
<ul>
<li><p><code>Function&lt;T&gt;</code>函数类接口，此接口方法接收参数，并返回结果</p>
<ul>
<li><code>Operator&lt;T&gt;</code>操作类接口，特殊的函数类接口，此接口方法的参数和结果类型相同</li>
</ul>
</li>
<li><p><code>Predicate&lt;T&gt;</code>断言类接口，此接口接受一个参数并返回一个布尔值</p>
</li>
<li><p><code>Supplier&lt;T&gt;</code>生产类接口，此接口不接受参数，但是会有返回值</p>
</li>
<li><p><code>Consumer&lt;T&gt;</code>消费类接口，此接口只接受参数，但是不会有返回值</p>
</li>
</ul>
<p>可以发现函数式接口的分类都是根据参数和返回类型进行分类，因此想要记住他们并不困难。</p>
<blockquote>
<p>可能有些人比较疑惑<code>Consumer&lt;T&gt;</code>会怎么使用，此类接口用在消费对象的时候，比如发消息，更典型的比如：System.out::println</p>
</blockquote>
<p>如果需要更加细分的话，还有根据参数个数进行区分。不过对于基本数据类型，上述接口都有基本数据类型的变体，主要是为了不必要的<code>Box</code>和<code>UnBox</code>操作。</p>
<h2 id="Function"><a href="#Function" class="headerlink" title="Function"></a>Function</h2><p>表示一个方法接收参数并返回结果。</p>
<h3 id="接收单个参数"><a href="#接收单个参数" class="headerlink" title="接收单个参数"></a>接收单个参数</h3><table>
<thead>
<tr>
<th align="left"><code>Interface</code></th>
<th align="left"><code>functional method</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Function&lt;T,R&gt;</code></td>
<td align="left"><code>R apply(T t)</code></td>
<td align="left">接收参数类型为T，返回参数类型为R</td>
</tr>
<tr>
<td align="left"><code>IntFunction&lt;R&gt;</code></td>
<td align="left"><code>R apply(int value)</code></td>
<td align="left">以下三个接口，指定了接收参数类型，返回参数类型为泛型R</td>
</tr>
<tr>
<td align="left"><code>LongFunction&lt;R&gt;</code></td>
<td align="left"><code>R apply(long value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>Double&lt;R&gt;</code></td>
<td align="left"><code>R apply(double value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>ToIntFunction&lt;T&gt;</code></td>
<td align="left"><code>int applyAsInt(T value)</code></td>
<td align="left">以下三个接口，指定了返回参数类型，接收参数类型为泛型T</td>
</tr>
<tr>
<td align="left"><code>ToLongFunction&lt;T&gt;</code></td>
<td align="left"><code>long applyAsLong(T value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>ToDoubleFunction&lt;T&gt;</code></td>
<td align="left"><code>double applyAsDouble(T value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>IntToLongFunction</code></td>
<td align="left"><code>long applyAsLong(int value)</code></td>
<td align="left">以下六个接口，既指定了接收参数类型，也指定了返回参数类型</td>
</tr>
<tr>
<td align="left"><code>IntToDoubleFunction</code></td>
<td align="left"><code>double applyAsLong(int value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>LongToIntFunction</code></td>
<td align="left"><code>int applyAsLong(long value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>LongToDoubleFunction</code></td>
<td align="left"><code>double applyAsLong(long value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>DoubleToIntFunction</code></td>
<td align="left"><code>int applyAsLong(double value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>DoubleToLongFunction</code></td>
<td align="left"><code>long applyAsLong(double value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>UnaryOperator&lt;T&gt;</code></td>
<td align="left"><code>T apply(T t)</code></td>
<td align="left">特殊的Function，接收参数类型和返回参数类型一样</td>
</tr>
<tr>
<td align="left"><code>IntUnaryOperator</code></td>
<td align="left"><code>int applyAsInt(int left, int right)</code></td>
<td align="left">以下三个接口，制定了接收参数和返回参数类型，并且都一样</td>
</tr>
<tr>
<td align="left"><code>LongUnaryOperator</code></td>
<td align="left"><code>long applyAsInt(long left, long right)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>DoubleUnaryOperator</code></td>
<td align="left"><code>double applyAsInt(double left, double right)</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="接收两个参数"><a href="#接收两个参数" class="headerlink" title="接收两个参数"></a>接收两个参数</h3><table>
<thead>
<tr>
<th align="left"><code>interface</code></th>
<th align="left"><code>functional method</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BiFunction&lt;T,U,R&gt;</code></td>
<td align="left"><code>R apply(T t, U u)</code></td>
<td align="left">接收两个参数的Function</td>
</tr>
<tr>
<td align="left"><code>ToIntBiFunction&lt;T,U&gt;</code></td>
<td align="left"><code>int applyAsInt(T t, U u)</code></td>
<td align="left">以下三个接口，指定了返回参数类型，接收参数类型分别为泛型T, U</td>
</tr>
<tr>
<td align="left"><code>ToLongBiFunction&lt;T,U&gt;</code></td>
<td align="left"><code>long applyAsLong(T t, U u)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>ToDoubleBiFunction&lt;T,U&gt;</code></td>
<td align="left"><code>double appleyAsDouble(T t, U u)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>BinaryOperator&lt;T&gt;</code></td>
<td align="left"><code>T apply(T t, T u)</code></td>
<td align="left">特殊的BiFunction, 接收参数和返回参数类型一样</td>
</tr>
<tr>
<td align="left"><code>IntBinaryOperator</code></td>
<td align="left"><code>int applyAsInt(int left, int right)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>LongBinaryOperator</code></td>
<td align="left"><code>long applyAsInt(long left, long right)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">DoubleBinaryOperator</td>
<td align="left">double applyAsInt(double left, double right)</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h2><p>表示一个方法接收参数但不产生返回值。</p>
<h3 id="接收一个参数"><a href="#接收一个参数" class="headerlink" title="接收一个参数"></a>接收一个参数</h3><table>
<thead>
<tr>
<th align="left">interface</th>
<th align="left">functional method</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Consumer&lt;T&gt;</code></td>
<td align="left"><code>void accept(T t)</code></td>
<td align="left">接收一个泛型参数，无返回值</td>
</tr>
<tr>
<td align="left"><code>IntConsumer</code></td>
<td align="left"><code>void accept(int value)</code></td>
<td align="left">以下三个类，接收一个指定类型的参数</td>
</tr>
<tr>
<td align="left"><code>LongConsumer</code></td>
<td align="left"><code>void accept(long value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">DoubleConsumer</td>
<td align="left">void accept(double value)</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="接收两个参数-1"><a href="#接收两个参数-1" class="headerlink" title="接收两个参数"></a>接收两个参数</h3><table>
<thead>
<tr>
<th align="left"><code>interface</code></th>
<th align="left"><code>functional method</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>BiConsumer&lt;T,U&gt;</code></td>
<td align="left"><code>void accept(T t, U u)</code></td>
<td align="left">接收两个泛型参</td>
</tr>
<tr>
<td align="left"><code>ObjIntConsumer&lt;T&gt;</code></td>
<td align="left"><code>void accept(T t, int value)</code></td>
<td align="left">以下三个类，接收一个泛型参数，一个指定类型的参</td>
</tr>
<tr>
<td align="left"><code>ObjLongConsumer&lt;T&gt;</code></td>
<td align="left"><code>void accept(T t, long value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left">ObjDoubleConsumer<T></td>
<td align="left">void accept(T t, double value)</td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Supplier"><a href="#Supplier" class="headerlink" title="Supplier"></a>Supplier</h2><p>返回一个结果，并不要求每次调用都返回一个新的或者独一的结果</p>
<table>
<thead>
<tr>
<th align="left"><code>interface</code></th>
<th align="left"><code>functional method</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Supplier&lt;T&gt;</code></td>
<td align="left"><code>T get()</code></td>
<td align="left">返回类型为泛型T</td>
</tr>
<tr>
<td align="left"><code>BooleanSupplier</code></td>
<td align="left"><code>boolean getAsBoolean()</code></td>
<td align="left">以下三个接口，返回指定类型</td>
</tr>
<tr>
<td align="left"><code>IntSupplier</code></td>
<td align="left"><code>int getAsInt()</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>LongSupplier</code></td>
<td align="left"><code>long getAsLong()</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>DoubleSupplier</code></td>
<td align="left"><code>double getAsDouble()</code></td>
<td align="left"></td>
</tr>
</tbody></table>
<h2 id="Predicate"><a href="#Predicate" class="headerlink" title="Predicate"></a>Predicate</h2><p>根据接收参数进行断言，返回boolean类型</p>
<table>
<thead>
<tr>
<th align="left"><code>interface</code></th>
<th align="left"><code>functional method</code></th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>Predicate&lt;T&gt;</code></td>
<td align="left"><code>boolean test(T t)</code></td>
<td align="left">接收一个泛型参数</td>
</tr>
<tr>
<td align="left"><code>IntPredicate</code></td>
<td align="left"><code>boolean test(int value)</code></td>
<td align="left">以下三个接口，接收指定类型的参数</td>
</tr>
<tr>
<td align="left"><code>LongPredicate</code></td>
<td align="left"><code>boolean test(long value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>DoublePredicate</code></td>
<td align="left"><code>boolean test(double value)</code></td>
<td align="left"></td>
</tr>
<tr>
<td align="left"><code>BiPredicate&lt;T,U&gt;</code></td>
<td align="left"><code>boolean test(T t, U u)</code></td>
<td align="left">接收两个泛型参数，分别为T，U</td>
</tr>
</tbody></table>
<p>参考资料</p>
<p>《Effective Java》 3th</p>
<p><a href="https://segmentfault.com/a/1190000016596774">java 8 函数式接口</a></p>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java8</tag>
      </tags>
  </entry>
  <entry>
    <title>Map实现类介绍</title>
    <url>/2019/06/27/Java/java%E9%9B%86%E5%90%88/Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>本文主要是对java中的Map实现类进行简单的对比了解(不包含<code>java.util.concurrent</code>包下的Map)。基于<code>Jdk1.8.0_171</code></p>
<p>Map 接口存储一组键值对象，提供key（键）到value（值）的映射。</p>
<span id="more"></span>

<p>Map.Entry ：描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。</p>
<p>Map实现类的框架图(Map实现类大多数都直接实现了Map接口(treeMap、EnumMap除外)，图中未体现)：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E6%8A%80%E6%9C%AF/java%E9%9B%86%E5%90%88/Map%E5%AE%9E%E7%8E%B0%E7%B1%BB%E6%A1%86%E6%9E%B6%E5%9B%BE.png" alt="Map实现类框架图"></p>
<p>Map实现类简单对比：</p>
<ul>
<li>HashMap<ul>
<li>无序</li>
<li>非线程安全的</li>
<li>底层使用拉链式散列算法，数据结构为数据+链表+红黑树。</li>
<li>使用频率最高的Map实现类，关于HashMap更详细的源码分析，可以<a href="http://zhangyuying.cn/2019/06/20/%E6%8A%80%E6%9C%AF/HashMap/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">点击查看</a></li>
</ul>
</li>
<li>LinkedHashMap<ul>
<li>继承自HashMap</li>
<li>有序的Map：实现基于插入顺序排序</li>
<li>底层维护了一个双向链表实现排序</li>
</ul>
</li>
<li>TreeMap<ul>
<li>有序的Map：基于key的自然排序</li>
<li>底层使用红黑树实现</li>
</ul>
</li>
</ul>
<ul>
<li>EnumMap<ul>
<li>该类是专门针对枚举类设计的一个集合类，集合中的所有键必须是同一个枚举类的实例。</li>
<li>当EnumMap创建后，会表现成一个数组array，这种表现方式是紧凑高效的。</li>
<li>EnumMap的顺序，由枚举类实例的定义顺序决定。</li>
<li>不允许空键</li>
<li>线程不安全</li>
</ul>
</li>
<li>WeakHashMap<ul>
<li>只持有key的弱引用，所以当key被回收时，可自动删除对应key的那条记录。</li>
</ul>
</li>
<li>IdentityHashMap<ul>
<li>一般Map实现中key的值相等（equals为true）就认为是同一个key，这个Map是以同一个对象（引用）作为判断依据，官方不建议使用。</li>
</ul>
</li>
<li>HashTable<ul>
<li>类似于HashMap的功能，线程安全，老式实现，建议不要再使用！</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>java基础</category>
      </categories>
      <tags>
        <tag>java集合</tag>
      </tags>
  </entry>
  <entry>
    <title>XMLHTTPRequest</title>
    <url>/2018/10/17/%E5%89%8D%E7%AB%AF/AJAX/XMLHTTPRequest/</url>
    <content><![CDATA[<h3 id="XMLHTTPRequest"><a href="#XMLHTTPRequest" class="headerlink" title="XMLHTTPRequest"></a>XMLHTTPRequest</h3><ul>
<li>定义</li>
<li>示例</li>
<li>属性说明</li>
<li>事件句柄</li>
<li>方法说明</li>
<li>局限性</li>
</ul>
<span id="more"></span>

<p>XMLHTTPRequest是一组API函数集，可被JavaScript、JScript、VBScript以及其它web浏览器内嵌的[脚本语言]调用，通过HTTP在浏览器和web服务器之间收发XML或其它数据。XMLHTTP最大的好处在于可以动态地更新网页，它无需重新从服务器读取整个网页，也不需要安装额外的插件。</p>
<p>XMLHTTP是<strong>AJAX</strong>网页开发技术的重要组成部分。</p>
<p>除XML之外，XMLHTTP还能用于获取其它格式的数据，如JSON或者甚至纯文本。</p>
<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>XMLHttpRequest 对象用于在后台与服务器交换数据。</p>
<p>XMLHttpRequest 对象可以：</p>
<ul>
<li>在不重新加载页面的情况下更新网页</li>
<li>在页面已加载后从服务器请求数据</li>
<li>在页面已加载后从服务器接收数据</li>
<li>在后台向服务器发送数据</li>
</ul>
<p>XMLHttpRequest 对象提供了对 HTTP 协议的完全的访问，包括做出 POST 和 HEAD 请求以及普通的 GET 请求的能力。XMLHttpRequest 可以同步或异步返回 Web 服务器的响应，并且能以文本或者一个 DOM 文档形式返回内容。尽管名为 XMLHttpRequest，它并不限于和 XML 文档一起使用：它可以接收任何形式的文本文档。</p>
<p>XMLHttpRequest是一个浏览器接口，使得Javascript可以进行HTTP(S)通信，这就是我们熟悉的AJAX。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="comment">//创建XMLHttpRequest对象</span></span><br><span class="line">    <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    xhr.timeout = <span class="number">3000</span>;</span><br><span class="line">    xhr.ontimeout = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;请求超时！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> formData = <span class="keyword">new</span> FormData();</span><br><span class="line">    formData.append(<span class="string">&#x27;tel&#x27;</span>, <span class="string">&#x27;18217767969&#x27;</span>);</span><br><span class="line">    formData.append(<span class="string">&#x27;psw&#x27;</span>, <span class="string">&#x27;111111&#x27;</span>);</span><br><span class="line">    xhr.open(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;http://www.test.com:8000/login&#x27;</span>);</span><br><span class="line">    xhr.send(formData);</span><br><span class="line">    xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (xhr.readyState == <span class="number">4</span> &amp;&amp; xhr.status == <span class="number">200</span>) &#123;</span><br><span class="line">            alert(xhr.responseText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            alert(xhr.statusText);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>



<h4 id="属性说明："><a href="#属性说明：" class="headerlink" title="属性说明："></a>属性说明：</h4><ul>
<li><p>xhr.readyState：XMLHttpRequest对象的状态，等于4表示数据已经接收完毕。</p>
<ul>
<li><p>一共5 个状态中每一个都有一个相关联的非正式的名称，下表列出了状态、名称和含义：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>Uninitialized</td>
<td>初始化状态。XMLHttpRequest 对象已创建或已被 abort() 方法重置。</td>
</tr>
<tr>
<td>1</td>
<td>Open</td>
<td>open() 方法已调用，但是 send() 方法未调用。请求还没有被发送。</td>
</tr>
<tr>
<td>2</td>
<td>Send</td>
<td>Send() 方法已调用，HTTP 请求已发送到 Web 服务器。未接收到响应。</td>
</tr>
<tr>
<td>3</td>
<td>Receiving</td>
<td>所有响应头部都已经接收到。响应体开始接收但未完成。</td>
</tr>
<tr>
<td>4</td>
<td>Loaded</td>
<td>HTTP 响应已经完全接收。</td>
</tr>
</tbody></table>
<p>readyState 的值不会递减，除非当一个请求在处理过程中的时候调用了abort() 或 open() 方法。每次这个属性的值增加的时候，都会触发 onreadystatechange 事件句柄。</p>
</li>
</ul>
</li>
<li><p>xhr.status：服务器返回的状态码，等于200表示一切正常。</p>
<ul>
<li>由服务器返回的 HTTP 状态代码，如 200 表示成功，而 404 表示 “Not Found” 错误。当 readyState 小于 3 的时候读取这一属性会导致一个异常。</li>
</ul>
</li>
<li><p>xhr.statusText：服务器返回的状态文本。</p>
<ul>
<li>这个属性用名称而不是数字指定了请求的 HTTP 的状态代码。也就是说，当状态为 200 的时候它是 “OK”，当状态为 404 的时候它是 “Not Found”。和 status 属性一样，当 readyState 小于 3 的时候读取这一属性会导致一个异常。</li>
</ul>
</li>
<li><p>xhr.responseText：服务器返回的文本数据</p>
<ul>
<li><p>目前为止从服务器接收到的响应体（不包括头部），或者如果还没有接收到数据的话，就是空字符串。</p>
<p>如果 readyState 小于 3，这个属性就是一个空字符串。当 readyState 为 3，这个属性返回目前已经接收的响应部分。如果 readyState 为 4，这个属性保存了完整的响应体。</p>
<p>如果响应包含了为响应体指定字符编码的头部，就使用该编码。否则，假定使用 Unicode UTF-8。</p>
</li>
</ul>
</li>
<li><p>xhr.responseXML：服务器返回的XML格式的数据</p>
<ul>
<li>对请求的响应，解析为 XML 并作为 Document 对象返回。如果响应体不是“text/xml”返回null。</li>
</ul>
</li>
</ul>
<h4 id="事件句柄"><a href="#事件句柄" class="headerlink" title="事件句柄"></a>事件句柄</h4><ul>
<li>onreadystatechange<ul>
<li>每次 readyState 属性改变的时候调用的事件句柄函数。当 readyState 为 3 时，它也可能调用多次。</li>
</ul>
</li>
</ul>
<h4 id="方法说明"><a href="#方法说明" class="headerlink" title="方法说明"></a>方法说明</h4><ul>
<li><p>abort()</p>
<p>取消当前响应，关闭连接并且结束任何未决的网络活动。</p>
<p>这个方法把 XMLHttpRequest 对象重置为 readyState 为 0 的状态，并且取消所有未决的网络活动。例如，如果请求用了太长时间，而且响应不再必要的时候，可以调用这个方法。</p>
</li>
<li><p>getAllResponseHeaders()</p>
<p>把 HTTP 响应头部作为未解析的字符串返回。</p>
<p>如果 readyState 小于 3，这个方法返回 null。否则，它返回服务器发送的所有 HTTP 响应的头部。头部作为单个的字符串返回，一行一个头部。每行用换行符 “” 隔开。</p>
</li>
<li><p>getResponseHeader()</p>
<p>返回指定的 HTTP 响应头部的值。其参数是要返回的 HTTP 响应头部的名称。可以使用任何大小写来制定这个头部名字，和响应头部的比较是不区分大小写的。</p>
<p>该方法的返回值是指定的 HTTP 响应头部的值，如果没有接收到这个头部或者 readyState 小于 3 则为空字符串。如果接收到多个有指定名称的头部，这个头部的值被连接起来并返回，使用逗号和空格分隔开各个头部的值。</p>
</li>
<li><p>open()</p>
<p>初始化 HTTP 请求参数，例如 URL 和 HTTP 方法，但是并不发送请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">open(method, url, <span class="keyword">async</span>, username, password)</span><br><span class="line"><span class="comment">//method 参数是用于请求的 HTTP 方法。值包括 GET、POST 和 HEAD。</span></span><br><span class="line"><span class="comment">//url 参数是请求的主体。大多数浏览器实施了一个同源安全策略，并且要求这个 URL 与包含脚本的文本具有相同的主机名和端口。</span></span><br><span class="line"><span class="comment">//async 参数指示请求使用应该异步地执行。如果这个参数是 false，请求是同步的，后续对 send() 的调用将阻塞，直到响应完全接收。如果这个参数是 true 或省略，请求是异步的，且通常需要一个 onreadystatechange 事件句柄。</span></span><br><span class="line"><span class="comment">//username 和 password 参数是可选的，为 url 所需的授权提供认证资格。如果指定了，它们会覆盖 url 自己指定的任何资格。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明：这个方法初始化请求参数以供 send() 方法稍后使用。它把 readyState 设置为 1，删除之前指定的所有请求头部，以及之前接收的所有响应头部，并且把 responseText、responseXML、status 以及 statusText参数设置为它们的默认值。当 readyState 为 0 的时候（当 XMLHttpRequest 对象刚创建或者 abort() 方法调用后）以及当 readyState 为 4 时（已经接收响应时），调用这个方法是安全的。当针对任何其他状态调用的时候，open() 方法的行为是未指定的。</p>
<p>除了保存供 send() 方法使用的请求参数，以及重置 XMLHttpRequest 对象以便复用，open() 方法没有其他的行为。要特别注意，当这个方法调用的时候，实现通常不会打开一个到 Web 服务器的网络连接。</p>
</li>
</ul>
</li>
<li><p>send()</p>
<p>发送 HTTP 请求，使用传递给 open() 方法的参数，以及传递给该方法的可选请求体。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">send(body)</span><br><span class="line"><span class="comment">// 如果通过调用 open() 指定的 HTTP 方法是 POST 或 GET，body 参数指定了请求体，作为一个字符串或者 Document 对象。</span></span><br><span class="line"><span class="comment">//如果请求体不是必须的话，这个参数就为 null。对于任何其他方法，这个参数是不可用的，应该为 null（有些实现不允许省略该参数）。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明：这个方法导致一个 HTTP 请求发送。如果之前没有调用 open()，或者更具体地说，如果 readyState 不是 1，send() 抛出一个异常。否则，它发送一个 HTTP 请求，该请求由以下几部分组成：</p>
<p>1.之前调用 open() 时指定的 HTTP 方法、URL 以及认证资格（如果有的话）。</p>
<p>2.之前调用 setRequestHeader() 时指定的请求头部（如果有的话）。</p>
<p>3.传递给这个方法的 body 参数。 一旦请求发布了，先触发 onreadystatechange 事件句柄，随后send() 把 readyState 设置为 2，并触发 onreadystatechange 事件句柄。</p>
<p>​    如果之前调用的 open() 参数 async 为 false，这个方法会阻塞并不会返回，直到 readyState 为 4 并且服务器的响应被完全接收。否则，如果 async 参数为 true，或者这个参数省略了，send() 立即返回，并且正如后面所介绍的，服务器响应将在一个后台线程中处理。</p>
<p>​    如果服务器响应带有一个 HTTP 重定向，send() 方法或后台线程自动遵从重定向。当所有的 HTTP 响应头部已经接收，send() 或后台线程把 readyState 设置为 3 并触发 onreadystatechange 事件句柄。如果响应较长，send() 或后台线程可能在状态 3 中触发 onreadystatechange 事件句柄：这可以作为一个下载进度指示器。最后，当响应完成，send() 或后台线程把 readyState 设置为 4，并最后一次触发事件句柄</p>
</li>
</ul>
</li>
<li><p>setRequestHeader()</p>
<p>向一个打开但未发送的请求设置或添加一个 HTTP 请求头。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setRequestHeader(name, value)</span><br><span class="line"><span class="comment">//name 参数是要设置的头部的名称。这个参数不应该包括空格、冒号或换行。</span></span><br><span class="line"><span class="comment">//value 参数是头部的值。这个参数不应该包括换行。</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>说明：setRequestHeader() 方法指定了一个 HTTP 请求的头部，它应该包含在通过后续 send() 调用而发布的请求中。这个方法只有当 readyState 为 1 的时候才能调用，例如，在调用了 open() 之后，调用 send() 之前。</p>
<p>如果带有指定名称的头部已经被指定了，这个头部的新值就是：之前指定的值，加上逗号、空格以及这个调用指定的值。</p>
<p>如果 open() 调用指定了认证资格，XMLHttpRequest 自动发送一个适当的 Authorization 请求头部。但是，你可以使用 setRequestHeader() 来添加这个头部。类似地，如果 Web 服务器已经保存了和传递给 open() 的 URL 相关联的 cookie，适当的 Cookie 或 Cookie2 头部也自动地包含到请求中。可以通过调用 setRequestHeader() 来把这些 cookie 添加到头部。XMLHttpRequest 也可以为 User-Agent 头部提供一个默认值。如果它这么做，你为该头部指定的任何值都会添加到这个默认值后面。</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<h4 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h4><p>XmlHttpRequest不支持跨域访问，这是由网景公司(netscape)在开发浏览器时定义的同源策略导致的。</p>
<p>参考资料</p>
<p><a href="http://www.w3school.com.cn/xml/xml_http.asp">http://www.w3school.com.cn/xml/xml_http.asp</a></p>
<p><a href="https://baike.baidu.com/item/XMLHTTPRequest/6788735?fr=aladdin">https://baike.baidu.com/item/XMLHTTPRequest/6788735?fr=aladdin</a></p>
<p><a href="https://www.cnblogs.com/shijingjing07/p/7096657.html">https://www.cnblogs.com/shijingjing07/p/7096657.html</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState">https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest/readyState</a></p>
]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX</title>
    <url>/2018/10/17/%E5%89%8D%E7%AB%AF/AJAX/AJAX/</url>
    <content><![CDATA[<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><ul>
<li>定义</li>
<li>优点</li>
<li>示例</li>
<li>安全限制</li>
</ul>
<span id="more"></span>

<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>AJAX</code> = <code>Asynchronous JavaScript and XML</code>（异步的<code>JavaScript</code>和 <code>XML</code>）。意思就是用<code>JavaScript</code>执行异步网络请求。</p>
<p><code>AJAX </code>不是新的编程语言，而是一种使用现有标准的新方法。可用于创建快速动态网页。</p>
<p><code>AJAX</code>是基于现有的<code>Internet</code>标准，并且联合使用它们：</p>
<ul>
<li><code>XMLHttpRequest </code>对象 (异步的与服务器交换数据)： <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest"><code>XMLHttpRequest</code> API</a>是Ajax的核心。</li>
<li><code>JavaScript/DOM </code>(信息显示/交互)</li>
<li><code>CSS </code>(给数据定义样式)</li>
<li><code>XML</code> (作为转换数据的格式)</li>
</ul>
<p><img src="http://www.runoob.com/images/lamp.gif" alt="lamp">  <code>AJAX</code>应用程序是与浏览器和平台无关的！</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p><code>AJAX</code> 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。</p>
<p>没有<code>AJAX</code>时：一个<code>HTTP</code>请求对应一个页面，即发送一个请求之后需要刷新页面。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p><code>AJAX</code> 请求是异步执行的，也就是说，要通过回调函数获得响应。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">success</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fail</span>(<span class="params">code</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> textarea = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;test-response-text&#x27;</span>);</span><br><span class="line">    textarea.value = <span class="string">&#x27;Error code: &#x27;</span> + code;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象</span></span><br><span class="line"><span class="keyword">var</span> request;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.XMLHttpRequest) &#123;</span><br><span class="line">    request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 针对低版本的IE的支持 IE5 IE6</span></span><br><span class="line">    request = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;Microsoft.XMLHTTP&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.onreadystatechange = state_Change;</span><br><span class="line"> <span class="comment">// 发送请求:</span></span><br><span class="line">request.open(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;/api/categories&#x27;</span>);</span><br><span class="line">request.send();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">state_Change</span>(<span class="params"></span>) </span>&#123; <span class="comment">// 状态发生变化时，函数被回调</span></span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123; <span class="comment">// 请求是否成功完成</span></span><br><span class="line">        <span class="comment">// 判断请求的响应结果:</span></span><br><span class="line">        <span class="keyword">if</span> (request.status === <span class="number">200</span>) &#123;</span><br><span class="line">            <span class="comment">// 成功，通过responseText拿到响应的文本:</span></span><br><span class="line">            <span class="keyword">return</span> success(request.responseText);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 失败，根据响应码判断失败原因:</span></span><br><span class="line">            <span class="keyword">return</span> fail(request.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// HTTP请求还在继续...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">alert(<span class="string">&#x27;请求已发送，请等待响应...&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li><code>onreadystatechange</code> 是一个事件句柄。它的值 (<code>state_Change</code>) 是一个函数的名称，当 <code>XMLHttpRequest </code>对象的状态发生改变时，会触发此函数。状态从 <code>0 (uninitialized</code>) 到 <code>4 (complete</code>) 进行变化。仅在状态为<code>4</code>时，我们才执行代码。</li>
</ul>
<ul>
<li><code>XMLHttpRequest</code>对象的<code>open()</code>方法有3个参数：<ul>
<li>第一个参数指定是<code>GET</code>还是<code>POST</code></li>
<li>第二个参数指定<code>URL</code>地址</li>
<li>第三个参数指定是否使用异步，默认是<code>true</code>，所以不用写。<strong>注意</strong>，第三个参数指定为<code>false</code>时，浏览器将停止响应，直到<code>AJAX</code>请求完成。如果这个请求耗时10秒，那么10秒内你会发现浏览器处于“假死”状态。</li>
</ul>
</li>
<li>最后调用<code>send()</code>方法才真正发送请求。</li>
</ul>
<h4 id="安全限制（跨域）"><a href="#安全限制（跨域）" class="headerlink" title="安全限制（跨域）"></a>安全限制（跨域）</h4><p>上面代码的<code>URL</code>使用的是相对路径。如果你把它改为<code>&#39;http://zhangyuying.cn/&#39;</code>，再运行，肯定报错。在Chrome的控制台里，还可以看到错误信息。</p>
<p>这是因为浏览器的<strong>同源策略</strong>导致的。默认情况下，<code>JavaScript</code>在发送AJAX请求时，<code>URL</code>的域名必须和当前页面<strong>完全一致</strong>。</p>
<p><strong>完全一致</strong>的意思是，域名要相同（<code>www.example.com</code>和<code>example.com</code>不同），协议要相同（<code>http</code>和<code>https</code>不同），端口号要相同（默认是<code>:80</code>端口，它和<code>:8080</code>就不同）。有的浏览器口子松一点，允许端口不同，大多数浏览器都会严格遵守这个限制。</p>
<p>使用<code>JavaScript</code> 请求外域（就是其他网站）的<code>URL</code>：大概有这么几种：</p>
<ul>
<li><p>一是通过<code>Flash</code>插件发送<code>HTTP</code>请求，这种方式可以绕过浏览器的安全限制，但必须安装<code>Flash</code>，并且跟<code>Flash</code>交互。不过<code>Flash</code>用起来麻烦，而且现在用得也越来越少了。</p>
</li>
<li><p>二是通过在同源域名下架设一个代理服务器来转发，<code>JavaScript</code>负责把请求发送到代理服务器：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#x2F;proxy?url&#x3D;http:&#x2F;&#x2F;www.sina.com.cn&#39;</span><br></pre></td></tr></table></figure>

<p>代理服务器再把结果返回，这样就遵守了浏览器的同源策略。这种方式麻烦之处在于需要服务器端额外做开发。</p>
</li>
<li><p>第三种方式称为<code>JSONP</code>，它有个限制，只能用<code>GET</code>请求，并且要求返回<code>JavaScript</code>。这种方式跨域实际上是利用了浏览器允许跨域引用<code>JavaScript</code>资源：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;script src=<span class="string">&quot;http://example.com/abc.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line">    ...</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;... &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p><code>JSONP</code>通常以函数调用的形式返回，例如，返回<code>JavaScript</code>内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foo(&#39;data&#39;);</span><br></pre></td></tr></table></figure>

<p>这样一来，我们如果在页面中先准备好<code>foo()</code>函数，然后给页面动态加一个<code>&lt;script&gt;</code>节点，相当于动态读取外域的<code>JavaScript</code>资源，最后就等着接收回调了。</p>
</li>
<li><p><code>CORS</code>：支持<code>HTML5</code>的浏览器可用的跨域策略</p>
</li>
</ul>
<p>参考资料</p>
<p><a href="http://www.runoob.com/ajax/ajax-intro.html">http://www.runoob.com/ajax/ajax-intro.html</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001434499861493e7c35be5e0864769a2c06afb4754acc6000</a></p>
<p><a href="http://www.w3school.com.cn/xml/xml_http.asp">http://www.w3school.com.cn/xml/xml_http.asp</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX">https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX</a></p>
]]></content>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(10)-覆盖equals时遵守通用约定</title>
    <url>/2019/07/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(10)-%E8%A6%86%E7%9B%96equals%E6%97%B6%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/</url>
    <content><![CDATA[<p>第10条：覆盖<code>equals</code>时遵守通用约定</p>
<p>覆盖<code>equals</code>方法看起来简单，但是有许多覆盖方式会导致错误，并且后果严重。</p>
<span id="more"></span>

<p>一个类满足以下任意一个条件，即可不覆盖<code>equals</code>:</p>
<ul>
<li><p>类的每个实例本质上都是唯一的</p>
<p>代表活动实体，而不是值，例如<code>thread</code>,Object提供的<code>equals</code>即可满足</p>
</li>
<li><p>不关心类是否提供了“逻辑相等(<code>logical equality</code>)”的测试功能</p>
</li>
<li><p>超类已经覆盖了<code>equals</code>，从超类继承过来的行为对于子类也是合适的，</p>
<p>例如，大多数Set实现从<code>AbstractSet</code>继承了<code>equals</code>实现、List实现从<code>AbstractList</code>继承了<code>equals</code>实现，Map实现从<code>AbstractMap</code>的Map继承了<code>equals</code>实现。</p>
</li>
<li><p>类是私有的或是包级私有的，可以确定它的<code>equals</code>方法永远不会被调用</p>
<p>这种比较特殊，但是其实也应该是覆盖<code>equals</code>方法的，以防止它被意外调用</p>
</li>
</ul>
<p>什么时候应该覆盖<code>equals</code>方法呢？</p>
<p>当一个类属于“值类”，我们在比较的时候，需要关注这个类是否“逻辑相等”，且这个类的父类没有覆盖<code>equals</code>方法，例如Integer、Date等类</p>
<p><code>equals</code>方法实现了等价关系(<code>equivalence relation</code>)，在覆盖equals方法时，需要遵守它的通用约定：</p>
<ul>
<li>自反性(<code>reflexive</code>)：对于任何非null引用值x，<code>x.equals(x)</code>必须返回true。</li>
<li>对称性(<code>symmetric</code>)：对于任何非null引用值x和y，当且仅当<code>y.equals(x)</code>返回true时<code>x.equals(y)</code>必须返回true。</li>
<li>传递性(<code>transitive</code>)：对于任何非null引用值x、y、z，如果<code>x.equals(y)</code>返回true，并且<code>y.equals(z)</code>也返回true，则<code>x.equals(z)</code>必须返回true。</li>
<li>一致性(<code>consistent</code>)：对于任何非null引用值x和y，如果在equals比较中使用的信息没有修改，则<code>x.equals(y)</code>的多次调用必须始终返回true或始终返回false。</li>
<li>非空性(<code>Non-nullity</code>)：对于任何非空引用x，<code>x.equals(null)</code>必须返回false。</li>
</ul>
<p>结合上述要求，实现高质量的<code>equals</code>方法的诀窍：</p>
<ol>
<li><p>使用<code>==</code>操作符检查“参数是否为这个对象的引用”</p>
<p>是增返回true</p>
</li>
<li><p>使用<code>instanceof</code>操作符检查“参数是否为正确的类型”</p>
<p>不是返回false</p>
</li>
<li><p>把参数转换成正确的类型</p>
<p>因为转换之前做了第三步的检查，所以确保会成功</p>
</li>
<li><p>对于该类中的每个“关键(<code>Significant</code>)”域，检查参数中的域是否与该对象中对应的域相匹配</p>
<p>如果是，则返回true，相反则返回false</p>
</li>
<li><p>当你编写完成了<code>equals</code>方法之后，应该确认三个问题：它是否是对称的、传递的、一致的</p>
<p>可编写单元测试来验证</p>
</li>
</ol>
<p>关于实现<code>equals</code>的其他告诫：</p>
<ul>
<li><p>覆盖<code>equals</code>时总要覆盖<code>hashCode</code></p>
</li>
<li><p>不要企图让<code>equals</code>方法过于智能</p>
<p>即满足简单的值域相等，不要过度追求各种等价关系</p>
</li>
<li><p>不要将<code>equals</code>声明中的Object对象替换为其他类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(MyClass o)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时不再是覆盖equals方法，而是重载，此时可以采用<code>@Override</code>方法来避免</p>
</li>
</ul>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(1)-考虑用静态工厂方法代替构造器</title>
    <url>/2019/01/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(1)-%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/</url>
    <content><![CDATA[<p>第1条：考虑用静态工厂方法代替构造器</p>
<p>静态工厂方法对比构造器的优势：</p>
<span id="more"></span>

<ul>
<li><p>有名称</p>
</li>
<li><p>不必在每次调用他们的时候都创建一个新对象</p>
</li>
<li><p>可以返回原返回类型的任何子类型的对象</p>
</li>
<li><p>在创建参数化类型实例的时候，它们使代码变得更加简洁,示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Map&lt;String,List&lt;String&gt;&gt; map = <span class="keyword">new</span> HashMap&lt;String,List&lt;String&gt;&gt;();</span><br><span class="line"></span><br><span class="line">使用静态工厂：</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">HashMap&lt;K,V&gt; <span class="title">newInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>静态工厂方法的缺点：</p>
<ul>
<li><p>主要缺点：类如果不含共有的或者受保护的构造器，就不能被子类化</p>
<blockquote>
<p>不过也有可能不是缺点，因为鼓励使用复合而不是继承</p>
</blockquote>
</li>
<li><p>他们与其他的静态方法实际上没有任何区别</p>
<blockquote>
<p>这导致他们没有在API文档中呗明确标识出来，此时通过文档查看如何示例话，比较困难</p>
</blockquote>
<p>此时使用一些静态工厂的惯用名，可以弥补这一劣势，惯用名称：</p>
<ul>
<li><code>valueOf</code>：该方法返回的实例与他的参数具有相同的值，这样的静态工厂实际上是类型转换方法</li>
<li><code>of</code>：<code>valueOf</code>的简洁替代</li>
<li><code>getInstance</code>：返回的实例是通过方法的参数来描述的，但是不能说与参数具有同样的值，对于<code>Singleton</code>来说，该方法没有参数，并返回唯一实例</li>
<li><code>newInstance</code>：像<code>getInstance</code>一样，但是<code>newInstance</code>能够确保返回的每个实例都与所有其他实例不同</li>
<li><code>getType</code>：像<code>getInstance</code>一样，但是在工厂方法处于不同的类中的时候使用，<code>Type</code>表示工厂方法所返回的对象类型</li>
<li><code>newType</code>：像<code>newInstance</code>一样，但是在工厂方法处于不用的类中的时候使用，<code>Type</code>表示工厂方法所返回的对象类型</li>
</ul>
</li>
</ul>
<p>总结：简而言之，静态工厂方法和共有构造器都各有用处，我们需要理解他们各自的长处，静态工厂通常更加合适，因此，切记第一反应就是提供公有的构造器，而不先考虑静态工厂。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>网络模型理解</title>
    <url>/2021/05/22/%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<p>目录</p>
<p>ISO/OSI七层模型</p>
<p>TCP/IP四层模型</p>
<p>数据封装过程</p>
<p>网络通信流程</p>
<span id="more"></span>

<h3 id="ISO-OSI七层模型"><a href="#ISO-OSI七层模型" class="headerlink" title="ISO/OSI七层模型"></a>ISO/OSI七层模型</h3><blockquote>
<p>ISO:国际标准化组织 OSI:开放系统互联模型</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E7%BD%91%E7%BB%9C/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B.png" alt="OSI七层模型"></p>
<p>OSI七层模型大致：上三层为用户提供服务 ，下四层是为数据传递提供服务的，其中物理层才负责实际的数据传输</p>
<p><strong>每层的具体作用:</strong></p>
<ul>
<li><p>应用层：用户接口</p>
</li>
<li><p>表示层：数据的表现形式(比如针对图片进行编码解码)、特定的功能的实现如-加密</p>
</li>
<li><p>会话层：对应用会话的管理、同步</p>
</li>
<li><p>传输层：可靠与不可靠的传输(确定传输协议后确定对应端口)、传输前的错误检测、流控 。注：主要是确定端口号</p>
<p>常见设备：四层交换机、四层的路由器</p>
</li>
<li><p>网络层：提供逻辑地址(源和目标的IP地址)、选路(选择经过路径，即通过的路由器) 。注：主要是确定IP地址</p>
<p>常见设备：路由器、三层交换机</p>
</li>
<li><p>数据链路层：成帧(在数据包中写入mac地址)、用mac地址访问媒介、错误检测于修正</p>
<p>常见设备：网桥、以太网交换机、网卡</p>
</li>
<li><p>物理层：设备之间的比特流(0101…)的传输、物理接口、电气特性等。</p>
<p>常见设备：中继器、集线器、双绞线</p>
<blockquote>
<p>物理层传输的数据是比特流的形式，就是001010….，0和1对于物理层来说就是两种状态 所以理论上任何能表示两种状态的物理现象并且可以传播的都可以用于传输数据 包括光 电 电磁波等等</p>
<p>对于我们日常用到的<strong>无线传输</strong> 采用的是电磁波的方式</p>
</blockquote>
</li>
</ul>
<p>七层模型理解示例（OSI七层模型并没有实际应用，该示例只是便于理解）：</p>
<ul>
<li>应用层：打开邮箱系统，编写内容，点击发送</li>
<li>表示层：将邮件内容进行编码，压缩或者加密</li>
<li>会话层：判断会不会进行网络传递，比如是邮件而不是PPT，是用来进行网络传递的</li>
<li>传输层：写入邮件端口号，确定邮件协议(TCP 发送数据端口25 接受数据端口110 )</li>
<li>网络层：把源和目标的IP地址写进去</li>
<li>数据链路层：增加源和目标的mac地址</li>
<li>物理层：数据传输</li>
</ul>
<h3 id="TCP-IP四层模型"><a href="#TCP-IP四层模型" class="headerlink" title="TCP/IP四层模型"></a>TCP/IP四层模型</h3><p>OSI七层模型只是模型，并没有在实际中使用，TCP/IP四层模型才是实际应用的模型</p>
<p>TCP/IP四层模型是从七层模型演变而来，可以对比理解，如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E7%BD%91%E7%BB%9C/%E6%A8%A1%E5%9E%8B%E5%AF%B9%E5%BA%94.png" alt="对应关系"></p>
<p>TCP/IP四层模型每层对应的协议：</p>
<ul>
<li><p>应用层</p>
<p>对用OSI参考模型的会话层、表示层、应用层，为用户提供所需要的各种服务且规定应用程序的数据格式。</p>
<p>例如：FTP、Telnet、DNS、SMTP等</p>
</li>
<li><p>传输层：</p>
<p>对应OSI参考模型的传输层，为应用层实体提供端到端的通信功能，保证了数据包的顺序传送及数据的完成性</p>
<p>主要协议：</p>
<ul>
<li><p>传输控制协议（TCP）,可靠地，面向连接的协议</p>
<p>TCP/IP三次握手流程如下图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E7%BD%91%E7%BB%9C/TCP%3AIP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png" alt="TCP/IP三次握手"></p>
<p>TCP 3次握手原因：</p>
<ol>
<li><p>确认双方接收能力和发送能力没有问题。</p>
<p>A-&gt;B ： 证明A的发送能力没有问题</p>
<p>B-&gt;A ： 证明B的接收能力和B的发送能力没有问题</p>
<p>A-&gt;B ： 证明A的接收能力没有问题</p>
</li>
<li><p><code>TCP</code>的可靠通信建立在<code>SEQ NUMBER</code>上，因此在刚开始的时候，需要互相交流起始的<code>SEQ NUM</code></p>
<p>A-&gt;B : 告诉A自己的其实seq num</p>
<p>B-&gt;A : 表示自己收到A的seq num,同时告诉A B的起始seq num</p>
<p>A-&gt;B： 表示A收到了B的seq</p>
</li>
<li><p>过滤失效的连接，比如A连接B，但是其实由于网络延迟原因A其实是一个很久之前发送的的连接，此时B建立了和A的连接，需要向A确认此条连接依然有效，因此B需要等待A的再次回应，避免B的资源泄露</p>
<p>PS：失效的连接请求：若客户端向服务端发送的连接请求丢失，客户端等待应答超时后就会再次发送连接请求，此时，上一个连接请求就是『失效的』。</p>
</li>
</ol>
</li>
<li><p>用户数据报协议（UDP），不可靠的，面向无连接的协议</p>
</li>
</ul>
</li>
<li><p>网际互联层：</p>
<p>对应OSI参考模型的网络层，主要解决主机到主机的通信问题</p>
<p>主要协议：</p>
<ul>
<li>网际协议（IP）</li>
<li>互联网组管理协议（IGMP）</li>
<li>互联网控制报文协议（ICMP），<code>ping</code>命令使用的协议</li>
</ul>
</li>
<li><p>网络接口层：</p>
<p>对应OSI参考模型的数据链路层和物理层，负责监视数据在主机和网络之间的交换</p>
<p>主要协议：</p>
<ul>
<li><p>地址解析协议（ARP，数据链路层）：把IP地址翻译成为网卡物理地址(mac地址)</p>
<blockquote>
<p>有了mac地址，同一网络内的两台主机就可以通信了（一台主机通过arp协议获取另外一台主机的mac地址）</p>
<p>arp协议：广播的方式发送数据包，获取目标主机的mac地址</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="实际使用中的数据封装的过程"><a href="#实际使用中的数据封装的过程" class="headerlink" title="实际使用中的数据封装的过程"></a>实际使用中的数据封装的过程</h4><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E8%BF%87%E7%A8%8B.png" alt="数据封装过程"></p>
<h3 id="网络通信流程"><a href="#网络通信流程" class="headerlink" title="网络通信流程"></a>网络通信流程</h3><ol>
<li><p>本机获取</p>
<ul>
<li>本机的IP地址：192.168.1.100</li>
<li>子网掩码：255.255.255.0</li>
<li>网关的IP地址：192.168.1.1</li>
<li>DNS的IP地址：8.8.8.8</li>
</ul>
</li>
<li><p>打开浏览器，想要访问Google，在地址栏输入了网址：<a href="http://www.google.com./">www.google.com。</a></p>
</li>
<li><p>dns协议，根据域名查找到对应IP地址</p>
</li>
<li><p>HTTP部分的内容，类似于下面这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GET &#x2F; HTTP&#x2F;1.1</span><br><span class="line">Host: www.google.com</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0 (Windows NT 6.1) ……</span><br><span class="line">Accept: text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,*&#x2F;*;q&#x3D;0.8</span><br><span class="line">Accept-Encoding: gzip,deflate,sdch</span><br><span class="line">Accept-Language: zh-CN,zh;q&#x3D;0.8</span><br><span class="line">Accept-Charset: GBK,utf-8;q&#x3D;0.7,*;q&#x3D;0.3</span><br><span class="line">Cookie: … …</span><br></pre></td></tr></table></figure>

<p>我们假定这个部分的长度为4960字节，它会被嵌在TCP数据包之中。</p>
</li>
<li><p>TCP协议</p>
<p>TCP数据包需要设置端口，接收方（Google）的HTTP端口默认是80，发送方（本机）的端口是一个随机生成的1024-65535之间的整数，假定为51775。</p>
<p>TCP数据包的标头长度为20字节，加上嵌入HTTP的数据包，总长度变为4980字节。</p>
</li>
<li><p>IP协议</p>
<p>然后，TCP数据包再嵌入IP数据包。IP数据包需要设置双方的IP地址，这是已知的，发送方是192.168.1.100（本机），接收方是172.194.72.105（Google）。</p>
<p>IP数据包的标头长度为20字节，加上嵌入的TCP数据包，总长度变为5000字节。</p>
</li>
<li><p>以太网协议</p>
<p>最后，IP数据包嵌入以太网数据包。以太网数据包需要设置双方的MAC地址，发送方为本机的网卡MAC地址，接收方为网关192.168.1.1的MAC地址（通过ARP协议得到）。</p>
<p>以太网数据包的数据部分，最大长度为1500字节，而现在的IP数据包长度为5000字节。因此，IP数据包必须分割成四个包。因为每个包都有自己的IP标头（20字节），所以四个包的IP数据包的长度分别为1500、1500、1500、560</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E7%BD%91%E7%BB%9C/%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B%E6%95%B0%E6%8D%AE.png" alt="img"></p>
</li>
<li><p>服务器端响应</p>
<p>经过多个网关的转发，Google的服务器172.194.72.105，收到了这四个以太网数据包。</p>
<p>根据IP标头的序号，Google将四个包拼起来，取出完整的TCP数据包，然后读出里面的”HTTP请求”，接着做出”HTTP响应”，再用TCP协议发回来。</p>
<p>本机收到HTTP响应以后，就可以将网页显示出来，完成一次网络通信。</p>
</li>
</ol>
<p>参考资料</p>
<p><a href="https://www.zhihu.com/question/24853633">TCP 为什么是三次握手，而不是两次或四次？-知乎</a></p>
<p><a href="https://www.cnblogs.com/linhaifeng/articles/5937962.html">网络基础之网络协议篇</a></p>
<p><a href="https://www.zhihu.com/question/35769259">无线的情况下，数据传输是如何实现的？-知乎</a></p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(11)-覆盖equals时总要覆盖hashCode</title>
    <url>/2019/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(11)-%E8%A6%86%E7%9B%96equals%E6%97%B6%E6%80%BB%E8%A6%81%E8%A6%86%E7%9B%96hashCode/</url>
    <content><![CDATA[<p>第11条：覆盖<code>equals</code>时总要覆盖<code>hashCode</code></p>
<p><strong>在每个类中，在重写 <code>equals</code> 方法的时侯，一定要重写 <code>hashcode</code> 方法</strong>。</p>
<span id="more"></span>

<p>如果不这样做，你的类将违反了<code>hashCode</code>的通用约定，这会阻止它在<code>HashMap</code>和<code>HashSet</code>这样的集合中正常工作。</p>
<p>根据 <code>Object</code> 规范，以下是具体约定：</p>
<ul>
<li>当在一个应用程序执行过程中，如果在<code>equals</code>方法比较中没有修改任何信息，在一个对象上重复调用<code>hashCode</code>方法时，它必须始终返回相同的值。从一个应用程序到另一个应用程序的每一次执行返回的值可以是不一致的。</li>
<li>如果两个对象根据<code>equals(Object)</code>方法比较是相等的，那么在两个对象上调用<code>hashCode</code>就必须产生相同结果的整数。</li>
<li>如果两个对象根据<code>equals(Object)</code>方法比较并不相等，则不要求在每个对象上调用<code>hashCode</code>都必须产生不同的结果。 但是，程序员应该意识到，为不相等的对象生成不同的结果可能会提高散列表（<code>hash tables</code>）的性能。</li>
</ul>
<p><strong>没有重写<code>hashCode</code>时，所违反第二个关键条款是：相等的对象必须具有相等的哈希码（ <code>hash codes</code>）</strong>。</p>
<p>一个好的散列方法趋向于：为不相等的实例生成不相等的哈希码。这也正是 <code>hashCode</code> 约定中第三条的表达。理想情况下，散列函数应该把集合中不相等的实例均匀地分布到所有可能的散列值上。实现这种理想情况可能是困难的。 幸运的是，要获得一个合理的近似的方式并不难。 以下是一个简单的解决方法：</p>
<ol>
<li><p>声明一个 <code>int</code> 类型的变量<code>result</code>，并将其初始化为对象中第一个重要属性<code>c</code>的哈希码，如下面步骤2.a中所计算的那样。</p>
</li>
<li><p>对于对象中剩余的重要属性<code>f</code>，请执行以下操作：</p>
<p>a. 计算属性<code>f</code> 的散列码<code>c</code><br>– i. 如果这个属性是基本类型的，使用<code>Type.hashCode(f)</code>方法计算，其中<code>Type</code>类是对应属性 f 基本类型的包装类。<br>– ii 如果该属性是一个对象引用，并且该类的equals方法通过递归调用<code>equals</code>来比较该属性，则同样递归地调用<code>hashCode</code>方法。 如果需要更复杂的比较，则计算此字段的“范式（<code>canonical representation</code>）”，并在范式上调用<code>hashCode</code>。 如果该字段的值为空，则使用<code>0</code>（也可以使用其他常数，但通常来使用<code>0</code>表示）。<br>– iii 如果属性<code>f</code>是一个数组，则要把每个元素当做单独的域来处理。 也就是说，递归的应用上述规则，对每个重要元素计算一个散列码，并且根据步骤2.b中的做法把这些散列值合并。 如果数组没有重要的元素，则使用一个常量，最好不要为<code>0</code>。如果所有元素都很重要，则可以使用<code>Arrays.hashCode</code>方法。</p>
<p>b. 将步骤2.a中<code>f</code>属性计算出的哈希码<code>c</code>合并到<code>result</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result &#x3D; 31 * result + c;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回 <code>result</code> 值。</p>
</li>
<li><p>写完之后，确认是否相等的实例有相同的散列码，可以编写单元测试进行验证</p>
</li>
</ol>
<blockquote>
<p>针对上述得到hashCode的流程，可能会奇怪与为什么我们选择31这个数字呢？</p>
<p>因为它是一个奇数的素数。 如果它是偶数，并且乘法溢出，信息将会丢失，因为乘以2相当于移位。 使用素数的好处不太明显，但习惯上都是这么做的。 </p>
<p>31的一个很好的特性，是在一些体系结构中乘法可以被替换为移位和减法以获得更好的性能：<code>31 * i ==（i &lt;&lt; 5） - i</code>。 现代JVM可以自动进行这种优化。</p>
</blockquote>
<p>在<code>hashCode</code>的编写中：</p>
<ul>
<li>排除派生属性（<code>derived fields</code>）。换句话说，如果一个属性的值可以根据参与计算的其他属性值计算出来，那么可以忽略这样的属性。</li>
<li>必须排除在<code>equals</code>比较中没有使用的任何属性，否则可能会违反<code>hashCode</code>约定的第二条。</li>
</ul>
<p>根据上述方法产生的<code>hashCode</code>的示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = Short.hashCode(areaCode);</span><br><span class="line">    result = <span class="number">31</span> * result + Short.hashCode(prefix);</span><br><span class="line">    result = <span class="number">31</span> * result + Short.hashCode(lineNum);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Objects</code>类有一个静态方法，它接受任意数量的对象并为它们返回一个哈希码。 这个名为<code>hash</code>的方法可以让你编写一行<code>hashCode</code>方法，其质量与根据这个项目中的上面编写的方法相当。 不幸的是，它们的运行速度更慢，因为它们需要创建数组以传递可变数量的参数，以及如果任何参数是基本类型，则进行装箱和取消装箱。 这种哈希函数的风格建议仅在性能不重要的情况下使用。 以下是使用这种技术编写的<code>PhoneNumber</code>的哈希函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// One-line hashCode method - mediocre performance</span></span><br><span class="line"><span class="meta">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> Objects.hash(lineNum, prefix, areaCode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果一个类是不可变的，并且计算哈希码的代价很大，那么可以考虑在对象中缓存哈希码，而不是在每次请求时重新计算哈希码。如果你认为这种类型的大多数对象将被用作哈希键，那么应该在创建实例时计算哈希码。 不过<strong>不要试图从哈希码计算中排除重要的属性来提高性能</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// hashCode method with lazily initialized cached hash code</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> hashCode; <span class="comment">// Automatically initialized to 0</span></span><br><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = hashCode;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        result = Short.hashCode(areaCode);</span><br><span class="line">        result = <span class="number">31</span> * result + Short.hashCode(prefix);</span><br><span class="line">        result = <span class="number">31</span> * result + Short.hashCode(lineNum);</span><br><span class="line">        hashCode = result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于<code>hashCode</code> ：<strong>不要为<code>hashCode</code>返回的值提供详细的规范，因此客户端不能合理地依赖它； 你可以改变它的灵活性</strong>。</p>
<p>总之，每次重写<code>equals</code>方法时都必须重写<code>hashCode</code>方法，否则程序将无法正常运行。且<code>hashCode</code>方法必须遵从<code>Object</code>类指定的常规约定，可以使用文章中的方法来实现分布较均匀的<code>hashCode</code></p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(12)-始终要覆盖toString</title>
    <url>/2019/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(12)-%E5%A7%8B%E7%BB%88%E8%A6%81%E8%A6%86%E7%9B%96toString/</url>
    <content><![CDATA[<p>第12条：始终要覆盖<code>toString</code></p>
<p>虽然<code>Object</code>类提供了<code>toString</code>方法的实现，但它返回的字符串通常不是想要的。 是由 <strong>类名</strong>+<strong><code>“at”</code>符号(<code>@</code>)</strong>+<strong>哈希码的无符号十六进制表示</strong> 组成的</p>
<span id="more"></span>

<p><code>toString</code>默认实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hashCode</span></span><br><span class="line"><span class="comment">/** As much as is reasonably practical, the hashCode method defined by</span></span><br><span class="line"><span class="comment"> * class &#123;<span class="doctag">@code</span> Object&#125; does return distinct integers for distinct</span></span><br><span class="line"><span class="comment"> * objects. (This is typically implemented by converting the internal</span></span><br><span class="line"><span class="comment"> * address of the object into an integer, but this implementation</span></span><br><span class="line"><span class="comment"> * technique is not required by the</span></span><br><span class="line"><span class="comment"> * Java&amp;trade; programming language.)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>  a hash code value for this object.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.Object#equals(java.lang.Object)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span>     java.lang.System#identityHashCode</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>; </span><br><span class="line"><span class="comment">//可以看到，默认hashCode是通过调用C/C++获取对象地址然后转换为一个整数而来。</span></span><br></pre></td></tr></table></figure>

<p>调用示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EquslsTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EquslsTest</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EquslsTest equslsTest=<span class="keyword">new</span> EquslsTest(<span class="number">5</span>);</span><br><span class="line">        System.out.println(equslsTest.hashCode());</span><br><span class="line">        System.out.println(equslsTest.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">5</span></span><br><span class="line">cn.zhangyuying.demo.EquslsTest@<span class="number">5</span></span><br></pre></td></tr></table></figure>

<p><code>toString</code>通用约定：“建议所有的子类都覆盖这个方法”。我们应该尽量遵循</p>
<p>对象在被<code>println</code>，<code>printf</code>,字符串连接，断言，调试打印的时候，<code>toString</code>方法会自动被调用。</p>
<p><code>toString</code>应该包含所有需要关注的对象的信息，一边以后在调试或者打印的时候，能够一目了然。</p>
<p>实现<code>toString</code>的时候，需要在文档中指定返回值的格式，虽然指定格式在以后的代码都要继续使用这种格式，不是很灵活，但是指定返回值的格式后，可以提供一个静态方法用来反序列化此对象，这样可以在对象和字符串中来回切换。在指定格式后，需要添加注释来说明用途，具体可以参照<code>BigInteger</code>，<code>BigDecimal</code>等。</p>
<p>在静态工具类中编写<code>toString</code>方法是没有意义的。 也不应该在大多数枚举类型中写一个<code>toString</code>方法，因为Java为你提供了一个非常好的方法。 但是，应该抽象类中定义<code>toString</code>方法，该类的子类共享一个公共字符串表示形式。 例如，大多数集合实现上的<code>toString</code>方法都是从抽象集合类继承的。</p>
<p>总之，除非父类已经重写了<code>toString</code>方法，否则在每个实例化的类中重写<code>Object</code>的<code>toString</code>实现。 它使得类更加舒适地使用和协助调试。 <code>toString</code>方法应该以一种美观的格式返回对象的简明有用的描述。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(13)-谨慎的覆盖clone方法</title>
    <url>/2019/07/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(13)-%E8%B0%A8%E6%85%8E%E7%9A%84%E8%A6%86%E7%9B%96clone%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<p>第13条：谨慎的覆盖<code>clone</code>方法</p>
<p>1.可以通过实现Cloneable接口重载对象的clone方法，若不实现Cloneable接口而重载clone方法，将会抛出<code>CloneNotSupportedException</code>异常。（这是比较反常的接口使用，因为Cloneable中没有任何方法，它所修改的父类上受保护方法的行为）</p>
<span id="more"></span>

<p>2.clone是唯一个创建对象但是却不需要调用构造方法的方法,正因为这样，也带来了很多问题。<br>3.clone方法通用规范：创建并返回此对象的副本</p>
<ul>
<li>对于任何对象x，<code>x.clone()!=x</code></li>
<li><code>x.clone().getClass()==x.getClass()</code></li>
</ul>
<p>下面解析一下以上规则，<code>x.clone()!=x</code>，使用的是<code>!=</code>表示两个对象所引用的堆的对象的地址是不同的，因此不能用简单的<code>Type x=y;</code>进行复制，第二条：<code>x.clone().getClass==x.getClass()</code>用的是<code>getClass</code>而不是<code>instanceof</code>，说明是严格判断，对于派生类什么的是不行的。</p>
<p>想要实现以上规则，我们需要：</p>
<ul>
<li>首先调用<code>super.clone()</code></li>
<li>对于每个<code>clone</code>方法中，给每个对象赋值的时候，需要调用对象的<code>clone</code></li>
<li>对于装载对象的容器，我们需要遍历容器调用容器里面的对象的<code>clone</code>方法，而不是直接调用容器的<code>clone</code>方法</li>
</ul>
<p>4.重写方法的返回类型可以是重写方法的返回类型的子类。</p>
<p>5.为了使一个类可以被克隆，可能需要从一些属性中移除final修饰符。</p>
<p>6.<code>clone</code>方法不能再构建过程中调用一个可以重写的方法。如果调用一个可重写的方法，子类很可能在克隆中的进行修复步骤之前执行该方法，这样可能会使得克隆和原始对象的损坏。</p>
<p>7.具有易用性的公共<code>clone</code>方法最好不要抛出<code>CloneNotSupportedException</code></p>
<p>8.父类不应该实现Cloneable接口，而是应该交由给子类自己选择是否支持<code>clone</code>方法。</p>
<p>9.最好的clone方法：</p>
<ul>
<li><p>通过类似C++的拷贝构造函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Yum(Yum yum)&#123;...&#125;；</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</li>
<li><p>通过静态工厂</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static Yun newInstance(Yum yum)&#123;...&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>相比Cloneable/clone方法：</p>
<ul>
<li>不用依赖于风险很大的语言外的对象创建机制：子类依赖于父类的良好的clone();首先调用super.clone()；</li>
<li>不要求遵守那些不太明确的管理– 不需要先实现Cloneable接口等</li>
<li>不会与final属性相冲突</li>
<li>不需要类型转换</li>
<li>不需要抛出不必要的检查异常</li>
</ul>
</li>
</ul>
<p>总之，最好不要实现Cloneable接口，通常，复制功能最好由构造方法或者工厂提供，这个规则有个例外：数组最好使用clone方法复制。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(15)-使类和成员的可访问性最小化</title>
    <url>/2019/07/30/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(15)-%E4%BD%BF%E7%B1%BB%E5%92%8C%E6%88%90%E5%91%98%E7%9A%84%E5%8F%AF%E8%AE%BF%E9%97%AE%E6%80%A7%E6%9C%80%E5%B0%8F%E5%8C%96/</url>
    <content><![CDATA[<p>第15条：使类和成员的可访问性最小化</p>
<p>1.封装(将其内部数据和实现细节隐藏起来)是软件设计的基本原则 <span id="more"></span></p>
<p>2.信息隐藏十分重要：可以并行开发，并且在对内部细节进行修改的时候，不会影响其他组件</p>
<p>4.<strong>让每个类或成员尽可能地不可访问</strong>。Java为了信息隐藏，提供了访问控制机制(<code>access control mechanism</code>)，指定了类，接口和成员的可访问性</p>
<ul>
<li>对于类和接口只有两个访问级别：<ul>
<li>包级私有（<code>package-private</code>）</li>
<li>公共的（<code>public</code>）</li>
</ul>
</li>
<li>对于成员(属性、方法、嵌套类和嵌套接口)，有四种可能的访问级别：<ul>
<li><code>private</code>——该成员只能在声明它的顶级类内访问。</li>
<li><code>package-private</code>——成员可以从被声明的包中的任何类中访问。从技术上讲，如果没有指定访问修饰符(接口成员除外，它默认是公共的)，这是默认访问级别。</li>
<li><code>protected</code>——成员可以从被声明的类的子类中访问(受一些限制，JLS，6.6.2)，以及它声明的包中的任何类。</li>
<li><code>public</code>——该成员可以从任何地方被访问。</li>
</ul>
</li>
</ul>
<p>5.<strong>公共类的实例属性很少公开</strong>，因为<strong>公共可变属性的类通常不是线程安全的</strong></p>
<p>非零长度的数组总是可变的，所以<strong>类具有公共静态final数组属性，或返回这样一个属性的访问器是错误的</strong>。 如果一个类有这样的属性或访问方法，客户端将能够修改数组的内容。 这是安全漏洞的常见来源：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Potential security hole!</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] VALUES = &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>有两种方法可以解决这个问题。 </p>
<ul>
<li>你可以使公共数组私有并添加一个公共的不可变列表</li>
<li>可以将数组设置为<code>private</code>，并添加一个返回私有数组拷贝的公共方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//公共的不可变列表</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Thing&gt; VALUES =</span><br><span class="line">Collections.unmodifiableList(Arrays.asList(PRIVATE_VALUES));</span><br><span class="line"><span class="comment">//返回私有数组拷贝的公共方法</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] PRIVATE_VALUES = &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Thing[] values() &#123;</span><br><span class="line">    <span class="keyword">return</span> PRIVATE_VALUES.clone();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>6.在Java 9中引入了模块的访问级别，不过现在还在观望</p>
<p>总而言之，应该尽可能地降低可访问性。 在仔细设计一个最小化的公共API之后，你应该防止任何散乱的类、接口或成员成为API的一部分。 除了作为常量的公共<code>static final</code> 域之外，公共类不应该有公共属性。 确保<code>public static final</code>属性引用的对象是不可变的。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(14)-考虑实现Comparable接口</title>
    <url>/2019/07/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(14)-%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>第14条：考虑实现<code>Comparable</code>接口</p>
<p>先看一段代码：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (length &lt; INSERTIONSORT_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=low; i&lt;high; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i; j&gt;low &amp;&amp;</span><br><span class="line">                 ((Comparable) dest[j-<span class="number">1</span>]).compareTo(dest[j])&gt;<span class="number">0</span>; j--)</span><br><span class="line">            swap(dest, j, j-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是<code>Arrays.sort();</code>中的一段代码,可以看见:</p>
<ul>
<li>想要使用集合工具中自带的<code>sort()</code>方法，只用实现<code>Comparable</code>接口。</li>
<li>在集合进行排序的时候，使用的是compareTo方法，也就是说，我们实现的值类，只要实现<code>Comparable</code>接口，重载compareTo方法即可。</li>
</ul>
<hr>
<p>在<code>java.util</code> 中，还有一个<code>Comparator&lt;T&gt;</code>接口方法，不过这个接口方法是对compareTo的另外一层包装。</p>
<p><strong>思考：</strong> 既然有了<code>Comparable</code>接口了，为什么还需要<code>Comparator&lt;T&gt;</code>呢？<br>其实仔细看看可以发现：<code>Comparable</code>是类自身需要实现的，让自身具有可比较性。而<code>Comparator&lt;T&gt;</code>是一个外部比较器，使用<code>Comparator&lt;T&gt;</code>可以让没有实现<code>Comparable</code>的类也能够使用类似<code>Collections.sort()</code>方法。</p>
<p>实现<code>Comparable</code>接口需要遵循的通用约定：</p>
<p>下面的描述中，符号sgn(expression)表示数学中的 signum 函数，它根据表达式的值为负数、零、正数，对应返回-1、0和1。</p>
<ul>
<li>实现类必须确保所有的<code>x</code>,和<code>y</code>都满足<code>sgn(x.compareTo(y))==-sgn(y.compareTo(x))</code>。(这意味着当且仅当<code>y.compareTo(x)</code>抛出异常的时候，<code>x.compareTo(y)</code>也必须抛出异常。</li>
<li>实现类必须确保该关系是可传递的：<code>x.compareTo(y)&gt;0&amp;&amp;y.compareTo(z)&gt;0)</code>意味着<code>x.compareTo(z)&gt;0</code>。</li>
<li>最后，对于所有的<code>z</code>,实现类必须确保<code>x.compareTo(y)==0</code>意味着<code>sgn(x.compareTo(z))==sgn(y.compareTo(z))</code></li>
<li>强烈推荐<code>(x.compareTo(y)==0)==(x.equals(y))</code>，但不是必须的。一般来说，任何实现了<code>Comparable</code>接口的类违反了这个条件都应该清楚的在接口注释和文档中说明。（只是推荐，但不是必须）</li>
</ul>
<p>简单来说：就是<strong>对称性</strong>，<strong>传递性</strong>，<strong>自反性</strong>。</p>
<p>这里多说一点：<br>这几个性质对于派生类来说，都很容易出现问题，如果一个派生类增加了一个新的属性。那么</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">父类.compareTo(子类)可能&#x3D;&#x3D;0</span><br><span class="line">子类.compareTo(父类)可能&#x3D;&#x3D;1</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>引起这个问题的原因就是子类多出来的属性。<br>解决方法和<code>equals</code>解决方法一样：</p>
<p><strong>不使用继承，将父类作为一个属性，注入到另外的类中</strong></p>
<p>1.类实现<code>comparable</code>接口的时候，对于属性可以调用属性的<code>compareTo</code>接口，若属性没有实现<code>Compareable</code>可以使用<code>Comparator</code>方法。</p>
<p>2.使用<code>Comparator</code>为了性能优化，可以使用Java的静态导入。比如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Comparator&lt;PhoneNumber&gt; COMPARATOR =</span><br><span class="line">        comparingInt((PhoneNumber pn) -&gt; pn.areaCode)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.prefix)</span><br><span class="line">          .thenComparingInt(pn -&gt; pn.lineNum);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(PhoneNumber pn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> COMPARATOR.compare(<span class="keyword">this</span>, pn);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.不要使用<code>&quot;&gt;&quot;</code>,<code>&quot;&lt;&quot;</code>来实现<code>compareTo</code>，容易出现整数最大长度溢出和IEEE 754浮点计算失真，可以使用包装类的比较方法。</p>
<p>总而言之，无论何时实现具有合理排序的值类，你都应该让该类实现<code>Comparable</code>接口，以便在基于比较的集合中轻松对其实例进行排序，搜索和使用。 比较<code>compareTo</code>方法的中的字段值时，请避免使用”&lt;”和”&gt;”运算符。 可以使用包装类中的静态<code>compare</code>方法或<code>Comparator</code>接口中的构建方法。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(2)-遇到多个构造器参数时要考虑用构建器</title>
    <url>/2019/07/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(2)-%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%A6%81%E8%80%83%E8%99%91%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8/</url>
    <content><![CDATA[<p>第2条：遇到多个构造器参数时要考虑用构建器</p>
<p>静态工厂和构造器有个共同的局限性：它们都不能很好的扩展到大量的可选参数</p>
<p>那么对于具有大量可选参数的类，如何编写呢？</p>
<span id="more"></span>

<h4 id="1-重叠构造器"><a href="#1-重叠构造器" class="headerlink" title="1.重叠构造器"></a>1.重叠构造器</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line">    <span class="keyword">private</span> String str3;</span><br><span class="line">    <span class="keyword">private</span> String str4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">        <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String str1, String str2, String str3,)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">        <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">        <span class="keyword">this</span>.str3 = str3;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">(String str1, String str2, String str3, String str4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">        <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">        <span class="keyword">this</span>.str3 = str3;</span><br><span class="line">        <span class="keyword">this</span>.str4 = str4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于重叠构造器：</p>
<p>重叠构造器模式可行，但是当有许多参数的时候，客户端代码会很难编写，并且仍然较难以阅读。</p>
<h4 id="2-javaBeans模式"><a href="#2-javaBeans模式" class="headerlink" title="2.javaBeans模式"></a>2.javaBeans模式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line">    <span class="keyword">private</span> String str3;</span><br><span class="line">    <span class="keyword">private</span> String str4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr1</span><span class="params">(String str1)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr2</span><span class="params">(String str2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr3</span><span class="params">(String str3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str3 = str3;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStr4</span><span class="params">(String str4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str4 = str4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Test test=<span class="keyword">new</span> Test();</span><br><span class="line">   test.setStr1(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">   test.setStr2(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">   test.setStr3(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">   test.setStr4(<span class="string">&quot;4&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于javaBeans模式：</p>
<ol>
<li>构造被分到了几个调用中，在构造过程中JavaBean可能处于不一致的状态，类无法仅仅通过校验构造器参数的有效性来保证一直性，当因为使用状态不一致对象产生问题时，排查困难。</li>
<li>阻止了把类做成不可变的可能，需要额外的努力确保线程安全</li>
</ol>
<h4 id="3-Builder模式"><a href="#3-Builder模式" class="headerlink" title="3.Builder模式"></a>3.Builder模式</h4><p><strong>既能保证像重叠构造器那样的安全性，也能保证像JavaBeans那么好的可读性</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String str1;</span><br><span class="line">    <span class="keyword">private</span> String str2;</span><br><span class="line">    <span class="keyword">private</span> String str3;</span><br><span class="line">    <span class="keyword">private</span> String str4;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Test</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.str1 = builder.str1;</span><br><span class="line">        <span class="keyword">this</span>.str2 = builder.str2;</span><br><span class="line">        <span class="keyword">this</span>.str3 = builder.str3;</span><br><span class="line">        <span class="keyword">this</span>.str4 = builder.str4;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String str1;</span><br><span class="line">        <span class="keyword">private</span> String str2;</span><br><span class="line">        <span class="keyword">private</span> String str3;</span><br><span class="line">        <span class="keyword">private</span> String str4;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String str1, String str2)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str1 = str1;</span><br><span class="line">            <span class="keyword">this</span>.str2 = str2;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setStr3</span><span class="params">(String str3)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str3 = str3;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setStr4</span><span class="params">(String str4)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.str4 = str4;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> Test <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Test(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Test test = <span class="keyword">new</span> Test.Builder(<span class="string">&quot;str1&quot;</span>, <span class="string">&quot;str2&quot;</span>).setStr3(<span class="string">&quot;str3&quot;</span>).setStr4(<span class="string">&quot;str4&quot;</span>).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>对于Builder模式：</p>
<ol>
<li><p>模拟了具名的可选参数</p>
</li>
<li><p>builder构造器可以对其参数进行强加约束</p>
</li>
<li><p>灵活、可以有多个多变参数，可以使用一个builder构建多个对象</p>
</li>
<li><p>可以进行泛型约束，比如builder都实现接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>不足： </p>
<ol>
<li><p>为了创建对象，需要先创建他的构造器，虽然创建构造器的开销在实践中不明显，但是在十分注重性能的情况下，会有影响</p>
</li>
<li><p>比重叠构造器更加冗长，所以只有在很多参数的时候才使用。</p>
<p>但是：你可能增加参数，如果一开始使用构造器或静态工厂，等到类需要的时候才添加构建器就会无法控制，那些过时的构造器和静态工厂显得十分的不协调，所以最好是一开始就使用构建器</p>
</li>
</ol>
<p>简而言之：如果类的构造器或者静态工厂中具有多个参数，设计这种类时，Builder模式就是种不错的选择</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(16)-在公共类中使用访问方法而不是公共属性</title>
    <url>/2019/07/31/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(16)-%E5%9C%A8%E5%85%AC%E5%85%B1%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95%E8%80%8C%E4%B8%8D%E6%98%AF%E5%85%AC%E5%85%B1%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>第16条：在公共类中使用访问方法而不是公共属性</p>
<p>退化类(<code>degenerate classes</code>)指的只有属性而没有其他操作的类，这样的类不应该直接提供公共属性，可以使用<code>getter</code> 和<code>setter</code>  <span id="more"></span></p>
<p>对于公共类来说，坚持面向对象是正确的：<strong>如果一个类在其包之外是可访问的，则提供访问方法</strong>来保留更改类内部表示的灵活性。</p>
<p>总之，公共类不应该暴露可变属性。对于不可变属性被暴露危害较小。 然而，有时包级私有或私有内部类可以暴露属性，无论此属性是否是可变的。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(3)-用私有构造器或者枚举类型实现Singleton属性</title>
    <url>/2019/07/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(3)-%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E8%80%85%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0Singleton%E5%B1%9E%E6%80%A7/</url>
    <content><![CDATA[<p>第3条：用私有构造器或者枚举类型实现<code>Singleton</code>属性</p>
<p><code>Singleton</code>指仅仅被实例化一次的类，即单例类</p>
<span id="more"></span>

<p>可使用三种方法：</p>
<p>1.公有域</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with public final field</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2.静态工厂</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Singleton with static factory</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Elvis INSTANCE = <span class="keyword">new</span> Elvis();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Elvis</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Elvis <span class="title">getInstance</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> INSTANCE; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于序列化：</p>
<p>想要以上两种方式实现的<code>Singleton</code>类变成是可序列化的(<code>Serializable</code>)，仅仅在声明中加上“<code>implements Serializable</code>”是不够的，因为仅仅这样做，会导致每次反序列化一个序列化的实例时，都会创建一个新的实例。所以在声明中加上“<code>implements Serializable</code>”后，需要声明所有实例域都是瞬时的(<code>transient</code>)，并提供一个<code>readResolve</code>方法,即自己实现序列化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// readResolve method to preserve singleton property</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">// Return the one true Elvis and let the garbage collector</span></span><br><span class="line">     <span class="comment">// take care of the Elvis impersonator.</span></span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.枚举</p>
<p>包含单个元素的枚举类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Enum singleton - the preferred approach</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Elvis</span> </span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">leaveTheBuilding</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>枚举方式在功能上与公有域方法相近，但是它更加简洁，无偿的提供了序列化机制，绝对防止多次实例化，即使在面对复杂的序列化或者反射攻击的时候</p>
<p>单元素的枚举类型已经成为实现Singleton的最佳方法</p>
<p>题外话：</p>
<p>关于单例类的创建，此篇博客只讨论的饿汉式，具体可参见<a href="http://zhangyuying.cn/2018/08/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式</a></p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(4)-使用私有构造方法实现非实例化</title>
    <url>/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(4)-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%AE%9E%E4%BE%8B%E5%8C%96/</url>
    <content><![CDATA[<p>第4条：使用私有构造方法实现非实例化</p>
<p>有时会编写这样的类：只包含一些静态方法和属性，例如：<code>java.lang.Math</code> 、<code>java.util.Arrays</code> 或<code>java.util.Collections</code></p>
<p>这样的类(<code>utility classes</code>) 不是设计用来被实例化的：因为实例对于这样的类是没有意义的</p>
<span id="more"></span>

<p>但是编辑器在没有显式构造器的情况下是默认提供了一个公共的、无参的默认构造方法，所以导致可以实例化这个类。</p>
<p>不过只有当类不包含显式构造方法时，才会生成一个默认构造方法，<strong>因此可以通过设置一个私有构造方法来实现类的非实例化</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Noninstantiable utility class</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UtilityClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Suppress default constructor for noninstantiability</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">UtilityClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line">    &#125;</span><br><span class="line">    ... <span class="comment">// Remainder omitted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于设置私有构造方法：</p>
<ul>
<li>因为显式构造方法是私有的，所以在类之外是不可访问的。</li>
<li><code>AssertionError</code>异常不是严格要求的，但是它提供了一种保证，以防在类中意外地调用构造方法。它保证类在任何情况下都不会被实例化。</li>
<li>这个用法有点违反直觉，好像构造方法就是设计成不能调用的一样。因此，如前面所示，添加注释是种明智的做法。</li>
<li>这个用法有一个副作用，阻止了类的子类化。</li>
</ul>
<p>总而言之：对于只有类成员变量和类成员方法的类，可通过<strong>私有构造器</strong>的方式来实现这个类的非实例化，防止其他人错误使用</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(5)-使用依赖注入取代硬连接资源(hardwiring resources)</title>
    <url>/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(5)-%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8F%96%E4%BB%A3%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90(hardwiring%20resources)/</url>
    <content><![CDATA[<p>第5条：使用依赖注入取代硬连接资源(<code>hardwiring resources</code>)</p>
<p>当一个类依赖一个或多个底层资源，例如拼写检查器依赖字典，此时可能将这个类实现为静态工具类或者单例类：</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//静态工具类</span></span><br><span class="line"><span class="comment">// Inappropriate use of static utility - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// Noninstantiable</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//单例类</span></span><br><span class="line"><span class="comment">// Inappropriate use of singleton - inflexible &amp; untestable!</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary = ...;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SpellChecker</span><span class="params">(...)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> INSTANCE = <span class="keyword">new</span> SpellChecker(...);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是这两种方法对于这个类的使用这来说都不是让人很满意，因为拼写检查的字典可能不只是一个，需要支持多个，即静态工具类和单例对于行为被底层参数影响的类来说是不合适的，那么怎么处理呢？</p>
<p>可以采用<strong>依赖注入(<code>dependency injection</code>)的方式</strong></p>
<p>依赖注入通俗的解释就是将类所依赖的对象作为参数让使用者在调用的时候注入</p>
<p>即在创建新实例的时候把底层资源传递到构造方法中，依赖注入模式非常简单，许多程序员使用它多年而不知道它有一个名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dependency injection provides flexibility and testability</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpellChecker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lexicon dictionary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpellChecker</span><span class="params">(Lexicon dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dictionary = Objects.requireNonNull(dictionary);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String word)</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">suggestions</span><span class="params">(String typo)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>依赖注入同样适用于构造方法，静态工厂和 <code>builder</code>模式。</p>
<p>尽管依赖注入极大地提高了灵活性和可测试性，但它可能使大型项目变得混乱，这些项目通常包含数千个依赖项。使用依赖注入框架(如<code>Spring</code>)可以消除这些混乱。在此不对框架做介绍。</p>
<p>总之，一个类依赖于一个或多个底层资源且不同的资源的行为会影响它的行为时，不要使用单例或静态工具类来实现它，且不要让它直接创建这些资源。将资源或工厂传递给构造方法(或静态工厂或<code>builder</code>模式)。这种称为依赖注入的实践将极大地增强类的灵活性、可重用性和可测试性。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(6)-避免创建不必要的对象</title>
    <url>/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(6)-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>第6条：避免创建不必要的对象</p>
<p>一般来说，最好能重用对象而不是新建一个相同功能的对象</p>
<p>重用可以更快，如果对象是不变的，他总是可以被重用</p>
<span id="more"></span>

<p>重用对象的第一个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//不是</span></span><br><span class="line">String s = <span class="keyword">new</span> String(<span class="string">&quot;String&quot;</span>);  <span class="comment">// DON&#x27;T DO THIS!</span></span><br><span class="line"><span class="comment">//而应该是</span></span><br><span class="line">String s = <span class="string">&quot;String&quot;</span>; </span><br></pre></td></tr></table></figure>

<p>上述示例中，第2中方式使用单个String实例，而不是每次执行时创建一个新实例。此外，它可以保证对象运行在同一虚拟机上的包含相同的字符串字面量的任何其他代码重用</p>
<p>通过使用静态工厂方法(<code>static factory methods</code>)，可以避免创建不需要的对象。例如，工厂方法<code>Boolean.valueOf(String)</code> 比构造方法<code>Boolean(String</code>)更可取，后者在Java 9中被弃用。构造方法每次调用时都必须创建一个新对象，而工厂方法永远不需要这样做，在实践中也不需要。除了重用不可变对象，如果知道它们不会被修改，还可以重用可变对象。</p>
<p>对于重用对象的第二个示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//没有重用对象</span></span><br><span class="line"><span class="comment">// Performance can be greatly improved!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">            + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改为 重用对象</span></span><br><span class="line"><span class="comment">// Reusing expensive object for improved performance</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RomanNumerals</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Pattern ROMAN = Pattern.compile(</span><br><span class="line">            <span class="string">&quot;^(?=.)M*(C[MD]|D?C&#123;0,3&#125;)&quot;</span></span><br><span class="line">            + <span class="string">&quot;(X[CL]|L?X&#123;0,3&#125;)(I[XV]|V?I&#123;0,3&#125;)$&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isRomanNumeral</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ROMAN.matcher(s).matches();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>没有重用时，内部为正则表达式创建一个<code>Pattern</code>实例，并且只使用它一次，之后它就有资格进行垃圾收集。 创建<code>Pattern</code>实例是昂贵的。所以为了提高性能，作为类初始化的一部分，将正则表达式显式编译为一个<code>Pattern</code>实例（不可变），缓存它，并在<code>isRomanNumeral</code>方法的每个调用中重复使用相同的实例。</p>
<p>还有一种创建不必要的对象的方法是自动装箱(<code>autoboxing</code>)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Hideously slow! Can you spot the object creation?</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Long sum = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">0</span>; i &lt;= Integer.MAX_VALUE; i++)</span><br><span class="line">        sum += i;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个程序的结果是正确的，但由于写错了一个字符，运行的结果要比实际慢很多。变量<code>sum</code>被声明成了<code>Long</code>而不是<code>long</code>，这意味着程序构造了大约231不必要的<code>Long</code>实例（大约每次往<code>Long</code>类型的 <code>sum</code>变量中增加一个<code>long</code>类型构造的实例），把<code>sum</code>变量的类型由<code>Long</code>改为<code>long</code>，在我的机器上运行时间从6.3秒降低到0.59秒。这个教训很明显：<strong>优先使用基本类型而不是装箱的基本类型，也要注意无意识的自动装箱</strong>。</p>
<p>以上所有的对象重用当然并不是说创建对象是昂贵的，应该避免，相反，使用构造方法创建和回收小的对象是非常廉价的，而且除非像数据库连接那种创建成本非常高的对象，自己维护对象池是不明智的</p>
<p>总之，当你应该重用一个现有对象时，不要创建一个新的对象。</p>
<p>[当然：“当你应该创建新对象的时候，不要使用现有对象。”——当因重用对象而付出的代价要远远大于因创建重复对象而付出的代价，自然选择创建重复对象。</p>
<p>必要时没有创建重复对象，则会导致潜在的错误和安全漏洞；而不必要地创建对象只会影响程序的风格和性能。]</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(8)-避免使用Finalizer和Cleaner机制</title>
    <url>/2019/07/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(8)-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8Finalizer%E5%92%8CCleaner%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>第8条：避免使用<code>Finalizer</code>和<code>Cleaner</code>机制</p>
<p><strong><code>Finalizer</code>和<code>Cleaner</code>并不等同于C++中的析构函数，是不确定多久会被调用的，甚至有时候可能不会被调用，并且存在性能损失，因此除了作为一个安全网或者终止非关键的本地资源，不应该在<code>Finalizer</code>或<code>Cleaner</code>里面包含任何业务代码。</strong></p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(7)-消除过期的对象引用</title>
    <url>/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(7)-%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/</url>
    <content><![CDATA[<p>第7条：消除过期的对象引用</p>
<p>对于像java这样带有垃圾回收机制的语言，大部分的时候是不需要考虑内存管理的，但是也有时需要自己进行内存管理。</p>
<span id="more"></span>

<p>内存泄露示例：</p>
<p>内存泄露：由于垃圾回收器的活动的增加，或内存占用的增加，静默地表现为性能下降。 在极端的情况下，这样的内存泄漏可能会导致磁盘分页（<code> disk paging</code>），甚至导致内存溢出（<code>OutOfMemoryError</code>）的失败，但是这样的故障相对较少。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Can you spot the &quot;memory leak&quot;?</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Stack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Stack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[DEFAULT_INITIAL_CAPACITY];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Object e)</span> </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">        <span class="keyword">return</span> elements[--size];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Ensure space for at least one more element, roughly</span></span><br><span class="line"><span class="comment">     * doubling the capacity each time the array needs to grow.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elements.length == size)</span><br><span class="line">            elements = Arrays.copyOf(elements, <span class="number">2</span> * size + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>存在内存泄露的地方：如果一个栈增长后收缩，那么从栈弹出的对象不会被垃圾收集，因为即使使用栈的程序不再引用这些对象。但是栈还在维护对这些对象的过期引用（<code> obsolete references</code>）。 过期引用简单来说就是不被使用且永远不会解除的引用。 在这种情况下，元素数组“活动部分（<code>active portion</code>）”之外的任何引用都是过期的。 活动部分是由索引下标小于<code>size</code>的元素组成。</p>
<p>对于这种垃圾收集语言中的内存泄漏（更适当地称为无意的对象保留 <code>unintentional object retentions</code>）是隐蔽的。 如果无意中保留了对象引用，那么不仅这个对象排除在垃圾回收之外，而且该对象引用的任何对象也是如此。 即使只有少数对象引用被无意地保留下来，也可以阻止垃圾回收机制对许多对象的回收，这对性能产生很大的影响。</p>
<p>针对这种内存泄露如何解决呢？：**一旦对象引用过期，将它们设置为 <code>null</code>**。 </p>
<p>对于上述示例，当元素取出时，将他们设置为<code>null</code>，元素的引用即可被垃圾回收机制回收，如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (size == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EmptyStackException();</span><br><span class="line">    Object result = elements[--size];</span><br><span class="line">    elements[size] = <span class="keyword">null</span>; <span class="comment">// Eliminate obsolete reference</span></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而且取消过期引用的另一个好处是：如果它们随后被错误地引用，程序立即抛出<code>NullPointerException</code>异常，而不是悄悄地做继续做错误的事情。——尽可能快地发现程序中的错误是有好处的</p>
<p>不过<strong>清空对象引用应该是例外而不是规范</strong>。一般来说：<strong>当一个类自己管理内存时，程序员应该警惕内存泄漏问题</strong>。 其中每当一个元素被释放时，元素中包含的任何对象引用都应该被清除。</p>
<p>常见的内存泄露场景：</p>
<ol>
<li>上述描述的：类自己管理内存(例如示例中的<code>Stack</code>类自己管理内存<code>elements</code>)，没有及时处理过期引用</li>
<li>缓存：缓存中可能存在已经被遗忘的对象引用，或者随着时间的推移越来越没价值的对象引用。——可以使用<code>WeakHashMap</code>或者定时任务进行清理</li>
<li>监听器和其他回调，如果你实现了一个API，其客户端注册回调，但是没有显式地撤销注册回调，除非采取一些操作，否则它们将会累积。确保回调可以被垃圾回收的一种方法是只存储弱引用（<code>weak references</code>），例如，仅将它们保存在<code>WeakHashMap</code>的键（<code>key</code>）中。</li>
</ol>
<p>总之：因为内存泄漏通常不会表现为明显的故障，所以它们可能会在系统中保持多年。 通常仅在仔细的代码检查或借助堆分析器（ <code>heap profiler</code>）的调试工具才会被发现。 因此，学习如何预见这些问题，并防止这些问题发生，是非常值得的。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava(9)-使用try-with-resources语句替代try-finally语句</title>
    <url>/2019/07/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava(9)-%E4%BD%BF%E7%94%A8try-with-resources%E8%AF%AD%E5%8F%A5%E6%9B%BF%E4%BB%A3try-finally%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<p>第9条：使用<code>try-with-resources</code>语句替代<code>try-finally</code>语句</p>
<p>Java类库中包含许多必须通过调用<code>close</code>方法手动关闭的资源。 比如<code>InputStream</code>，<code>OutputStream</code>和<code>java.sql.Connection</code>。 如果经常忽视关闭资源，其性能结果可想而知。 尽管这些资源中有很多使用finalizer机制作为安全网，但finalizer机制却不能很好地工作（条目 8）。</p>
<span id="more"></span>

<p>从以往来看，<code>try-finally</code>语句是保证资源正确关闭的最佳方式，即使是在程序抛出异常或返回的情况下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个资源</span></span><br><span class="line"><span class="comment">// try-finally - No longer the best way to close resources!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(path));</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个资源</span></span><br><span class="line"><span class="comment">// try-finally is ugly when used with more than one resource!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        OutputStream out = <span class="keyword">new</span> FileOutputStream(dst);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">            <span class="keyword">int</span> n;</span><br><span class="line">            <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">                out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            out.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是使用<code>try-finally</code> 语句关闭资源，代码冗长且容易丢失异常。</p>
<p>Java 7引入了<code>try-with-resources</code>语句，所有这些问题一下子都得到了解决。不过要使用<code>try-with-resources</code>，需要关闭的资源必须实现 <code>AutoCloseable</code>接口，该接口由一个返回为<code>void</code>的<code>close</code>组成。Java类库和第三方类库中的许多类和接口现在都实现或继承了<code>AutoCloseable</code>接口。如果你编写的类表示必须关闭的资源，那么这个类也应该实现<code>AutoCloseable</code>接口。</p>
<p>使用<code>try-with-resources</code>语句重新实现上述代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个资源</span></span><br><span class="line"><span class="comment">// try-with-resources - the the best way to close resources!</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">           <span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">       <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个资源</span></span><br><span class="line"><span class="comment">// try-with-resources on multiple resources - short and sweet</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String src, String dst)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream   in = <span class="keyword">new</span> FileInputStream(src);</span><br><span class="line">         OutputStream out = <span class="keyword">new</span> FileOutputStream(dst)) &#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUFFER_SIZE];</span><br><span class="line">        <span class="keyword">int</span> n;</span><br><span class="line">        <span class="keyword">while</span> ((n = in.read(buf)) &gt;= <span class="number">0</span>)</span><br><span class="line">            out.write(buf, <span class="number">0</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// try-with-resources 语句中也可以捕获异常，添加catch子句的，例如</span></span><br><span class="line"><span class="comment">// try-with-resources with a catch clause</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> String <span class="title">firstLineOfFile</span><span class="params">(String path, String defaultVal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> (BufferedReader br = <span class="keyword">new</span> BufferedReader(</span><br><span class="line">           <span class="keyword">new</span> FileReader(path))) &#123;</span><br><span class="line">        <span class="keyword">return</span> br.readLine();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> defaultVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结论明确：在处理必须关闭的资源时，使用<code>try-with-resources</code>语句替代<code>try-finally</code>语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。<code> try-with-resources</code>语句在编写必须关闭资源的代码时会更容易，也不会出错。</p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：一.对象导论</title>
    <url>/2018/08/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E4%B8%80-%E5%AF%B9%E8%B1%A1%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<p>现在java编程思想看到第五章，由于博客是按照创建时间排序，所以前四章先创建，内容以后补充</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：七.复用类</title>
    <url>/2018/08/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E4%B8%83-%E5%A4%8D%E7%94%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>代码重用机制：</p>
<ul>
<li>组合：在新的类中产生现有类的对象，由于新的类是由现有类的对象所组成，所以这种方法称为组合</li>
<li>继承：按照现有类的类型来创建新类，无需改变现有类形式采用现有类的形式并在其中添加代码。继承是面向对象的基石之一。</li>
</ul>
<span id="more"></span>

<p>1.组合语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  A a; <span class="comment">//组合，使用现有类A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：</p>
<ul>
<li>每一个非基本类型的对象都有一个toString()方法，而且当编译器需要一个String,而你却只有一个对象时，该方法便会被调用。</li>
<li>编译器并不是简单的为每一个引用都创建默认对象，如果想初始化这些引用，可以在代码中的下列位置进行<ul>
<li>在定义对象的地方，这意味着他们总是能够在构造器被调用之前被初始化</li>
<li>在类的构造器中</li>
<li>就在正要使用这些对象之前，这种方式成为<code>惰性初始化</code> ，在生成对象不值得及不必每次都生成对象的情况下，这种方式可以减少额外负担</li>
<li>使用实例初始化(new A())</li>
</ul>
</li>
</ul>
<p>2.继承语法</p>
<p>当创建一个类时，总是在继承。因为除非已明确声明要从其它类继承，否则就是在隐式地从java标准根类Object进行继承</p>
<p>继承使用 <strong>extends</strong>关键字</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123; <span class="comment">//B继承自A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**<code>super</code> **表示超类</p>
<p>在继承过程中，并不一定非得使用基类的方法，也可以在导出类中添加新方法（子类对象可调用自己的方法，也可调用父类对象的所有可用方法）</p>
<p>继承中初始化的保证：</p>
<ul>
<li>在构造器中调用基类构造器来执行初始化，而基类构造器具有执行基类初始化所需要的所有知识和能力</li>
<li>java会自动在导出类的构造器中插入对基类构造器的调用（默认构造器）</li>
<li>如果没有默认的基类构造器，或者想调用一个带参数的基类构造器，就必须用关键字<code>super</code> 显示的编写调用基类构造器的语句，并配以适当的参数列表。</li>
<li>由于以上保证，构建过程是：从基类“向外”扩散的，所以基类在导出类可以访问他之前，就已经完成了初始化</li>
</ul>
<p>注：</p>
<ul>
<li><code>+=</code> 操作符将几个String对象连接成一个String，此操作符是被java设计者重载用以处理String对象的操作符之一（还有<code>+</code>）</li>
<li>一个类似包访问权限，其public main(),仍然是可访问的</li>
</ul>
<p>3.代理</p>
<p>是继承和组合的中庸之道：我们将一个成员对象置于所要构造的类中（就像组合），但与此同时我们在新类中暴露了该对象的所有（可选择）成员方法（就像继承）</p>
<p>【像代理模式】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//例子场景：A找B帮忙洗衣服，但是实际上是洗衣机在洗衣服，所以B算代理。（比较牵强！）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WashingMachine</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">washClothes</span><span class="params">(String clothes)</span></span>&#123;</span><br><span class="line">    System.out.println(clothes+<span class="string">&quot;已洗完！&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  WashingMachine washingMachine =<span class="keyword">new</span> WashingMachine();</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">washClothes</span><span class="params">(String clothes)</span></span>&#123;</span><br><span class="line">    washingMachine.washClothes(clothes);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  B b = <span class="keyword">new</span> B();</span><br><span class="line">  b.washClothes(<span class="string">&quot;A的衣服！&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>4.结合使用组合和继承</p>
<p>组合和继承可以结合使用，具体使用结合实际</p>
<p>清理：</p>
<ul>
<li>如果想要某个类清理一些东西就要显示编写方法来做这件事，首要任务是：必须将这一清理动作置于finally字句中。（预防异常的出现）</li>
<li>顺序：执行类所有特定的清理动作，其顺序同生成顺序相反。（通常这就要求基类元素仍旧存活，防止仍然被使用到）</li>
</ul>
<p>名称屏蔽：如果java的基类拥有某个已经被对此重载的方法名称，那么在导出类中重新定义该方法名称，并不会屏蔽其在基类中的任何版本。因此：无论是在该层或者它的基类中对方法进行定义，重载机制都可以正常工作</p>
<p><strong><code>@override</code></strong> 注解可以防止你在不想重载时而意外进行了重载！</p>
<p>5.在组合与继承之间选择</p>
<p>组合和继承都允许在新的类中放置子对象，组合是显示的这样做，继承是隐式的这样做</p>
<p>组合：**<code>has-a</code> (有一个)的关系** 通常用于想在新类中使用现有类的功能而非他的接口这种形式，即：在新类中嵌入某个对象，让其实现所需要的功能，但新类的用户看到的只是为新类所定义的接口，而非所嵌入对象的接口（为达到这个效果，需要在新类中嵌入一个现有类的private对象）</p>
<p>继承：**<code>is-a</code> (是一个)的关系**  :使用某个现有类，并开发一个他的特殊版本，通常这意味着，你在使用一个通用类，并为了某种特殊需要而将其特殊化</p>
<p>到底使用组合还是继承也可参照 <code>7.向上转型</code>中提到的判断方式</p>
<p>6.protected关键字</p>
<p>访问权限：</p>
<ul>
<li>相同包内的其他成员也可以访问</li>
<li>继承的子类可以访问</li>
</ul>
<p>最好将域保持为<code>private</code> (为了保留更改底层实现的权利)，然后通过<code>protected</code> 方法来控制类的继承者的访问权限</p>
<p>7.向上转型</p>
<p>集成最重要的方面不是为新的类提供方法，而是表现新类和基类之间的关系： <strong>新类是现有类的一种类型</strong></p>
<p>将子类引用转化为基类引用的动作，我们称之为 <strong>向上转型</strong></p>
<p>为什么称为向上转型：由导出类转型成基类，在继承图上是向上移动的，因此一般称为向上转型</p>
<p>到底使用组合还是继承：一个最清晰的判断就是问一问自己是否需要从新类向基类进行向上转型，如果必须向上转型，则继承是必要的，如果不需要，就要考虑自己是否需要继承</p>
<p>8.final关键字</p>
<p>final：无法改变的（没有static的时候，是指在一个对象中恒定不变）</p>
<p>（1）、final数据</p>
<ul>
<li>对于基本类型：final使数据恒定不变<ul>
<li>我们不能因为某个数据是<code>final</code> 的就认为在编译时可以知道它的值，也可以在运行时随机生成这个数据</li>
</ul>
</li>
<li>对于引用：final使引用恒定不变(一个引用初始化指向一个对象，就无法再把他指向另一个对象，然而，对象自身确实可以修改的！这个情况同样适用与数组（数组也是对象）)</li>
<li>一个既是<code>static </code>又是<code>final</code> 的域只占据一段不能改变的存储空间<ul>
<li>既是<code>static </code>又是<code>final</code> 的域，将用大写表示，并用下划线分隔各个单词</li>
</ul>
</li>
</ul>
<p>空白final：是指被声明为final,但又未给定初值的域，无论什么时候，编译器都确保空白final在使用前必须被初始化（必须在域的定义处或者每个构造器中用表达式对final进行赋值）</p>
<p>空白final在final上提供了更大的灵活性：一个类中的final域，就可以做到根据对象不同而有所不同，却又保持其恒定不变的特性</p>
<p>final参数：java允许在参数列表中以声明的方式将参数指明为final</p>
<ul>
<li>若参数是引用，这意味着无法在方法中更改参数引用所指向的对象</li>
<li>若参数是基本类型，你可以读参数，却无法更改参数，这一特性主要用来像匿名内部类传递数据</li>
</ul>
<p>（2）final方法</p>
<p>使用原因：</p>
<ul>
<li>把方法锁定，不允许继承类修改他的含义（在继承类行为保持不变，并且不会被覆盖）</li>
<li>效率（java 5以后差别不大）</li>
</ul>
<p>（3）、final类</p>
<p>当某个类的整体定义为<code>final</code> 时,表明这个类不允许被继承。这时final类中的所有方法都隐式的指定为<code>final</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在设计类时，不想其他类继承时，可以考虑将这个类定义为<code>final</code></p>
<p>9.初始化及类的加载</p>
<p>java的加载方式：因为java中都是对象，每个类的编译代码都存在与他自己的独立文件中，该文件只在需要使用程序代码时待会被加载：类的代码在初次使用时才加载（创建类对象或是访问static域或方法。初次使用之处，也是static初始化发生之处）</p>
<p>继承与初始化：</p>
<p>在继承中：先加载基类在依次加载子类，这种方式很重要：因为导出类的static的初始化可能会依赖与基类成员能否被正确初始化</p>
<p>必要的类加载完毕，对象就开始创建了，由于继承的存在此处对象的创建是先基类在子类，对象的具体创建过程可参照第五章对象的创建过程，</p>
<p>10.总结</p>
<p>开始一个设计时，应优先选择组合，在必要时才使用继承</p>
<p>程序开发是一种增量过程</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：三.操作符</title>
    <url>/2018/08/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%AC%A6/</url>
    <content><![CDATA[<p>现在java编程思想看到第五章，由于博客是按照创建时间排序，所以前四章先创建，内容以后补充</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：九.接口</title>
    <url>/2018/08/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E4%B9%9D-%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>接口和内部类为我们提供了一种将接口与实现分离的更加结构化的方法</p>
<span id="more"></span>

<h4 id="1-抽象类和抽象方法"><a href="#1-抽象类和抽象方法" class="headerlink" title="1.抽象类和抽象方法"></a>1.抽象类和抽象方法</h4><p>抽象方法：这种方法是不完整的，仅有声明而没有方法体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<p>包含抽象方法的类叫做抽象类</p>
<p>如果一个类包含一个或多个抽象方法，该类必须被限定为抽象的（否则编译器报错）</p>
<h4 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h4><p><code>abstract</code>关键字允许在类中创建一个或多个没有定义的方法，但是没有提供具体实现，这些实现是有此类的继承者创建的</p>
<p><code>interface</code>关键字产生一个完全抽象类，它根本就没有提供任何具体实现，它允许创建者确定方法名、参数列表和返回类型，但是没有任何方法体，接口只提供了形式，而未提供任何具体实现</p>
<ul>
<li>接口中的域隐式的是<code>static</code>和<code>final</code>的</li>
<li>接口中的域和方法都是<code>public</code>的(不管你声不声明)</li>
</ul>
<p>接口用来建立类与类之间的协议</p>
<p>要让一个类遵循某个特定接口（或是一组接口），使用<code>implements</code>关键字</p>
<ul>
<li>当实现一个接口时，在接口中被定义的方法必须是被定义的<code>publlic</code>的（在继承中，可访问权限降低是java编译器不允许的）</li>
</ul>
<h4 id="3-完全解耦"><a href="#3-完全解耦" class="headerlink" title="3.完全解耦"></a>3.完全解耦</h4><p>将接口从具体实现中解耦使得接口可以应用于多种不同的具体实现，因此代码也就更具可复用性</p>
<p>可使用策略模式、适配器模式、代理模式等实现复用</p>
<h4 id="4-Java中的多重继承"><a href="#4-Java中的多重继承" class="headerlink" title="4.Java中的多重继承"></a>4.Java中的多重继承</h4><p>java中只可以继承（extends）一个类,但是可以实现（implements）多个接口（并可以向上转型为任一接口）</p>
<ul>
<li>当一个类同时继承类和实现接口时，继承类要放在前面（否则编译器报错）</li>
</ul>
<p>使用接口的核心原因：</p>
<ul>
<li>为了能够向上转型为多个基类型（以及由此而带来的灵活性）</li>
<li>防止客户端程序员创建该类对象，并确保这仅仅是一个接口（这一点和抽象类相同）</li>
</ul>
<p>选择接口还是抽象类：如果创建不带任何方法定义和成员变量的基类，那么就应该选择接口而不是抽象类。事实上，如果知道某事物应该成为一个基类，那么第一选择应该是使他成为一个接口</p>
<h4 id="5-通过继承来扩展接口"><a href="#5-通过继承来扩展接口" class="headerlink" title="5.通过继承来扩展接口"></a>5.通过继承来扩展接口</h4><p>通过继承，可以很容易的在接口中添加新的方法声明，还可以通过继承在新接口中组合数个接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  f1()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">  f2()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//当前语法只适用于接口继承</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span> <span class="keyword">extends</span> <span class="title">A</span> , <span class="title">B</span> </span>&#123;</span><br><span class="line">  f3()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  f4()&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，当<code>A</code>和<code>B</code>中同时存在方法<code>f()</code> 的时候，<code>C</code> 是不可以同时实现<code>A</code>和<code>B</code>的</p>
<p><code> =&gt;</code> 在打算组合的不同接口中使用相同的方法名通常会造成代码可读性混乱，尽量避免</p>
<h4 id="6-适配接口"><a href="#6-适配接口" class="headerlink" title="6.适配接口"></a>6.适配接口</h4><p>接口允许同一个接口具有多个不同的具体实现，所以接口的常见用法：</p>
<ul>
<li>策略模式</li>
<li>适配器模式</li>
</ul>
<p>一个接口的方法接受的参数是一个接口：相当于<code>=&gt;</code> 你可以用任何你想要的对象来调用我的方法，只要你的对象遵循我的接口</p>
<p>所以这意味着让方法接受接口类型，是一种让任何类都可以对该方法进行适配的方式。这也体现了接口的强大</p>
<h4 id="7-接口中的域"><a href="#7-接口中的域" class="headerlink" title="7.接口中的域"></a>7.接口中的域</h4><p>接口中的域都自动是<code>static</code>和<code>final</code>的（也自动是<code>public</code>的），所以接口是便捷的用来创建常量的工具，<code>java5</code>以后，应该更倾向于更加强大而灵活的<code>enum</code> 关键字</p>
<p>接口中的域不能是“空final”,但是可以是非常量表达式</p>
<p>这些域不是接口的一部分，他们的值被存储在该接口的静态存储区域内</p>
<h4 id="8-嵌套接口"><a href="#8-嵌套接口" class="headerlink" title="8.嵌套接口"></a>8.嵌套接口</h4><p>接口可以嵌套在其他类或其他接口中</p>
<p>当实现某个接口时，并不需要实现嵌套在其内部的任何接口，而且private接口不能在定义他的类之外被实现</p>
<h4 id="9-接口与工厂"><a href="#9-接口与工厂" class="headerlink" title="9.接口与工厂"></a>9.接口与工厂</h4><p>接口是实现多继承的途径，而生成某个接口的对象的典型方式就是工厂方法设计模式</p>
<p>理论上，通过这种方式，我们的代码将完全与接口的实现分离，这使得我们可以透明的像某个实现替换为另一个实现</p>
<h4 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h4><p>恰当的原则应该是优先选择类而不是接口，从类开始，如果接口的必需性变得非常明确，那么就进行重构。</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>EffectiveJava笔记目录</title>
    <url>/2019/07/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%E7%AC%94%E8%AE%B0%E7%9B%AE%E5%BD%95/</url>
    <content><![CDATA[<p><strong>第二章.创建和销毁对象</strong></p>
<p><a href="http://zhangyuying.cn/2019/01/14/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%281%29-%E8%80%83%E8%99%91%E7%94%A8%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BF%E6%9E%84%E9%80%A0%E5%99%A8/">1. 考虑使用静态工厂方法替代构造方法</a><br><a href="http://zhangyuying.cn/2019/07/15/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%282%29-%E9%81%87%E5%88%B0%E5%A4%9A%E4%B8%AA%E6%9E%84%E9%80%A0%E5%99%A8%E5%8F%82%E6%95%B0%E6%97%B6%E8%A6%81%E8%80%83%E8%99%91%E7%94%A8%E6%9E%84%E5%BB%BA%E5%99%A8/">2. 当构造方法参数过多时使用<code>builder</code>模式</a><span id="more"></span><br><a href="http://zhangyuying.cn/2019/07/16/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%283%29-%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E5%99%A8%E6%88%96%E8%80%85%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B%E5%AE%9E%E7%8E%B0Singleton%E5%B1%9E%E6%80%A7/">3. 使用私有构造方法或枚类实现<code>Singleton</code>属性</a><br><a href="http://zhangyuying.cn/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%284%29-%E4%BD%BF%E7%94%A8%E7%A7%81%E6%9C%89%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E5%AE%9E%E7%8E%B0%E9%9D%9E%E5%AE%9E%E4%BE%8B%E5%8C%96/">4. 使用私有构造方法执行非实例化</a><br><a href="http://zhangyuying.cn/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%285%29-%E4%BD%BF%E7%94%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%8F%96%E4%BB%A3%E7%A1%AC%E8%BF%9E%E6%8E%A5%E8%B5%84%E6%BA%90%28hardwiring%20resources%29">5. 使用依赖注入取代硬连接资源</a><br><a href="http://zhangyuying.cn/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%286%29-%E9%81%BF%E5%85%8D%E5%88%9B%E5%BB%BA%E4%B8%8D%E5%BF%85%E8%A6%81%E7%9A%84%E5%AF%B9%E8%B1%A1/">6. 避免创建不必要的对象</a><br><a href="http://zhangyuying.cn/2019/07/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%287%29-%E6%B6%88%E9%99%A4%E8%BF%87%E6%9C%9F%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8/">7. 消除过期的对象引用</a><br><a href="http://zhangyuying.cn/2019/07/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%288%29-%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8Finalizer%E5%92%8CCleaner%E6%9C%BA%E5%88%B6/">8. 避免使用<code>Finalizer</code>和<code>Cleaner</code>机制</a><br><a href="http://zhangyuying.cn/2019/07/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%289%29-%E4%BD%BF%E7%94%A8try-with-resources%E8%AF%AD%E5%8F%A5%E6%9B%BF%E4%BB%A3try-finally%E8%AF%AD%E5%8F%A5/">9. 使用<code>try-with-resources</code>语句替代<code>try-finally</code>语句</a></p>
<p><strong>第三章.对于所有对象都通用的方法</strong></p>
<p><a href="http://zhangyuying.cn/2019/07/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%2810%29-%E8%A6%86%E7%9B%96equals%E6%97%B6%E9%81%B5%E5%AE%88%E9%80%9A%E7%94%A8%E7%BA%A6%E5%AE%9A/">10. 覆盖<code>equals</code>方法时遵守通用约定</a><br><a href="http://zhangyuying.cn/2019/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%2811%29-%E8%A6%86%E7%9B%96equals%E6%97%B6%E6%80%BB%E8%A6%81%E8%A6%86%E7%9B%96hashCode/">11. 覆盖<code>equals</code>方法时总要重写<code>hashcode</code>方法</a><br><a href="http://zhangyuying.cn/2019/07/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%2812%29-%E5%A7%8B%E7%BB%88%E8%A6%81%E8%A6%86%E7%9B%96toString/">12. 始终覆盖<code>toString</code> 方法</a><br><a href="http://zhangyuying.cn/2019/07/26/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%2813%29-%E8%B0%A8%E6%85%8E%E7%9A%84%E8%A6%86%E7%9B%96clone%E6%96%B9%E6%B3%95/">13. 谨慎地覆盖<code> clone</code> 方法</a><br><a href="http://zhangyuying.cn/2019/07/29/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Effective%20Java/EffectiveJava%2814%29-%E8%80%83%E8%99%91%E5%AE%9E%E7%8E%B0Comparable%E6%8E%A5%E5%8F%A3/">14.考虑实现<code>Comparable</code>接口</a></p>
<p><strong>第四章.类和接口</strong></p>
]]></content>
      <tags>
        <tag>《Effective Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：二.一切都是对象</title>
    <url>/2018/08/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E4%BA%8C-%E4%B8%80%E5%88%87%E9%83%BD%E6%98%AF%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>现在java编程思想看到第五章，由于博客是按照创建时间排序，所以前四章先创建，内容以后补充</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：二十-注解</title>
    <url>/2019/02/24/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E4%BA%8C%E5%8D%81-%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<p>注解(也被称为元数据)，为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据</p>
<span id="more"></span>

<p>注解使得我们能够以将由编译器来测试和验证的格式，存储有关程序的额外信息，注解可以用来生成描述符文件，甚至或是新的类定义，并且有助于减轻编写“样板”代码的负担</p>
<p><code>java SE5</code>内置了三种，定义在<code>java.lang</code>中的注解（标准注解）</p>
<ul>
<li><code>@Override</code></li>
<li><code>@Deprecated</code></li>
<li><code>@SuppressWarnings</code></li>
</ul>
<h4 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h4><p>注解的定义很像是接口的定义，事实上与其他任何<code>java</code>接口一样，注解也会编译成<code>class</code>文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test1()&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>在注解中一般会包含某些元素以表示某些值，当分析注解时，程序或工具可以利用这些值，没有元素的注解称为标记注解</p>
<p>有元素注解示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;no description&quot;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure>

<p>在定义注解时，会需要一些元注解(<code>meta-annotation</code>),如<code>@Target</code>和<code>@Retention</code></p>
<ul>
<li><p><code>@Target</code>用来定义你的注解将应用于什么地方（例如一个方法或是一个域）,<code>ElementType</code>可选值包括：</p>
<ul>
<li><code>CONSTRUCTOR</code>：构造器的声明</li>
<li><code>FIElD</code>：域声明（包括<code>enum</code>元素）</li>
<li><code>LOCAL_VARIABLE</code>：局部变量声明</li>
<li><code>METHOD</code>：方法声明</li>
<li><code>PACKAGE</code>：包声明</li>
<li><code>PARAMETER</code>：参数声明</li>
<li><code>TYPE</code>：类、接口（包含注解类型）或<code>enum</code>声明</li>
</ul>
<p>如果想要将该注解应用于所有的<code>ElementType</code>，那么可以省去<code>@Target</code>元注解，不过这不常见</p>
</li>
<li><p><code>@Retention</code>用来定义该注解在哪一个级别可用，</p>
<ul>
<li><code>SOURCE</code>：在源代码中，注解被编译器丢弃</li>
<li><code>CLASS</code>：类文件中，注解在<code>class</code>文件中可用，但会被<code>jvm</code>丢弃</li>
<li><code>RUNTIME</code>：运行时，<code>JVM</code>在运行期也保留注解，因此可以通过反射机制读取注解信息</li>
</ul>
</li>
<li><p><code>@Decumented</code>：将次注解包含在<code>javadoc</code>中</p>
</li>
<li><p><code>@Inherited</code>：允许子类继承父类中的注解</p>
</li>
</ul>
<p>大多数情况，程序员自己定义注解，并编写自己的处理器来处理他们</p>
<h4 id="2-编写注解处理器"><a href="#2-编写注解处理器" class="headerlink" title="2.编写注解处理器"></a>2.编写注解处理器</h4><p>在使用注解的过程中，很重要的一个部分就是创建与使用注解处理器</p>
<p>一般可使用反射获取注解并对注解进行处理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestTracker</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">trackTest</span><span class="params">(Class&lt;?&gt; cl)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Method m : cl.getDeclaredMethods())&#123;</span><br><span class="line">      Test test = m.getAnnotation(Tset.class);</span><br><span class="line">      <span class="keyword">if</span>(test!=<span class="keyword">null</span>)&#123;</span><br><span class="line">        System.out.println(test.getId()+test.getDescription)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    trackTest(Utils.class)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注解元素的可用类型如下：</p>
<ul>
<li>所有基本类型（<code>int</code>、<code>float</code>、<code>boolen</code>等）</li>
<li><code>String</code></li>
<li><code>Class</code></li>
<li><code>enum</code></li>
<li><code>Annotation</code></li>
<li>以上类型的数组</li>
</ul>
<p>使用其他类型，编译器即将报错（特殊注意的是：也不允许使用任何包装类型）</p>
<p>对于注解的元素：不能有不确定的值，也就是说，元素要么具有默认值，要么在使用注解时提供元素的值</p>
<p>其次对于非基本类型的元素，无论是在源代码中声明时，或是在注解接口中定义默认值时，都不能以<code>null</code>作为其值，这个约束使得处理器很难表现一个元素的存在或是缺失的状态</p>
<ul>
<li><p>为类绕开这个约束，我们只能自己定义一些特殊的值，例如空字符串或负数，以表示某个元素不存在。在定义注解的时候，这算是一个习惯用法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target(ElementType.METHOD)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Test2 &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span> <span class="keyword">default</span> -1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> &quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果程序员的注解中定义了名为<code>value</code>的元素，并且在应用该注解的时候，该元素是唯一需要赋值的元素，那么此时无需使用名-值对的这种写法，而只需在括号内给出<code>value</code>元素所需的值即可，这可以应用于任何合法类型的元素，当然这也限制了程序员必须将此元素命名为<code>value</code>,不过这样可能更加简洁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SqlCount(30)</span></span><br></pre></td></tr></table></figure>

<p>使用对个注解的时候，同一个注解不能重复使用</p>
<p><strong>注解不支持继承</strong></p>
<ul>
<li>不能使用关键字<code>extends</code>来继承某个<code>@interface</code></li>
</ul>
<h4 id="3-使用apt处理注解"><a href="#3-使用apt处理注解" class="headerlink" title="3.使用apt处理注解"></a>3.使用<code>apt</code>处理注解</h4><p><code>apt</code>是注解处理工具</p>
<p><code>apt</code>与<code>javac</code>一样被设计为操作<code>java</code>源文件</p>
<p>使用<code>apt</code>生成注解处理器时，我们无法利用<code>java</code>的反射机制，因为我们操作的是源代码，而不是编译后的类</p>
<h4 id="4-基于注解的单元测试"><a href="#4-基于注解的单元测试" class="headerlink" title="4.基于注解的单元测试"></a>4.基于注解的单元测试</h4><p>在<code>java</code>中，最著名的单元测试就是<code>JUnit</code>,<code>JUnit</code>中就使用了注解</p>
<h4 id="5-总结"><a href="#5-总结" class="headerlink" title="5.总结"></a>5.总结</h4><p>注解是<code>java</code>引入的一项非常受欢迎的补充</p>
<p>他提供了一种结构化的，并且具有类型检查能力的新途径，从而使得程序员能够为代码加入元数据，而不会导致代码杂乱且难以阅读，使用注解能够帮助我们避免编写累赘的部署描述文件，以及其他生成的文件，而<code>javadoc</code>中的<code>@deprecated</code>被<code>@Deprecated</code>注解取代的事实也说明，与注释性文字相比，注解绝对更适合用于描述类相关的信息</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：五.初始化与清理</title>
    <url>/2018/08/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E4%BA%94-%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%8E%E6%B8%85%E7%90%86/</url>
    <content><![CDATA[<p>1.用构造器确保初始化：</p>
<p>构造器：java中通过构造器，类设计者可确保每个对象都会得到初始化：在创建对象时，如果其类具有构造器，java就会在用户有能力操作对象之前自动调用相应的构造器，从而保证了初始化的进行。（即用构造器确保初始化）</p>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：在创建对象时：</span><br><span class="line"><span class="keyword">new</span> Dog(); </span><br><span class="line">将会为对象分配存储空间（对象在堆上），并调用相应的构造器，这就确保了在你能操作对象之前，该对象已经被恰当的初始化了</span><br></pre></td></tr></table></figure>

<ul>
<li>构造器采用与类相同的名称（1.所起名称可能和类中其他成员方法冲突 2.调用构造器是编译器的责任，需要让编译器知道调用哪个方法）<ul>
<li>由于构造器的名称必须和类名完全相同，所以<code>每个方法首字母小写</code> 的编码风格并不适用于构造器 </li>
</ul>
</li>
</ul>
<ul>
<li><p>不接受任何参数的构造器叫做 <code>默认构造器</code> === <code>无参构造器</code></p>
<ul>
<li>构造器可带有形式参数，以便指定如何创建对象（有了构造器形式参数，就可以在初始化对象时，提供实际参数）</li>
</ul>
</li>
<li><p>概念上 <code>初始化</code> 和<code>创建</code> 是彼此独立的，在java中<code>初始化</code> 和<code>创建</code> 是捆绑在一起的，两者不能分离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">例如：</span><br><span class="line">Dog dog=<span class="keyword">new</span> Dog()  创建并初始化（构造器保证的初始化，调用的无参构造器）</span><br><span class="line">或</span><br><span class="line">Dog dog=<span class="keyword">new</span> Dog(<span class="string">&quot;tom&quot;</span>)）  创建并初始化（构造器保证的初始化，调用的有参构造器）</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造器是一种特殊类型的方法，他没有返回值</p>
<ul>
<li><p>与返回值为空（void）明显不同，对于空返回值，尽管方法本身不会自动返回什么，但是可以选择让他返回别的东西</p>
</li>
<li><p>构造器则不会返回任何东西，别无选择（new 表达式确实返回了对新建对象的引用，单构造器本身并没有任何返回值）</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<p>2.方法重载</p>
<p>每个方法要有唯一的名称（同一个类中）</p>
<ul>
<li><p>为了让方法名相同而形式参数不同的构造器同时存在（构造器名称必须和类名相同），必须用到方法重载（即构造器是强制重载方法名的一个原因）</p>
<ul>
<li>尽管方法重载是构造器所必须的，他也可应用于其他方法</li>
</ul>
</li>
<li><p>每个重载方法都必须有一个独一无二的参数列表（数量或是类型不同）</p>
</li>
<li><p>对于基本类型的重载：</p>
<ul>
<li>如果传入的数据类型（实际参数类型）小于方法中声明的形式参数类型，实际数据类型就会被提升</li>
<li>char类型略有不同，如果无法找到恰好接受char类型参数的方法，就会把char类型直接提升至int型</li>
<li>如果实际参数大于重载方法声明的形式参数：通过类型转化类执行窄化转化</li>
</ul>
</li>
<li><p>不可以返回值区分重载方法</p>
<ul>
<li><p>方法的构造要素为：方法名和参数列表(<strong>不包括返回值</strong>)，因此重载只能由返回值来重载，无法通过返回值来重载方法</p>
</li>
<li><p>有时的调用不关心方法的返回值，想要方法的其他效果（常被称为<code>为了副作用而调用</code>）</p>
<p>​</p>
</li>
</ul>
</li>
</ul>
<p>3.默认构造器</p>
<p>如果类中没有构造器，编译器会自动创建一个默认构造器，但是如果已经定义了一个构造器（无论是否有参数），编译器就不会帮你自动创建默认构造器了</p>
<p>4.this关键字</p>
<p>编译器会暗自（幕后操作）把<code>所操作对象的引用</code> 作为第一个参数传递给所调用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">即可理解为：</span><br><span class="line">方法：peel(<span class="keyword">int</span> i)</span><br><span class="line">a.peel（<span class="number">1</span>）  ————&gt; a.peel（a，<span class="number">1</span>） </span><br></pre></td></tr></table></figure>

<p>现在希望在方法内部中获得当前对象的引用，有专门的关键字：this</p>
<p>this关键字只能在方法内部使用，表示对<code>调用方法的那个对象</code> 的引用,只有需要明确指出当前对象的引用时，才需要使用this关键字</p>
<ul>
<li>一个类中有多个构造器，想在一个构造器中调用另一个构造器（避免重复代码），可使用this关键字<ul>
<li>可以用this调用一个构造器，却不能调用两个，而且必须将构造器调用置于最起始处，否则编译报错</li>
<li>除了构造器之外，编译器禁止在其他任何地方调用构造器</li>
</ul>
</li>
<li>一个方法中参数名称和该类中的成员名称相同，可使用this.name，代表类的成员名称，将两者区分</li>
</ul>
<p><strong>static方法就是没有this的方法</strong></p>
<p>5.清理：终结处理和垃圾回收</p>
<ul>
<li>对象可能不被垃圾回收</li>
<li>垃圾回收不等于析构</li>
<li>垃圾回收只与内存有关：垃圾回收是为了回收程序不在使用的内存</li>
</ul>
<p>垃圾回收器：</p>
<ul>
<li>找到垃圾<ul>
<li>引用计数法(有循环引用问题)</li>
<li>追溯引用法</li>
</ul>
</li>
<li>处理垃圾<ul>
<li>停止-复制法</li>
<li>标记-清扫法</li>
</ul>
</li>
</ul>
<blockquote>
<p>一般更多的是将他们结合起来，大对象标记，小对象复制</p>
</blockquote>
<p>6.成员初始化</p>
<p>对于方法中的局部变量，没有初始化便使用的话，编译器会报错</p>
<p>类的数据成员（字段）是基本类型时，每个基本类型数据成员保证都会有一个初始值（char为0，会显示为空白）</p>
<p>在类中定义一个引用时，如果不将其初始化，此引用会获得一个特殊值：null</p>
<p>指定初始化===为类中某个变量初始化</p>
<ul>
<li><p>1.可以在定义类成员变量的地方为其赋值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">double</span> weight = <span class="number">25</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.通过某个方法来提供初值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = f();</span><br><span class="line">  f()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这个方法也可以带有参数，但这些参数必须也是已经初始化了的</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Dog</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> age = f();       <span class="comment">//(1)语句1</span></span><br><span class="line">  <span class="keyword">int</span> weight= f2(age)  <span class="comment">//(2)语句2</span></span><br><span class="line">  </span><br><span class="line">  f()&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f2(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">return</span> i * <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>如果将上述程序<code>语句1</code>和<code>语句2</code> 互换位置，便会报错，因为初始化的顺序导致  f2()中使用的参数为被初始化</li>
</ul>
</li>
</ul>
</li>
<li><p>构造器初始化</p>
<p>可以使用构造器进行初始化：<strong>无法阻止自动初始化的进行，自动初始化将在构造器被调用之前发生</strong>（自动初始化引用的对象在不被使用的时候或被丢弃，并作为垃圾回收）</p>
<p>初始化的顺序：</p>
<ul>
<li>在类的内部，变量定义的先后顺序决定了初始化的顺序，即使变量定义散布在方法定义之间，他们仍然会在任何方法（包括构造器）被调用之前得到初始化</li>
</ul>
<p>静态初始化：</p>
<ul>
<li><p>无论创建多少个对象，<strong>静态数据都只占用一份存储区域</strong> </p>
</li>
<li><p>static关键字不能应用于局部变量，因此只能作用于域，如果一个域是静态的基本类型域，且也没有对她进行初始化，那么他会获得基本类型的标准初值，如果是对象引用，默认初始值是null</p>
</li>
<li><p>静态初始化只有在必要时刻才会进行：只有在第一个对象被创建，或者第一次访问静态数据的时候，他们才会被初始化，此后，静态对象不会被再次初始化</p>
</li>
<li><p>初始化的顺序是先静态对象，而后是非静态对象</p>
</li>
<li><p>*对象的创建过程**：假设有个<code>Dog</code>类</p>
</li>
</ul>
<ul>
<li>1.第一次访问<code>Dog</code>的静态方法（构造函数可看成静态方法）或者静态对象的时候，Java 解释器会先查找<code>Dog</code>类的路径，以定位Dog.class文件</li>
<li>2.JVM会载入<code>Dog.class</code>，并按定义顺序初始化所有<code>静态</code>变量</li>
<li>3.当使用<code>new Dog()</code>创建对象的时候，首先在堆上分配足够的存储空间</li>
<li>4.将分配的存储空间清零并将对象所有的成员自动初始化（将所有成员内存设为二进制零值而一举生成的）</li>
<li>5.执行所有出现在字段定义的时候的初始化操作</li>
<li>6.执行构造函数</li>
</ul>
<p>显示的静态初始化===多个静态初始化动作===静态块</p>
<ul>
<li>静态块内的数据与其他静态初始化动作一样</li>
</ul>
<p>非静态示例初始化：</p>
<ul>
<li><p>实例初始化：用来初始化每一个对象的非静态变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">示例初始化：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mug</span>()</span>&#123;</span><br><span class="line">  Mug(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    print(<span class="string">&quot;Mug&quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">  f(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    print(<span class="string">&quot;Mug f &quot;</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Mugs</span><span class="params">()</span></span>&#123;</span><br><span class="line">  Mug mug1;</span><br><span class="line">  Mug mug2;</span><br><span class="line">  <span class="comment">//实例初始化语句</span></span><br><span class="line">  &#123;</span><br><span class="line">    mug1=<span class="keyword">new</span> Mug(<span class="number">1</span>);</span><br><span class="line">    mug2=<span class="keyword">new</span> Mug(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  Mugs()&#123;</span><br><span class="line">    print(<span class="string">&quot;Mugs&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>实例初始化的语法对于支持 匿名内部类 的初始化是必须的</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code>* 实例初始化字句是在构造器之前执行的</code></pre>
<p>8.数组初始化</p>
<p>数组只是相同类型的、用同一个标识符名称封装到一起的一个对象序列活基本类型序列</p>
<p>数组是通过方括号下标操作符[]来定义和使用的</p>
<ul>
<li><p>数组的定义</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a  <span class="comment">//推荐</span></span><br><span class="line">或</span><br><span class="line"><span class="keyword">int</span> a[]</span><br></pre></td></tr></table></figure>
</li>
<li><p>上述语句只是拥有数据的一个引用（已经为该引用分配了足够的存储空间），但是没有给数据对象本身分配任何空间</p>
</li>
<li><p>为了给数组对象创建相应的存储空间，必须写初始化表达式</p>
<ul>
<li><p>特殊初始化：在创建数组的地方出现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>

<p>在java中可以将一个数组赋值给另一个数组：<strong>其实真正做的只是复制了一个引用</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a1;</span><br><span class="line">a1 = a;</span><br><span class="line">现在我修改 a1[<span class="number">0</span>] = <span class="number">5</span> 那么 a[<span class="number">0</span>] = <span class="number">5</span> (a[<span class="number">0</span>]也是等于<span class="number">5</span>因为复制的是引用)</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能确定数组中有多少个元素的初始化</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Random rand=<span class="keyword">new</span> Random(<span class="number">47</span>)</span><br><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">20</span>)] <span class="comment">//基本类型，定义的同时自动初始化，内部20个0</span></span><br><span class="line">Integer[] a2 =<span class="keyword">new</span> Integer[rand.nextInt(<span class="number">20</span>)]  <span class="comment">//非基本类型的数组自动初始化，内部20个null</span></span><br></pre></td></tr></table></figure>

<p>因为是随机数，数据的创建是在运行时创建的</p>
</li>
<li><p>也可以用花括号括起来的列表来初始化<code>对象</code>数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只用用于数组被定义的地方</span></span><br><span class="line">Integer[] a = &#123;</span><br><span class="line">  <span class="keyword">new</span> Integer(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> Integer(<span class="number">2</span>),</span><br><span class="line">  <span class="number">3</span> <span class="comment">//自动装箱</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可以任何地方使用 ：例如：提供参数使用：f(new String[]&#123;&quot;one&quot;,&quot;two&quot;&#125;)</span></span><br><span class="line">Ingteger b = <span class="keyword">new</span> Integer[] &#123;</span><br><span class="line">  <span class="keyword">new</span> Integer(<span class="number">1</span>),</span><br><span class="line">  <span class="keyword">new</span> Integer(<span class="number">2</span>),</span><br><span class="line">  <span class="number">3</span> <span class="comment">//自动装箱</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>所有数组都有一个固有成员：length :可以通过他获取数组有多少元素，但是不能修改。</p>
<ul>
<li>java 数据从0元素开始，所能使用的最大下标是 length-1</li>
</ul>
</li>
<li><p>可变参数列表：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">printArray(Object... args)&#123;</span><br><span class="line">  <span class="comment">//content</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当传入指定参数时，编译器会将参数填充为数组（所以直接传递数组也是可以的）</li>
<li>将0个参数传递给可变参数列表是可行的</li>
</ul>
</li>
</ul>
<p>9.枚举类型</p>
<p><strong>enum关键字</strong> javaSE5添加</p>
<p>在创建enum时，编辑器会自动添加一些有用的特性:</p>
<ul>
<li>toString()</li>
<li>ordinal():标识某个特定enum常量的声明顺序</li>
<li>static values() :按照enum常量的声明顺序，产生由这些常量值构成的数组</li>
</ul>
<p><strong>enum和switch是绝佳组合</strong></p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：八.多态</title>
    <url>/2018/08/20/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%85%AB-%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<p>多态：也称作动态绑定、后期绑定、或运行时绑定</p>
<h4 id="1-再论向上转型"><a href="#1-再论向上转型" class="headerlink" title="1.再论向上转型"></a>1.再论向上转型</h4><p>向上转型：把某个对象的引用视为对其基类型的引用的做法被称作向上转型</p>
<p>向上转型可能会“缩小”接口</p>
<span id="more"></span>

<h4 id="2-转机"><a href="#2-转机" class="headerlink" title="2.转机"></a>2.转机</h4><p>绑定：将一个方法调用同一个方法主体关联起来</p>
<ul>
<li>前期绑定：若在程序执行前进行绑定（如果有的话，由编译器和连接程序实现）</li>
<li>后期绑定：在运行时根据对象的类型进行绑定，又叫做动态绑定或运行时多态</li>
</ul>
<p>java中除了<code>static</code>方法和<code>final</code>方法（<code>private</code>方法属于<code>final</code>方法）之外，其他所有的方法都是后期绑定</p>
<p>可扩展性：</p>
<ul>
<li><p>多态的特性使我们所做的代码修改，不会对程序中其他不应该受到影响的部分产生破坏</p>
<p><code>===</code></p>
</li>
<li><p>多态是一项让程序员：将改变的事物与未变的事物分离开来 的重要技术</p>
</li>
</ul>
<p>缺陷：</p>
<ul>
<li>只有非private方法才可以被覆盖（<code>private</code>被自动认为是<code>final</code>），最好是在导出类中，对于基类的<code>private</code>方法，最好采用不同的名字</li>
<li>成员变量（域）和静态方法是没有多态的（静态方法是与类，而并非单个对象相关联的）</li>
</ul>
<h4 id="3-构造器和多态"><a href="#3-构造器和多态" class="headerlink" title="3.构造器和多态"></a>3.构造器和多态</h4><p>构造器并不具备多态性（他们实际上是static方法，只不过该static声明是隐式的）</p>
<p>基类的构造器总是导出类的构造过程中被调用，而且按照继承的层次逐渐向上链接已使每个积累的构造器都能得到调用（意义：构造器：检查对象是否被正确构造）</p>
<p>继承与清理：当子类的清理方法被调用时，一定要调用基类的清理方法，否则基类的清理动作不会发生。</p>
<blockquote>
<p> 销毁的顺序应该是和初始化的顺序相反，对于字段则意味着与声明的顺序相反（因为字段的初始化是按照声明顺序进行的）,应该首先对其导出类进行清理，然后才是基类，这是因为导出类的清理可能会调用基类的某些方法（依赖），所以需要使基类的构件仍起作用不应过早的销毁</p>
</blockquote>
<p>调用构造器的顺序：</p>
<ul>
<li>1.在其他任何事发生之前，将分配给对象的存储空间初始化成二进制的零</li>
<li>2.调用基类构造器，这个步骤会不断地反复递归下去，首先是构造这种层次结构的根，然后是下一层导出类，等等，直到最底层的导出类</li>
<li>3.按声明顺序调用成员的初始化方法</li>
<li>4.调用导出类构造器的主体</li>
</ul>
<p>编写构造器时有一条有效准则：用尽可能简单的方法是对象进入正常状态，如果可以的话，避免调用其他方法。（在构造器内能够安全调用的那些方法是基类中的<code>final</code>方法）</p>
<h4 id="4-协变返回类型"><a href="#4-协变返回类型" class="headerlink" title="4.协变返回类型"></a>4.协变返回类型</h4><p>在导出类中被覆盖的方法可以返回基类方法的返回类型的某种导出类型</p>
<h4 id="5-用继承进行设计"><a href="#5-用继承进行设计" class="headerlink" title="5.用继承进行设计"></a>5.用继承进行设计</h4><p>进行设计时：首先考虑组合</p>
<p>一条通用准则： <strong>用继承表达行为间的差异，并用字段（组合）表达状态上的变化</strong></p>
<p><code>纯粹的is-a（是一种）</code> 关系：只有在基类中已经建立的方法才可以在导出类中被覆盖，也可认为是纯替代</p>
<p>运行时类型识别（RTTI）：在java中，所有转型都会得到检查，即使我们只是进行一次普通的加括弧形式的类型转换，在进入运行期时仍然会对其进行检查，以保证他的确四我们希望的那种类型，如果不是，就会返回一个<code>ClassCastException</code>(类转型异常),这种在运行期间对类型进行检查的行为被称作 运行时类型识别</p>
<p>RTTI不仅包括转型处理，例如还提供在向下转型之前可以查看你所要处理的类型的方法</p>
<h4 id="6-总结"><a href="#6-总结" class="headerlink" title="6.总结"></a>6.总结</h4><p>多态是建立在数据抽象和继承的基础之上的</p>
<p>多态是一种不能单独来看待的特性（例如<code>switch</code>是可以的）,他是类关系全景中的一部分</p>
<p>为了有效的在程序中运用多态乃至面向对象技术，要扩展自己的编程视野，使其不仅包括个别类的成员和消息，还要包括类与类之间的共同特性以及他们之间的关系。这样做可以使程序更好扩展、更好维护等。</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十-内部类</title>
    <url>/2018/09/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<p>可以将一个类的定义放在另一个类的内部，这就是内部类</p>
<span id="more"></span>

<h4 id="1-创建内部类"><a href="#1-创建内部类" class="headerlink" title="1.创建内部类"></a>1.创建内部类</h4><p>把类定义在外围类的里面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Inner <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想在外部的非静态方法之外的任意位置创建某个内部类的对象，那么必须具体的指明这个对象的类型：<code>Outer.Inner</code></p>
<p>例如： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.inner = outer.getInner();</span><br></pre></td></tr></table></figure>

<h4 id="2-链接到外部类"><a href="#2-链接到外部类" class="headerlink" title="2.链接到外部类"></a>2.链接到外部类</h4><p>当生成一个内部类对象时，此对象与制造他的<code>外围对象</code>之间就有了一种<strong>联系</strong>，所以他能访问其<code>外围对象</code>的所有成员，而不需要任何特殊条件，此外，内部类还拥有其外围类的所有元素的访问权</p>
<blockquote>
<p> 为什么 内部类还拥有其外围类的所有元素的访问权？</p>
<p> ​    当某个外围类的对象创建了一个内部类对象时，此内部类对象必定会秘密的捕获一个指向那个外围类的引用，然后当你访问此外围类的成员时，就是用那个引用来选择外围类的成员</p>
<p> ​    //编译器帮我们处理细节，我们看到的只是：内部类对象只能在与其外围类对象相关联的情况下才能被创建</p>
</blockquote>
<h4 id="3-使用-this和-new"><a href="#3-使用-this和-new" class="headerlink" title="3.使用.this和.new"></a>3.使用.this和.new</h4><p>(1) <code> .this</code></p>
<p>如果想要生成对外部类的引用，可以使用外部类的名字后面紧跟圆点和<code>this</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Outer <span class="title">getOuter</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> Outer.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这样产生的引用自动的具有正确的类型，</p>
<p>这一点在编译期就被知晓并受到检查，因此没有任何运行时的开销。</p>
</blockquote>
<p>(2)  <code>.new</code></p>
<p>创建某个内部类的对象，必须在new表达式提起器外部类的引用，使用<code>.new</code>语法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Inner为Outer中的内部类</span></span><br><span class="line">Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">// 错误写法 ： Outer.Inner inner = outer.new Outer.Inner();</span></span><br></pre></td></tr></table></figure>

<h4 id="4-内部类与向上转型"><a href="#4-内部类与向上转型" class="headerlink" title="4.内部类与向上转型"></a>4.内部类与向上转型</h4><p>内部类的向上转型为基类，尤其是转型为一个接口的时候：此内部类 <code>===</code> 某个接口的实现 <code>===</code> 能够完全不可见，并且不可用。</p>
<p>所得到的只是指向基类或接口的引用，所以很方便的实现隐藏细节</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">External</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">External</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> External <span class="title">getInner</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestInner</span> </span>&#123;</span><br><span class="line">  Outer outer = <span class="keyword">new</span> Outer();</span><br><span class="line">  <span class="comment">//所得到的只是指向基类或接口的引用</span></span><br><span class="line">  External external = outer.getInner();</span><br><span class="line">  <span class="comment">//报错： Outer.Inner inner = outer.new Inner() //can&#x27;t access private class</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>private</code> 的内部类给类的设计者提供了一种途径，通过这种方式可以完全阻止任何依赖于类型的编码，并且完全 <strong>隐藏了实现的细节</strong></p>
<p>此外，从客户端程序员角度来看，由于不能访问任何新加的，不属于公共接口的方法，所以扩展接口是没有价值的，这位编译器提供了生成更高效代码的机会</p>
</blockquote>
<h4 id="5-在方法和作用域内的内部类"><a href="#5-在方法和作用域内的内部类" class="headerlink" title="5.在方法和作用域内的内部类"></a>5.在方法和作用域内的内部类</h4><p>可以在一个方法里面或者在任意的作用域内定义内部类内定义内部类</p>
<p>理由：</p>
<ul>
<li><p>实现某类型的接口，于是可以创建并返回对其的应用</p>
</li>
<li><p>要解决一个复杂问题，想创建一个类来辅助你的解决方案，但是又不希望这个类是公共可用的</p>
</li>
<li><p>*局部内部类**：在方法的作用域内（而不是在类的作用域内），创建一个完整的类</p>
</li>
</ul>
<p>局部内部类可以在任何作用域中，并且出了这个作用域之外是不可用的（但是这个内部类的创建不是有条件的是，是和其他类一起编译过了的）。</p>
<blockquote>
<p>局部内部类不能有访问说明符，因为他不是外围类的一部分，但是他可以访问当前代码块内的常量，以及此外围类的所有成员</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">External</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> External <span class="title">getExternal</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="comment">// if(true)&#123; 可以打开注释，这个完整的类，可以在任何作用域，并且除了这个作用域之外他是不可用的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">External</span> </span>&#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Inner();</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6.匿名内部类"></a>6.匿名内部类</h4><p>匿名内部类：如下示例。指的是：创建一个继承自<code>External</code> 的匿名类对象，通过<code>new</code> 表达式返回的引用被自动向上转型为<code>External</code> 的引用。例如示例1</p>
<ul>
<li>定义匿名内部类，并且希望他使用一个在其外部定义的对象，那么编译器会要求其参数引用时final的（传给匿名类的基类的构造器使用的参数不要求一定是final的，因为并不会在匿名类内部被直接使用），示例3</li>
<li>匿名内部类不能有命名构造器（因为他根本没有名字），但是通过 <code>实例初始化</code> 能够达到为匿名内部类创建一个构造器的效果，（但是有限制：不能重载，所以仅有一种(即使多个代码块也是一种)）示例4</li>
</ul>
<p>匿名内部类与正规的继承相比有些受限，因为匿名内部类可以扩展类，也可以实现接口，但是不能两者兼备，而且如果是实现接口，也只能实现一个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//外部接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">External</span> </span>&#123;</span><br><span class="line">  <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例1：匿名类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> External <span class="title">getExternal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> External &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;;<span class="comment">//需要分号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">上述的匿名类是下面语法的简化形式：</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">External</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> External <span class="title">getExternal</span><span class="params">()</span></span>&#123;</span><br><span class="line">   <span class="function">reurn new <span class="title">Inner</span><span class="params">()</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例2：匿名类的基类需要有参构造器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> External <span class="title">getExternal</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> External (<span class="keyword">int</span> param) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;;<span class="comment">//需要分号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例3：在匿名内部类中定义字段可进行初始化操作</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> External <span class="title">getExternal</span><span class="params">(<span class="keyword">final</span> String strParam)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> External (<span class="keyword">int</span> param) &#123;</span><br><span class="line">      ptivate String name = strParam;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;;<span class="comment">//需要分号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//示例4：匿名类中不可能有命名构造器，通过 实例初始化 可达到命名构造器的效果</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> External <span class="title">getExternal</span><span class="params">(<span class="keyword">final</span> String strParam,<span class="keyword">final</span> <span class="keyword">int</span> intParam)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> External (<span class="keyword">int</span> param) &#123;</span><br><span class="line">      <span class="keyword">private</span> String name = strParam;</span><br><span class="line">      <span class="keyword">private</span> String age;</span><br><span class="line">      &#123;</span><br><span class="line">        age = intParam;</span><br><span class="line">        <span class="keyword">if</span>(age &gt; <span class="number">150</span>) System.out.println(<span class="string">&quot;年龄过大！&quot;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  	&#125;;<span class="comment">//需要分号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用：匿名内部类可优雅的实现工厂方法。</p>
<p>既然局部内部类的名在方法外事不是可见得，那为什么我们仍然使用局部内部类而不是匿名内部类呢：</p>
<p>（1）.我们需要一个已命名的构造器，或者需要重载构造器，而匿名内部类只能用于实初始化。</p>
<p>（2）.还有一个理由是：需要不止一个该内部类的对象。</p>
<h4 id="7-嵌套类"><a href="#7-嵌套类" class="headerlink" title="7.嵌套类"></a>7.嵌套类</h4><p> 嵌套类：如果不需要内部类对象与其外围类对象之间有联系，那么可以将内部类声明为<code>static</code> </p>
<ul>
<li>要创建嵌套类的对象，并不需要其外围类的对象</li>
<li>不能从嵌套类的对象中访问非静态的外围类对象</li>
<li>普通的内部类不能有static数据和static字段，也不能包含嵌套类，但是嵌套类可以包含这些东西</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> <span class="keyword">implements</span> <span class="title">External</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="string">&quot;inner name&quot;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">int</span> age;</span><br><span class="line">     <span class="function"><span class="keyword">static</span> String <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">     &#125; </span><br><span class="line">     <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreInner</span></span>&#123;</span><br><span class="line">       <span class="keyword">static</span> <span class="keyword">int</span> index;</span><br><span class="line">       <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接口中可以存在嵌套类（这个类中可以有实现），这种方式可以在接口中创建默认实现，使得接口的不同实现可共用</p>
<p>一个内部类呗嵌套多少层不重要——他能透明的访问所有他嵌入的所有外围类的所有成员</p>
<h4 id="8-为什么需要内部类"><a href="#8-为什么需要内部类" class="headerlink" title="8.为什么需要内部类"></a>8.为什么需要内部类</h4><p>内部类的优势：</p>
<p>每个内部类都能独立的继承一个（接口的）实现，所以无论外围类是否已经继承了某个（接口的）实现，对于内部类都没有影响</p>
<p>内部类允许继承多个非接口类型</p>
<p>内部类特性：</p>
<ul>
<li><p>内部类可以有多个实例，每个实例都有自己的状态信息，并且与其外围类对象的信息相互独立</p>
</li>
<li><p>在单个外围类中，可以让多个内部类以不同的方式实现同一个接口，或继承同一个类</p>
</li>
<li><p>创建内部类对象的时候并不依赖于外部类的创建</p>
</li>
<li><p>内部类并没有令人迷惑的<code>is-a</code> 的关系，他就是一个独立的实体</p>
</li>
<li><p>*为什么需要内部类**</p>
</li>
<li><p>闭包和回调</p>
<ul>
<li><p>闭包是一个可调用对象，他记录了一些信息，这些信息来源于它的作用域</p>
<p>内部类是面向对象的闭包：因为他不仅包含外围类对象（创建类的作用域）信息，还自动拥有一个指向此外围类的引用，在此作用域内，内部类有权操作所有成员</p>
</li>
<li><p>回调：通过回调，对象能携带一些信息，这些信息允许他在稍后的某个时刻调用初始的对象</p>
</li>
</ul>
</li>
<li><p>控制框架与内部类</p>
<p>应用程序框架：被设计用以解决某类特定问题的一个类或一组类（例如模板方法）</p>
<p>控制框架：是一类特殊的应用程序框架，他用来解决响应事件的请求，主要用来响应事件的系统被称作事件驱动系统</p>
</li>
</ul>
<h4 id="9-内部类的继承"><a href="#9-内部类的继承" class="headerlink" title="9.内部类的继承"></a>9.内部类的继承</h4><p>只继承内部类而不是外围类，生成一个构造器时需要传递一个指向外围类对象的引用，使用如下语法，编译才会通过：</p>
<p>enclosingClassReference.super()</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OtherInner</span> <span class="keyword">extends</span> <span class="title">Outer</span>.<span class="title">Inner</span> </span>&#123;</span><br><span class="line">    OtherInner(Outer outer) &#123;</span><br><span class="line">        <span class="comment">//enclosingClassReference.super()</span></span><br><span class="line">        outer.<span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-内部类可以被覆盖吗"><a href="#10-内部类可以被覆盖吗" class="headerlink" title="10.内部类可以被覆盖吗"></a>10.内部类可以被覆盖吗</h4><p>当继承了某个外围类的时候，内部类并没有发生什么特别神奇的变化，这两个内部类是完全独立的两个实体，各自在自己的命名空间内。</p>
<ul>
<li>可在子类中明确的继承某个内部类，实现内部类和普通方法一样的子类覆盖父类的效果</li>
</ul>
<h4 id="11-内部类标识符"><a href="#11-内部类标识符" class="headerlink" title="11.内部类标识符"></a>11.内部类标识符</h4><p>每个类都会产生一个<code>.class</code>,其中包含了如何创建该类型对象的全部信息（此信息产生一个<code>“meta-class”</code>，叫做<code>class</code>对象）<br>内部类也必须生成一个<code>.class</code>文件，以包含他们的对象信息，<br>这些类文件的命名有严格规则：外围类的名字，加上<code>$</code>,在加上内部类的名字，如果内部类是匿名的，编译器会简单的生成一个数字作为其标识符。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Outer.class</span><br><span class="line">Outer$Inner.class</span><br><span class="line"><span class="comment">//匿名内部类</span></span><br><span class="line">Outer$<span class="number">1.</span>class</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：六.访问控制权限</title>
    <url>/2018/08/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%85%AD-%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<p>访问权限的控制等级，从最大权限到最小权限依次为：public、protected、包访问权限(没有关键词)、private</p>
<span id="more"></span>

<p>1.包：库单元</p>
<p>当编写一个java源代码文件时，此文件通常被称为编译单元（有时也被称为转移单元）</p>
<ul>
<li>每个编译单元都必须有一个后缀名<code>.java</code>,</li>
<li>在编译单元内<strong>有且只能有</strong>一个 <code>public</code>类，该类的名称必须与文件名称相同（包括大小写，但是不包括文件的后缀名.java）</li>
</ul>
<p>代码的组织：</p>
<p>当编译一个<code>.java</code> 文件时，在<code>.java</code> 文件的每个类都会有一个输出文件，而该输出文件的名称与<code>.java</code> 文件中的每个类相同，只是多了一个后缀名 <code>.class</code>.</p>
<ul>
<li>例如：编译 HelloWord.java——&gt;HelloWord.class</li>
</ul>
<ul>
<li>因此在编译少量的<code>.java</code>文件之后，会得到大量的<code>.class</code>文件</li>
</ul>
<p>java可运行程序是一组可以打包并压缩为一个java文档文件（JAR,使用Java的jar文档生成器）的<code>.class</code>文件</p>
<ul>
<li>java解释器负责这些文件的查找、装载和解释（java并不强求要求必须要使用解释器，因为存在用来生成一个单一的可执行文件的本地代码JAVA编译器）</li>
</ul>
<p>类库：类库是一组类文件，每个文件都有一个public类，以及任意数量的非public类，因此每个文件都有一个 <strong>构件</strong>（每一个都有他们自己独立的<code>.java</code>文件和<code>.class</code>文件）</p>
<p>package：使 <strong>构件</strong>从属于一个群组</p>
<ul>
<li><p>如果使用package语句，它必须是文件中除注释以外的第一句代码，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">在文件的起始处：</span><br><span class="line"><span class="keyword">package</span> cn</span><br><span class="line">表示该编译单元是名为cn的类库下的一部分，别人想使用cn中的任何<span class="keyword">public</span>类，必须使用<span class="keyword">import</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>java包的命名全部为小写</p>
</li>
<li><p>包的名称必须对应目录路径（平时的编码中编译器会帮忙做）</p>
</li>
<li><p>package和import是将单一的全局名字空间分隔开，使得无论多少人使用Internet以及java开始编写类，都不会出现名称冲突问题</p>
</li>
</ul>
<p>java解释器的运行过程如下：首先找出环境变量CLASSPATH,CLASSPATH包含一个或多个目录，用做查找.calss文件的根目录，从根目录开始，解释器获取包的名称并将每个句点替换成反斜杠，以从CLASSPATH根路径产生一个路径名称，得到的路径会与CLASSPATH中的各个不同的项相连接，解释器就在这些目录中查找与你所要创建的类名称相同的.class文件。（解释器还会去查找某些涉及java解释器所在位置的标准目录）</p>
<p>2.Java访问权限修饰词</p>
<p>所有事物（类、类的成员方法、成员变量）都具有某种形式的访问权限</p>
<p>包访问权限：</p>
<ul>
<li>默认访问权限，没有任何关键字，为包访问权限，（也可表示为friendly）</li>
<li>包内的所有成员都是具有访问权限的，对于包外的成员来说就是private</li>
<li>默认包（未设定任何包名称）：隶属于默认包内的类，也是具有包（指的是默认包）权限的</li>
</ul>
<p>public:接口访问权限：</p>
<ul>
<li>对每个人都是可用的</li>
</ul>
<p>private:你无法访问 ：</p>
<ul>
<li>除了包含该成员的类之外，其他任何类都无法访问这个成员</li>
</ul>
<p>protected:继承访问权限</p>
<ul>
<li>相同包内的其他成员也可以访问</li>
<li>继承的子类可以访问</li>
</ul>
<p>3.接口和实现</p>
<p>访问权限的控制常被称为是<code>具体实现的隐藏</code> .</p>
<p>把数据和方法包装进类中，以及具体实现的隐藏常共同被称作是 <strong>封装</strong></p>
<p>封装的结果是一个同时带有特征和行为的<code>数据类型</code>：访问权限将边界划在了<code>数据类型</code>的内部,两个原因：</p>
<ul>
<li>1.要设定客户端程序员可以使用和不可以使用的界限</li>
<li>2.1引出了2：将接口和具体实现进行分离</li>
</ul>
<p>4.类的访问权限</p>
<ul>
<li>每个编译单元（文件）都只能有一个public类</li>
<li>public类的名称必须完全与含有编译单元的文件名相匹配</li>
<li>（不常用）编译单元内完全不带public类也是可以的，这个时候可以随意对文件命名（不好）</li>
</ul>
<p><strong>类即不可以是private的，也不可以是protected的</strong>（内部类除外，内部类可以使private或protected）</p>
<p>所以类的访问权限只有两个选择：包访问权限或是public</p>
<ul>
<li><p>如果不希望其他任何人对类拥有访问权限，可以吧所有构造器都指定为private,从而阻止任何人创建该类对象。</p>
</li>
<li><p>上述有一个例外：在该类的static成员内部可以创建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Soup</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup <span class="title">markSoup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//在该类的static成员内部可以创建</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Soup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或是</span><br><span class="line"><span class="comment">//单例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Soup2</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Soup2</span><span class="params">()</span></span>&#123;&#125;;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Soup2 s2=<span class="keyword">new</span> Soup2();</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Soup2 <span class="title">getSouo2</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s2;  </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>如果包访问权限下，一个类的某个static成员是public的话，则客户端程序员仍然可以调用该static成员，尽管他们并不生成该类的对象</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十一.持有对象</title>
    <url>/2018/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E4%B8%80-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<p>主要讲容器，暂时先不记录，等十七章一起记录</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十七-容器深入研究</title>
    <url>/2019/06/18/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E4%B8%83-%E5%AE%B9%E5%99%A8%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<p>java集合类库：</p>
<span id="more"></span>

<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/java%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/%E5%AE%B9%E5%99%A8%E6%95%B4%E4%BD%93%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="java集合类图"></p>
<p>容器类库对于面向对象语言来说是最重要的类库，大多数的编程对容器的使用比对其他类库中的构件要多。</p>
<p>本书的当前章节对于java中容器的介绍，大多数是介绍如何使用，具体可参照文档和查看源码，在此不在赘述。</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十三.字符串</title>
    <url>/2018/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E4%B8%89-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>可以证明，字符串操作是计算机程序中最常见的行为</p>
<span id="more"></span>

<h4 id="1-不可变-String"><a href="#1-不可变-String" class="headerlink" title="1.不可变 String"></a>1.不可变 <code>String</code></h4><p><code>String</code>对象是不可变的。</p>
<p><code>String</code>类中每一个看起来会修改<code>String</code>值的方法，实际上都是创建了一个全新的<code>String</code>对象，以包含修改后的字符串内容，而最初的<code>String</code>对象则丝毫未动</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stringTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  String str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">  String upStr = str.toUpperCase();</span><br><span class="line">  System.out.println(upStr); <span class="comment">//输出为：HELLO </span></span><br><span class="line">  System.out.println(str);   <span class="comment">//输出为：hello</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每当把<code>String</code>对象作为方法的参数时，都会复制一份引用，而该引用所指的对象其实一直待在单一的物理位置上，从未动过。</p>
<h4 id="2-重载-quot-quot-与StringBuilder"><a href="#2-重载-quot-quot-与StringBuilder" class="headerlink" title="2.重载&quot;+&quot;与StringBuilder"></a>2.重载<code>&quot;+&quot;</code>与StringBuilder</h4><p>不可变性会带来一定的效率问题。例如：<code>String</code>对象重载的<code>+</code>操作符，<code>+</code>可以用来连接两个<code>String</code></p>
<p>注：重载的意思是：一个操作符在应用于特定的类时，被赋予了特殊的意义。用于String的<code>+</code>与<code>+=</code>是Java中仅有的两个重载过的操作符，而Java并不允许程序员重载任何操作符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    String newStr = <span class="string">&quot;hello&quot;</span> + <span class="string">&quot;world&quot;</span> + <span class="string">&quot;string&quot;</span> + <span class="string">&quot;test&quot;</span>;</span><br><span class="line">     System.out.println(newStr); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>想查看以上代码是如何工作的，可是用JDK自带工具：<code>javap</code>反编译以上代码。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javap -c Test   <span class="comment">//-c 标志 表示将生成JVM字节码</span></span><br></pre></td></tr></table></figure>

<p>生成字节码后可看出编译器自动引入了<code>java.lang.StringBuilder</code>类（我们在代码中没有使用），因为他更高效</p>
<p>注意：此时可能会觉得：可以随意使用<code>String</code>对象，反正编译器会为你自动优化性能。但是：若是在循环中是用<code>+</code>操作符来链接字符串，编译器会使得每经过一次循环，就会创建一个<code>StringBuilder</code>对象</p>
<p>因此：当为一个类编写<code>toString()</code>方法时，如果字符串操作比较简单，那就可以信赖编译器，他会为你合理地构造最终的字符串结果，但是如果在<code>toString()</code>方法中使用循环，那么要自己创建<code>StringBuilder</code>对象，用它构造最终的结果。</p>
<p>注意：使用<code>StringBuilder</code>时：<code>append(a+&quot;:&quot;+c)</code> 时，编译器就会为你另外创建一个<code>StringBuilder</code>对象处理括号内的字符串操作</p>
<p><code>StringBuilder</code>提供了丰富而全面的方法:</p>
<p><code>insert()</code>、<code>repleace()</code>、<code>substring()</code>、<code>reverse()</code> 、<code>delete()</code></p>
<p>最常用的：<code>append()</code>、<code>toString()</code></p>
<p>Java5以后引入的<code>StringBuilder</code>,之前使用<code>StringBuffer</code>。<code>StringBuffer</code>是线程安全的，因此开销大些。</p>
<h4 id="3-无意识的递归"><a href="#3-无意识的递归" class="headerlink" title="3.无意识的递归"></a>3.无意识的递归</h4><p>当在<code>toString()</code>方法中使用<code>this</code>时，调用<code>toString()</code>会导致递归，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;test&quot;</span> + <span class="keyword">this</span> + <span class="string">&quot;toString&quot;</span>; <span class="comment">//产生递归</span></span><br><span class="line">    <span class="comment">//return &quot;test&quot; + super.toString() + &quot;toString&quot;; //正确调用</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为编译器看到一个<code>String</code>对象（<code>“test”</code>）后面跟着一个<code>+</code>,而后的对象不是<code>String</code>，于是编译器试着将<code>this</code>转换成一个<code>String</code>,就是调用<code>toString()</code>方法，于是产生递归</p>
<p>如果真的想打印出对象的内存地址，应该调用<code>Object.toString()</code>方法，这才是负责此任务的方法，所以此处不应该是<code>this</code>而应该是<code>super.toString()</code>方法。</p>
<h4 id="4-String上的操作"><a href="#4-String上的操作" class="headerlink" title="4.String上的操作"></a>4.String上的操作</h4><p>关于<code>String</code>对象具备的一些方法，可查看文档。</p>
<p>但是无论什么方法，当需要改变字符串内容时，<code>String</code>类的方法都会返回一个新的<code>String</code>对象，同时，如果内容没有发生改变，<code>String</code>的方法只是返回指向原对象的引用而已，这可以节约空间以及避免额外的开销。</p>
<h4 id="5-格式化输出"><a href="#5-格式化输出" class="headerlink" title="5.格式化输出"></a>5.格式化输出</h4><p>格式修饰符：格式化输出时的占位符，他们不但说明了插入数据的位置，同时还说明了将插入类型的变量，以及如何对其格式化。例如：</p>
<ul>
<li><code>%d</code> ：表示整数；</li>
<li><code>%f</code> ：浮点数（float或是double）,默认小数点后六位（十进制）</li>
<li><code>%s</code> ：表示字符串</li>
<li><code>%c</code> ：Unicode字符</li>
<li><code>%b</code> ：Boolean值</li>
<li><code>%e</code>：浮点数（科学计数）</li>
<li><code>%x</code> ：整数（十六进制）</li>
<li><code>%h </code>：散列码（十六进制）</li>
<li><code>%%</code>：字符 “%”</li>
</ul>
<p><code>System.out.format()</code> === <code>System.out.printf()</code> 可用于<code>PrintStream</code>或<code>PrintWriter</code></p>
<p><strong><code>Formatter</code></strong> ：Java中，所有格式化功能都由<code>java.util.Formatter</code>类处理。</p>
<p>当创建一个<code>Formatter</code>对象的时候，需要向其构造器传递一些信息，告诉他最终的结果将向哪里输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Formatter format = <span class="keyword">new</span> Formatter(System.out);</span><br><span class="line"><span class="comment">//或者</span></span><br><span class="line">Formatter format = <span class="keyword">new</span> Formatter(<span class="keyword">new</span> StringBuilder());</span><br></pre></td></tr></table></figure>

<p>格式化说明符：在插入数据时，如果想要控制空格与对齐，你需要更精准复杂的格式修饰符，以下为抽象语法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">%[argument_index$][flags][width][.precision]conversion</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String.format(<span class="string">&quot;%3$-6.8f,%2$s&quot;</span>, <span class="string">&quot;11&quot;</span>,<span class="string">&quot;22&quot;</span>,<span class="number">33.111</span>);</span><br><span class="line"><span class="comment">//其中 </span></span><br><span class="line"><span class="comment">//3$:argument_index 表示使用第三个参数：33.111</span></span><br><span class="line"><span class="comment">//-:flags表示输出长度不足width的时候，以左对齐，默认右对齐（一般用于%s中）</span></span><br><span class="line"><span class="comment">//6:width表示输出长度</span></span><br><span class="line"><span class="comment">//.8:precision表示在%f中保留小数点多少位，在%s中表示保留String的最大长度，不可用于整数，会产生异常</span></span><br></pre></td></tr></table></figure>

<h4 id="6-正则表达式"><a href="#6-正则表达式" class="headerlink" title="6.正则表达式"></a>6.正则表达式</h4><p>（1）正则表达式是一种强大而灵活地文本处理工具。</p>
<p>正则表达式提供了一种完全通用的方式，能够解决各种字符串处理相关的问题：匹配、选择、编辑验证。</p>
<p>注：java 中的正则普遍是多一个<code>\</code>,换种说法就是java双斜杠（<code>\\</code>）表示插入一个正则表示的斜线</p>
<p>例如：<code>\d</code> ：一位数字，在java的正则中表示为：<code>\\d</code>；</p>
<p>（2）**<code>String</code>类自带的使用正则表达式的方法**：</p>
<ul>
<li><code>split()</code>：将字符串从正则表达式的地方分隔。还有一个重载版本，可以限制字符串分割的次数</li>
<li>替换类方法：<ul>
<li><code>replaceFirst()</code>：只替换正则表达式第一个匹配的字符串</li>
<li><code>replaceAll()</code>：替换所有匹配的地方</li>
</ul>
</li>
<li><code>matches()</code>：是否和传入的正则匹配</li>
</ul>
<p>如果正则不是只使用一次的话，非<code>String</code>对象的正则表达式明显具备更佳的性能</p>
<p>（3）<strong>正则表达式的完整构造字列表，参考<code>java.util.regex</code>包中的<code>Pattern</code>类</strong></p>
<p>此处不一一列举，只说明部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">+：一个或多个 之前的表达式  因在表达式中有特殊含义 所以想表示普通字符+时 \\+</span><br><span class="line">？：一个或零个 之前的表达式</span><br><span class="line">*：零个或多个 之前的表达式</span><br><span class="line">括号：将表达式分组</span><br><span class="line">|：或操作</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>（4）量词</p>
<p>量词描述了一个模式吸入文本的方式</p>
<ul>
<li>贪婪型：贪婪表达式会为所有可能的模式发现尽可能多的匹配</li>
<li>勉强型：用问号来指定，这个量词匹配满足模式所需的最小字符数</li>
<li>占有性：目前这种类型的量词只在java中才可用，较为复杂。</li>
</ul>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一个正则表达式 ： 《.*》</span><br><span class="line"></span><br><span class="line">一段字符串为：</span><br><span class="line">《p》段落《a》链接《/a》《/p》</span><br><span class="line"></span><br><span class="line">贪婪型使用上述正则返回为：《p》段落《a》链接《/a》《/p》</span><br><span class="line">勉强型使用上述正则返回为：《p》</span><br></pre></td></tr></table></figure>

<p>（5）<code>CharSequence</code></p>
<p>接口<code>CharSequence</code>从<code>CharBuffer</code>、<code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code>类之中抽象出了字符序列的一般化定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">  charAt(<span class="keyword">int</span> i);</span><br><span class="line">  length();</span><br><span class="line">  subSequense();</span><br><span class="line">  toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此这些类都实现了该接口，多数正则表达式操作都接受CharSequence类型的参数。</p>
<p>（6）<code>Pattern</code> 和 <code>Matcher</code></p>
<p><code>Pattern.compile()</code> :编译正则表达式，生成<code>Pattern</code>对象。<code>Pattern</code>对象表示编译后的正则表达式</p>
<p><code>Pattern</code>的对象的 <code>matcher()</code>：会生成一个<code>Matcher</code>对象.</p>
<p><code>Matcher</code>有许多功能可用：</p>
<ul>
<li><code>find()</code>：在<code>CharSequense</code>中查找多个匹配,若是传入参数，则从传入的位置开始向后查找；<ul>
<li><code>matches()</code>：整个输入都匹配正则表达式时成功</li>
<li><code>lookingAt()</code>：只要输入的第一部分匹配就会成功</li>
</ul>
</li>
<li><code>start()</code>：先前匹配的起始位置索引</li>
<li><code>end()</code>：所匹配的最后字符索引加一的值</li>
<li><code>Groups</code>:<ul>
<li>正则表达式：<code>A(B(C))D</code>：组0是ABCD;组1是BC;组2是C.</li>
<li><code>group()</code>：前一次匹配操作的第0组</li>
<li><code>group(int)</code>：返回再前一次匹配操作期间指定的组号；没有则返回null</li>
<li><code>groupCount()</code>：返回该匹配器的模式中的分组数目</li>
<li><code>start()</code>：前一次匹配操作中寻找到的组的起始索引</li>
<li><code>end()</code>：前一次匹配操作中寻找到的最后一个字符索引加一的值</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">matcherTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  String needCheckStr = <span class="string">&quot;需要做正则校验的字符串123ddd543 2323das文字&quot;</span>;</span><br><span class="line">  String regex = <span class="string">&quot;-?\\d+&quot;</span>;</span><br><span class="line">  String needCheckStr1 = <span class="string">&quot;14325534&quot;</span>;</span><br><span class="line">  <span class="comment">// Pattern.matches(regex,needCheckStr)</span></span><br><span class="line">  System.out.println(Pattern.matches(regex, needCheckStr));</span><br><span class="line">  System.out.println(Pattern.matches(regex, needCheckStr1));</span><br><span class="line">  <span class="comment">// Pattern.compile(regex)</span></span><br><span class="line">  Pattern pattern = Pattern.compile(regex);</span><br><span class="line">  <span class="comment">// pattern.split(String);</span></span><br><span class="line">  String[] spiltResult = pattern.split(needCheckStr);</span><br><span class="line">  System.out.println(Arrays.toString(spiltResult));</span><br><span class="line">  String[] spiltResult1 = pattern.split(needCheckStr,<span class="number">2</span>);</span><br><span class="line">  System.out.println(Arrays.toString(spiltResult1));</span><br><span class="line">  <span class="comment">// pattern.matcher(String)</span></span><br><span class="line">  Matcher matcher = pattern.matcher(needCheckStr);</span><br><span class="line">  <span class="comment">// matcher相关方法</span></span><br><span class="line">  <span class="keyword">while</span> (matcher.find()) &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;group:&quot;</span> + matcher.group() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;start:&quot;</span> + matcher.start() + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;end:&quot;</span> + matcher.end());</span><br><span class="line">  &#125;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line"><span class="keyword">false</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">[需要做正则校验的字符串, ddd,  , das文字]</span><br><span class="line">[需要做正则校验的字符串, ddd543 2323das文字]</span><br><span class="line">group:<span class="number">123</span>	start:<span class="number">11</span>	end:<span class="number">14</span></span><br><span class="line">group:<span class="number">543</span>	start:<span class="number">17</span>	end:<span class="number">20</span></span><br><span class="line">group:<span class="number">2323</span>	start:<span class="number">21</span>	end:<span class="number">25</span></span><br></pre></td></tr></table></figure>

<p>（7）<code>Pattern</code>标记</p>
<p><code>Pattern.compile()</code>还有一个接受一个标记参数的版本，以调整匹配的行为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Pattern.compile(String regex, <span class="keyword">int</span> flag)</span><br></pre></td></tr></table></figure>

<p><code>flag</code>是<code>Pattern</code>类中的常量，具体查看源码或文档。</p>
<p>（8）替换操作</p>
<ul>
<li><p><code>replaceFirst(String replacement)</code>：以参数字符串<code>replacement</code>替换掉第一个匹配成功的部分</p>
</li>
<li><p><code>replaceAll(String replacement))</code>：以参数字符串<code>replacement</code>替换所有匹配成功的部分</p>
</li>
<li><p><code>appendRepalcement(StringBuffer sbuf, String replacement)</code>：执行渐进式替换（而不是像<code>replceFirst()</code>和<code>replaceAll()</code>那样只替换第一个匹配或是全部匹配）它允许你调用其他方法来生成或处理<code>replacement</code>,使你能够用编程的方式将目标分割成组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> Matcher matcher=Pattern.compile(<span class="string">&quot;A&quot;</span>).matcher(<span class="string">&quot;CACAAA&quot;</span>);</span><br><span class="line"> matcher.find(<span class="number">2</span>);<span class="comment">//从所匹配的字符串的第1位开始查找，不传入参数是从第0位开始查找</span></span><br><span class="line"> StringBuilder stringBuilder=<span class="keyword">new</span> StringBuilder();</span><br><span class="line"> matcher.appendReplacement(stringBuilder,<span class="string">&quot;B&quot;</span>);</span><br><span class="line"> System.out.println(stringBuilder);</span><br><span class="line"><span class="comment">//输出：CACB</span></span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><code>appendTail(String sbuf)</code>：在执行了一次或多次<code>appendRepalcement()</code>之后，调用此法可以将输入字符串余下的部分复制到<code>sbuf</code>中</li>
</ul>
<p>（9）<code>reset()</code></p>
<p>可以将现有的<code>Matcher</code>对象应用于一个新的字符序列</p>
<p>使用不带参数的<code>reset()</code>方法，可以将<code>Matcher</code>对象重新设置到当前字符序列的其实位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Matcher matcher = Pattern.compile(<span class="string">&quot;regex&quot;</span>).matcher(<span class="string">&quot;needCheckStr&quot;</span>);</span><br><span class="line">String resetStr = <span class="string">&quot;替换后的字符串&quot;</span>;</span><br><span class="line">matcher.reset(resetStr);  <span class="comment">//此时matcher匹配的字符串就被变为：resetStr</span></span><br></pre></td></tr></table></figure>

<h4 id="7-扫描输入"><a href="#7-扫描输入" class="headerlink" title="7.扫描输入"></a>7.扫描输入</h4><p>javaSE5 新增<code>Scanner</code>类，减少扫描输入的负担</p>
<p><code>Scanner</code>的构造器可以接受任何类型的输入参数：包括<code>File</code>、<code>InputStream</code>、<code>String</code>、<code>Readable</code>(接口，表示“具有<code>read()</code>方法的某种东西”，例如<code>BufferedReader</code>就归属于这类)</p>
<p><code>Scanner</code>的所有输入、分词以及翻译的操作都隐藏在不同类型的<code>next()</code>方法中</p>
<p>普通的<code>next()</code>方法返回下一个<code>String</code><br>所有的基本类型（除了<code>char</code>之外），都有对应的<code>next()</code>方法（其中还包括<code>bigDecimal</code>和<code>BigInteger</code>）<br>所有的<code>next()</code>方法，只有在找到一个完整的分词后才会返回<br><code>Scanner</code>还有<strong>相应的</strong> <code>hasNext()</code>方法，用以判断下一个输入的分词是否是所需的类型</p>
<p><code>Scanner</code>定界符：</p>
<p><code>Scanner</code>根据空白字符对输入进行分词，但是你可以用正则表达式指定自己所需的定界符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>( Scanner scanner=<span class="keyword">new</span> Scanner(<span class="string">&quot;12 , 42, 56 ,55&quot;</span>)) &#123;</span><br><span class="line">  scanner.useDelimiter(<span class="string">&quot;\\s*,\\s*&quot;</span>);</span><br><span class="line">  <span class="keyword">while</span> (scanner.hasNextInt()) &#123;</span><br><span class="line">      System.out.println(scanner.nextInt());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">42</span></span><br><span class="line"><span class="number">56</span></span><br><span class="line"><span class="number">55</span></span><br></pre></td></tr></table></figure>

<p>用正则表达式扫描：</p>
<p><code>next()</code>方法配合正则使用时，将找出下一个匹配该模式的输入部分。调用<code>match()</code>方法就可获得匹配的结果</p>
<p>注：再配合正则扫描时，仅仅针对下一个分词进行匹配，如果你的正则表达式中含有定界符，那永远不可能匹配成功</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> String needCheckStr = <span class="string">&quot;1234 dsdsd&quot;</span>;</span><br><span class="line">   <span class="keyword">try</span>(Scanner scanner=<span class="keyword">new</span> Scanner(needCheckStr))&#123;</span><br><span class="line">   String pattern=<span class="string">&quot;(\\d+)(\\w+)&quot;</span>;</span><br><span class="line">   <span class="keyword">while</span> (scanner.hasNext(pattern))&#123;</span><br><span class="line">   	 scanner.next(pattern);</span><br><span class="line">     MatchResult matchResult=scanner.match();</span><br><span class="line">     String number=matchResult.group(<span class="number">1</span>);</span><br><span class="line">     String str=matchResult.group(<span class="number">2</span>);</span><br><span class="line">     System.out.println(<span class="string">&quot;数字:&quot;</span>+number+<span class="string">&quot;\n&quot;</span>+<span class="string">&quot;字符串：&quot;</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//输出</span></span><br><span class="line">数字:<span class="number">123</span></span><br><span class="line">字符串：<span class="number">4</span></span><br></pre></td></tr></table></figure>

<h4 id="8-StringTokenizer"><a href="#8-StringTokenizer" class="headerlink" title="8.StringTokenizer"></a>8.<code>StringTokenizer</code></h4><p>在jdk1.4引入正则和jdk1.5引入<code>scanner</code>之前，分隔字符串的唯一方法是使用<code>StringTokenizer</code>来分词。</p>
<p>现在<code>StringTokenizer</code>已经被废弃了</p>
<h4 id="9-总结"><a href="#9-总结" class="headerlink" title="9.总结"></a>9.总结</h4><p>Java现在对字符串操作的支持已经很完善了，不过，在使用时要在细节上注意效率问题：例如恰当的使用<code>StringBuilder</code>等</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十二.通过异常处理错误</title>
    <url>/2018/10/04/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E4%BA%8C-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF/</url>
    <content><![CDATA[<p>Java的基本理念是：结构不佳的代码不能运行</p>
<p>发现错误的理想时机是在编译阶段，也就是在你试图运行代码之前。</p>
<p>异常处理是Java中唯一正式的错误报告机制，并且通过编译器强制执行</p>
<span id="more"></span>

<h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h4><p><code>&quot;异常&quot;</code>这个词有<code>&quot;我对此感到意外的意思&quot;</code></p>
<ul>
<li>使问题出现了，并可以被注意并且被处理</li>
<li>异常能降低错误处理代码的复杂度（只需在<code>异常处理程序</code>中处理），并且可以把“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离</li>
</ul>
<p>异常的基本概念是用名称代表发生的问题，并且异常的名称应该可以望文知意。</p>
<h4 id="2-基本异常"><a href="#2-基本异常" class="headerlink" title="2.基本异常"></a>2.基本异常</h4><p> <strong>异常情形</strong>：是指阻止当前方法或作用域继续执行的问题</p>
<p>抛出异常后，有几件事会随之发生：</p>
<ul>
<li><p>同java其他对象的创建一样，将使用<code>new</code>在堆上创建异常对象</p>
</li>
<li><p>当前的执行路径被终止，并且从当前环境中弹出对异常对象的引用，此时，异常机制结果程序，并开始寻找一个恰当的地方来继续执行程序，这个恰当的地方就是<strong>异常处理程序</strong>，他的任务就是将程序从错误状态中恢复，以使程序要么换一种方式执行，要么继续执行下去</p>
</li>
<li><p>*异常参数**：与使用java中其他的对象一样，我们总是用<code>new</code>在对上创建异常对象，这也伴随着存储空间的分配和构造器的调用。</p>
</li>
</ul>
<p>所有的标准异常类都有两个构造器：</p>
<ul>
<li><p>一个是默认构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li><p>另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;传入对象为null&quot;</span>);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>关键字**<code>throw</code>** :使用<code>new</code>创建了异常对象之后，此对象的引用将传给<code>throw</code> 。</p>
<p>可使用抛出异常的方式从当前作用域退出，这时将会返回一个异常对象，然后退出方法或作用域</p>
<h4 id="3-捕获异常"><a href="#3-捕获异常" class="headerlink" title="3.捕获异常"></a>3.捕获异常</h4><p><strong>监控区域</strong> ：是一段可能产生异常的代码，并且后面跟着处理这些异常的代码</p>
<p><strong><code>try</code>块</strong> ：因为在这个块里“尝试”各种方法调用，所以称为：<code>try</code>块</p>
<p>如果方法内部抛出异常，这个方法将在抛出异常的过程中结束。要是不希望方法就此结束，可以在方法中使用<code>try块</code>,来捕获异常。示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>异常处理程序</strong> ：抛出的异常必须在某处得到处理，这个“地点”就是 <code>异常处理程序</code> 。紧跟在try块之后，使用**<code>catch</code>**表示:</p>
<p>需的针对每个要捕获的异常准备相应的处理程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type1 t1)&#123;</span><br><span class="line">  <span class="comment">//Handle Type1</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(Type2 t2)&#123;</span><br><span class="line">  <span class="comment">//Handle Type2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个<code>catch</code> 字句（异常处理程序）看起来就像是接受一个且仅接受一个特殊类型的参数的方法</p>
<p>异常处理程序必须紧跟在try块之后，当异常被抛出的时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序，然后进入<code>catch</code>字句执行，此时认为异常得到了处理</p>
<p>注意：只有匹配的<code>catch</code>字句才能得到执行。（与<code>switch</code>不用）</p>
<p>异常处理理论上有两种基本模型：</p>
<ul>
<li>终止模型：Java支持的模型，在这种模型中将假设错误非常关键，以至于程序无法返回到异常发生的地方继续执行，一旦异常被抛出，就表明错误已无法挽回，也不能要回来继续执行。</li>
<li>恢复模型：意思是异常处理程序的工作是修正错误，然后尝试重新调用出问题的方法，并认为第二次可以成功。java想实现类似行为：一是遇见错误调用方法修正而不抛出异常，二是将try块放到while循环中，这样能不断进入try块，直到达到满意的结果</li>
</ul>
<h4 id="4-创建自定义异常"><a href="#4-创建自定义异常" class="headerlink" title="4.创建自定义异常"></a>4.创建自定义异常</h4><p>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承。建立新的异常类型最简单的方法就是让编译器为你生成默认的构造器。</p>
<p>对异常来说：最重要的部分就是类名。</p>
<p>在异常处理程序中可调用<code>Thriwable</code>类声明（<code>Exception</code>即从此类继承）的<code>printStackTrace()</code>方法，他将打印“从方法调用处直到异常抛出处”的方法调用序列（默认情况信息将会被输出带标准错误流）。</p>
<p>对于异常类来说：<code>getMessage()</code>方法有点类似与toString()方法。</p>
<p>异常也是对象的一种，所以可以修改（自定义的异常）以得到更强的功能，但是大多数情况下用不上。</p>
<h4 id="5-异常说明"><a href="#5-异常说明" class="headerlink" title="5.异常说明"></a>5.异常说明</h4><p>异常说明：属于方法声明的一部分，紧跟在形式参数列表之后。</p>
<p>异常说明主要作用是说明某个方法可能会抛出的异常类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">function</span><span class="params">()</span> <span class="keyword">throws</span> E1,E2 </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>代码必须与异常说明保持一致，存在异常时，编译器会提示你，要么处理，要么抛出</p>
<p>也可声明某个方法将抛出异常，实际上却不抛出：接口和抽象基类可以使用，这样为异常先占个位子，以后存在异常可以执行抛出</p>
<p>这种在编译时被强制检查的异常称为 <strong>被检查的异常</strong></p>
<h4 id="6-捕获所有异常"><a href="#6-捕获所有异常" class="headerlink" title="6.捕获所有异常"></a>6.捕获所有异常</h4><p>可以只写一个异常处理程序来捕获所有类型的异常：通过捕获异常类型的基类<code>Exception</code>可以做到这一点</p>
<p>捕获异常类型的基类<code>Exception</code>将捕获所有异常，所以最好放在处理程序列表的末尾</p>
<p>(1).栈轨迹（栈是先进后出）：</p>
<p><code>printStackTrace()</code>方法所提供的信息可以通过<code>getStackTrace()</code>方法来直接访问，这个方法将返回一个由栈轨迹中的元素所构成的数组，其中每个元素都表示栈中的一帧。元素0是栈顶元素，并且是调用序列的最后一个方法调用（这个<code>Throwable</code>被创建和抛出之处）。数组中的最后一个元素和栈底是调用序列的第一个方法调用。</p>
<blockquote>
<p>由栈轨迹可看出：一个异常抛出，先看上边，此处才是这个异常被创建和抛出的地方</p>
</blockquote>
<p>(2).重新抛出异常</p>
<p>有时希望把刚捕获的异常重新抛出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">  <span class="keyword">throw</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重抛异常会把异常抛给上一级环境中的异常处理程序，同一个<code>try块</code>的后续<code>catch</code>字句将被忽略。此外异常对象的所有信息都得以保持，所以高一级环境中捕获此异常的处理程序可以从这个异常对象中得到所有信息。</p>
<p>如果只是把当前异常对象重新抛出，那么<code>printStackTrace()</code>方法显示的将是原来异常抛出点的调用栈信息，而非重新抛出点的信息。要想更新这个信息可以调用<code>fillInStackTrace()</code>方法，这将返回一个<code>Throwable</code>对象，他是通过把当前调用栈信息填入原来那个异常对象而建立的.（即：当前的栈轨迹是从重新抛出到调用处的，之前的轨迹不会再显示）示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">  <span class="keyword">throw</span> (Exception)e.fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用<code>fillInStackTrace()</code>的那一行就成了异常的新发生地了</p>
<p>有可能在捕获异常之后抛出另一种异常，这么做的话，得到的效果类似于使用<code>fillInStackTrace()</code>,有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信息。</p>
<p>永远不必为清理一个异常对象而担心，或者说为异常对象的清理而担心，他们都是用<code>new</code>在堆上创建的对象，所以垃圾回收器会自动把他们清理掉</p>
<p>(3).异常链</p>
<p>常常会想要在捕获一个异常的后抛出另一个异常，并且希望把原始的异常信息保存下来，这称为异常链。</p>
<p>JDK1.4以后，<code>Throwable</code>子类在构造器中都可以接受一个<code>cause</code>(因由)对象作为参数，这个<code>cause</code>就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e)</span><br></pre></td></tr></table></figure>

<p><code>Throwable</code>的子类中，只有三种基本的异常类提供了带<code>cause</code>参数的构造器，他们是<code>Error</code>、<code>Exception</code>、<code>RuntimeException</code>,如果要把其他类型的异常链接起来，使用<code>initCause</code>方法，而不是构造器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">e1.initCause(<span class="keyword">new</span> NullPointException());</span><br></pre></td></tr></table></figure>

<h4 id="7-Java标准异常"><a href="#7-Java标准异常" class="headerlink" title="7.Java标准异常"></a>7.Java标准异常</h4><p><code>Throwable</code>这个Java类被用来表示任何可以作为异常被抛出的类，<code>Throwable</code>对象可分为两种类型（指从<code>Throwable</code>继承而得到的类型）</p>
<ul>
<li><code>Error</code>：用来表示编译时和系统错误（除特殊情况，一般无需关心）</li>
<li><code>Exception</code>：是可以被抛出的基本类型。</li>
</ul>
<p>特例：<code>RuntimeException</code></p>
<p>运行时异常，会自动被Java虚拟机抛出，所以不必在异常说明中把它们列出来，这类异常都是从<code>RuntimeException</code>类继承而来。它们也被称为<strong>不受检查异常</strong>。这种异常属于错误， 将被自动捕获。</p>
<p>注：只能在代码中忽略<code>RuntimeException</code>(及其子类)类型的异常，其他类型异常的处理都是由编译器强制实施的，究其原因：<code>RuntimeException</code>代表的是变成错误：</p>
<ul>
<li>无法预料的错误。比如从你控制范围之外传递进来的null引用</li>
<li>作为程序员，应该在代码中检查的错误（比如<code>ArrayIndexOutOfBoundsException</code>）</li>
</ul>
<h4 id="8-使用finally进行清理"><a href="#8-使用finally进行清理" class="headerlink" title="8.使用finally进行清理"></a>8.使用finally进行清理</h4><p>对于一些代码，可能会希望无论<code>try</code>块中的异常是否抛出，他们都能得到执行，这通常适用于内存回收之外的情况，为了达到这个效果，可在异常处理程序后面加上<code>finally</code>字句</p>
<p>注： <code>finally</code>相当于在正常代码的<code>return</code>之前执行，没有return就是正常代码结束后执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无论异常是否被抛出，<code>finally</code>字句总能被执行</p>
<p>当涉及<code>break</code>、<code>continue</code>、<code>return</code>语句的时候，<code>finally</code>字句也会得到执行</p>
<p><code>finally</code> 字句最强大的作用：把内存之外的资源恢复到他们的初始状态，这种资源包括：打开的文件、网络连接等</p>
<p>异常丢失：某些特殊方式使用<code>finally</code>字句，会造成异常丢失,示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">  <span class="comment">//Code</span></span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-异常的限制"><a href="#9-异常的限制" class="headerlink" title="9.异常的限制"></a>9.异常的限制</h4><p>限制：当覆盖方法的时候，只能抛出在基类方法的异常说明里面列出的那些异常（或者这些异常的子类）</p>
<p>异常限制对构造器不起作用，但是派生类的构造器的异常说明必须包含基类构造器的异常说明。且派生类构造器不能捕获基类构造器抛出的异常</p>
<p>这些限制都是为了能产生更为强壮的异常处理代码</p>
<p>尽管在继承过程中，编译器会对异常说明做强制要求，但是异常说明本身并不属于方法类型的一部分，方法类型是由方法的名字与参数的类型组成的，因此，不能基于异常说明来重载方法。</p>
<h4 id="10-构造器"><a href="#10-构造器" class="headerlink" title="10.构造器"></a>10.构造器</h4><p>如果在构造器内抛出了异常，某些清理行为就不能正常工作了（例如关闭文件，在构造器中抛出异常文件还未打开，所以此时从里就是有问题）。</p>
<p>对于构造阶段可能会抛出异常，并且要求清理的类，最安全的使用方式是使用嵌套的<code>try</code>字句</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  InputFile in = InputFile(<span class="string">&quot;clean.java&quot;</span>)</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    String str = in.getLine();</span><br><span class="line">  &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">    <span class="comment">//Code</span></span><br><span class="line">  &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//在此处关闭，此时如果构造失败，不会进入关闭方法</span></span><br><span class="line">    in.dispose()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">  <span class="comment">//Code 初始化失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种通用的清理惯用法在构造器不抛出任何异常时也应该使用，其基本规则是：在创建需要清理的对象之后，立即进入一个<code>try-finally</code>语句块</p>
<h4 id="11-异常匹配"><a href="#11-异常匹配" class="headerlink" title="11.异常匹配"></a>11.异常匹配</h4><p>抛出异常的时候，异常处理系统会按照代码的书写顺序找出“最近”的出来程序，找到匹配的处理程序之后，他就认为异常将得到处理，然后就不会再继续查找</p>
<p>查找的时候并不要求抛出的异常同处理程序所声明的异常完全匹配，派生类的对象也可以匹配其基类的处理程序。<br>例如：<code>catch(Exception e)</code> , 会捕获Exception以及所有从他派生的类</p>
<p>如果把 <code>catch(Exception e)</code>字句放在最前面，会将派生类的异常全部“屏蔽”掉。（此时如果这个<code>catch</code>字句后还存在派生类的<code>catch</code>字句，编译器会报错.）</p>
<h4 id="12-其他可选方式"><a href="#12-其他可选方式" class="headerlink" title="12.其他可选方式"></a>12.其他可选方式</h4><p>如果某些“被检查异常”不知道该如何处理：</p>
<ul>
<li>把异常传递给控制台：即一直throws 出去</li>
<li>把”被检查异常”转换为”不被检查异常”</li>
</ul>
<h4 id="13-异常使用指南"><a href="#13-异常使用指南" class="headerlink" title="13.异常使用指南"></a>13.异常使用指南</h4><p>应该在下列情况下使用异常：</p>
<ul>
<li>在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常）</li>
<li>解决问题并重新调用产生异常的方法</li>
<li>进行少许修补，然后绕过异常发生的地方继续执行</li>
<li>用别的数据进行计算，以代替方法预计会返回的值</li>
<li>把当前环境下能做的事情尽量做完，然后把 <strong>相同的</strong>异常重抛到更高层</li>
<li>把当前环境下能做的事情尽量做完，然后把 <strong>不同的</strong>异常抛到更高层</li>
<li>终止程序</li>
<li>进行简化（如果你的异常模式使问题变得太复杂，那用启来会非常痛苦也很烦人）</li>
<li>让类库和程序更安全：这既是在为调试做短期投资，也是在为程序的健壮性做长期投资</li>
</ul>
<h4 id="14-总结"><a href="#14-总结" class="headerlink" title="14.总结"></a>14.总结</h4><p>异常是Java程序不可分割的一部分</p>
<p>异常的有点之一就是他使得你可以在某处集中精力处理你要解决的问题，而在另一处处理你编写的这段代码中产生的错误</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十五.泛型</title>
    <url>/2018/10/21/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E4%BA%94-%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<p>一般的类和方法，只能使用具体的类型：要么是基本类型，要么是自定义的类。如果要编写可以应用于多种类型的代码，这种刻板的限制对代码的束缚就会很大</p>
<span id="more"></span>

<p>泛型实现了<strong>参数化类型</strong>的概念</p>
<h4 id="1-简单的泛型"><a href="#1-简单的泛型" class="headerlink" title="1.简单的泛型"></a>1.简单的泛型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个示例中：T就是类型参数</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> T t;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(T t)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">this</span>.t = t</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setT</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.t = t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">getT</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JAVA</code>泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节</p>
<p>元组类库：</p>
<p>元组（<code>tuple</code>）：它是将一组对象直接打包存储于其中的一个单一对象，这个容器对象允许读取其中元素，但是不允许向其中存放新的对象。（这个概念也被称为数据传送对象或信使）</p>
<blockquote>
<p> 元组可解决return只返回单个对象，而我们想要多个对象的问题</p>
</blockquote>
<p>元组示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> A first; <span class="comment">// 因为是final,所以可以不用private</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">final</span> B second;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TwoTuple</span><span class="params">(A a,B b)</span></span>&#123;</span><br><span class="line">    first = a;</span><br><span class="line">    second = b;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> first+<span class="string">&quot;;&quot;</span>+second;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>元组隐含的保持了其中元素的顺序</p>
<p>可用集成机制增加长度更长的元组，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreeTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>,<span class="title">C</span>&gt; <span class="keyword">extends</span> <span class="title">TwoTuple</span>&lt;<span class="title">A</span>,<span class="title">B</span>&gt; </span>&#123;</span><br><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> C third;</span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreeTuple</span><span class="params">(A a,B b,C c)</span></span>&#123;</span><br><span class="line">   <span class="keyword">super</span>(a,b);</span><br><span class="line">   third = c;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>为了使用元组，只需定义一个长度合适的院，将其作为方法的返回值，然后再<code>return</code>语句中创建该元组，并返回即可。</p>
<h4 id="2-泛型接口"><a href="#2-泛型接口" class="headerlink" title="2.泛型接口"></a>2.泛型接口</h4><p>泛型也可以应用与接口，接口使用泛型和类使用泛型没什么区别</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function">T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>JAVA</code>泛型的一个局限性：基本类型无法作为类型参数</p>
<h4 id="3-泛型方法"><a href="#3-泛型方法" class="headerlink" title="3.泛型方法"></a>3.泛型方法</h4><p>是否拥有泛型方法，与其所在的类是否是泛型没有关系</p>
<p>泛型方法使得该方法能够独立于类而产生变化</p>
<p>无论何时，只要能做到，就应该尽量使用泛型方法</p>
<p><strong>要定义泛型方法，只需将泛型参数列表置于返回值之前</strong>,示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Demo()&#123;</span><br><span class="line">  public &lt;T&gt; void f(T t)&#123;</span><br><span class="line">    Sysout.out.println(t.getClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用泛型类时，必须在创建对象时指定参数类型的值，而使用方法的时候，通常不必指明参数类型，因为编译器会为我们找出具体的类型，这称为<strong>参数类型推断</strong>。因此可像普通方法一样调用<code>f()</code>,像是<code>f()</code>为无限重载过</p>
<ul>
<li><p>类型推断只对赋值操作有效，其他时候并不起作用，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">NewTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; <span class="function">Map&lt;K,V&gt; <span class="title">map</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> HashMap&lt;K,V&gt;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Map&lt;String,List&lt;Animal&gt;&gt;)</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function">oublic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">   <span class="comment">// fun(New.map()) //此时这个语法是不能编译的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>复制操作类型推断不起作用时，可使用：显示的类型说明：在泛型方法中可以显示的指明类型（很少用）</p>
<ul>
<li><p>要显示的指明类型，必须在点操作符与方法名之间插入尖括号，然后把类型置于尖括号内，如果是在定义该方法的内部，必须在点操作符前使用<code>this</code>，如果是使用静态方法，必须在点操作符之前加上类名,例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//改写上述的Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Test</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(Map&lt;String,List&lt;Animal&gt;&gt;)</span></span>&#123;&#125;;</span><br><span class="line">  <span class="function">oublic <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//如果是使用静态方法，必须在点操作符之前加上类名</span></span><br><span class="line">   fun(New.&lt;String,List&lt;Animal&gt;&gt;map()) </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<p>可变参数与泛型方法：泛型方法可以与可变参数列表很好的共存：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; List&lt;T&gt; makeList&lt;T... args&gt; &#123;</span><br><span class="line">  List&lt;T&gt; result =<span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">  <span class="keyword">for</span>(T item : args)&#123;</span><br><span class="line">    result.add(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>泛型还可以应用于内部类以及匿名类</p>
<p>泛型的一个重要好处是能够简单而安全的创建复杂的模型</p>
<h4 id="4-擦除的神秘之处"><a href="#4-擦除的神秘之处" class="headerlink" title="4.擦除的神秘之处"></a>4.擦除的神秘之处</h4><p>在泛型代码内部，无法获得任何有关泛型参数的类型信息</p>
<p><code>java</code>泛型是使用擦除来实现的：这意味着当你在使用泛型时，任何具体的类型信息都被擦除了，你唯一知道的就是你在使用一个对象，因为<code>List&lt;String&gt;</code> 和<code>ist&lt;integer&gt; </code>在运行时，事实上是相同的类型。这两种形式都被擦除成他们的“原生类型”，即：<code>List</code></p>
<p>泛型类型参数将擦除到他的第一个边界（可能有多个）</p>
<p><code>java</code>中泛型类型只有在静态类型检查期间才出现，在此之后，程序中的所有泛型类型都将被擦除，替换为他们的非泛型上界</p>
<ul>
<li>普通的类型变量在未指定边界的情况下将被擦除为<code>Object</code></li>
<li><code>List&lt;T&gt; </code>将被擦除为<code>List</code></li>
</ul>
<p>擦除的核心动机是他使得泛化的客户端可以用非泛化的类库来使用，反之亦然。这经常被称为：迁移兼容性。</p>
<p>擦除的问题：泛型不能显式的引用运行时类型的操作之中，例如：转型、<code>instanceof</code>操作、<code>new</code> 表达式，因为所有关于参数的类型信息都丢失了</p>
<p>因为擦除在方法体中移除了类型信息，所以在运行时的问题就是边界：即对象进入和离开方法的地点，这些正是编译器在编译期间执行类型检查并插入转型代码的地点。</p>
<p>在泛型中的所有动作都发生在边界处——对传递进来的值进行额外的编译期检查，并插入对传递出去的值的转型。边界就是发生动作的地方。</p>
<h4 id="5-擦除的补偿"><a href="#5-擦除的补偿" class="headerlink" title="5.擦除的补偿"></a>5.擦除的补偿</h4><p>编译器将确保类型标签可以匹配泛型参数，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class&lt;T&gt; kind;</span><br><span class="line">kind.isInstance(Object obj);</span><br><span class="line"><span class="comment">//obj instanceof T //不可用,因为类型信息被擦除</span></span><br></pre></td></tr></table></figure>

<p>创建类型实例：<code>new T()</code>无法实现，1是因为擦除，2是编译器不能验证具有无参构造器，解决办法：使用工厂方法</p>
<p><code>java</code>中不能创建泛型数组，一般的解决方案是在任何想要创建泛型数组的地方都是用<code>ArrayList</code></p>
<h4 id="6-边界"><a href="#6-边界" class="headerlink" title="6.边界"></a>6.边界</h4><p>边界使得你可以在用于泛型的参数类型上设置限制条件</p>
<ul>
<li>可以强制规定泛型可以应用的类型</li>
<li>可以按照自己的边界类型来调用方法</li>
</ul>
<p><code>java</code>泛型重用了<code>extends</code>关键字：将泛型参数限制为某个类型子集，那么你就可以用这些类型子集来调用方法，</p>
<p>（即可以通过<code>extend</code>关键字指定最终擦除所替代的类型。）例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">Bird</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">Animal</span> &amp; <span class="title">Fly</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>通配符被限制为单一边界</p>
<h4 id="7-通配符"><a href="#7-通配符" class="headerlink" title="7.通配符"></a>7.通配符</h4><p><strong>泛型与向上转型的概念</strong></p>
<p>先讲一讲几个概念：</p>
<ul>
<li>协变：子类能向父类转换 <code>Animal a1=new Cat();</code></li>
<li>逆变: 父类能向子类转换 <code>Cat a2=(Cat)a1;</code></li>
<li>不变: 两者均不能转变</li>
</ul>
<p>对于协变，我们见得最多的就是多态（协变）,而逆变常见于强制类型转换。</p>
<ul>
<li><p>强制类型转换原理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Object obj=<span class="string">&quot;test&quot;</span>;</span><br><span class="line">String str=(String)obj;</span><br></pre></td></tr></table></figure>

<p>原理便是<code>Java</code>反射机制能够记住变量<code>obj</code>的实际类型，在强制类型转换的时候发现<code>obj</code>实际上是一个<code>String</code>类型，于是就正常的通过了运行</p>
</li>
</ul>
<ul>
<li><p>数组是协变的：<code>  Object[] nums=new Integer[3]</code>;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">   Object[] nums=<span class="keyword">new</span> Integer[<span class="number">3</span>];</span><br><span class="line">   nums[<span class="number">0</span>]=<span class="number">3.2</span>;</span><br><span class="line">   nums[<span class="number">1</span>]=<span class="string">&quot;string&quot;</span>; <span class="comment">//运行时报错，nums运行时类型是Integer[]</span></span><br><span class="line">   nums[<span class="number">2</span>]=<span class="string">&#x27;2&#x27;</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>数组协变可能导致运行时报错，为什么还要设计成协变的：答案是在泛型还没出现之前，数组协变能够解决一些通用的问题：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//只操作数组本身，而不关心数组中具体保存的原始，</span></span><br><span class="line"><span class="comment">//或者是不管什么元素，取出来就作为一个Object存储的时候，只用编写一个Object[]就能写出通用的数组参数方法。例如</span></span><br><span class="line">Arrays.sort(<span class="keyword">new</span> Student[]&#123;...&#125;)</span><br><span class="line">Arrays.sort(<span class="keyword">new</span> Apple[]&#123;...&#125;)</span><br></pre></td></tr></table></figure>

<p>Arrays.sort(new Apple[]{…})</p>
</li>
</ul>
<p><strong>泛型</strong>的出现，是为了保证类型安全的问题，如果将泛型也设计为协变的话，那也就违背了泛型最初设计的初衷，因此在<code>Java</code>中，泛型是不变的，即：</p>
<p><code>List&lt;Number&gt;</code> 和 <code>List&lt;Integer&gt;</code> 是没有任何关系的，即使<code>Integer</code> 是 <code>Number</code>的子类</p>
<p>也就是对于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static void test(List&lt; Number&gt; nums)&#123;...&#125;</span><br></pre></td></tr></table></figure>

<p>方法，是无法传递一个<code>List&lt;Integer&gt;</code>参数的</p>
<p>如何解决既能使用数组协变带来的方便性，又能得到泛型不变带来的类型安全？  解决方案：<code>extend</code>,<code>super</code>关键字与通配符<code>?</code></p>
<p>(1)不可操作的数组（既不能存储也不能获取）：通配符</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">playEveryList</span><span class="params">(List &lt;?&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">//..</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>playEveryList</code>方法，传递任何类型的<code>List</code>都没有问题，但是你会发现对于<code>list</code>参数，你无法对里面的元素存和取。这样便达到了上面所说的<strong>安全类型的协变数组</strong>的效果。</p>
<p>如果希望对元素进行操作，可以选择：<code>extend</code>和<code>super</code>。</p>
<p>(2)协变泛型</p>
<p>数<code>List &lt; ? extend Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>，其中尖括号所指定的具体类型必须是继承自<code>Fruit</code>的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">playFruit</span><span class="params">(List &lt; ? extends Fruit&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do somthing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; apples=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Orange&gt; oranges=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Food&gt; foods =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    playFruit(apples);</span><br><span class="line">    playFruit(oranges);</span><br><span class="line">    <span class="comment">//playFruit(foods); 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组也能向上转型，但是存取元素有问题啊，泛型是怎么解决这一问题的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">playFruit</span><span class="params">(List &lt; ? extends  Fruit&gt; list)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 向传入的list添加元素，你会发现编译器直接会报错。可获取</span></span><br><span class="line">    list.add(<span class="keyword">new</span> Apple());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>(3)逆变泛型</p>
<p>参数<code>List &lt; ? super Fruit&gt;</code>所表示是需要一个<code>List&lt;&gt;</code>,其中尖括号所指定的具体类型必须是<code>Fruit</code>的父类类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">playFruitBase</span><span class="params">(List &lt; ? <span class="keyword">super</span>  Fruit&gt; list)</span></span>&#123;</span><br><span class="line">     <span class="comment">//..</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Apple&gt; apples=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Food&gt; foods =<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Object&gt; objects=<span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    playFruitBase(foods);</span><br><span class="line">    playFruitBase(objects);</span><br><span class="line">    <span class="comment">//playFruitBase(apples); 编译错误</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span>  <span class="keyword">static</span>  <span class="keyword">void</span> <span class="title">playFruitBase</span><span class="params">(List &lt; ? <span class="keyword">super</span>  Fruit&gt; list)</span></span>&#123;</span><br><span class="line">	<span class="comment">//取出list的元素，你会发现编译器直接会报错，可添加</span></span><br><span class="line">    Object obj=list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-问题"><a href="#8-问题" class="headerlink" title="8.问题"></a>8.问题</h4><p>java泛型中的问题：</p>
<ul>
<li><p>不能将基本类型用作泛型的类型参数：</p>
<ul>
<li>一般时候可以使用基本类型的包装器</li>
</ul>
</li>
<li><p>一个类不能实现同一个泛型接口的两种变体，由于擦除的原因，这两个变体会成为相同的接口，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Payable</span>&lt;<span class="title">T</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hourly</span> <span class="keyword">extends</span> <span class="title">Employee</span> <span class="keyword">implements</span> <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; //<span class="title">Hourly</span> 不能编译</span></span><br><span class="line"><span class="class">  </span></span><br><span class="line"><span class="class">//因为擦除会把 <span class="title">Payable</span>&lt;<span class="title">Employee</span>&gt; 和  <span class="title">Payable</span>&lt;<span class="title">Hourly</span>&gt; 简化成相同的类（但是都移除泛型，就可以编译）</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用带有泛型类型的参数的转型或<code>instanceof</code>不会有任何效果，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedSizeStack</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> index = <span class="number">0</span>; </span><br><span class="line">  <span class="keyword">private</span> Object[] storage;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(T item)</span></span>&#123;</span><br><span class="line">    storage[index++] = item;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//由于擦除，编译器无法判断此处的转型是否安全。所以会产生警告</span></span><br><span class="line">    <span class="keyword">return</span> (T)storage[--index]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>不能使用不同的泛型参数进行重载,例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>()</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; t1)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(List&lt;T&gt; t2)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>基类劫持了接口</p>
<p>如下示例，一旦为<code>Comparable</code>确定了<code>Pet</code>参数，那么其他<code>Pet</code>的任何实现类都不能与<code>Pet</code>置为的任何对象进行比较</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Comparable</span>&gt; </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Pet pet)</span></span>&#123;<span class="keyword">return</span> <span class="number">0</span>&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时Pet的子类Cat，更合理的是应该与Cat比较，但是这不能工作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">extends</span> <span class="title">Pet</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Cat</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// int compareTo(Cat cat) //不能编译</span></span><br><span class="line">  <span class="comment">// 因为两个类都继承了Comparable 区别是泛型参数不一样，但是泛型参数会被擦除，最后在Cat类中相当于：</span></span><br><span class="line">  <span class="comment">// int compareTo(Object pet)</span></span><br><span class="line">  <span class="comment">// int compareTo(Object cat) //所以这个不能编译</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="9-自限定的类型"><a href="#9-自限定的类型" class="headerlink" title="9.自限定的类型"></a>9.自限定的类型</h4><p>自限定类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>自限定所做的，就是要求在继承关系中，像下面这样使用上面的类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span>&lt;<span class="title">A</span>&gt; </span>&#123;&#125;  <span class="comment">//强制要求将正在定义的类当做参数传递给基类</span></span><br><span class="line"><span class="comment">//自限定惯用法不是可强制执行的，即下面的代码可编译</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">SelfBounded</span> </span>&#123;&#125;  </span><br></pre></td></tr></table></figure>

<p>自限定参数的意义：可以保证类型参数必须与正在被定义的类相同</p>
<p>自限定的限制是作用在继承关系上</p>
<p>自限定还可用于泛型方法，例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SelfBoundingMethods</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> &lt;T extends SelfBounded&lt;T&gt;&gt; <span class="function">T <span class="title">function</span><span class="params">(T arg)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String [] args)</span></span>&#123;</span><br><span class="line">    A a = function(<span class="keyword">new</span> A());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自限定类型可以协变参数类型——方法参数类型会随子类而变化</p>
<ul>
<li>在使用自限定类型时，在导出类只有一个方法，并且这个方法接受导出类型而不是基类型为参数</li>
</ul>
<h4 id="10-动态类型安全"><a href="#10-动态类型安全" class="headerlink" title="10.动态类型安全"></a>10.动态类型安全</h4><p><code>JDK5</code>的<code>java.util.Conllections</code>中有一组工具，可进行动态类型检查问题：</p>
<p><code>checkedCollection()</code>、<code>checkedList()</code>、<code>checkMap()</code>、<code>checkedSet()</code>、<code>checkedSortedMap()</code>、<code>checkedSortedSet()</code></p>
<p>这些方法的第一个参数是希望动态检查的容器，第二个参数是强制要求的类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Collections.checkedList(<span class="keyword">new</span> ArrayList&lt;Dog&gt;, Dog.class)</span><br></pre></td></tr></table></figure>

<p>将导出类型的对象放置到将要检查基类型的受检查容器中是没有问题的</p>
<h4 id="11-异常"><a href="#11-异常" class="headerlink" title="11.异常"></a>11.异常</h4><p>由于擦除，将泛型应用于异常是受限的：<code>catch</code>语句不能捕获泛型类型的异常，因为在编译期和运行时都必须知道异常的确切类型，泛型类也不能直接或者间接继承自<code>Throwable</code>.</p>
<h4 id="12-潜在的类型机制"><a href="#12-潜在的类型机制" class="headerlink" title="12.潜在的类型机制"></a>12.潜在的类型机制</h4><p>泛化：代码不关心他将要作用的类型，这种代码可以真正的应用于任何地方</p>
<p><code>java</code>泛型的边界限制了泛型的类型，是对泛化的限制</p>
<p>对泛化限制的解决：潜在类型机制或结构化类型机制或鸭子类型机制：即如果他走起来像鸭子，叫起来像鸭子，那么你就可以把他当做鸭子。</p>
<ul>
<li><p>潜在类型机制是一种代码组织和复用机制，有了它编写出的代码相对于没有他编写出的代码，能够更容易复用</p>
</li>
<li><p>支持潜在类型机制的语言：<code>python</code>和<code>c++</code></p>
</li>
<li><p>java是不支持潜在类型机制的</p>
<blockquote>
<p>对潜在类型机制的理解：例如<code>python</code>可以一个方法，传入一个参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function(cat)  &#123;</span><br><span class="line">	&#x2F;&#x2F;编译时可以这样调用，不会在编写时被限制，只要最后cat是有这个fun()方法就可以，否则运行时报错</span><br><span class="line">	cat.fun();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>java </code>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function (Anomal cat )&#123; &#x2F;&#x2F;首先传入时就要标明类型（此处举例没有使用泛型，使用泛型的话，Anomal相当于是边界）</span><br><span class="line">    cat.eat();</span><br><span class="line">    cat.fun(); &#x2F;&#x2F;此时传入的类型被认为是Anomal  如果Anomal没有fun()方法，这行代码，不能被编译。即依赖类型编码，缺乏泛化性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<h4 id="13-对缺乏潜在类型机制的补偿"><a href="#13-对缺乏潜在类型机制的补偿" class="headerlink" title="13.对缺乏潜在类型机制的补偿"></a>13.对缺乏潜在类型机制的补偿</h4><p><code>java</code>不支持潜在类型机制，不意味着有界泛型代码不能在不同的类型层次结构之间使用，只是需要额外的努力</p>
<ul>
<li>反射</li>
<li>类型标记技术</li>
<li>用适配器仿真潜在类型机制</li>
</ul>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十九-枚举类型</title>
    <url>/2018/12/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E4%B9%9D-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>关键字<code>enum</code> 可以将一组具名的值的有限集合创建为一种新的类型，而这些具名的值可以作为常规的程序组件使用，这是一种非常有用的功能</p>
<span id="more"></span>

<h4 id="1-基本enum特性"><a href="#1-基本enum特性" class="headerlink" title="1.基本enum特性"></a>1.基本enum特性</h4><p><code>enum</code>的<code>values()</code>方法，可以遍历<code>enum</code>实例，<code>alues()</code>方法返回<code>enum</code>实例的数组，而且该数组严格保持其在<code>enum</code>中声明时的顺序</p>
<p>创建<code>enum</code>时，编译器会为你生成一个相关的类，这个类继承自<code>ava.lang.Enum</code>：</p>
<ul>
<li><code>ordinal()</code>方法返回一个<code>int</code>值：这是每个<code>enum</code>实例在声明时的次序，从0开始</li>
<li>可以使用<code>==</code>来比较<code>enum</code>实例，编译器会自动为你提供<code>equals()</code>和<code>hashcode()</code>方法</li>
<li><code>Enum</code>类实现了<code>Comparable</code>接口，所以它具有<code>compareTO()</code>方法，</li>
<li>同时还实现了<code>Serializable</code>接口</li>
<li><code>name()</code>返回<code>enum</code>实例声明时的名字</li>
<li><code>valueOf()</code>是<code>static</code>方法，根据给定的名字返回相应的<code>enum</code>实例，如果不存在给定名字的实例，将会抛出异常</li>
</ul>
<p>使用 静态导入（<code>import static</code> 路径）能够将<code>enum</code>带入当前的命名空间，所以无需再用<code>enum</code>类型来修饰<code>enum</code>实例</p>
<ul>
<li>注意：在定义<code>enum</code>的同一个文件中，这种技巧无法使用，如果是在默认包中定义<code>enum</code>,这种技巧也无法使用</li>
</ul>
<h4 id="2-向enum中添加新方法"><a href="#2-向enum中添加新方法" class="headerlink" title="2.向enum中添加新方法"></a>2.向enum中添加新方法</h4><p>除了<strong>不能继承自一个enum之外</strong> ，基本可以将<code>enum</code>看做一个常规的类，我们可以先向<code>enum</code>中增加方法，<code>enum</code>中甚至可以有<code>main()方</code>法</p>
<p><code>java</code>要求必须先定义<code>enum</code>实例，在定义实例之前定义任何方法和属性都会报错</p>
<p><code>enum</code>中的构造方法和普通方法没有区别，不过默认为私有，我们只能在<code>enum</code>定义的内部使用其构造器创建<code>enum</code>实例</p>
<h4 id="3-switch语句中的enum"><a href="#3-switch语句中的enum" class="headerlink" title="3.switch语句中的enum"></a>3.switch语句中的enum</h4><p><code>switch</code>中只能使用整数值（字符串时，使用的是<code>hashcode</code>）,而枚举实例天生就具备整数值的次序（并且可通过<code>ordinal()</code>获取）</p>
<p>所以可以在<code>switch</code>中使用<code>enum</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Signal</span> </span>&#123;GREEN , YELLOW ,RED&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrafficLight</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(Signal color)</span></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(color) &#123;</span><br><span class="line">      <span class="keyword">case</span> RED :color.name(); <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> YELLOW :color.name() ; <span class="keyword">break</span>; </span><br><span class="line">      <span class="keyword">case</span> GREEN :color.name(); <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-values-的神秘之处"><a href="#4-values-的神秘之处" class="headerlink" title="4.values()的神秘之处"></a>4.values()的神秘之处</h4><p><code>values()</code>是由编译器添加的<code>static</code>方法</p>
<p>由于<code>values()</code>是编译器插入到<code>enum</code>定义中的<code>static</code>方法，所以你将<code>enum</code>实例向上转型为<code>Enum</code>，那么<code>values()</code>方法就不可访问了，不过还可使用其他方式获取所有<code>enum</code>实例：<code>Class</code>中有一个<code>getEnumConstans()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Enum e = Signal.RED;</span><br><span class="line">e.getClass.getEnumConstants();</span><br></pre></td></tr></table></figure>

<p><code>getEnumConstants</code>是<code>Class</code>上的方法，所以不是枚举类也可以使用：但是 此时此方法返回<code>null</code>。</p>
<h4 id="5-实现，并非继承"><a href="#5-实现，并非继承" class="headerlink" title="5.实现，并非继承"></a>5.实现，并非继承</h4><p>因为所有的<code>enum</code>都继承自<code>java.lang.Enum</code>,所以**<code>enum</code>不能在继承其他的类**，但是可以实现一个或多个接口</p>
<h4 id="6-随机获取"><a href="#6-随机获取" class="headerlink" title="6.随机获取"></a>6.随机获取</h4><p>在<code>enum</code>实例中随机选择：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumUtils</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Random rand =<span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T extend Enum&lt;T&gt;&gt; random(Class&lt;T&gt; ec)&#123;</span><br><span class="line">    <span class="keyword">return</span> random(ec.getEnumConstants());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">random</span><span class="params">(T[] values)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> values[ran.nextInt(values.length)];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-使用接口组织枚举"><a href="#7-使用接口组织枚举" class="headerlink" title="7.使用接口组织枚举"></a>7.使用接口组织枚举</h4><p>在一个接口内部，创建实现接口的枚举以此将元素进行分组，可以达到将枚举元素分类组织的目的,例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Appetizer</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    SALAD,SOUP;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">MainCourse</span> <span class="keyword">implements</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    LASAGNE,BURRITO;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于<code>enum</code>而言，实现接口是使其子类化的唯一办法</p>
<p>当与一大堆枚举打交道时，实现“枚举中的枚举”,可创建新的<code>enum</code>,然后用实例包装<code>Food</code>中的每一个<code>enum</code>类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Course</span> </span>&#123;</span><br><span class="line">  APPETIZER(Food.Appetizer.class),</span><br><span class="line">  MAINCOURSE(Food.MainCourse.class);</span><br><span class="line">  <span class="keyword">private</span> Food[] values;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Course</span><span class="params">(Class&lt;? extends Food&gt; kind)</span></span>&#123;</span><br><span class="line">    values = kind.getEnumContants();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Food <span class="title">randomSelect</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> EnumUtils.random(values)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>还可以更简洁，将一个<code>enum</code>嵌套在另一个<code>enum</code>内.</p>
<h4 id="8-使用EnumSet替代标志"><a href="#8-使用EnumSet替代标志" class="headerlink" title="8.使用EnumSet替代标志"></a>8.使用EnumSet替代标志</h4><p><code>java SE5</code>引入<code>EnumSet,EnumSet</code>非常高效快速</p>
<p>使用<code>EnumSet</code>的优点是，他在说明一个二进制位是否存在时，具有更好地表达能力，并且无需担心性能</p>
<p><code>EnumSet</code>中的元素必须来自一个<code>enum</code></p>
<ul>
<li><code>EnumSet.noneOf()</code></li>
<li><code>EnumSet.of()</code></li>
<li><code>EnumSet.allOf()</code></li>
<li><code>EnumSet.removeAll()</code></li>
<li><code>EnumSet.complementOf()</code></li>
</ul>
<p><code>EnumSet</code>的基础是<code>long</code></p>
<h4 id="9-使用EnumMap"><a href="#9-使用EnumMap" class="headerlink" title="9.使用EnumMap"></a>9.使用EnumMap</h4><p><code>EnumMap</code>是一种特殊的<code>map</code>，要求其中的key必须来自一个<code>enum</code>，</p>
<p>由于<code>enum</code>本身的限制，所以<code>EnumMap</code>在内部可由数组实现，所以<code>EnumMap</code>的速度很快。</p>
<p>除了<code>key</code>值要求，其他操作与一般的<code>map</code>差不多</p>
<p>与<code>EnumSet</code>一样，<code>enum</code>实例定义时的次序决定了骑在<code>EnumMap</code>中的顺序</p>
<p>与常量方法相比：<code>EnumMap</code>有一个优点：允许改变值对象，而常量相关的方法，在编译期就被固定了</p>
<h4 id="10-常量相关的方法"><a href="#10-常量相关的方法" class="headerlink" title="10.常量相关的方法"></a>10.常量相关的方法</h4><p>可以为<code>enum</code>实例编写方法，从而为每个<code>enum</code>实例赋予各自不同的行为。</p>
<p>要实现常量相关的方法，你需要为<code>enum</code>定义一个或多个<code>abstract</code>方法，然后为每个<code>enum</code>实例实现该抽象方法，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">ConstantsMethod</span> </span>&#123;</span><br><span class="line">  DATE_TIME &#123;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> String.valueOf(<span class="keyword">new</span> Date);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  VERSION &#123;</span><br><span class="line">    <span class="function">String <span class="title">getInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">&quot;java version&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">abstract</span> String <span class="title">getInfo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过相应的<code>enum</code>实例，我们可以调用其上的方法，这通常也称为表驱动的代码</p>
<p>常量方法比内部类更高效一些</p>
<p>每个<code>enum</code>元素都是一个<code>LikeClasses</code>类型的<code>static final</code>实例</p>
<h4 id="11-总结"><a href="#11-总结" class="headerlink" title="11.总结"></a>11.总结</h4><p><code>java</code>枚举是一个“小”功能，但是有时就是因为他，才能更优雅而干净的解决问题</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十八-Java I/O系统</title>
    <url>/2019/04/17/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%85%AB-Java-I-O%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>对于程序语言的设计者来说，创建一个好的输入/输出（<code>I/O</code>）系统是一项艰难的任务</p>
<span id="more"></span>

<h4 id="1-File类"><a href="#1-File类" class="headerlink" title="1.File类"></a>1.File类</h4><p><code>File</code> 既能代表一个特定文件的名称，又能代表一个目录下的一组文件的名称（<code>File</code>是文件和目录路径名的抽象形式）</p>
<p>简单示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fileTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建文件</span></span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">&quot;D:/test.txt/&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.exists())&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;不存在&quot;</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            file.createNewFile();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 可以回去文件信息：file.getName()、file.length()、file.isFile()、file.isDirectory() 等等</span></span><br><span class="line">   </span><br><span class="line">	 <span class="comment">// 创建目录</span></span><br><span class="line">     File filedir = <span class="keyword">new</span> File(<span class="string">&quot;D:/test/test&quot;</span>);</span><br><span class="line">     <span class="keyword">if</span>(!filedir.exists())&#123;</span><br><span class="line">         System.out.println(<span class="string">&quot;路径不存在&quot;</span>);</span><br><span class="line">         filedir.mkdirs();</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//可以获取目录信息：filedir.isDirectory()、filedir.isFile()、filedir.list().length等等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>Java</code>中，<code>File </code>类是 <code>java.io </code>包中唯一代表磁盘文件本身的对象。</p>
<p><code>File</code>类主要用来获取或处理与磁盘文件相关的信息，像文件名、 文件路径、访问权限和修改日期等，还可以浏览子目录层次结构。</p>
<p><code>File </code>类表示处理文件和文件系统的相关信息。也就是说，<code>File</code> 类不具有从文件读取信息和向文件写入信息的功能，它仅描述文件本身的属性。</p>
<h4 id="2-输入和输出"><a href="#2-输入和输出" class="headerlink" title="2.输入和输出"></a>2.输入和输出</h4><p>编程语言的<code>I/O</code>类库中常使用“流’’这个概念，它代表任何有能力产出数据的数据源对象或者有能力接收数据的接收端对象，“流”屏蔽了实际的<code>I/O</code>设备中处理数据的细节</p>
<p><code>java</code>类库中的<code>I/O</code>类分成输入和输出两部分：</p>
<ul>
<li>任何自<code>InputStrean</code>或<code>Reader</code>派生而来的类都含有名为<code>read()</code>的基本方法，用于读取单个字节或者字节数组</li>
<li>任何自<code>OutputStream</code>或<code>Writer</code>派生而来的类都含有名为<code>write()</code>的基本方法，用于写单个字节或者字节数组</li>
</ul>
<p>不过，我们很少使用单一的类来创建流对象，而是通过叠合多个对象来提供期望的功能(装饰器模式)</p>
<p><code>java</code>中“流”让人困惑的主要原因就在于：创建单一的结果流，却需要创建多个对象</p>
<p><strong><code>InputStrean</code>类型</strong></p>
<p><code>InputString</code>的作用是用来表示那些从不同数据源产生输入的类，这些数据源包括：</p>
<ul>
<li>子节数组（<code>ByteArrayInputStream</code>）</li>
<li><code>String</code>对象（<code>StringBufferInputStream</code>:已弃用）</li>
<li>文件（<code>FileInputStream</code>）</li>
<li>“管道”，工作方式与实际管道相似，即：从一端输入，从另一端输出（<code>PipedInputStream</code>）</li>
<li>一个由其他种类的流组成的序列，以便我们可以将它们收集合并到一个流内（<code>SequenceInputStream</code>）</li>
<li>其他数据源，如<code>Internet</code>连接等</li>
</ul>
<p>每一种数据源都有相应的<code>InputStream</code>子类</p>
<p><code>FilterInputStream</code>也属于一种<code>InputStream</code>，为“装饰器”类提供基类，其中“装饰器”类可以把属性或有用的接口与输入流连接在一起</p>
<p><strong><code>OutputStream</code>类型</strong></p>
<p>该类别的类决定了输出所要去往的目标：</p>
<ul>
<li>子节数组(但不是<code>String</code>,不过可以用子节数组自己创建)（<code>ByteArrayOutputStream</code>）</li>
<li>文件（<code>FileOutputStream</code>）</li>
<li>管道（<code>PipeOutputStream</code>）</li>
</ul>
<p><code>FilterOutputStream</code>为“装饰器”类提供了一个基类，“装饰器”类把属性或者有用的接口与输出流连接了起来</p>
<h4 id="3-添加属性和有用的接口"><a href="#3-添加属性和有用的接口" class="headerlink" title="3.添加属性和有用的接口"></a>3.添加属性和有用的接口</h4><p><code>java I/O</code>需要多种不同功能的组合，这正是使用装饰器模式的理由所在</p>
<p>装饰器模式也有一个缺点：在编写程序时，他给我们提供了相当多的灵活性（因为我们可以很容易的混合和匹配属性），但是他同样也增加了代码的复杂性</p>
<p>通过<code>FilterInputStream</code>从<code>InputStream</code>读取数据：</p>
<p><code>FilterInputStream</code>类能够完成两件完全不同的事情：</p>
<ul>
<li><code>DataInputStream</code>允许我们读取不同的基本类型数据以及<code>String</code>对象(所有方法都以<code>read</code>开头，例如<code>readByte()</code>等等)，搭配相应的<code>DataOutputStream</code>,我们就可以通过数据“流”将基本类型的数据从一个地方迁移到另一个地方</li>
<li>其他的<code>FilterInputStream</code>类则在内部修改<code>InputStream</code>的行为方式：是否缓冲、是否保留读过的行等等（其他的<code>FilterInputStream</code>例如：<code>BufferedInputStream</code>）</li>
</ul>
<p>通过<code>FilterOutputStream</code>向<code>OutStream</code>写入：</p>
<p><code>FilterInputStream</code>类包括：</p>
<ul>
<li><p><code>DataOutputStream</code>：与<code>DateInputStream</code>对应的是<code>DataOutputStream,</code>他可以将各种基本数据类型以及<code>String</code>对象格式化输出到“流”中，这样一来，任何机器上的<code>DataInputStream</code>都能够读取他们，所有方法都以<code>write</code>开头，例如<code>writeByte()</code>等等</p>
</li>
<li><p><code>PrintStream</code>的目的是为了格式化输出（<code>DataOutputStream</code>的目的时间数据元素置入“流”中，使<code>DateInputStream</code>能够可移植的重构他们）</p>
<p><code>PrintStream</code>是有一些问题的：一个是捕捉了所有<code>IOException</code>(因为我们必须使用<code>checkErrors</code>自行的检查错误状态)，二是为完全国际化，不能以平台无关的方式处理换行动作（这些问题在<code>printWrite</code>中得到了解决）</p>
</li>
<li><p><code>BufferedOutputStream</code>:对数据使用缓存技术，每次像流写入时，不必每次都进行实际的物理写动作，在输出时，我们可能经常使用它</p>
</li>
</ul>
<h4 id="4-Reader和Writer"><a href="#4-Reader和Writer" class="headerlink" title="4.Reader和Writer"></a>4.<code>Reader</code>和<code>Writer</code></h4><p><code>Reader</code>和<code>Writer</code>是提供兼容<code>Unicode</code>与<strong>面向字符</strong> 的<code>I/O</code>功能</p>
<p>有时候我们需要把字节流的类和字符流的类结合起来使用，为了实现这个目的，要用到适配器类：<code>InputStreamReader</code>可以把<code>InputStream</code>转换为<code>Reader</code>,而<code>OutputStreamWriter</code>可以把<code>OutputStream</code>转换为<code>Writer</code></p>
<p>设计<code>Reader</code>和<code>Writer</code>主要是为了支持国际化，之前的子节流继承结构只支持<code>8</code>位的子节流，不能很好地处理<code>16</code>位的<code>Unicode</code>字符</p>
<p>几乎所有原始的<code>java I/O</code>流类都有相应的<code>Reader</code>和<code>Writer</code>类，来提供天然的<code>Unicode</code>操作</p>
<p>但是有时我们还是需要使用字节流，例如<code>java.util.Zip</code>类库就是面向字节的而不是面向字符的，因此最明智的做法是尽量尝试使用<code>Reader</code>和<code>Writer</code>一旦代码无法成功编译，我们就知道不得不使用面向字节的类库</p>
<p>无论何时我们使用<code>readLine()</code>都不应该使用<code>DataInputStream</code>(过时方法)，而应该使用<code>BufferedReader</code>,除了这一点，<code>DataInputStream</code>仍是I/O类库的首选成员</p>
<h4 id="5-自我独立的类：RandomAccessFile"><a href="#5-自我独立的类：RandomAccessFile" class="headerlink" title="5.自我独立的类：RandomAccessFile"></a>5.自我独立的类：<code>RandomAccessFile</code></h4><p><code>RandomAccessFile</code>不是<code>InputStream</code>和<code>OutputStream</code> 继承层次结构中的一部分，除了实现了<code>DataInput</code>和<code>DateOutput</code>接口（<code>DataInputStream</code>和<code>DataOutputStream</code>也实现了这两个接口）之外，无其他关联</p>
<p><code>RandomAccessFile</code>的工作方式类似于把<code>DataInputStream</code>和<code>DataOutputStream</code>组合起来使用，还添加了一些方法：例如<code>getFilepointer()</code>(查找当前所处的文件位置)</p>
<p>只有<code>RandomAccessFile</code>支持搜寻方法，并且只适用于文件（<code>BufferedInputStream</code>能允许标注位置(<code>mark()</code>),其值存储于内部某个简单变量内）和重新设定位置(<code>reaset()</code>),这些功能很有限，不是非常有用</p>
<p>在<code>JDK1.4</code>中，<code>RandomAccessFile</code>的大多数功能（不是全部）由<code>nio</code>存储映射文件所取代</p>
<h4 id="6-I-O流的典型使用方式"><a href="#6-I-O流的典型使用方式" class="headerlink" title="6.I/O流的典型使用方式"></a>6.<code>I/O</code>流的典型使用方式</h4><ul>
<li><p>1.缓冲输入文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">in.readLine()</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.从内存输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringReader in = <span class="keyword">new</span> StringReader(BufferedInputFile.read(<span class="string">&quot;Test.java&quot;</span>));</span><br><span class="line">in.read()</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.格式化的内存输入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> ByteArrayInputStream(BufferedInputFile.read(<span class="string">&quot;Test.java&quot;</span>).getBytes()));</span><br><span class="line">System.out.print(in.readByte());</span><br></pre></td></tr></table></figure>
</li>
<li><p>4.基本的文件输出</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;Test.out&quot;</span>)));</span><br><span class="line">out.println(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//JAVA SE5在PrintWriter添加了一个辅助构造器，不必自己执行所有装饰工作，不过其他的常见写入任务没有快捷方式</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;Test.out&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>5.存储和恢复数据</p>
<p><code>PrintWriter</code>可以对数据进行格式化，以便人们的阅读，但是为了输出可供另一个“流”恢复的数据，我们需要用<code>DataOutputStream</code>写入数据，并用<code>DataInputStream</code>恢复数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataOutputStream out = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">out.writeUTF(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">out.close();</span><br><span class="line">DataInputStream in = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.txt&quot;</span>)));</span><br><span class="line">System.out.println(in.readUTF());</span><br></pre></td></tr></table></figure>

<p>不过，对象序列化和<code>XML</code>可能是更容易的存储和读取复杂数据结构的方式</p>
</li>
<li><p>6.读写随机访问文件</p>
<p><code>RandomAccessFile</code>中，利用<code>seek()</code>可以在文件中到处移动，并修改文件中的某个值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器的第二个参数：r:只读，rw:读写</span></span><br><span class="line">RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;r&quot;</span>);</span><br><span class="line">rf.writeUTF(<span class="string">&quot;String&quot;</span>);</span><br><span class="line">rf.close();</span><br><span class="line">display();</span><br><span class="line">RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">rf.seek(<span class="number">5</span>*<span class="number">8</span>);<span class="comment">//double是8个字长，方法的意思是查找第五个双精度的值</span></span><br><span class="line">rf.writeDouble(<span class="string">&quot;50.0&quot;</span>);</span><br><span class="line">display();</span><br></pre></td></tr></table></figure>
</li>
<li><p>7.管道流</p>
<p>多线程中更能体现他的价值，因为管道流用于任务之间的通信</p>
</li>
</ul>
<h4 id="7-标准I-O"><a href="#7-标准I-O" class="headerlink" title="7.标准I/O"></a>7.标准<code>I/O</code></h4><p>标准<code>I/O</code>这个术语是参照<code>Unix</code>中的“程序所使用的单一信息流”这个概念。</p>
<ul>
<li>程序的所有输入都可以来自于标准输入</li>
<li>程序的所有输出都可以发送到标准输出</li>
<li>程序的所有错误信息都可以发送到标准错误</li>
</ul>
<p>标准<code>I/O</code>的意义在于：我们可以很容易的把程序串联起来，一个程序的标准输出可以成为另一个程序的标准输入</p>
<p>按照标准<code>I/O</code>的模型，<code>java</code>提供了<code>System.in</code>、<code>System.out</code>、<code>System.err</code></p>
<ul>
<li><p><code>System.out</code>：标准输出，已经被包装成了<code>printStream</code>对象</p>
<p><code>System.out</code>可以被转化为<code>PrintWriter</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造器的第二个参数要设置为true,以便开启自动清空功能，否则可能看不到输出</span></span><br><span class="line">PrintWriter out = <span class="keyword">new</span> PrintWriter(System.out,<span class="keyword">true</span>);</span><br><span class="line">out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>System.err</code>：标准错误，已经被包装了成<code>printStream</code>对象</p>
</li>
<li><p><code>System.in</code>：标准输入，没有被包装过的，未被加工的<code>InputStream</code>。所以：我们可以立即使用<code>System.out</code>和<code>System.err</code>，但是在读取<code>System.in</code>之前必须对其进行包装，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));<span class="comment">//System.in和大多数流一样，通常应该对它进行缓冲</span></span><br><span class="line">in.readLine();</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>标准<code>I/O</code>的重定向：<code>System</code>类提供了一些静态方法，允许对标准输入、输出、错误<code>I/O</code>流进行重定向</p>
<ul>
<li><code>setIn(InputStream)</code></li>
<li><code>setOut(PrintStream)</code></li>
<li><code>setErr(PrintStream)</code></li>
</ul>
<p>当输出滚动太快导致无法阅读或者想重复测试某个特定用户的输入序列的命令行程序的时候，重定向输出就显得尤为有用</p>
<p>需要注意的是：<code>I/O</code>重定向操纵的是字节流，而不是字符流。</p>
<h4 id="8-新I-O"><a href="#8-新I-O" class="headerlink" title="8.新I/O"></a>8.新<code>I/O</code></h4><p><code>JDK 1.4</code>的<code>java.nio.*</code>包中引入了新的<code>javaI/O</code>类库，其目的主要在于提高速度</p>
<p>实际上旧的<code>I/O</code>包已经使用<code>nio</code>重新实现过，以便充分的利用这种速度的提高，因此即使我们没有显示的使用<code>nio</code>编写代码，也能从其中受益</p>
<p>速度的提高在文件<code>I/O</code>和网络<code>I/O</code>中都存在，我们研究前者</p>
<p>速度的提高来自于所使用的结构更接近于操作系统执行<code>I/O</code>的方式：通道和缓冲器</p>
<p>唯一直接与通道交互的缓存器是<code>ByteBuffer</code>（也就是说：可以存储未加工字节的缓冲器）</p>
<p>旧<code>I/O</code>类库中有三个类被修改了，用以产生<code>FileChannel</code>。这三个类为：<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code>，注意这些是子节操作流和底层的<code>nio</code>性质一致，<code>Reader</code>和<code>Writer</code>这种字符模式类不能用于产生通道，但是<code>java.nio.channels.Channels</code>类提供了实用方法，用以在通道中产生<code>Reader</code>和<code>Writer</code></p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel fc = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>).getChannel();</span><br><span class="line">fc.write(ByteBuffer.wrap(<span class="string">&quot;some String&quot;</span>.getBytes()));</span><br></pre></td></tr></table></figure>

<p>通道是一种相当基础的东西：可以向它传送用于读写的<code>ByteBuffer</code>,并且可以锁定文件的某些区域用于独占式访问。</p>
<p>将字节存放于<code>ByteBuffer</code>的方法之一是：</p>
<ul>
<li>使用一种<code>“put”</code>方法直接对他们进行填充，填入一个或多个字节，或基本数据类型的值</li>
<li>使用<code>warp()</code>方法将已存在的字节数组“包装”到<code>ByteBuffer</code>中，一旦如此，就不再复制底层的数组，而是把它作为所产生的<code>ByteBuffer</code>的存储器，我们称之为数组支持的<code>ByteBuffer</code></li>
</ul>
<p>特殊方法<code>transferTo()</code>和<code>transferFrom()</code>允许我们将一个通道和另一个通道直接相连</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileChannel in = <span class="keyword">new</span> FileInputStram(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">  out = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">in.transferTo(<span class="number">0</span>,in.size,out);</span><br></pre></td></tr></table></figure>

<p>转换数据：缓冲器容纳的是普通的子节，为了把它们转换城字符，我们要么在输入它们的时候对其进行编码（这样，它们输出时才具有意义），要么在将其从缓冲器输出时对他们进行解码，可以使用<code>java.nio.charset.Charset</code>类实现这些功能，该类提供了把数据编码成多种不同类型的字符集的工具</p>
<p>获取基本数据类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">bb.asLongBuffer().put(<span class="number">11111</span>);</span><br><span class="line">bb.getLong();</span><br><span class="line">bb.rewind();</span><br><span class="line">bb.asDoubleBuffer().put(<span class="number">11111</span>);</span><br><span class="line">bb.getDouble();</span><br><span class="line"><span class="comment">//向ByteBuffer插入基本类型数据的最简单的方法是：利用asCharBuffer()、asShortBuffer()等获得该缓冲器上的视图，然后使用视图的put()方法</span></span><br></pre></td></tr></table></figure>

<p>视图缓冲器：可以让我们通过某个特定的基本数据类型的视窗来查看其底层的<code>ByteBuffer</code>，<code>ByteBuffer</code>依然是实际存储数据的地方，“支持着前面的视图”，因此，对视图的任何修改都会映射成为对<code>ByteBuffer</code>中数据的修改，如上的示例</p>
<p>一旦底层的<code>ByteBuffer</code>通过视图缓冲器填满了整数或其他基本类型时，就可以直接被写道通道中了</p>
<p>字节存放次序：不同的机器可能会使用不同的字节排序方法来存储数据：</p>
<ul>
<li><code>big endian</code>：高位优先，将最重要的字节存放在地址最低的存储器单元</li>
<li><code>little endian</code>：低位优先，将最重要的字节存放在地址最高的存储器单元</li>
</ul>
<p>当存储量大于一个字节时例如<code> int</code>、<code>float</code>等，就需要考虑字节的顺序问题了</p>
<p><code>ByteBuffer</code>是以高位优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式，不过我们可以采用带有参数<code>ByteOrder.BIG_ENDIAN</code>或<code>ByteOrder.LITTLE_ENDIAN</code>的<code>order()</code>方法改变<code>ByteBuffer</code>的字节排序方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.wrap(<span class="keyword">new</span> Byte[<span class="number">12</span>]);</span><br><span class="line">bb.order(ByteOrder.BIG_ENDIAN);<span class="comment">//默认方式</span></span><br><span class="line">bb.order(ByteOrder.LITTLE_ENDIAN);</span><br></pre></td></tr></table></figure>

<p><code>ByteBuffer</code>是将数据库移进移出通道的唯一方式，但是我们不能把基本类型的缓冲器转换为<code>ByteBuffer</code>,所以此时便可使用视图缓冲器将基本类型移进移出<code>ByteBuffer</code></p>
<p><code>Buffer</code>由数据和可以高效地访问及操纵这些数据的四个索引组成，这四个索引是：<code>mark</code>（标记）、<code>position</code>（位置）、<code>limit</code>（界限）、和<code>capacity</code>（容量）</p>
<p>在缓冲器中插入和提取数据的方法会更新这些索引，用于反映所发生的变化</p>
<p>内存映射文件：内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件，有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问，这种方法极大的简化了用于修改文件的代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> length = <span class="number">0X8FFFFF</span>;</span><br><span class="line">MappedByteBuffer out = <span class="keyword">new</span> RandomAccessFile(<span class="string">&quot;test.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>).getChannel().map(FileChannel.MapMode.READ_WRITE,<span class="number">0</span>,length);</span><br><span class="line">out.put((<span class="keyword">byte</span>)<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">out.get(length/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p><code>MappedByteBuffer</code>是一种特殊类型的直接缓冲器，注意我们必须制定映射文件的初始位置和映射区域的长度，这意味着我们可以映射某个文件的较小部分</p>
<p><code>MappedByteBuffer</code>由<code>ByteBuffer</code>继承而来，因此它具有<code>ByteBuffer</code>的所有方法</p>
<p>尽管“旧”的<code>I/O</code>流在用<code>nio</code>实现后性能有所提高，但是“映射文件访问”往往可以更加显著地加快速度（建立映射文件的花费很大，但是整体收益比起<code>I/O</code>流来说还是很显著的）</p>
<p>文件加锁：<code>JDK1.4</code>引入了文件加锁机制，允许我们同步访问某个作为共享资源的文件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.txt&quot;</span>);</span><br><span class="line">FileLock fl = fos.getChannel().tryLock();</span><br></pre></td></tr></table></figure>

<p>通过对<code>FileChannel</code>调用<code>tryLock()</code>或<code>lock()</code>,就可以获得整个文件的<code>FileLock</code>：</p>
<ul>
<li><p><code>tryLock()</code>是非阻塞式的，他设法获取锁，如果不能获得，将直接从方法调用返回</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, <span class="keyword">boolean</span> shared);<span class="comment">//第三个参数为是否是共享锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>lock()</code>是阻塞式的，他要阻塞进程直至锁可以获得，或调用<code>lock()</code>的线程中断，或调用<code>lock()</code>的通道关闭</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">lock(<span class="keyword">long</span> position, <span class="keyword">long</span> size, bollean shared);<span class="comment">//第三个参数为是否是共享锁</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用<code>FileLock.release()</code>可以释放锁</p>
</li>
</ul>
<p>对独占锁或者共享锁的支持必须由底层的操作系统提供，如果操作系统不支持共享锁并为每一个请求都创建一个锁，那么他就会使用独占锁，锁的类型(共享或独占)可以通过<code>FileLock.isShared()</code>进行查询。</p>
<h4 id="9-压缩"><a href="#9-压缩" class="headerlink" title="9.压缩"></a>9.压缩</h4><p><code>java I/O</code>类库中的类支持读写压缩格式的数据流，可以用他们对其他的<code>I/O</code>类进行封装，以提供压缩功能</p>
<p>这些类不是从<code>Reader</code>和<code>Writer</code>类派生而来，而是属于<code>InputStream</code>和<code>OutputStream</code>继承层次结构的一部分，这样做是因为压缩类库是按字节方式而不是字符方式处理的，不过有时我们可能会被迫要混合两种类型的数据流</p>
<p>尽管存在多种压缩算法：<code>GZIP</code>和<code>Zip</code>是最常用的</p>
<p>（1）使用<code>GZIP</code>进行简单压缩</p>
<p><code>GZIP</code>接口非常简单，因此如果我们要对单个数据流进行压缩，是比较合适的选择</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BufferedReader in = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(args[<span class="number">0</span>]));</span><br><span class="line">BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> GZIPOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.gz&quot;</span>)));</span><br><span class="line">out.write(...);</span><br><span class="line">BufferedReader in2 = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> GZIPInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;test.gz&quot;</span>))));</span><br><span class="line">in2.readLine();</span><br></pre></td></tr></table></figure>

<p>（2）使用<code>Zip</code>进行多文件保存</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">FileOutputStream f = <span class="keyword">new</span> FileOutputStream(<span class="string">&quot;test.zip&quot;</span>);</span><br><span class="line">CheckOutputStream csum = <span class="keyword">new</span> CheckOutputStream(f,<span class="keyword">new</span> Adler32());</span><br><span class="line">ZipOutputStream zos = <span class="keyword">new</span> ZipOutputStream(csum);</span><br><span class="line">BufferedOutputStream out = <span class="keyword">new</span> BufferedOutputStream(zos);</span><br><span class="line">out.setComment(<span class="string">&quot;String&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><code>java</code>档案文件：<code>Zip</code>格式也被应用于<code>JAR</code>（<code>Java Archive</code>,<code>java</code>档案文件）文件格式中（但是<code>jar</code>工具的功能没有<code>zip</code>工具那么强大）</p>
<h4 id="10-对象序列化"><a href="#10-对象序列化" class="headerlink" title="10.对象序列化"></a>10.对象序列化</h4><p>对象在程序终止时，不会再存在。存在某些情况，若是存在在程序不运行的情况下仍能存在并保存其信息，会非常有用，对象的序列化便可以做到</p>
<p><code>java</code>的对象序列化将那些<strong>实现了<code>Serializable</code>接口</strong>的对象转换成一个字节序列并能够在以后将这个字节序列完全恢复为原来的对象</p>
<ul>
<li>这一过程甚至可以通过网络进行，这意味着序列化机制能自动弥补不同操作系统之间的差异</li>
<li>对象序列化可以实现轻量级持久性，“持久性“意味着一个对象的生存周期并不取决与程序是否在执行，他可以生存于程序的调用之间，通过将一个序列化对象写入磁盘，然后再重新调用程序时恢复该对象，就能实现持久性的效果</li>
</ul>
<p>对象序列化加入到语言中，是为了支持两种特性：</p>
<ul>
<li><code>java</code>的远程方法调用（<code>RMI</code>），他是存活在其他计算机上的对象就像是存活在本机上一样，当向远程对象发送消息时，需要通过对象序列化来传输参数和返回值</li>
<li>对于<code>Java Beans</code>来说，对象序列化也是必需的（可能需要保留状态信息）</li>
</ul>
<p>要序列化一个对象：首先要创建某些<code>OutputStream</code>对象，然后将其封装在一个<code>ObjectOutputStream</code>对象内，这时，调用<code>writeObject()</code>即可将对象序列化，并将其发送给<code>OutputStream</code>。（对象序列化是基于字节的，因此使用<code>InputStream</code>和<code>OutputStream</code>继承结构）要反向进行该过程（即将一个序列还原为一个对象）需要将一个<code>InputStream</code>封装在<code>ObjectInputStream</code>内，然后调用<code>readObject()</code>。[我们获得的是一个引用，指向一个向上转型的<code>Object</code>,需要向下转型]</p>
<ul>
<li>被还原的对象确实包含了<strong>原对象中的所有连接</strong> </li>
<li>在对一个<code>Serializable</code>对象进行还原的过程中，没有调用任何构造器，包括默认的构造器，这个对象都是通过从<code>InputStream</code>中取得数据恢复而来的</li>
</ul>
<p>将一个对象从的序列化状态中恢复出来：需要必须保证<code>Java</code>虚拟机能够找到相关的<code>.class</code>文件</p>
<p>序列化的控制：可通过<code>Externalizable</code>接口代替<code>Serializable</code>接口来对对象的序列化过程进行控制，这个<code>Externalizable</code>继承了<code>Serializable</code>接口，同时新增了两个方法：<code>writeExternal()</code>和<code>readExternal()</code>。这两个方法会在序列化和反序列化还原的过程中被自动调用</p>
<ul>
<li>对于一个<code>Externalizable</code>对象，所有普通的默认构造器都会被调用（包括在字段定义时的初始化，然后调用<code>readExternal()</code>）</li>
<li>我们需要在<code>writeExternal()</code>方法（没有任何默认行为来为<code>Externalizable</code>对象写入任何成员对象）中将来自对象的重要信息写入，还必须在<code>readExternal()</code>方法中恢复数据</li>
</ul>
<p><code>transient</code>(瞬时)关键字：关闭序列化</p>
<p>不想被<code>java</code>的序列化机制自动保存与恢复的子对象，例如密码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> String password;</span><br></pre></td></tr></table></figure>

<p>因为<code>Externalizable</code>对象在默认情况下不保存他们的任何字段，所以<code>transient</code>关键字只能和<code>Serializable</code>对象一起使用</p>
<p><code>Externalizable</code>的替代方法：如果不是特别坚持实现<code>Externalizable</code>接口，我们可以实现<code>Serializable</code>接口并添加（不是覆盖或者实现）名为<code>writeObject()</code>和<code>readObject()</code>的方法，这样一旦对象被序列化或者反序列化还原，就会自动地分别调用这两个方法，也就是说，只要我们提供这两个方法，就会使用他们而不是默认的序列化机制</p>
<p>深拷贝：我们可以通过一个字节数组来使用对象序列化，从而实现对任何可<code>Serializable</code>对象的“深度复制”（<code>deep copy</code>）——深度复制意味着我们复制的是整个对象网，而不仅仅是基本对象及其引用</p>
<ul>
<li>如果我们想保存系统状态，最安全的做法是将其作为“原子”操作进行序列化</li>
</ul>
<p>要序列化<code>static</code>值，必须要自己动手去实现：需要添加<code>serializeStaticState()</code>和<code>deserializeStaticState()</code>两个<code>static</code>方法</p>
<h4 id="11-XML"><a href="#11-XML" class="headerlink" title="11.XML"></a>11.XML</h4><p>对象序列化的一个重要限制是他只是<code>Java</code>的解决方案：只有<code>Java</code>程序才能反序列化这种对象，一种更具互操作的解决方案是将数据转换为<code>XML</code>格式，这可以使各种各样的平台和语言使用</p>
<h4 id="12-Preferences"><a href="#12-Preferences" class="headerlink" title="12.Preferences"></a>12.Preferences</h4><p><code>Preferences API</code>(用户偏好)与对象序列化相比，前者与对象持久性更为密切，因为他可以自动存储和读取信息，不过他只能用于小的、受限的数据集合——我们只能存储基本类型和字符串，并且每个字符串的存储长度都不能超过<code>8K</code></p>
<p><code>Preferences API</code>用于存储和读取用户偏好以及程序配置项的设置</p>
<ul>
<li>是一个键-值集合（类似映射）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreferencesDemo</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    Preferences prefs = Preferences.useNodeForPackage(PreferencesDemo.class);</span><br><span class="line">    prefs.put(<span class="string">&quot;Location&quot;</span>,<span class="string">&quot;Oz&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Preferences API</code>对于数据的存储是利用了合适的系统资源来完成的： 例如:在<code>Windows </code>下面是使用注册表来保存这些信息，而在<code>Linux</code>下面是使用用户的<code>home</code>目录下面的一个隐藏文件来存储的。</p>
<h4 id="13-总结"><a href="#13-总结" class="headerlink" title="13.总结"></a>13.总结</h4><p><code>Java I/O</code>流类库的确能满足我们的基本需求：我们可以通过控制台、文件、内存块、甚至因特网进行读写。通过继承我们可以创建新类型的输入和输出对象。并且通过重新定义<code>toString()</code>,可以对流接受的对象类型进行简单扩充</p>
<p><strong>理解<code>I/O</code>流类库，需要先理解“装饰器”模式</strong> </p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十六-数组</title>
    <url>/2018/11/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%85%AD-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>对数组的基本看法是：可以创建并组装，可以用整型索引访问他们的元素，并且他们的尺寸不能变。大多数情况，这就是需要了解的全部，但是有时需要在数组上执行更加复杂的操作，并且你可能需要评估到底是使用容器还是数组</p>
<span id="more"></span>

<h4 id="1-数组为什么特殊"><a href="#1-数组为什么特殊" class="headerlink" title="1.数组为什么特殊"></a>1.数组为什么特殊</h4><p>数组与其他种类的容器之间的区别有三方面：</p>
<ul>
<li>效率</li>
<li>类型</li>
<li>保存基本类型的能力</li>
</ul>
<p>在<code>java</code>中，数组是一种效率最高的存储和随机访问对象引用序列的方式，数组就是一个简单的线性序列，这使得数组的访问非常快速，但是为这种速度所付出的代价是，数组对象的大小被固定，并且在其生命周期中不可改变。</p>
<p><code>ArrayList</code>的效率比数组低</p>
<p>随着泛型和自动包装机制的出现，数组硕果仅存的优点就是效率</p>
<h4 id="2-数组是一级对象"><a href="#2-数组是一级对象" class="headerlink" title="2.数组是一级对象"></a>2.数组是一级对象</h4><p>无论使用哪种类型的数组，数组标识符其实只是一个引用，指向堆中创建的一个真实对象，这个数组(数组)对象用以保存指向其他对象的引用。可以用数组初始化语法的一部分隐式的创建此对象或用<code>new</code>表达式显式的创建</p>
<p>只读成员<code>length</code>是数组对象的一部分（事实上，这是唯一一个可以访问的字段和方法），表示此数组对象可以存储多少元素</p>
<p><code>“[]”</code>语法是访问数组对象的唯一方式</p>
<p>数组初始化的各种方式：</p>
<ul>
<li><p>1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] first = <span class="keyword">new</span> String[<span class="number">5</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">5</span> ; i++)&#123;</span><br><span class="line">  first[i]=i.toString</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>2.聚集初始化语法（隐式的使用<code>new </code>在堆中创建）:只可在定义时使用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Arr</span></span>&#123;</span><br><span class="line">  <span class="keyword">private</span> Integer index;</span><br><span class="line">  Arr(Integer index)&#123;</span><br><span class="line">    <span class="keyword">this</span>.index = index;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Arr[] second = &#123;<span class="keyword">new</span> Arr(<span class="number">1</span>),<span class="keyword">new</span> Arr(<span class="number">2</span>),<span class="keyword">new</span> Arr(<span class="number">3</span>) &#125;</span><br><span class="line">String[] second2 = &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span> &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.动态的聚集初始化：可以在任意位置创建和初始化数组</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Arr[] third = <span class="keyword">new</span> Arr[] &#123;<span class="keyword">new</span> Arr(<span class="number">1</span>),<span class="keyword">new</span> Arr(<span class="number">2</span>),<span class="keyword">new</span> Arr(<span class="number">3</span>) &#125;</span><br><span class="line">String[] second2 = <span class="keyword">new</span> String[] &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;3&quot;</span> &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>注：</p>
<ul>
<li>对象数组和基本类型数组在使用上几乎是相同的，唯一的区别就是对象数组保存的引用，基本类型数组直接保存基本类型的值</li>
<li><code>length</code>是数组的大小，而不是实际保存元素个数</li>
</ul>
<h4 id="3-返回一个数组"><a href="#3-返回一个数组" class="headerlink" title="3.返回一个数组"></a>3.返回一个数组</h4><p>在<code>java</code>中可以直接返回一个数组：使用完后垃圾回收器会自动清理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] getArr()&#123;</span><br><span class="line">  String[] results = <span class="keyword">new</span> String[<span class="number">5</span>]</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span> ;i&lt;<span class="number">5</span> ; i++)&#123;</span><br><span class="line">    first[i]=i.toString</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-多维数组"><a href="#4-多维数组" class="headerlink" title="4.多维数组"></a>4.多维数组</h4><p>初始化：</p>
<ul>
<li><p>1.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [][] first = &#123;</span><br><span class="line">  &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,</span><br><span class="line">  &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
</li>
<li><p>2.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [][][] second=<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>][<span class="number">3</span>][<span class="number">4</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.数组中构成矩阵的每个向量都可以具有任意的长度（这被称为粗糙数组）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> [][][] third = <span class="keyword">new</span> <span class="keyword">int</span>[rand.nextInt(<span class="number">7</span>)][][];</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>自动包装机制对数组初始化器也起作用</p>
<p><code>Arrays.deepToString() </code>方法对基本类型数组和对象数组都起作用</p>
<ul>
<li><code>deepToString()</code>是针对多维数组的</li>
<li>数组没有实现<code>toString() </code>方法</li>
<li>数组中没有实现<code>object</code>中的任何方法</li>
</ul>
<h4 id="5-数组与泛型"><a href="#5-数组与泛型" class="headerlink" title="5.数组与泛型"></a>5.数组与泛型</h4><p>通常数组与泛型不能很好的结合，不能 <strong>实例化</strong>具有参数化类型的数组：例如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Peel&lt;Banana&gt;[] peels = <span class="keyword">new</span> Peel&lt;Banana&gt;[<span class="number">10</span>] ;<span class="comment">// 不能编译  </span></span><br><span class="line">T[] ts = <span class="keyword">new</span> T[]; <span class="comment">//不能编译</span></span><br></pre></td></tr></table></figure>

<p>擦除会移除参数类型信息，而数组必须知道他所持有的确切类型，以强制保证类型安全</p>
<p>但是，可以参数化数组本身的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//参数化类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParam</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> T[] fun(T[] arg)&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="comment">//参数化方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParam</span> </span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] fun (T[] arg)&#123;</span><br><span class="line">    <span class="keyword">return</span> arg;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参数化方法是首选：使用参数化方法而不使用参数化类的方便之处在于：不必为需要应用的每种不同的类型都使用一个参数去实例化这个类，并且你可以将其定义为静态的</p>
<p>不能实例化泛型数组，但是可以创建这种数组的引用，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt;[] ls;</span><br></pre></td></tr></table></figure>

<p>所以可以创建非泛型数组，然后将其转型：例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">toArr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  List&lt;String&gt;[] ls;</span><br><span class="line">  List[] la = <span class="keyword">new</span> List[<span class="number">10</span>];</span><br><span class="line">  ls = (List&lt;String&gt;[]) la;</span><br><span class="line">  ls[<span class="number">0</span>] = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">  <span class="comment">// ls[1] = new ArrayList&lt;Integer&gt;(); //不能编译通过</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组是协变的，<code>List&lt;String&gt;[] </code>也是一个 <code>Object[]</code></p>
<p>泛型容器是比泛型数组更好的选择</p>
<h4 id="6-创建测试数据"><a href="#6-创建测试数据" class="headerlink" title="6.创建测试数据"></a>6.创建测试数据</h4><p>填充数组：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] strs= <span class="keyword">new</span> String[<span class="number">5</span>]</span><br><span class="line">Array.fill(strs,<span class="string">&quot;str&quot;</span>);</span><br></pre></td></tr></table></figure>

<h4 id="7-Arrays-实用功能"><a href="#7-Arrays-实用功能" class="headerlink" title="7.Arrays 实用功能"></a>7.<code>Arrays</code> 实用功能</h4><p><code>Arrays</code>类是一套用于数组的<code>static</code>实用方法。其中有六个基本方法：</p>
<ul>
<li><p><code>equals()</code>：两个数组是否相等（<code>deepEquals()</code>用于多维数组）</p>
</li>
<li><p><code>fill()</code>：用于填充数组</p>
</li>
<li><p><code>sort()</code>：用于数组排序</p>
<ul>
<li><p>对象数组使用<code>sort()</code>方法排序，需要实现<code>Comparable</code>接口或具有相关联的<code>Comparator</code>。即：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span>  <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Test</span>&gt;</span></span><br><span class="line"><span class="class">  或</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TestComparator</span> <span class="keyword">implements</span> <span class="title">Comparator</span>&lt;<span class="title">Test</span>&gt; </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Test o1, Test o2)</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Arrays.sort(tests,<span class="keyword">new</span> TestComparator());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>​       <code> Collections</code>类包含一个<code>reverseOrder()</code>方法，这个方法可以产生一个<code>Comparator</code>，他可以反转自然的排序顺序</p>
<p>​    <code>String</code> 排序算法依据词典编排顺序排序</p>
<p>​    针对基本类型：快速排序。针对对象：稳定归并排序</p>
</li>
<li><p><code>binarySearch()</code>：用于在已经排序的数组中查找元素</p>
<ul>
<li>排序好才可用</li>
<li>如果数组包含重复元素，无法保证找到的是哪一个</li>
</ul>
</li>
<li><p><code>toString()</code>：产生数组的<code>String</code>表示</p>
</li>
<li><p><code>hashCode()</code>：产生数组的散列码</p>
</li>
</ul>
<p>此外：<code>Arrays.asList()</code>：接受任意的序列或数组作为七参数，并将其转化为<code>List</code>容器</p>
<p>复制数组：<code>System.arraycopy()</code>：<code>java</code>标准类库提供的<code>static</code>方法，用来复制数组（比<code>for</code>循环块）。<code>System.arraycopy()</code> 针对所有类型做了重载</p>
<p><code>arraycopy()</code>的参数：源数组、表示从源数组的什么位置开始复制的偏移量、目标数组、表示从目标数组什么位置开始复制的偏移量、需要复制的个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] i = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span>[] j = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line">System.arraycopy(i, <span class="number">0</span>, j, <span class="number">0</span>, i.length);</span><br></pre></td></tr></table></figure>

<p>基本类型数组与对象数组都可以复制，然而如果复制对象数组那么只是复制了对象的引用–而不是对象的本身（浅拷贝）</p>
<p><code>System.arraycopy()</code>不会执行自动包装和自动拆包，两个数组必须具有相同的确切类型。</p>
<h4 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h4><p>数组强调的是性能而不是灵活</p>
<p>当使用最近的<code>java</code>版本编程时，应该 <strong>“优先容器而不是数组”</strong>，只有在以证明性能成为问题（并且切换到数组对性能有所帮助）时，才应该将程序重构为数组。</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：四.控制执行流程</title>
    <url>/2018/08/05/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%9B%9B-%E6%8E%A7%E5%88%B6%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>现在java编程思想看到第五章，由于博客是按照创建时间排序，所以前四章先创建，内容以后补充</p>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA编程思想：十四.类型信息</title>
    <url>/2018/10/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3/JAVA%E7%BC%96%E7%A8%8B%E6%80%9D%E6%83%B3%EF%BC%9A%E5%8D%81%E5%9B%9B-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF/</url>
    <content><![CDATA[<p>运行时类型信息使得你可以在程序运行时发现和使用类型信息</p>
<span id="more"></span>

<h4 id="1-为什么需要RTTI"><a href="#1-为什么需要RTTI" class="headerlink" title="1.为什么需要RTTI"></a>1.为什么需要RTTI</h4><p><code>RTTI</code> (<code>Runtime Type Information</code>)：运行时类型信息</p>
<p>面向对象编程的基本的目的是：让代码只操纵对基类的引用<br><code>RTTI</code>最基本的形式(示例)：<br>从容器（<code>List&lt;Animal&gt;</code>：实际上这些容器是将所有的事物都当做<code>Object</code>持有）中取出元素时，会自动将结果转型为<code>Animal</code>。<br>但是这个例子中<code>RTTI</code>转型并不彻底，<code>Object</code>被转型为<code>Animal</code>，而不是具体的子类：<br>这是因为目前我们只知道这个<code>List&lt;Animal&gt;</code>里面保存的都是<code>Animal</code>,在编译时由容器和<code>java</code>的泛型系统来强制确保这一点，而在运行时，由类型转换操作来确保这一点</p>
<p>在<code>java</code>中所有类型，都是在运行时进行正确性检查的，这也是<code>RTTI</code>名字的含义：在运行时，识别一个对象的类型</p>
<p>使用RTTI可以查询某个引用（例如<code>animal</code>）所指向对象的确切类型</p>
<h4 id="2-class对象"><a href="#2-class对象" class="headerlink" title="2.class对象"></a>2.class对象</h4><p><code>Class</code>对象：包含了与类有关的信息，事实上，<code>Class</code>对象就是用来创建类的所有的“常规”对象的</p>
<p>类是程序的一部分，<strong>每个类都有一个<code>Class</code>对象</strong>，</p>
<ul>
<li>换言之：每当编写并且编译了一个新类，就会产生一个<code>Class</code>对象（是被保存在一个同名的<code>.class</code>文件中）</li>
<li>为了生成这个对象，运行这个程序的<code>java</code>虚拟机（<code>JVM</code>）将使用被称为“类加载器”的子系统（类加载器首先检查这个类的<code>Class</code>对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找<code>.class</code>文件）</li>
<li>一旦某个类的<code>Class</code>对象被载入内存，他就用来创建这个类的所有对象</li>
<li><code>Class</code>对象仅在需要的时候才被加载</li>
<li><code>Class.forName</code>(“全限定名（包含包名）”)：取得<code>Class</code>对象引用的一种方法：无论何时，只要你想在运行时使用类型信息，就必须首先获得对恰当的<code>Class</code>对象的引用</li>
<li><code>Class</code>的<code>newInstance()</code>方法是实现“虚拟构造器”的一种途径（使用<code>newInstance()</code>来创建的类，必须带有默认的构造器）</li>
</ul>
<p>（1）、类字面常量：</p>
<p>类的字面常量是java提供的另一种生成<code>java</code>引用的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Animal</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的字面量</span></span><br><span class="line">Animal.class</span><br></pre></td></tr></table></figure>

<p>类字面常量不仅可以应用于普通的类，也可以应用于接口、数组、以及基本数据类型</p>
<p>另外：对于基本数据类型的包装器类，还有一个标准字段<code>TYPE</code>,<code>TYPE</code>字段是一个引用，指向对应的基本数据类型的<code>Class</code>对象</p>
<p>注意：当使用<code>.Class</code>来创建对<code>Class</code>对象的引用时，不会自动的初始化该<code>Class</code>对象，（但是<code>Class.forName()</code>会立即进行初始化）为了使用类而做的准备工作实际上包含三个步骤：</p>
<ul>
<li><strong>1.加载</strong>，这是由类加载器执行的，该步骤将查找字节码（通常在<code>classpath</code>所指定的路径中查找，但这并非是必需的），并从这些字节码中创建一个<code>Class</code>对象</li>
<li><strong>2.链接</strong>，在链接阶段将验证类中的字节码，为静态域分配存储空间，并且如果必须的话，将解析这个类创建的对其他类的所有引用</li>
<li><strong>3.初始化</strong>，如果该类具有超类，则对其初始化，执行静态初始化器和静态初始化块</li>
</ul>
<p>初始化被延迟到了对静态方法（构造器隐式的是静态的）或者非常量静态域进行首次引用时才执行</p>
<p>（2）、泛化的<code>Class</code>引用</p>
<p><code>Class</code>引用总是指向某个<code>Class</code>对象，他可以制造类的示例，并包含可作用于这些实例的所有方法代码，他还包含该类的静态成员，因此，<code>Class</code>引用表示的就是他所指向的对象的确切类型，而该对象便是<code>Class</code>类的一个对象</p>
<p>javaSE5将<code>Class</code>引用的类型变得更具体了一些：例如:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class intClass=<span class="keyword">int</span>.class;</span><br><span class="line">Class&lt;Integer&gt; integerClass=<span class="keyword">int</span>.class;</span><br><span class="line">integerClass=Integer.class;</span><br><span class="line"><span class="comment">//integerClass=double.class; 编译器报错（泛型语法编译器执行额外的类型检查）</span></span><br><span class="line">intClass=<span class="keyword">double</span>.class;</span><br><span class="line"></span><br><span class="line"><span class="comment">//此时泛型影响newInstance()的返回类型:1.intClass未指定泛型类型，只能返回Object类型 2.integerClas指定了泛型类型为Integer，所以可直接返回Integer类型</span></span><br><span class="line">Object test1 = intClass.newInstance(); <span class="comment">//1</span></span><br><span class="line">Integer test2 = integerClass.newInstance(); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>

<p>比如此时想放松一下限制，该如果做：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Integer是继承自Number类的，但是此时下面的语句是不能通过编译检查的：因为Integer Class对象不是 Number Class对象的子类</span></span><br><span class="line"><span class="comment">//Class&lt;Number&gt; numberClass=Integer.class;</span></span><br></pre></td></tr></table></figure>

<p>java中使用通配符解决放松<code>Class</code>引用限制的问题：通配符<code>？</code>表示“任何事物”：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//？与extends关键字一起使用，创建一个范围，本例中表示继承自Number的子类</span></span><br><span class="line">Class&lt;? extends Number&gt; numberClass=Integer.class;</span><br></pre></td></tr></table></figure>

<p>向<code>Class</code>引用添加泛型语法的原因仅仅是为了提供编译器类型检查</p>
<p>（3）、转型语法</p>
<p>Java SE5添加了用于<code>Class</code>引用的转型语法：<code>cast()</code>方法</p>
<p><code>cast</code>方法接受方法参数，并将其转化为<code>Class</code>引用的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number number=<span class="keyword">new</span> Integer(<span class="number">3</span>);</span><br><span class="line">Class&lt;Integer&gt; integerClass=Integer.class;</span><br><span class="line"><span class="comment">//cast()方法</span></span><br><span class="line">Integer integer=integerClass.cast(number); <span class="comment">//1</span></span><br><span class="line"><span class="comment">//相当于：</span></span><br><span class="line">integer=(Integer)number;<span class="comment">//2</span></span><br><span class="line"><span class="comment">//但是在使用泛型时，有事会出现 语句2 无法使用的情况，此时只能使用语句1 </span></span><br></pre></td></tr></table></figure>

<h4 id="3-类型转换前先做检查"><a href="#3-类型转换前先做检查" class="headerlink" title="3.类型转换前先做检查"></a>3.类型转换前先做检查</h4><p><code>RTTI</code>形式：</p>
<ul>
<li><p>1.传统的类型转换，如“<code>（Animal）</code>”,由RTTI确保类型转换的正确性，如果执行了一个错误的类型转换，就会抛出一个<code>ClassCastException</code>异常(“<code>（Animal）</code>”在java中要执行类型检查，这通常被称为“类型安全的向下转型”)</p>
</li>
<li><p>2.代表对象的类型的<code>Class</code>对象，通过查询<code>Class</code>对象可以获取运行时所需的信息</p>
</li>
<li><p>3.关键字<code>instanceof</code>：他返回一个布尔值：对象是不是某个特定类型，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Animal animal =<span class="keyword">new</span> Animal()</span><br><span class="line"><span class="keyword">if</span>(animal <span class="keyword">instanceof</span> Cat) &#123;</span><br><span class="line">  <span class="comment">//此时经过 instanceof 判断过的类型是不会出现 ClassCastException 异常的</span></span><br><span class="line">   ((Cat)animal).goTree();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instanceof</code>有比较严格的限制：只可将其与命名类型进行比较，而不能与<code>Class</code>对象作比较</p>
<ul>
<li><p>动态的<code>instanceof</code></p>
<p><code>Class.isInstance</code>方法提供了一种动态的测试对象的途径，示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Number number = <span class="keyword">new</span> Integer(<span class="number">987</span>);</span><br><span class="line"><span class="keyword">if</span> (number <span class="keyword">instanceof</span> Integer) &#123;<span class="comment">//true</span></span><br><span class="line">  <span class="keyword">if</span> (Integer.class.isInstance(number)) &#123;<span class="comment">//true</span></span><br><span class="line">    System.out.println(<span class="string">&quot;Integer.class.isInstance(number) :true&quot;</span>); </span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;number instanceof Integer :true&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
</li>
</ul>
<h4 id="4-instanceof与Class的等价性"><a href="#4-instanceof与Class的等价性" class="headerlink" title="4.instanceof与Class的等价性"></a>4.instanceof与Class的等价性</h4><p>查询类型信息时：以<code>instanceof</code>（<code>instanceof</code>或<code>isInstance</code>）的形式与直接比较<code>Class</code>对象有一个很重要的差别</p>
<ul>
<li><code>instanceof</code>保持了类型的概念：他指的是：你是这个类或是这个类的派生类么</li>
<li>而<code>==</code>（或者<code>equals</code>）比较的<code>Class</code>对象，就没有考虑继承：是这个确切类型或者不是</li>
</ul>
<h4 id="5-反射：运行时的类型信息"><a href="#5-反射：运行时的类型信息" class="headerlink" title="5.反射：运行时的类型信息"></a>5.反射：运行时的类型信息</h4><p>如果不知道某个对象的确切类型，<code>RTTI</code>可以告诉你，但是有一个限制：这个类在编译时必须已知，这样<code>RTTI</code>才能识别他，换言之，在编译时，编译器必须知道所有要通过RTTI来处理的类</p>
<p>但是有一些场景可能不能满足上述条件：GUI、RMI</p>
<p><code>Class</code>类与<code>java.lang.reflect</code>类库一起对 <strong>反射</strong>的概念进行了支持。</p>
<ul>
<li><p>该类库包含了：<code>Filed</code>、<code>Method</code>、<code>Constructor</code>类（每个类都实现了<code>Member</code>接口）</p>
</li>
<li><p>这些类型的对象是由JVM在运行时创建的，用以表示未知类里对应的成员，这样就可以使用<code>Constructor</code>创建新的对象、用<code>get()</code>和<code>set()</code>方法读取和修改与<code>Field</code>对象关联的字段、用<code>invoke()</code>方法调用与<code>Method</code>对象关联的方法，还可以调用<code>getFields()</code>、<code>getMethods()</code>、<code>getConstructors()</code>等便利的方法以返回表示字段、方法、以及构造器的对象的数组。</p>
<p>这样匿名对象的类信息就能在运行时被完全确定下来，而在编译时不需要知道任何事情</p>
</li>
</ul>
<p>通过反射与一个未知类型的对象打交道时，JVM只是简单的检查这个对象看他属于哪个特定的类（就像<code>RTTI</code>那样），在用他做其他事之前必须先加载那个类的<code>Class</code>对象，因此<code>.class</code>文件对于JVM来说必须是可获取的：要么在本地机器上，要么可通过网络获得</p>
<p>所以<code>RTTI</code>和反射真正的区别在于：</p>
<ul>
<li>对<code>RTTI</code>来说，编译器在编译时打开和检查<code>.class</code>文件(换句话说就是我们可以用“普通”方式调用对象的所有方法)</li>
<li>而对于反射机制来说：<code>.class</code>文件在编译时实不可获取的，所以在运行时打开和检查<code>.class</code>文件</li>
</ul>
<p>动态代理（<code>Proxy.newProxyInstance()</code> :创建动态代理）是对反射应用的重要实例。可以非常好的解决某些类型问题</p>
<ul>
<li>动态代理可以动态的引用空对象</li>
</ul>
<h4 id="6-接口与类型信息"><a href="#6-接口与类型信息" class="headerlink" title="6.接口与类型信息"></a>6.接口与类型信息</h4><p><code>interface</code>关键字的一种重要目标就是允许程序员隔离构件，进而降低耦合性。</p>
<p>但是通过类型信息，这种耦合性还是会传播出去，——接口并非是对解耦的一种无懈可击的保障。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">A</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">    A a=<span class="keyword">new</span> B()</span><br><span class="line">    a.f();</span><br><span class="line">    <span class="comment">//a.g(); //不可调用</span></span><br><span class="line">    <span class="keyword">if</span>(a <span class="keyword">instanceof</span> B)&#123;</span><br><span class="line">      B b=(B)a</span><br><span class="line">      b.g();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时客户端的调用方式耦合程度超出原本的想象，解决办法：</p>
<ul>
<li><p>一种是直接声明，如果决定使用实际的类而不是接口，他们需要自己负责</p>
</li>
<li><p>最简单的方式是实现包访问权限</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> <span class="keyword">implements</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">h</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">E</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> A <span class="title">makeA</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> D();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是此时通过反射，仍旧可以拿到并调用所有方法，甚至<code>private</code>方法（<code>setAccessible(true)</code>）</p>
<p>只发布编译后的代码也不能解决通过反射查看的问题：javap可突破限制</p>
<p><code>java -private D </code></p>
<ul>
<li><code>-private </code>表示的所有成员都应该显示，甚至包括私有成员</li>
<li>所以运行这个命令，任何人可获取你的私有方法的名字和签名，并调用他们</li>
</ul>
<p>没有任何方式可以阻止反射到达并调用那些非公共访问权限的方法，对于此：</p>
<ul>
<li>如果有人使用反射调用这些<code>private</code>或是包访问权限的方法，后来人的修改，他们不能“抱怨”</li>
<li>另一方面，总在类中留下后门，也许能解决某些特定问题，反射带来的好处是不可否认的</li>
</ul>
</li>
</ul>
]]></content>
      <tags>
        <tag>《Thinking in Java》</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试</title>
    <url>/2019/05/17/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
    <content><![CDATA[<h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>单元测试（Unit Testing）又称为模块测试，是针对程序模块（程序单元，软件设计的最小单位）来进行正确性检验的测试工作。</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">即：对软件中的最小可测试单元进行检查和验证</span><br></pre></td></tr></table></figure>

<p>程序单元是应用的最小可测试部件。</p>
<ul>
<li>在过程化编程中，一个单元就是单个程序、函数、过程等；</li>
<li>对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</li>
</ul>
<h4 id="为什么要有单元测试"><a href="#为什么要有单元测试" class="headerlink" title="为什么要有单元测试"></a>为什么要有单元测试</h4><p>实际工作中我们为什么需要单元测试，主要有以下几点：</p>
<ul>
<li>发布周期缩短，传统测试不满足需要</li>
<li>软件提测质量差，债务积累太多</li>
<li>代码修改内容影响范围不可掌控</li>
</ul>
<h4 id="单元测试的好处"><a href="#单元测试的好处" class="headerlink" title="单元测试的好处"></a>单元测试的好处</h4><p>单元测试的目标是隔离程序部件并证明这些单个部件是正确的。</p>
<p>一个单元测试提供了代码片断需要满足的严密的书面规约。因此， 单元测试在软件开发过程的早期就能发现问题。</p>
<ul>
<li><p>适应变更</p>
<p>单元测试允许程序员在未来重构代码，并且确保模块依然工作正确</p>
</li>
<li><p>简化集成</p>
<p>单元测试消除程序单元的不可靠，采用自底向上的测试路径。通过先测试程序部件再测试部件组装，使集成测试变得更加简单。</p>
</li>
<li><p>文档记录</p>
<p>单元测试提供了系统的一种文档记录。借助于查看单元测试提供的功能和单元测试中如何使用程序单元，开发人员可以直观的理解程序单元的基础API。</p>
</li>
<li><p>表达设计</p>
<p>在测试驱动开发的软件实践中，单元测试可以取代正式的设计。每一个单元测试案例均可以视为一项类、方法和待观察行为等设计元素。</p>
</li>
</ul>
<h4 id="单元测试框架"><a href="#单元测试框架" class="headerlink" title="单元测试框架"></a>单元测试框架</h4><p>单元测试框架通常是没有作为编译器包的第三方产品。他们帮助简化单元测试的过程，并且已经为各种编程语言开发</p>
<p>java中现常用的单元测试框架包括：</p>
<ul>
<li><p>JUnit</p>
</li>
<li><p><a href="http://zhangyuying.cn/2018/08/15/%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Mocktio/">Mockito</a></p>
</li>
<li><p>TestNG</p>
</li>
<li><p>….</p>
<p>​</p>
</li>
</ul>
<p>参考资料</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试-Mocktio</title>
    <url>/2018/08/15/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95-Mocktio/</url>
    <content><![CDATA[<p><a href="http://zhangyuying.cn/2019/05/17/%E6%8A%80%E6%9C%AF/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/">单元测试的定义及好处</a></p>
<h4 id="Mocktio"><a href="#Mocktio" class="headerlink" title="Mocktio"></a>Mocktio</h4><p>Mockito是一个流行的Mocking(模拟测试)框架，通过使用Mocking框架，可以尽可能使unit test <strong>独立</strong>。</p>
<span id="more"></span>

<h4 id="Stub对象和Mock对象的区别"><a href="#Stub对象和Mock对象的区别" class="headerlink" title="Stub对象和Mock对象的区别"></a>Stub对象和Mock对象的区别</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Stub对象用来提供测试时所需要的测试数据，可以对各种交互设置相应的回应。例如我们可以设置方法调用的返回值等等。Mockito中when(…).thenReturn(…)。这样的语法便是设置方法调用的返回值。另外也可以设置方法在何时调用会抛异常等。</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mock对象用来验证测试中所依赖对象间的交互是否能够达到预期。Mockito中用verify(…).methodXxx(…) 语法来验证 methodXxx 方法是否按照预期进行了调用</span><br></pre></td></tr></table></figure>

<h4 id="mocktio支持注解："><a href="#mocktio支持注解：" class="headerlink" title="mocktio支持注解："></a>mocktio支持注解：</h4><ul>
<li>@Mock ：将mock对象设为测试类的属性</li>
<li>@Spy ：监视真实的对象</li>
<li>@Captor ：参数捕获器</li>
<li>@InjectMocks ：mock对象自动注入</li>
</ul>
<h3 id="mocktio的使用："><a href="#mocktio的使用：" class="headerlink" title="mocktio的使用："></a>mocktio的使用：</h3><h4 id="1-Mock-对象的期望行为及返回值设定"><a href="#1-Mock-对象的期望行为及返回值设定" class="headerlink" title="1.Mock 对象的期望行为及返回值设定"></a>1.Mock 对象的期望行为及返回值设定</h4><p>注意，Mockito的Stubbing有两种语法，并支持迭代。</p>
<ul>
<li><p>(1) Stubbing对方法设定返回值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">when(mock.someMethod()).thenReturn(value1).thenReturn(value2);  </span><br><span class="line">when(mock.someMethod()).thenReturn(value1, value2);  </span><br></pre></td></tr></table></figure>

<p>上面两种方式等同于</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">when(mock.someMethod()).thenReturn(value1);  </span><br><span class="line">when(mock.someMethod()).thenReturn(value2);  </span><br></pre></td></tr></table></figure>

<p>另一种风格:doReturn，主要用于<code>spy</code>对象的情况下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doReturn(value1).doReturn(value2).when(mock).someMethod();  </span><br></pre></td></tr></table></figure>

<p>对 void 方法进行方法预期设定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doNothing().when(mock).someMethod();  </span><br></pre></td></tr></table></figure>
</li>
<li><p>(2) 对方法设定返回异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">when(mock.someMethod()).thenThrow(new RuntimeException());  </span><br></pre></td></tr></table></figure>

<p>对 void 方法进行方法预期设定</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doThrow(new RuntimeException()).when(mock).someMethod();  </span><br></pre></td></tr></table></figure>
</li>
<li><p>(3) Argument Matcher（参数匹配器）</p>
<p>Mockito提供了参数匹配器，用于灵活的匹配参数。</p>
<p>比如 any(User.class)，匹配任意User对象；anyString()匹配任意字符串；anyInt()匹配任意int型。</p>
</li>
</ul>
<h4 id="2-Mock对象的行为验证"><a href="#2-Mock对象的行为验证" class="headerlink" title="2.Mock对象的行为验证"></a>2.Mock对象的行为验证</h4><p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test  </span><br><span class="line">public void verifyTestTest() &#123;  </span><br><span class="line">    List&lt;String&gt; mock &#x3D; mock(List.class);  </span><br><span class="line">    List&lt;String&gt; mock2 &#x3D; mock(List.class);  </span><br><span class="line">    when(mock.get(0)).thenReturn(&quot;Hello&quot;);  </span><br><span class="line">    when(mock.get(1)).thenReturn(&quot;World&quot;);  </span><br><span class="line">    mock.get(0);  </span><br><span class="line">    mock.get(1);  </span><br><span class="line">    &#x2F;&#x2F; 验证指定方法被调用一次  </span><br><span class="line">    verify(mock).get(0);  </span><br><span class="line">    &#x2F;&#x2F; 验证指定方法没有被调用  </span><br><span class="line">    verify(mock, never()).get(3);  </span><br><span class="line">    &#x2F;&#x2F; 验证get方法在100毫秒内被调用两次  </span><br><span class="line">    verify(mock, timeout(100).times(2)).get(anyInt());  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 通过验证方法的执行顺序  </span><br><span class="line">    InOrder inOrder &#x3D; inOrder(mock, mock2);  </span><br><span class="line">    inOrder.verify(mock).get(0);  </span><br><span class="line">    inOrder.verify(mock).get(1);  </span><br><span class="line">    inOrder.verify(mock2, never()).get(1);  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 查询多余的方法调用 mock所有调用的方法都已经被验证  </span><br><span class="line">    verifyNoMoreInteractions(mock);  </span><br><span class="line">    &#x2F;&#x2F; 查询没有交互的mock对象  </span><br><span class="line">    verifyZeroInteractions(mock2);  </span><br><span class="line">  </span><br><span class="line">    &#x2F;&#x2F; 创建ArgumentCaptor（参数捕获器）用于捕获方法参数进行验证  </span><br><span class="line">    ArgumentCaptor&lt;Integer&gt; argument &#x3D; ArgumentCaptor.forClass(Integer.class);  </span><br><span class="line">    &#x2F;&#x2F; 该方法被调用多次 只能捕捉到最后一次参数  </span><br><span class="line">    verify(mock, times(2)).get(argument.capture());  </span><br><span class="line">    assertThat(argument.getValue()).isEqualTo(1);  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>

<ul>
<li><p>(1) 验证方法的调用次数</p>
<p>通过 verify(mock,times(?)).someMethod()验证方法的调用次数，是常用的验证方式，包括可以验证指定明确的方法被调用次数、某方法未被调用。或一个方法总体被调用次数。</p>
<p> Mockito除了提供times(N)方法供我们调用外，还提供了很多可选的方法：</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* never() 没有被调用，相当于times(0)</span><br><span class="line">* atLeast(N) 至少被调用N次</span><br><span class="line">* atLeastOnce() 相当于atLeast(1)</span><br><span class="line">*  atMost(N) 最多被调用N次</span><br></pre></td></tr></table></figure>

<ul>
<li><p>(2) 超时验证</p>
<p>通过timeout，并制定毫秒数验证超时。注意，如果被调用多次，times还是需要的。</p>
</li>
<li><p>(3) 方法调用顺序</p>
<p>通过InOrder对象，验证方法的执行顺序，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 通过验证方法的执行顺序  </span><br><span class="line">InOrder inOrder &#x3D; inOrder(mock, mock2); </span><br></pre></td></tr></table></figure>
</li>
<li><p>(4) verifyNoMoreInteractions</p>
<p>查询是否存在被调用，但未被验证的方法，如果存在则抛出异常。这里因为验证了get(anyInt())，相当于所有的get方法被验证，所以通过。</p>
</li>
<li><p>(5) verifyZeroInteractions</p>
<p>查询对象是否未产生交互，如果传入的mock对象的方法被调用过，则抛出异常。这里mock2的方法没有被调用过，所有通过。</p>
</li>
<li><p>(6) 利用ArgumentCaptor（参数捕获器）捕获方法</p>
<p>参数进行验证通过 ArgumentCaptor 对象的forClass(Class<T> clazz)方法来构建ArgumentCaptor对象。然后便可在验证时对方法的参数进行捕获，最后验证捕获的参数值。如果方法有多个参数都要捕获验证，那就需要创建多个ArgumentCaptor对象处理。</p>
<p>当某个对象进行了多次调用后，比如mock对象。这时调用argument.getValue()获取到的是最后一次调用的参数。如果要获取所有的参数值可以调用argument.getAllValues()，它将返回参数值的List。</p>
</li>
</ul>
<h4 id="3-Spy-对象的监视"><a href="#3-Spy-对象的监视" class="headerlink" title="3.Spy-对象的监视"></a>3.Spy-对象的监视</h4><p>   Mock 对象只能调用stubbed 方法，调用不了它真实的方法。但Mockito 可以监视一个真实的对象，这时对它进行方法调用时它将调用真实的方法，同时也可以stubbing 这个对象的方法让它返回我们的期望值。另外不论是否是真实的方法调用都可以进行verify验证。和创建mock对象一样，对于final类、匿名类和Java的基本类型是无法进行spy的。</p>
<ul>
<li><p>监视对象</p>
<p>监视一个对象需要调用spy(T object)方法，</p>
<p>如下面的代码中spy变量就在监视LinkedList实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List spy &#x3D; spy(new LinkedList());  </span><br></pre></td></tr></table></figure>
</li>
<li><p>被监视对象的Stubbing<br> stubbing 被监视对象的方法时要慎用when(Object)。比如下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List spy &#x3D; spy(new LinkedList());  </span><br><span class="line">&#x2F;&#x2F; IndexOutOfBoundsException (the list is yet empty)  </span><br><span class="line">when(spy.get(0)).thenReturn(&quot;foo&quot;);  </span><br><span class="line">&#x2F;&#x2F; You have to use doReturn() for stubbing  </span><br><span class="line">doReturn(&quot;foo&quot;).when(spy).get(0);  </span><br></pre></td></tr></table></figure>

<p> 这时，when方法参数中spy.get(0)，调用的是真实list对象的get(0)，这会产生IndexOutOfBoundsException异常，所以这时需要用到doReturn方法来设置返回值。</p>
<p>参考示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Test  </span><br><span class="line"> public void spyTest() &#123;  </span><br><span class="line">     List list &#x3D; new LinkedList();  </span><br><span class="line">     List spy &#x3D; spy(list);  </span><br><span class="line">     &#x2F;&#x2F; optionally, you can stub out some methods:  </span><br><span class="line">     when(spy.size()).thenReturn(100);  </span><br><span class="line">     &#x2F;&#x2F; using the spy calls real methods  </span><br><span class="line">     spy.add(&quot;one&quot;);  </span><br><span class="line">     spy.add(&quot;two&quot;);  </span><br><span class="line">     &#x2F;&#x2F; prints &quot;one&quot; - the first element of a list  </span><br><span class="line">     System.out.println(spy.get(0));  </span><br><span class="line">     &#x2F;&#x2F; size() method was stubbed - 100 is printed  </span><br><span class="line">     System.out.println(spy.size());  </span><br><span class="line">     &#x2F;&#x2F; optionally, you can verify  </span><br><span class="line">     verify(spy).add(&quot;one&quot;);  </span><br><span class="line">     verify(spy).add(&quot;two&quot;);  </span><br><span class="line"> &#125;  </span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>代码示例：（自己工程中的单元测试（JUnit+Mocktio），并没有将上面所说的方法全部覆盖到！）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="meta">@Rollback</span></span><br><span class="line"><span class="comment">//在单元测试中使用mocktio</span></span><br><span class="line"><span class="meta">@RunWith(MockitoJUnitRunner.class)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//需要测试的service</span></span><br><span class="line">    <span class="comment">//被@InjectMocks注解标注的属性，可以自动注入标记@Mock、@Spy等注解的属性值</span></span><br><span class="line">    <span class="comment">//@InjectMocks标注的属性不能使用接口，因为@InjectMocks不能传入参数指明实现类</span></span><br><span class="line">    <span class="meta">@InjectMocks</span></span><br><span class="line">    <span class="keyword">private</span> SystemService systemService;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//service中需要mock的数据</span></span><br><span class="line">    <span class="meta">@Mock</span></span><br><span class="line">    <span class="keyword">private</span> ISystemStorage mockSystemStorage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        MockitoAnnotations.initMocks(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllSystemByValid_valid_null_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = SystemBean.buildTwoSystem_OneValid_OneNoValid();</span><br><span class="line">        <span class="comment">// Stud 设置方法调用的预期返回  </span></span><br><span class="line">        when(mockSystemStorage.getAllSystems()).thenReturn(systems);</span><br><span class="line"></span><br><span class="line">        List&lt;System&gt; systemsFromStorage = systemService.getAllSystemByValid(<span class="keyword">null</span>);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).getAllSystems();</span><br><span class="line">        Assert.assertEquals(<span class="number">2</span>, systemsFromStorage.size());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(expected = RedisStorageException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllSystemByValid_exception_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        <span class="comment">// Stud 设置方法调用的预期返回  //模拟抛出异常</span></span><br><span class="line">        when(mockSystemStorage.getAllSystems()).thenThrow(RedisStorageException.class);</span><br><span class="line">        systemService.getAllSystemByValid(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllSystemByValid_valid_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = SystemBean.buildTwoSystem_OneValid_OneNoValid();</span><br><span class="line">        <span class="comment">// Stud 设置方法调用的预期返回  </span></span><br><span class="line">        when(mockSystemStorage.getAllSystems()).thenReturn(systems);</span><br><span class="line"></span><br><span class="line">        List&lt;System&gt; systemsFromStorage = systemService.getAllSystemByValid(<span class="number">1</span>);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).getAllSystems();</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, systemsFromStorage.size());</span><br><span class="line">        Assert.assertEquals(SystemBean.systemValid_valid, systemsFromStorage.get(<span class="number">0</span>).getValid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getAllSystemByValid_noValid_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = SystemBean.buildTwoSystem_OneValid_OneNoValid();</span><br><span class="line">        <span class="comment">// Stud 设置方法调用的预期返回  </span></span><br><span class="line">        when(mockSystemStorage.getAllSystems()).thenReturn(systems);</span><br><span class="line"></span><br><span class="line">        List&lt;System&gt; systemsFromStorage = systemService.getAllSystemByValid(<span class="number">2</span>);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).getAllSystems();</span><br><span class="line">        Assert.assertEquals(<span class="number">1</span>, systemsFromStorage.size());</span><br><span class="line">        Assert.assertEquals(SystemBean.systemValid_noValid, systemsFromStorage.get(<span class="number">0</span>).getValid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSystem_normal_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = SystemBean.buildTwoSystem_OneValid_OneNoValid();</span><br><span class="line">        systemService.saveSystems(systems);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).saveSystem(eq(systems.get(<span class="number">0</span>)));</span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).saveSystem(eq(systems.get(<span class="number">1</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSystem_params_have_valid_null_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        systems.add(SystemBean.buildValidIsNullSystem());</span><br><span class="line">        systemService.saveSystems(systems);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).saveSystem(any(System.class));</span><br><span class="line">        Assert.assertEquals(Integer.valueOf(<span class="number">1</span>), systems.get(<span class="number">0</span>).getValid());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSystem_params_is_null_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = <span class="keyword">null</span>;</span><br><span class="line">        systemService.saveSystems(systems);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">0</span>)).saveSystem(any(System.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSystem_params_is_empty_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        systemService.saveSystems(systems);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">0</span>)).saveSystem(any(System.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test(expected = RedisStorageException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSystem_exception_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        <span class="comment">//模拟抛出异常</span></span><br><span class="line">        doThrow(RedisStorageException.class).when(mockSystemStorage).saveSystem(any(System.class));</span><br><span class="line">        List&lt;System&gt; systems = SystemBean.buildTwoSystem_OneValid_OneNoValid();</span><br><span class="line">        systemService.saveSystems(systems);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSystem_normal_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        System system = SystemBean.buildValidSystem();</span><br><span class="line">        systemService.updateSystem(system);</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).saveSystem(eq(system));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test(expected = RedisStorageException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">updateSystem_exception_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        <span class="comment">//模拟抛出异常</span></span><br><span class="line">        doThrow(RedisStorageException.class).when(mockSystemStorage).saveSystem(any(System.class));</span><br><span class="line">        System system = SystemBean.buildValidSystem();</span><br><span class="line">        systemService.updateSystem(system);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSystemById_normal_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        System system = SystemBean.buildValidSystem();</span><br><span class="line">        <span class="comment">// Stud 设置方法调用的预期返回  </span></span><br><span class="line">        when(mockSystemStorage.getSystemById(system.getId())).thenReturn(system);</span><br><span class="line">        System systemFromStorage = systemService.getSystemById(system.getId());</span><br><span class="line">         <span class="comment">// Mock 验证方法调用  </span></span><br><span class="line">        verify(mockSystemStorage, times(<span class="number">1</span>)).getSystemById(system.getId());</span><br><span class="line">        Assert.assertNotNull(systemFromStorage);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Test(expected = RedisStorageException.class)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getSystemById_exception_test</span><span class="params">()</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">       <span class="comment">//模拟抛出异常</span></span><br><span class="line">        doThrow(RedisStorageException.class).when(mockSystemStorage).getSystemById(anyString());</span><br><span class="line">        systemService.getSystemById(SystemBean.systemId1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service(&quot;systemService&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemService</span> <span class="keyword">extends</span> <span class="title">CommonService</span> <span class="keyword">implements</span> <span class="title">ISystemService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Integer VALID = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> ISystemStorage systemStorage;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;System&gt; <span class="title">getAllSystemByValid</span><span class="params">(Integer valid)</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        List&lt;System&gt; systems = systemStorage.getAllSystems();</span><br><span class="line">        <span class="keyword">if</span> (valid == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> systems;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;System&gt; validSystems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (System system : systems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (valid.equals(system.getValid())) &#123;</span><br><span class="line">                validSystems.add(system);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> validSystems;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveSystems</span><span class="params">(List&lt;System&gt; systems)</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (CollectionUtils.isEmpty(systems)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (System system : systems) &#123;</span><br><span class="line">            <span class="keyword">if</span> (system.getValid() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                system.setValid(VALID);</span><br><span class="line">            &#125;</span><br><span class="line">            systemStorage.saveSystem(system);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateSystem</span><span class="params">(System system)</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        systemStorage.saveSystem(system);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> System <span class="title">getSystemById</span><span class="params">(String systemId)</span> <span class="keyword">throws</span> RedisStorageException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> systemStorage.getSystemById(systemId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考资料：</p>
<p><a href="http://sgq0085.iteye.com/blog/2031319">http://sgq0085.iteye.com/blog/2031319</a></p>
<p><a href="https://blog.csdn.net/andy2019/article/details/79546657">https://blog.csdn.net/andy2019/article/details/79546657</a></p>
<p><a href="http://www.cnblogs.com/zishi/p/6780719.html">http://www.cnblogs.com/zishi/p/6780719.html</a></p>
<p><a href="http://hotdog.iteye.com/blog/937862">http://hotdog.iteye.com/blog/937862</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的线程</title>
    <url>/2023/03/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/Java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E6%8C%87%E5%8D%97/Java%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>进程（Process）：是程序的运行实例，进程是程序向操作系统申请资源(如内存空间和文件句柄)的基本单位，进程和程序之间的关系好比播放中的视频与响应的视频文件之间的关系，前者从动态的角度刻画事物而后者从静态的角度刻画事物</p>
<span id="more"></span>

<blockquote>
<p>运行一个Java程序的实质是启动一个Java虚拟机进程，一个运行的Java程序就是一个Java虚拟机进程</p>
</blockquote>
<p>线程（Thread）：是进程中可独立执行的最小单位，一个进程可以包含多个线程，同一个进程中的所有线程共享该进程中的资源</p>
<p>任务：线程所要完成的计算就被称为任务，任务代表线程所要完成的工作，任务是一个相对的概念</p>
<h3 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h3><p>什么是多线程编程</p>
<p>多线程编程就是以线程为基本抽象单位的一种编程范式（Paradigm），可以在面向对象编程的基础上实现多线程编程，Java平台中的一个线程就是一个对象。</p>
<p>多线程编程在实际的应用中类似于和尚挑水的故事，要结合实际使用多线程</p>
<blockquote>
<p>多线程编程线程为基本单位，类似于面向对象编程中的类（class）是基本抽象单位</p>
</blockquote>
<h3 id="JAVA线程API"><a href="#JAVA线程API" class="headerlink" title="JAVA线程API"></a>JAVA线程API</h3><p>Java标准库类<code>java.lang.Thread</code>就是Java平台对线程的实现。Thread类或其子类的一个实例就是一个线程。</p>
<p>线程的创建、启动和运行</p>
<p>在Java平台中创建一个线程就是创建一个Thread类（或其子类）的实例</p>
<p>运行一个线程实际上就是让Java虚拟机执行该线程的run方法</p>
]]></content>
      <categories>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title>JAVA中的乱码问题</title>
    <url>/2019/05/14/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/JAVA%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="http://zhangyuying.cn/2019/05/14/%E6%8A%80%E6%9C%AF/%E5%AD%97%E7%AC%A6%E9%9B%86/">字符集查看</a></p>
<p>在平时开发Java的时候，我们会遇到很多编码设置，其中包括：</p>
<span id="more"></span>

<ul>
<li><p>Java文件的编码：Java文件的编码表示编写代码的时候，<code>.java</code>文件本身的编码，这个编码的影响在于将你的写的代码源文件复制一份，使用其他编辑器打开，若两个编辑器的默认编码方式不一样，则打开源文件就会变成乱码。一般英文的影响不大，因为大多数编码都兼容<code>ASCII</code>编码，但是中文要是编码不正确，则会乱码。</p>
<p>IDEA的设置在：Setting-&gt;Editor-&gt;File Encodings中设置</p>
</li>
<li><p>JVM编码：JVM编码表示JVM在读取<code>String</code>类型的默认编码，可以使用<code>Charset.defaultCharset().name()</code> 获取。可以在JVM启动参数中使用<code>-Dfile.encoding=UTF-8</code>进行设置。</p>
</li>
</ul>
<p>一般需要区分的就是这两种编码。</p>
<h3 id="1-文件乱码"><a href="#1-文件乱码" class="headerlink" title="1.文件乱码"></a>1.文件乱码</h3><p>一般会出现字符乱码都在于需要与其他程序进行IO的时候。先看看使用字节流进行读取文件的时候：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">  <span class="comment">//&quot;G:\\test.txt&quot; 这个文件是新建的文本文件，输入文字后保存</span></span><br><span class="line">     String path=<span class="string">&quot;G:\\test.txt&quot;</span>;</span><br><span class="line">     <span class="keyword">try</span>(BufferedInputStream inputStream=<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(path))) &#123;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">byte</span> bytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>]; inputStream.read(bytes) != -<span class="number">1</span>; ) &#123;</span><br><span class="line">             String context = <span class="keyword">new</span> String(bytes);</span><br><span class="line">             System.out.println(context);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>此时输出是乱码</p>
<p>首先这里是JVM运行时的编码，因此和JVM的编码设置相关，查看JVM现在的编码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(Charset.defaultCharset().name());</span><br></pre></td></tr></table></figure>

<p>而新建的<code>.txt文件</code>,点击另存为，可以发现默认的编码为<code>ANSI</code>,在简体中文的Windows系统中默认是<code>GBK</code>的编码</p>
<p>这便是乱码的原因，解决方案有两种</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>设置JVM启动项：-Dfile.encoding=GB2312</span><br><span class="line">  	——tomcat 的日志文件乱码，也可以修改这个配置解决，只不过是修改为-Dfile.encoding=UTF-<span class="number">8</span>(和idea保证一致)，一个原理</span><br><span class="line"><span class="number">2.</span>在编码<span class="keyword">byte</span>数组的时候，指定GB2312编码:String context = <span class="keyword">new</span> String(bytes,<span class="string">&quot;GB2312&quot;</span>);</span><br><span class="line"></span><br><span class="line">这里推荐第二种，毕竟UTF8更加通用</span><br></pre></td></tr></table></figure>

<h3 id="2-网页乱码"><a href="#2-网页乱码" class="headerlink" title="2.网页乱码"></a>2.网页乱码</h3><p>一般来说，浏览器浏览的网页的数据其实是从服务器发送过来的，而发送的数据是通过字节流传输，这个过程就涉及到解码-&gt;编码的过程。</p>
<p>在HTTP协议中，编码的协议通过<code>Header</code>中的<code>charset</code>中设置。</p>
<blockquote>
<p>为什么放header，因为HTTP请求会先解析header，而且header一般不会有ASCII无法解析的字符，一般都是英文</p>
</blockquote>
<p>网页乱码其实很好解决，如果发现在Servlet中，返回中文给浏览器的时候浏览器返回的是???</p>
<p>点击F12，抓包网络后，找到<code>Response Body</code> 中的<code>charset</code>选项，可以发现<code>charset=ISO-8859-1</code></p>
<p>也就说默认的Tomcat使用的编码是<code>ISO-8859-1</code>，这是西欧的语言编码，它是不兼容中文的。如果你在<code>Servlet</code>返回的结果中添加一点法语：<code>Ä ä</code>或者德语什么的，你会发现会正常显示。</p>
<p><code>charset</code>的意思便是Tomcat是以什么样的方式编码字节，而浏览器便会以这样的编码方式解码字节。</p>
<p>我们可以将<code>charset</code>修改为兼容中文的即可，比如<code>UTf-8</code>,<code>GB2312</code>等,建议使用<code>UTF-8</code>，在Servlet中，设置编码的方式为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response.setCharacterEncoding(&quot;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<p>也可以如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resp.setContentType(&quot;text&#x2F;html;charset&#x3D;UTF-8&quot;);</span><br></pre></td></tr></table></figure>

<p>建议第一种方式(在IDE中一般带有拼写检查)。</p>
<h3 id="3-IDEA设置编码"><a href="#3-IDEA设置编码" class="headerlink" title="3.IDEA设置编码"></a>3.IDEA设置编码</h3><p>平时编写代码都是使用的IEDA，所以在此说明一下IDEA的编码设置，IDEA默认编码暂时没有找到查找方式，但是我们可以将其指定为<code>UTF-8</code>,找到IDEA的安装路径，在<code>bin</code>目录中可以发现一个名为<code>idea.exe.vmoptions</code>和<code>idea64.exe.vmoptions</code>选项，分别打开，添加<code>-Dfile.encoding=UTF-8</code>后，重启IDEA.</p>
<p>完成上面两步后，再次启动Tomcat服务，你会发现日志已经正常。</p>
<blockquote>
<p>注：如果依然发现乱码，则可能是IDEA缓存了当前项目的编码设置，你可以在当前项目的.idea文件夹中找到encoding.xml文件，删除所有不是UTF-8的编码设置，重启IDEA即可。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>字符集与编码</tag>
      </tags>
  </entry>
  <entry>
    <title>字符集</title>
    <url>/2019/05/14/%E9%80%9A%E7%94%A8%E6%8A%80%E6%9C%AF/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/%E5%AD%97%E7%AC%A6%E9%9B%86/</url>
    <content><![CDATA[<p>字符(<code>Character</code>)：各种文字和符号的总称，包括各国家文字、标点符号、图形符号、数字等</p>
<span id="more"></span>

<p>字符集(<code>Character set</code>)：多个字符的集合</p>
<ul>
<li><p>字符集种类较多，每个字符集包含的字符个数不同，常见字符集名称：</p>
<p><code>ASCII</code>字符集、<code>GB2312</code>字符集、<code>BIG5</code>字符集、<code> GB18030</code>字符集、<code>Unicode</code>字符集等 </p>
</li>
<li><p>计算机要准确的处理各种字符集文字，就需要进行<strong>字符编码</strong>，以便计算机能够识别和存储各种文字。</p>
<blockquote>
<p>编码：众所周知，计算机存储都是0和1，那计算机是如何区分开汉字，字母呢？后来人们就规定了一个编码表，这个表就相当于一个<strong>字典</strong>,比如我们通俗约定1100001就表示<code>A</code>,1100002表示<code>B</code>做计算机显示的时候，发现一个字符对象存储的值是<code>1100001</code>那就显示<code>A</code>就行了。像这样，<em>由信息的一种形式转换为另外一种形式的过程，称为编码。</em>而编码表便是编码过程的一种规则。</p>
</blockquote>
</li>
</ul>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><p>​    ——<code>American  Standard  Codefor  Information  Interchange</code></p>
<p><code>ASCII</code> 这部标准本身就直接规定了字符和字符编码的方式，所以既是字符集又是编码方案</p>
<p>是最出名也是最基本的编码表，最开始计算机发明的时候，计算机的使用一般都是一些特殊字符加上<code>26</code>个字母，因此美国人定制了<code>ASCII</code>表用来显示通用的<code>26</code>个字符加上一些特殊字母，<code>ASCII</code>码只占用一个1字节。</p>
<h3 id="ANSI"><a href="#ANSI" class="headerlink" title="ANSI"></a>ANSI</h3><p>最开始<code>ASCII</code>编码是够用的，但是随着计算机的发展，越来越多的国家陆续用上了计算机，这个时候，母语非英语的国家就开始不满意了，<code>ASCII</code>只能表示<code>26</code>个英文字母，那法语（é），汉语（中国），德语（Ä ä）等也要在计算机中表示，于是最开始，每个国家都自己定义了一套关于自己的编码规则，其中比较出名的有：</p>
<ul>
<li><p>西欧 <code>ISO 8859-1</code></p>
</li>
<li><p>台湾同胞的繁体 <code>Big 5</code></p>
</li>
<li><p>日本 <code>Shift_ JIS</code></p>
</li>
<li><p>中国国标 <code>GB 2312</code>（<code>GB18030</code>和<code>GBK</code>编码标准兼容<code>GB2312</code>）</p>
<p><code>GB2312</code>只是一个区位码形式的字符集标准，不过实际上基本都用 <code>EUC-CN</code> 来编码，所以提及「<code>GB 2312</code>」时也说的是一个字符集和编码连锁的方案。<code>GBK</code> 和 <code>GB 18030</code> 等向后兼容于 <code>GB 2312</code> 的方案也类似。</p>
</li>
</ul>
<p>这些编码都是在原有的<code>ASCII</code>基础上扩展而来，统称为<code>ANSI</code>编码。但是最大的缺点就是<strong>互不兼容</strong>，也就是每个编码都是在没有考虑其他国家的定义的基础上扩展的。一边来说，在解码/编码过程中，都是指定具体的编码，比如<code>GBK2312</code>，<code>ISO 8859-1</code> 等，<strong>ANSI</strong>只是对上述编码的一种统称。使用<strong>ANSI</strong>来作为一种编码格式的一般只见于<code>Windows</code>自带的记事本中。而在<code>Windows</code>记事本中，不同语言的操作系统，记事本所指的<strong>ANSI</strong>是不同的，</p>
<ul>
<li>简体中文 <code>GBK</code></li>
<li>日文 <code>Shift_JIS</code></li>
<li>繁体中文<code>Big 5</code></li>
<li>…</li>
</ul>
<p>因此，对于<code>Windows</code>的记事本，<strong>ANSI</strong>需要看具体的编码。</p>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><p><strong>Unicode字符集和编码是明确区分的</strong>（<code>ANSI</code>类的字符集合编码都是一对一的关系，一种字符集对应一种编码。）</p>
<p><code>Unicode/UCS</code> 标准首先是个统一的字符集标准。<code>Unicode</code>统一了各个国家的字符并规定了每个符号的编码，在<code>Unicode</code><strong>字符集</strong>中，每个字符占用两个字节表示。</p>
<p>而 <code>Unicode/UCS</code> 标准同时也定义了几种可选的<strong>编码方案</strong>，在标准文档中称作「<code>encoding form</code>」，主要包括 <code>UTF-8</code>、<code>UTF-16</code> 和 <code>UTF-32</code>。所以，对 <code>Unicode </code>方案来说，同样的基于 <code>Unicode</code> 字符集的文本可以用多种编码来存储、传输。所以，用「<code>Unicode</code>」来称呼一个编码方案不合适，并且误导。</p>
<ul>
<li><p><code>UTF-8</code></p>
<p>​    ——<code>8-bit Unicode Transformation Format</code></p>
<p>前面说得到，<code>Unicode</code>字符集是以2个字节表示一个字符，但是在有时候只需要<code>ASCII</code>编码即可完整表示所有内容的系统中，使用<code>Unicode</code>会浪费比较多的控件，因此出现了<code>UTF-8</code>编码，<code>UTF-8</code>是一种变长编码。UTF-8在编码<code>Unicode</code>码的时候，会将小位数的字符进行压缩，因此使用<code>UTF-8</code>的表示一个字母的时候，依然只使用一个字节。<code>UTF-8</code>对常用的字符一般3个字节即可表示，最多6个字节。（尽管如此，2003年11月<code>UTF-8</code>被<code>RFC 3629</code>重新规范，只能使用原来<code>Unicode</code>定义的区域，<code>U+0000</code>到<code>U+10FFFF</code>，也就是说最多四个字节：<a href="https://zh.wikipedia.org/wiki/UTF-8">维基百科</a>）</p>
<p><a href="https://www.zhihu.com/question/55140986/answer/142938758">utf-8没有字节序的原因</a></p>
</li>
<li><p><code>UTF-16</code></p>
<p><code>UTF-16</code>使用16位作为一个字长单位，使用<code>UTF-16</code>要么是两个字节表示一个字符，要么是4个字节。不过值得注意的是不同的操作系统读取直接的顺序不同，就好像古人写字是从右往左写一样，这里顺序，称为<strong>字节序</strong>，比如1122，有些系统读出来是1122，而有些系统读出来是2211，所以<code>UTF-16</code>又分大端（<strong>utf16-big endian</strong>）和小端（<strong>utf16-little endian</strong>）表示。</p>
</li>
<li><p><code>UTF-32</code></p>
<p><code>UTF-32</code> 将每一个 <code>Unicode</code> 代码点表示为相同值的 32 位整数</p>
</li>
</ul>
<h3 id="URLEncoding"><a href="#URLEncoding" class="headerlink" title="URLEncoding"></a>URLEncoding</h3><p><code>URLEncoding</code>又称为<strong>百分号编码</strong>,其主要作用在于解决在<strong>使用url中混合其他编码的时候所带来的语法冲突</strong>，比如<code>?</code>在URL中，表示参数分割，但是如果想要在参数中传递<code>？</code>就必须通过特殊的转换，而<code>URLEncoding</code>则正是用来将这些特殊符号转换为其他不会有歧义的统一编码。</p>
<p>其主要编码原理在于：将需要转码的字符转为16进制，然后从右到左，取4位(不足4位直接处理)，每2位做一位，前面加上%，编码成%XY格式</p>
<p>部分特殊字符转换规则如下：</p>
<table>
<thead>
<tr>
<th>空格</th>
<th>!</th>
<th>#</th>
<th>$</th>
<th>%</th>
<th>+</th>
<th>@</th>
<th>:</th>
<th>=</th>
<th>?</th>
</tr>
</thead>
<tbody><tr>
<td>%20</td>
<td>%21</td>
<td>%23</td>
<td>%24</td>
<td>%25</td>
<td>%2B</td>
<td>%40</td>
<td>%3A</td>
<td>%3D</td>
<td>%3F</td>
</tr>
</tbody></table>
<p>一般当参数会混合在URL中，都会先将参数进行URL编码再进行传递。比如<strong>Get</strong>请求或者Http中MIME类型为<code>application/x-www-form-urlencoded</code>的请求</p>
<p>参考资料</p>
<p><a href="https://www.zhihu.com/question/20650946/answer/15745831">https://www.zhihu.com/question/20650946/answer/15745831</a></p>
<p><a href="http://dengchengchao.com/?p=793">http://dengchengchao.com/?p=793</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>字符集与编码</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：七.在对象之间搬移特性</title>
    <url>/2018/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%83-%E5%9C%A8%E5%AF%B9%E8%B1%A1%E4%B9%8B%E9%97%B4%E6%90%AC%E7%A7%BB%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<h3 id="1-搬移函数：move-method"><a href="#1-搬移函数：move-method" class="headerlink" title="1.搬移函数：move method"></a>1.搬移函数：move method</h3><p>问题：你的程序中，有个函数与其所驻类之外的另一个类进行更多的交流，调用后者，或者被后者调用</p>
<p><strong>在该函数最常引用的类中建立一个有着类似行为的新函数，将旧函数变成一个单纯的委托函数，或是将旧函数完全移除</strong></p>
<span id="more"></span>

<p>一般是根据函数与哪个对象的交流比较多，决定其移动路径</p>
<h3 id="2-搬移字段：move-field"><a href="#2-搬移字段：move-field" class="headerlink" title="2.搬移字段：move field"></a>2.搬移字段：move field</h3><p>问题：在你的程序中，某个字段被其所驻类之外的另一个类更多的用到</p>
<p><strong>在目标类新建一个字段，修改源字段的所有用户，令他们改用新字段</strong></p>
<h3 id="3-提炼类：extract-class"><a href="#3-提炼类：extract-class" class="headerlink" title="3.提炼类：extract class"></a>3.提炼类：extract class</h3><p>问题：某个类做了应该有两个类做的事</p>
<p><strong>建立一个新类，将相关的字段和函数从旧类搬移到新类</strong></p>
<h3 id="4-将类内联化：Inline-class"><a href="#4-将类内联化：Inline-class" class="headerlink" title="4.将类内联化：Inline class"></a>4.将类内联化：Inline class</h3><p>问题：某个类没有做太多的事情</p>
<p><strong>将这个类的所有特性搬移到另一个类中，然后移除原类</strong></p>
<p>3和4是对应的，具体如何操作取决于实际情况分析</p>
<h3 id="5-隐藏委托关系：hide-delegate"><a href="#5-隐藏委托关系：hide-delegate" class="headerlink" title="5.隐藏委托关系：hide delegate"></a>5.隐藏委托关系：hide delegate</h3><p>问题：客户通过一个委托来调用另一个对象</p>
<p><strong>在服务类上建立客户所需的所有函数，用以隐藏委托关系</strong></p>
<p>可以减少耦合</p>
<h3 id="6-移除中间人-remove-middle-man"><a href="#6-移除中间人-remove-middle-man" class="headerlink" title="6.移除中间人:remove middle man"></a>6.移除中间人:remove middle man</h3><p>问题：某个类做了过多的简单委托动作</p>
<p><strong>让客户直接调用受托类</strong></p>
<p>5和6是对应的，具体如何操作取决于实际情况分析</p>
<h3 id="7-引入外加函数-introduce-foreign-method"><a href="#7-引入外加函数-introduce-foreign-method" class="headerlink" title="7.引入外加函数:introduce foreign method"></a>7.引入外加函数:introduce foreign method</h3><p>问题：你需要为提供服务的类增加一个函数，但你无法修改这个类</p>
<p><strong>在客户类中建立一个函数，并以第一参数形式传入一个服务类实例</strong></p>
<h3 id="8-引入本地扩展：introduce-local-extension"><a href="#8-引入本地扩展：introduce-local-extension" class="headerlink" title="8.引入本地扩展：introduce local extension"></a>8.引入本地扩展：introduce local extension</h3><p>问题：你需要为服务类提供一些额外函数，但你无法修改这个类<br><strong>建立一个新类，使他包含这些额外函数，让这个扩展品成为源类的子类或是包装类</strong></p>
<p>子类和包装类统称为本地扩展</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构,改善既有代码的设计：一.第一个案例</title>
    <url>/2018/08/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%80-%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<p>1.重构一个冗长的程序，使得添加新的特性非常容易 <code>===</code> 当想修改一段程序的时候，发现代码难以修改，就该重构了</p>
<span id="more"></span>

<p>2.重构的第一步：为即将修改的代码，建立一套可靠的测试环境（可见平时编写代码的时候，写单元测试的重要性！）<strong>好的测试是重构的根本</strong><br>（1）这些测试，是有自我检验能力的（个人理解：例如断言）</p>
<p>3.代码块越小，代码的功能越容易管理，代码的处理和移动也会相对轻松</p>
<p>4.重构技术就是以微小的步伐修改程序，（这样做的原因是，如果修改出错误，容易发现）</p>
<p>5.修改变量名称也是重构的一部分（写出机器能看懂的代码容易，写出人类能看懂的代码不容易）</p>
<p>6.代码应该表现自己的目的</p>
<p>7.绝大多数情况下，函数应该放在她所使用数据的所属对象内，（在使用这个函数的地方，用对象调用即可）</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重构前</span><br><span class="line">A:&#123;</span><br><span class="line">    name</span><br><span class="line">&#125;</span><br><span class="line">B:&#123;</span><br><span class="line">    name;</span><br><span class="line">    &#x2F;&#x2F;假设现在b中要是用a的name</span><br><span class="line">    getNameFromA(A a)&#123;</span><br><span class="line">        &#x2F;&#x2F;内部可能还有更复杂的操作，但是操作的是用A中的参数，</span><br><span class="line">        &#x2F;&#x2F;这个方法中没有使用B类中的数据，所以应该重构到A中去</span><br><span class="line">        return &#39;a name&#39; + a.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>理解：</p>
<ul>
<li>函数应该放在她所使用数据的所属对象内：即：getAName()放在A类中</li>
<li>在使用这个函数的地方，用对象调用即可：即：在C类中传入A对象，调用getAName</li>
</ul>
<p>重构的过程是，将getAName()转移到A类中（这中间一般要去掉参数，修改函数名称）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;重构后</span><br><span class="line">A:&#123;</span><br><span class="line">    name;</span><br><span class="line">    getAName()&#123;</span><br><span class="line">        return &#39;a name:&#39;+a.name ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">B:&#123;</span><br><span class="line">    name;</span><br><span class="line">    &#x2F;&#x2F;（1）可以这样用</span><br><span class="line">    &#x2F;&#x2F;继续保留原来旧的函数，调用新的函数---不用修改原来调用这个函数的其他函数</span><br><span class="line">     getNameFromA(A a)&#123;</span><br><span class="line">        return a.getAName</span><br><span class="line">    &#125;</span><br><span class="line">    &#x2F;&#x2F;（2）也可以这样用</span><br><span class="line">    &#x2F;&#x2F;这样去掉原理的旧函数，对应的调用旧函数的地方，也要改成调用新的方式调用函数</span><br><span class="line">    A a</span><br><span class="line">    nameStr &#x3D; a.getAName</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>8.尽量去除临时变量？—可能有性能问题，例如变量在循环中，拿出来就需要循环两次</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：三.代码的坏味道2</title>
    <url>/2018/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%89-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%932/</url>
    <content><![CDATA[<h3 id="12-冗赘类"><a href="#12-冗赘类" class="headerlink" title="12.冗赘类"></a>12.冗赘类</h3><p>一个类工作的内容不多，可能涉及问题。可能重构使他工作内容变少，当类的价值不大的时候，可以考虑删除他</p>
<span id="more"></span>

<h3 id="13-夸夸其谈未来性"><a href="#13-夸夸其谈未来性" class="headerlink" title="13.夸夸其谈未来性"></a>13.夸夸其谈未来性</h3><p>引入新的配置和概念，当下使用就引入，不要觉得未来所以引用。</p>
<h3 id="14-令人迷惑的暂时字段"><a href="#14-令人迷惑的暂时字段" class="headerlink" title="14.令人迷惑的暂时字段"></a>14.令人迷惑的暂时字段</h3><p>暂时字段，容易让人迷惑</p>
<ul>
<li>将这些变量和其相关函数提炼到一个独立的类中</li>
</ul>
<h3 id="15-过度耦合的消息链"><a href="#15-过度耦合的消息链" class="headerlink" title="15.过度耦合的消息链"></a>15.过度耦合的消息链</h3><p>现象是：一个对象请求另一个对象，然后再向后者请求另一个对象，然后在请求一个对象…</p>
<ul>
<li>隐藏委托关系</li>
<li>尽量先观察最终得出的对象是做什么的，然后提炼到单独的函数中，取消消息链</li>
</ul>
<h3 id="16-中间人"><a href="#16-中间人" class="headerlink" title="16.中间人"></a>16.中间人</h3><p>某个类接口有一半的函数都委托给其他类，就是过度运用</p>
<ul>
<li>移除中间人</li>
<li>若果中间人还有其他行为，可以以继承取代委托</li>
</ul>
<h3 id="17-过度亲密"><a href="#17-过度亲密" class="headerlink" title="17.过度亲密"></a>17.过度亲密</h3><p>两个类过于亲密</p>
<ul>
<li>移动方法 移动属性</li>
<li>将双向关联改为单向关联</li>
<li>隐藏委托</li>
<li>继承关系过度亲密的时候，可以以委托取代继承</li>
</ul>
<h3 id="18-异曲同工的类"><a href="#18-异曲同工的类" class="headerlink" title="18.异曲同工的类"></a>18.异曲同工的类</h3><ul>
<li>重命名</li>
<li>提炼超类</li>
</ul>
<h3 id="19-不完美的类库"><a href="#19-不完美的类库" class="headerlink" title="19.不完美的类库"></a>19.不完美的类库</h3><ul>
<li>只想修改类库的一两个函数：引入外加函数</li>
<li>添加一大堆额外行为：引入本地扩展</li>
</ul>
<h3 id="20-纯稚的数据类"><a href="#20-纯稚的数据类" class="headerlink" title="20.纯稚的数据类"></a>20.纯稚的数据类</h3><p>拥有一些字段，以及用于访问（读写）这些字段的函数，没有其他</p>
<ul>
<li>应该封装字段</li>
<li>封装容器</li>
<li>一些不可被其他类修改的字段，应该去掉set方法</li>
</ul>
<h3 id="21-被拒绝的馈赠"><a href="#21-被拒绝的馈赠" class="headerlink" title="21.被拒绝的馈赠"></a>21.被拒绝的馈赠</h3><p>在继承中，存在子类不想或者不需要的继承</p>
<ul>
<li>以委托取代继承</li>
</ul>
<h3 id="22-过多的注释"><a href="#22-过多的注释" class="headerlink" title="22.过多的注释"></a>22.过多的注释</h3><p>当感觉需要写注释的时候（不是业务场景），那么现场是重构。</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：三.代码的坏味道1</title>
    <url>/2018/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B8%89-%E4%BB%A3%E7%A0%81%E7%9A%84%E5%9D%8F%E5%91%B3%E9%81%931/</url>
    <content><![CDATA[<h3 id="1-重复代码"><a href="#1-重复代码" class="headerlink" title="1.重复代码"></a>1.重复代码</h3><p>合而为一，程序会更好</p>
<ul>
<li><p>1.同一个类中，提炼方法，将他提炼出来</p>
  <span id="more"></span>
</li>
<li><p>2.互为兄弟的子类中</p>
<ul>
<li>（1）重复代码相同，提炼方法，放到父类中</li>
<li>（2）两段重复的代码不完全相同，使用模板方法</li>
</ul>
</li>
<li><p>3.不相关的类中，可以提取到第三个独立的类中</p>
</li>
</ul>
<h3 id="2-过长函数"><a href="#2-过长函数" class="headerlink" title="2.过长函数"></a>2.过长函数</h3><p>独立的小函数，以其用途命名</p>
<ul>
<li><strong>提炼函数</strong></li>
<li>函数中有大量的参数和临时变量，对提取造成了阻碍<ul>
<li>以查询取代临时变量</li>
<li><strong>引入参数对象</strong> 例如：传入4个参数，可以将这4个参数设置为一个对象，然后传入对象</li>
<li><strong>保持参数的完整性</strong>  例如：传入类其中得晚两个个属性时，改为传入这个类</li>
</ul>
</li>
<li>以上的方法都做了，还是有大量的变量和参数，可以:<strong>以函数对象取代函数</strong></li>
</ul>
<p>如何确定提炼哪一段：</p>
<ul>
<li>需要注释的方法</li>
<li>条件表达式和循环也可以提炼<ul>
<li>分解条件表达式</li>
<li>将循环和其内的代码提炼到一个独立的函数中</li>
</ul>
</li>
</ul>
<h3 id="3-过大的类"><a href="#3-过大的类" class="headerlink" title="3.过大的类"></a>3.过大的类</h3><p>单个类做太多的事情，内部往往会有太多的实例变量，<br>而且即使没有太多的实例变量，太长的代码也不易读</p>
<ul>
<li>提炼类</li>
<li>提炼子类</li>
<li>提炼之前可以先提炼接口，帮助分析和理解这个类</li>
</ul>
<h3 id="4-过长的参数列"><a href="#4-过长的参数列" class="headerlink" title="4.过长的参数列"></a>4.过长的参数列</h3><p>太长的参数难以理解</p>
<ul>
<li>以函数取代参数</li>
<li>引入参数对象</li>
</ul>
<h3 id="5-发散式变化"><a href="#5-发散式变化" class="headerlink" title="5.发散式变化"></a>5.发散式变化</h3><p>某个类因为不同的原因在不同的方向上发生变化，即出现了 发散式变化</p>
<p>（当前类没有单一职责）</p>
<ul>
<li>提炼类<ul>
<li>找出特定原因，而造成的所有变化，提炼类</li>
</ul>
</li>
</ul>
<p>提炼后的目标是：使得每个对象只因一种变化而需要修改==针对某一外界变化的所有相应修改，都只应该发生在单一类中</p>
<h3 id="6-霰弹式修改"><a href="#6-霰弹式修改" class="headerlink" title="6.霰弹式修改"></a>6.霰弹式修改</h3><p>遇到某种变化，需要在修多不同的类做出修多小修改</p>
<ul>
<li>搬移方法</li>
<li>搬移字段</li>
</ul>
<p>将所有需要修改的代码放置到同一个类中</p>
<h3 id="7-依恋情节"><a href="#7-依恋情节" class="headerlink" title="7.依恋情节"></a>7.依恋情节</h3><p>某一方法，对某个类的兴趣超过自己所处类的兴趣</p>
<ul>
<li>搬移方法<ul>
<li>判断哪个类拥有最多被此方法使用的数据，就把这个函数和那些数据放到一起</li>
</ul>
</li>
</ul>
<p>Strategy、Visit、SelfDeleteation破坏了这个规则(根据情况选择)</p>
<h3 id="8-数据泥团"><a href="#8-数据泥团" class="headerlink" title="8.数据泥团"></a>8.数据泥团</h3><p>例如:两个类中相同的字段、修多函数签名中相同的参数，这些总是绑在一起出现的数据，就算是数据泥团（应该拥有属于自己的对象）</p>
<ul>
<li>引入参数对象</li>
<li>将参数作为对象</li>
</ul>
<h3 id="9-基本类型偏执"><a href="#9-基本类型偏执" class="headerlink" title="9.基本类型偏执"></a>9.基本类型偏执</h3><p>对象方便的时候，不使用基本类型</p>
<ul>
<li>以对象取代数据值</li>
<li>以类取代类型码</li>
<li>这个主要是提倡使用对象和类，而不是基本类型</li>
</ul>
<h3 id="10-switch惊悚现身"><a href="#10-switch惊悚现身" class="headerlink" title="10.switch惊悚现身"></a>10.switch惊悚现身</h3><p>switch语句的问题，在于重复，</p>
<p>可能同样的switch语句散布于不同的地方，如果增加一个新的case语句，就必须找到所有switch，并修改他们</p>
<ul>
<li>看到switch,首先考虑多态解决</li>
<li>比较小型的switch,考虑以明确的函数参数</li>
</ul>
<h3 id="11-平行集继承体系"><a href="#11-平行集继承体系" class="headerlink" title="11.平行集继承体系"></a>11.平行集继承体系</h3><p>当你为一个类增加一个子类，必须也为另一个类相应增加一个子类，如果发现某一继承体系的类名称前缀和另一个继承体系的类名称前缀完全相同，便是这种坏味道</p>
<ul>
<li>让一个继承体系的实例引用另一个继承体系的实例</li>
<li>移动方法+移动属性，将引用端的继承体系去掉</li>
</ul>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：九.简化条件表达式</title>
    <url>/2018/08/07/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%B9%9D-%E7%AE%80%E5%8C%96%E6%9D%A1%E4%BB%B6%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="1-分解条件表达式：decomponse-conditional"><a href="#1-分解条件表达式：decomponse-conditional" class="headerlink" title="1.分解条件表达式：decomponse conditional"></a>1.分解条件表达式：decomponse conditional</h3><p>问题：你有一个复杂的条件（if-then-else）语句</p>
<p><strong>从if、then、else三个段落中分别提炼出独立函数</strong></p>
<p>提炼的函数会使代码的可读性更高（像是注释）</p>
<span id="more"></span>

<h3 id="2-合并条件表达式：consolidate-conditional-expression"><a href="#2-合并条件表达式：consolidate-conditional-expression" class="headerlink" title="2.合并条件表达式：consolidate conditional expression"></a>2.合并条件表达式：consolidate conditional expression</h3><p>问题：你有一系列条件测试，都得到相同结果</p>
<p><strong>将这些测试合并为一个条件表达式，并将这个条件表达式提炼成为一个独立函数</strong></p>
<h3 id="3-合并重复的条件片段：consolidate-duplicate-conditional-fragments"><a href="#3-合并重复的条件片段：consolidate-duplicate-conditional-fragments" class="headerlink" title="3.合并重复的条件片段：consolidate duplicate conditional fragments"></a>3.合并重复的条件片段：consolidate duplicate conditional fragments</h3><p>问题：在条件表达式的每个分支上有着相同的代码片段</p>
<p><strong>将这段重复代码搬移到条件表达式之外</strong></p>
<p>代码应该清晰地表明，哪些东西随条件变化，哪些东西保持不变</p>
<h3 id="4-移除控制标记：remove-control-flag"><a href="#4-移除控制标记：remove-control-flag" class="headerlink" title="4.移除控制标记：remove control flag"></a>4.移除控制标记：remove control flag</h3><p>问题：在一系列布尔表达式中，某个变量带有“控制标记”的作用</p>
<p><strong>以break语句或return语句取代控制标记</strong></p>
<h3 id="5-以卫语句取代嵌套条件表达式：replace-nested-conditional-with-guard-clauses"><a href="#5-以卫语句取代嵌套条件表达式：replace-nested-conditional-with-guard-clauses" class="headerlink" title="5.以卫语句取代嵌套条件表达式：replace nested conditional with guard clauses"></a>5.以卫语句取代嵌套条件表达式：replace nested conditional with guard clauses</h3><p>问题:函数中的条件逻辑使人难以看清正常的执行路径</p>
<p><strong>使用卫语句表现所有情况</strong></p>
<p>如果某个条件极其罕见，就应该单独检查改条件，并在该条件为真时，立刻从函数中返回，这样的单独检查被称为<code>卫语句</code></p>
<p>该重构的精髓是：给某一条分支以特别重试</p>
<h3 id="6-以多态取代条件表达式：replace-conditional-with-polymorpism"><a href="#6-以多态取代条件表达式：replace-conditional-with-polymorpism" class="headerlink" title="6.以多态取代条件表达式：replace conditional with polymorpism"></a>6.以多态取代条件表达式：replace conditional with polymorpism</h3><p>问题：你手上有个条件表达式，他根据对象类型的不同而选择不同的行为</p>
<p><strong>将这个条件表达式的每个分支放进一个子类内的覆写函数中，然后将原始函数声明为抽象函数</strong></p>
<h3 id="7-引入null对象：introduce-null-object"><a href="#7-引入null对象：introduce-null-object" class="headerlink" title="7.引入null对象：introduce null object"></a>7.引入null对象：introduce null object</h3><p>问题：你需要再三检查某对象是否为null</p>
<p><strong>将null值替换为null对象</strong></p>
<h3 id="8-引入断言：introduce-assertion"><a href="#8-引入断言：introduce-assertion" class="headerlink" title="8.引入断言：introduce assertion"></a>8.引入断言：introduce assertion</h3><p>问题：某一段代码需要对程序状态作出某种假设</p>
<p><strong>以断言明确表现这种建设</strong></p>
<p>加入断言不会影响函数行为，但：不能滥用断言，不要使用它来检查<code>你认为应该为真</code>的条件，只使用他来检查<code>一定必须为真的条件</code>。</p>
<p>断言的价值在于：帮助程序员理解代码正确运行的必要条件</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：六.重新组织函数</title>
    <url>/2018/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%85%AD-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="1-提炼函数：extract-method"><a href="#1-提炼函数：extract-method" class="headerlink" title="1.提炼函数：extract method"></a>1.提炼函数：extract method</h3><p>问题：你有一段代码可以被组织在一起并独立出来</p>
<p><strong>将这段代码放进一个独立函数中，并让函数名称解释该函数的用途</strong></p>
<span id="more"></span>

<ul>
<li>每个函数的粒度越小，函数被复用的机会就越大，函数覆写也更容易</li>
<li>函数以‘做什么’来命名</li>
</ul>
<h3 id="2-内联函数：lnline-method"><a href="#2-内联函数：lnline-method" class="headerlink" title="2.内联函数：lnline method"></a>2.内联函数：lnline method</h3><p>问题：一个函数的本体域名城同样清楚易懂</p>
<p><strong>在函数调用点插入函数本体，然后移除该函数</strong></p>
<h3 id="3-内联临时变量-lnline-temp"><a href="#3-内联临时变量-lnline-temp" class="headerlink" title="3.内联临时变量:lnline temp"></a>3.内联临时变量:lnline temp</h3><p>问题：你有一个临时变量，只被一个简单的表达式赋值一次，而他妨碍了其他重构手法</p>
<p><strong>将所有对该变量的引用动作，替换为对他赋值的那个表达式自身</strong></p>
<h3 id="4-以查询取代临时变量：replace-temp-with-query"><a href="#4-以查询取代临时变量：replace-temp-with-query" class="headerlink" title="4.以查询取代临时变量：replace temp with query"></a>4.以查询取代临时变量：replace temp with query</h3><p>问题：你的程序以一个临时变量保存某一表达式的运算结果</p>
<p><strong>将这个表达式提炼到一个独立函数中，将这个临时变量的所有引用点替换为对新函数的调用，此后，新函数就可被其他函数使用</strong></p>
<p>如果临时变量不只被赋值一次（例如结果收集），我就不该进行这项重构</p>
<h3 id="5-引入解释性变量-introduce-explaining-variable"><a href="#5-引入解释性变量-introduce-explaining-variable" class="headerlink" title="5.引入解释性变量:introduce explaining variable"></a>5.引入解释性变量:introduce explaining variable</h3><p>问题：你有一个复杂的表达式</p>
<p><strong>将该复杂表达式（或其中一部分）的结果放进一个临时变量，以此变量名称来解释表达式用途</strong></p>
<h3 id="6-分解临时变量：split-temporary-variable"><a href="#6-分解临时变量：split-temporary-variable" class="headerlink" title="6.分解临时变量：split temporary variable"></a>6.分解临时变量：split temporary variable</h3><p>问题：你的程序有某个临时变量被赋值超过一次，他既不是循环变量，也不被用于收集计算结果</p>
<p><strong>针对每次赋值，创造一个独立、对应的临时变量</strong></p>
<p>每个变量应该只承担一个责任</p>
<h3 id="7-移除对参数的赋值：remove-assignments-to-parameters"><a href="#7-移除对参数的赋值：remove-assignments-to-parameters" class="headerlink" title="7.移除对参数的赋值：remove assignments to parameters"></a>7.移除对参数的赋值：remove assignments to parameters</h3><p>问题：代码对一个参数进行赋值</p>
<p><strong>以一个临时变量取代该参数的位置</strong></p>
<h3 id="8-以函数对象取代函数：replace-method-with-method-object"><a href="#8-以函数对象取代函数：replace-method-with-method-object" class="headerlink" title="8.以函数对象取代函数：replace method with method object"></a>8.以函数对象取代函数：replace method with method object</h3><p>问题：你有一个大型函数，其中对局部变量的使用，使你无法采用 提炼函数 的手法</p>
<p><strong>将这个函数放进一个单独对象中，如此一来局部变量就成了对象内的字段，然后你可以在同一个对象中将这个大型函数分解为多个小型函数</strong></p>
<h3 id="9-替换算法：substitute-algorithm"><a href="#9-替换算法：substitute-algorithm" class="headerlink" title="9.替换算法：substitute algorithm"></a>9.替换算法：substitute algorithm</h3><p>问题：你想要把某个算法替换为另一个更清晰的算法</p>
<p><strong>将函数本体替换为另一个算法</strong></p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：二.重构的原则</title>
    <url>/2018/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%BA%8C-%E9%87%8D%E6%9E%84%E7%9A%84%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<p>一：重构：</p>
<p>1.重构</p>
<ul>
<li><p>（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本</p>
</li>
<li><p>（动词）：使用一系列重构手法，再不改变软件可观察行为的前提下，调整其结构</p>
<span id="more"></span>

</li>
</ul>
<p>2.应该时刻清楚，自己现在在做什么，到底是重构还是增加新需求</p>
<p>二：为什么重构：</p>
<ul>
<li>重构改进软件设计</li>
<li>重构使软件更容易理解</li>
<li>重构帮助找到bug</li>
<li>重构提高变成速度</li>
</ul>
<p>三：何时重构：</p>
<p>三次法则：第一次做某件事时只管去做，第二次做类似的事会产生反感，但无论如何还是可以去做，第三次在做类似的事，你就应该重构</p>
<ul>
<li>添加功能时重构</li>
<li>修补错误时重构</li>
<li>复审代码时重构</li>
</ul>
<p><strong>只要有机会，就可重构</strong></p>
<p>四：重构的难题</p>
<ul>
<li>数据库</li>
<li>接口：不要过早发布接口，请修改你的代码所有权政策，使重构更顺畅</li>
<li>难以通过重构手法完成设计改动</li>
<li>当重构没有重写简单时，不该重构，应该重写</li>
</ul>
<p>五：重构与设计</p>
<p>重构的特殊使命：和设计彼此互补</p>
<p>六：重构与性能<br>重构不可忽视性能</p>
<p>可以：首先写出可调的软件，然后调整他以求获取足够速度</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：八.重新组织数据</title>
    <url>/2018/08/06/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%85%AB-%E9%87%8D%E6%96%B0%E7%BB%84%E7%BB%87%E6%95%B0%E6%8D%AE/</url>
    <content><![CDATA[<h3 id="1-自封装字段：self-encapsulate"><a href="#1-自封装字段：self-encapsulate" class="headerlink" title="1.自封装字段：self encapsulate"></a>1.自封装字段：self encapsulate</h3><p>问题：你直接访问一个字段，但与字段之间的耦合关系逐渐变得笨拙</p>
<p><strong>为这个字段建立取值/设置函数，并且只以这些函数来访问字段</strong></p>
<span id="more"></span>

<p>自封装：是在同一个类中，本类使用成员变量，也使用本类的取值/设置函数<br>10小节：封装：是其他类使用，将本来的字段封装</p>
<h3 id="2-以对象取代数据值：replace-data-value-with-object"><a href="#2-以对象取代数据值：replace-data-value-with-object" class="headerlink" title="2.以对象取代数据值：replace data value with object"></a>2.以对象取代数据值：replace data value with object</h3><p>问题：你有一个数据项，需要与其他数据和行为一起使用才有意义</p>
<p><strong>将数据项变成对象</strong></p>
<p>个人理解是当某一类的数据项多的时候，可以向这些数据项抽出成一个类</p>
<h3 id="3-将值对象改为引用对象：change-value-to-reference"><a href="#3-将值对象改为引用对象：change-value-to-reference" class="headerlink" title="3.将值对象改为引用对象：change value to reference"></a>3.将值对象改为引用对象：change value to reference</h3><p>问题：你从一个类衍生出许多彼此相等的类，希望将他们替换为同一对象</p>
<p><strong>将这个值对象变成引用对象</strong></p>
<h3 id="4-将引用对象改为值对象：chang-reference-to-value"><a href="#4-将引用对象改为值对象：chang-reference-to-value" class="headerlink" title="4.将引用对象改为值对象：chang reference to value"></a>4.将引用对象改为值对象：chang reference to value</h3><p>问题：你有一个引用，很小且不可变，而且不易管理</p>
<p><strong>将它变成值对象</strong></p>
<p>值对象有一个非常重要的特性：他们是不可变的</p>
<h3 id="5-以对象取代数组：replace-array-with-object"><a href="#5-以对象取代数组：replace-array-with-object" class="headerlink" title="5.以对象取代数组：replace array with object"></a>5.以对象取代数组：replace array with object</h3><p>问题：你有一个数组，其中的元素各自代表不同的东西</p>
<p><strong>以对象替换数组，对于数组中的每个元素，以一个字段来表示</strong></p>
<h3 id="6-复制“被监视数据”：duplicate-observed-data"><a href="#6-复制“被监视数据”：duplicate-observed-data" class="headerlink" title="6.复制“被监视数据”：duplicate observed data"></a>6.复制“被监视数据”：duplicate observed data</h3><p>问题：你有一些领域数据置身于GUI控件中，而领域函数需要访问这些数据</p>
<p><strong>将该数据复制到一个领域对象中，建立一个Observer模式，用以同步领域对象和GUI对象内的重复数据</strong></p>
<h3 id="7-将单向关联改为双向关联：change-unidrectional-association-to-bidirectional"><a href="#7-将单向关联改为双向关联：change-unidrectional-association-to-bidirectional" class="headerlink" title="7.将单向关联改为双向关联：change unidrectional association to bidirectional"></a>7.将单向关联改为双向关联：change unidrectional association to bidirectional</h3><p>问题：两个类都需要使用对方特性，但其间只有一条单向连接</p>
<p><strong>添加一个反向指针，并使修改函数（改变双方关系的函数）能够同时更新两条连接</strong></p>
<h3 id="8-将双向关联改为单向连接：change-bidirectional-association-to-unidirectional"><a href="#8-将双向关联改为单向连接：change-bidirectional-association-to-unidirectional" class="headerlink" title="8.将双向关联改为单向连接：change bidirectional association to unidirectional"></a>8.将双向关联改为单向连接：change bidirectional association to unidirectional</h3><p>问题：两个类之间有双向关联，但其中一个类如今不再需要另一类的特性</p>
<p><strong>去除不必要的关联</strong></p>
<h3 id="9-以字面常量取代魔法数：replace-magic-number-with-symbolic-constant"><a href="#9-以字面常量取代魔法数：replace-magic-number-with-symbolic-constant" class="headerlink" title="9.以字面常量取代魔法数：replace magic number with symbolic constant"></a>9.以字面常量取代魔法数：replace magic number with symbolic constant</h3><p>问题：你有一个字面常量，带有特别含义</p>
<p><strong>创造一个常量，根据其意义为它命名，并将上述的字面数值替换为这个常量</strong></p>
<p>常量不会造成任何性能开销，还可以大大的提高代码的可读性</p>
<h3 id="10-封装字段：encapsulate-field"><a href="#10-封装字段：encapsulate-field" class="headerlink" title="10.封装字段：encapsulate field"></a>10.封装字段：encapsulate field</h3><p>问题：你的类中存在一个public字段</p>
<p><strong>将它声明为private，并提供相应的访问函数</strong></p>
<p>1小节：自封装：是在同一个类中，本类使用成员变量，也使用本类的取值/设置函数<br>封装：是其他类使用，将本来的字段封装</p>
<h3 id="11-封装集合：encapsulate-collection"><a href="#11-封装集合：encapsulate-collection" class="headerlink" title="11.封装集合：encapsulate collection"></a>11.封装集合：encapsulate collection</h3><p>问题：有个函数返回一个集合</p>
<p><strong>让这个函数返回该集合的一个只读副本，并在这个类中添加/移除集合元素的函数</strong></p>
<p>不应该为这个集合提供一个设置函数，但应该提供 用以为集合添加/移除元素的函数，这样，集合拥有者（对象）就可以控制集合元素的添加和移除</p>
<h3 id="12-以数据类取代记录：replace-record-with-data-class"><a href="#12-以数据类取代记录：replace-record-with-data-class" class="headerlink" title="12.以数据类取代记录：replace record with data class"></a>12.以数据类取代记录：replace record with data class</h3><p>问题：你需要面对传统编程环境中的记录结构</p>
<p><strong>为该记录创建一个‘哑’数据对象</strong></p>
<p>个人理解：就像是创建对应数据库表的bena一样</p>
<h3 id="13-以类取代类型码：replace-type-code-with-class"><a href="#13-以类取代类型码：replace-type-code-with-class" class="headerlink" title="13.以类取代类型码：replace type code with class"></a>13.以类取代类型码：replace type code with class</h3><p>问题：类之中有一个数值类型码，但它并不影响类的行为</p>
<p><strong>以一个新的类替换该数值类型码</strong></p>
<h3 id="14-以子类取代类型码：replace-type-code-with-subclasses"><a href="#14-以子类取代类型码：replace-type-code-with-subclasses" class="headerlink" title="14.以子类取代类型码：replace type code with subclasses"></a>14.以子类取代类型码：replace type code with subclasses</h3><p>问题：你有一个不可变的类型码，他会影响类的行为</p>
<p><strong>以子类取代这个类型码</strong></p>
<h3 id="15-以State-Strategy取代类型码：replace-type-code-with-State-Strategy"><a href="#15-以State-Strategy取代类型码：replace-type-code-with-State-Strategy" class="headerlink" title="15.以State/Strategy取代类型码：replace type code with State/Strategy"></a>15.以State/Strategy取代类型码：replace type code with State/Strategy</h3><p>问题：你有一个类型码，它会影响类的行为，但你无法通过集成手法消除他</p>
<p><strong>以状态对象取代类型码</strong></p>
<h3 id="16-以字段取代子类：replace-subclass-with-fields"><a href="#16-以字段取代子类：replace-subclass-with-fields" class="headerlink" title="16.以字段取代子类：replace subclass with fields"></a>16.以字段取代子类：replace subclass with fields</h3><p>问题：你的各个子类唯一的差别只在‘返回常量数据’的函数上</p>
<p><strong>修改这些函数，使他们返回超类中的某个（新增）字段，然后销毁子类</strong></p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：五.重构列表</title>
    <url>/2018/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E4%BA%94-%E9%87%8D%E6%9E%84%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<p>本书第五章主要是说明本书的说明习惯</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：十.简化函数调用</title>
    <url>/2018/08/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%81-%E7%AE%80%E5%8C%96%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<h3 id="1-函数改名：rename-method"><a href="#1-函数改名：rename-method" class="headerlink" title="1.函数改名：rename method"></a>1.函数改名：rename method</h3><p>问题：函数的名称未能揭示函数的用途</p>
<p><strong>修改函数名称</strong></p>
<p>可以首先考虑应该加怎样的注释，然后将注释变成函数名称</p>
<span id="more"></span>

<h3 id="2-添加参数：add-parameter"><a href="#2-添加参数：add-parameter" class="headerlink" title="2.添加参数：add parameter"></a>2.添加参数：add parameter</h3><p>问题：某个函数需要从调用端得到更多信息</p>
<p><strong>为此函数添加一个对象参数，让该对象带进函数所需信息</strong></p>
<p>只要可能，其他选择都比添加参数好，参数列表越短越好</p>
<h3 id="3-移除参数：remove-parameter"><a href="#3-移除参数：remove-parameter" class="headerlink" title="3.移除参数：remove parameter"></a>3.移除参数：remove parameter</h3><p>问题：函数本体不需要某个参数</p>
<p><strong>将该参数去除</strong></p>
<p>参数列表越短越好</p>
<h3 id="4-将查询函数和修改函数分离：separate-query-from-modifier"><a href="#4-将查询函数和修改函数分离：separate-query-from-modifier" class="headerlink" title="4.将查询函数和修改函数分离：separate query from modifier"></a>4.将查询函数和修改函数分离：separate query from modifier</h3><p>问题：某个函数既返回对象状态值，又修改对象状态</p>
<p><strong>建立两个不同的函数，其中一个负责查询，另一个负责修改</strong></p>
<p>换句话说就是消除函数的副作用，之后可以任意调用</p>
<h3 id="5-令函数携带参数：parameterize-method"><a href="#5-令函数携带参数：parameterize-method" class="headerlink" title="5.令函数携带参数：parameterize method"></a>5.令函数携带参数：parameterize method</h3><p>问题：若干函数做了类似的工作，但在函数本体中却包含了不同的值</p>
<p><strong>建立单一函数，以参数表达那些不同的值</strong></p>
<p>该重构重点在于：以“可将少量数值视为参数”为依据，找出带有重复性的代码</p>
<h3 id="6-已明确函数取代参数：replace-parameter-with-explicit-methods"><a href="#6-已明确函数取代参数：replace-parameter-with-explicit-methods" class="headerlink" title="6.已明确函数取代参数：replace parameter with explicit methods"></a>6.已明确函数取代参数：replace parameter with explicit methods</h3><p>问题：你有一个函数，其中完全取决于参数值而采取不同的行为</p>
<p><strong>针对改参数的每一个可能值，建立一个独立函数</strong></p>
<h3 id="7-保持对象完整：preserve-whole-object"><a href="#7-保持对象完整：preserve-whole-object" class="headerlink" title="7.保持对象完整：preserve whole object"></a>7.保持对象完整：preserve whole object</h3><p>问题：你从若干个对象中取出若干值，将它们作为某一次函数调用时的参数</p>
<p><strong>改为传递整个对象</strong></p>
<h3 id="8-以函数取代参数：replace-parameter-with-methods"><a href="#8-以函数取代参数：replace-parameter-with-methods" class="headerlink" title="8.以函数取代参数：replace parameter with methods"></a>8.以函数取代参数：replace parameter with methods</h3><p>问题：对象调用某个函数，并将所得结果作为参数，传递给另一个函数，而接受该参数的函数本身也能调用前一个函数</p>
<p><strong>让参数接受者去除该项参数，并直接调用前一个函数</strong></p>
<p>缩短参数列的办法之一就是：看看参数接受端是否可以通过与调用端相同的计算来去的参数值</p>
<h3 id="9-引入参数对象：introduce-parameter-object"><a href="#9-引入参数对象：introduce-parameter-object" class="headerlink" title="9.引入参数对象：introduce parameter object"></a>9.引入参数对象：introduce parameter object</h3><p>问题：某些参数总是很自然的同时出现</p>
<p><strong>以一个对象取代这些参数</strong></p>
<p>本项重构的价值在于缩短参数列</p>
<h3 id="10-移除设置函数：remove-setting-method"><a href="#10-移除设置函数：remove-setting-method" class="headerlink" title="10.移除设置函数：remove setting method"></a>10.移除设置函数：remove setting method</h3><p>问题：类中的某个字段应该在对象创建时被设值，然后就不在改变</p>
<p><strong>去掉该字段的所有设值函数</strong></p>
<h3 id="11-隐藏函数：hide-method"><a href="#11-隐藏函数：hide-method" class="headerlink" title="11.隐藏函数：hide method"></a>11.隐藏函数：hide method</h3><p>问题：有一个函数，从来没有被其他任何类用到</p>
<p><strong>将这个函数修改为private</strong></p>
<p>尽可能降低所有函数的可见度</p>
<h3 id="12-以工厂函数取代构造函数：replace-construct-with-factory-method"><a href="#12-以工厂函数取代构造函数：replace-construct-with-factory-method" class="headerlink" title="12.以工厂函数取代构造函数：replace construct with factory method"></a>12.以工厂函数取代构造函数：replace construct with factory method</h3><p>问题：你希望在创建对象时不仅仅是做简单的建构动作</p>
<p><strong>将构造函数替换为工厂函数</strong></p>
<p>本项重构动机：就是在派生子类的过程中以工厂函数取代类型码</p>
<h3 id="13-封装向下转型：encapsulate-downcast"><a href="#13-封装向下转型：encapsulate-downcast" class="headerlink" title="13.封装向下转型：encapsulate downcast"></a>13.封装向下转型：encapsulate downcast</h3><p>问题：某个函数返回的对象，需要由函数调用者执行向下转型</p>
<p><strong>将向下转型动作移到函数中</strong></p>
<p>需要转型的情况通常在返回迭代器或是集合的时候发生，这个时候应该根据用途，有针对性的提供专用函数</p>
<h3 id="14-以异常取代错误码：replace-error-code-with-exception"><a href="#14-以异常取代错误码：replace-error-code-with-exception" class="headerlink" title="14.以异常取代错误码：replace error code with exception"></a>14.以异常取代错误码：replace error code with exception</h3><p>问题：某个函数返回一个特定的代码，用以表示某种错误情况</p>
<p><strong>改用异常</strong></p>
<p>非受控异常：表示：应该由调用者负责检查。非受控异常一般是运行时异常</p>
<p>受控异常：表示：在当前方法中检查，受控异常一般是自己定义的异常</p>
<h3 id="15-以异常取代测试"><a href="#15-以异常取代测试" class="headerlink" title="15.以异常取代测试"></a>15.以异常取代测试</h3><p>问题：面对一个调用者可以预先检查的条件，你抛出了一个异常</p>
<p><strong>修改调用者，使他在调用函数之前先做检查</strong></p>
<p>异常 应该用于产生意料之外的行为，而不应该成为条件的替代品。</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：十五.总结</title>
    <url>/2018/08/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%81%E4%BA%94-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>重构的技术只是个开始：因为还不知道何时应该使用它们、何时不应该使用；何时开始、何时停止；何时前进、何时等待。使重构能够成功的，不是前面各自独立的技术，而是这种<strong>节奏</strong></p>
<p>掌握重构：<strong>你可以自信的停止重构</strong></p>
<span id="more"></span>

<p>重构是一种可以学习的技术，如何学习：</p>
<ul>
<li>随时挑一个目标</li>
<li>没把握就停下来</li>
<li>学习原路返回</li>
<li>二重奏（就是和别人一起）</li>
</ul>
<p>当你面前的代码看起来乱极了的时候，不要着急，重构要一点一点的来，慢慢解决这些问题，当添加新功能的时候，先梳理。如果在添加新代码之前进行重构，那么添加新代码的风险将大大降低（重构可以让你更好的理解代码的使用和工作方式）</p>
<p>永远不要忘记“两顶帽子”（将增加功能和重构分开），重构时你的目标之一就是保持代码的功能完全不变，既不多也不少！</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：十二.大型重构</title>
    <url>/2018/08/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%81%E4%BA%8C-%E5%A4%A7%E5%9E%8B%E9%87%8D%E6%9E%84/</url>
    <content><![CDATA[<h3 id="1-梳理并分解继承体系：tease-apart-inheritance"><a href="#1-梳理并分解继承体系：tease-apart-inheritance" class="headerlink" title="1.梳理并分解继承体系：tease apart inheritance"></a>1.梳理并分解继承体系：tease apart inheritance</h3><p>问题：某个继承体系同时承担两项责任</p>
<p><strong>建立两个集成体系，并通过委托关系让其中一个可以调用调用另一个</strong></p>
<span id="more"></span>

<h3 id="2-将过程化设计转化为对象设计-：convert-procedural-design-to-objects"><a href="#2-将过程化设计转化为对象设计-：convert-procedural-design-to-objects" class="headerlink" title="2.将过程化设计转化为对象设计 ：convert procedural design to objects"></a>2.将过程化设计转化为对象设计 ：convert procedural design to objects</h3><p>问题：你手上有一些传统过程化风格的代码</p>
<p><strong>将数据记录变成对象，将大块的行为分成小块，并将行为移入相关对象之中</strong></p>
<h3 id="3-将领域和表述-显示分离：-separate-domain-from-presentation"><a href="#3-将领域和表述-显示分离：-separate-domain-from-presentation" class="headerlink" title="3.将领域和表述/显示分离： separate domain from presentation"></a>3.将领域和表述/显示分离： separate domain from presentation</h3><p>问题：某些GUI类之中包含了领域逻辑</p>
<p><strong>将领域逻辑分离出来，为他们建立独立的领域类</strong></p>
<h3 id="4-提炼继承体系：extract-hierarchy"><a href="#4-提炼继承体系：extract-hierarchy" class="headerlink" title="4.提炼继承体系：extract hierarchy"></a>4.提炼继承体系：extract hierarchy</h3><p>问题：你有某个类做了太多工作，其中一部分工作是以大量条件表达式完成的</p>
<p><strong>建立继承体系，以一个子类表示一种特殊情况</strong></p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：十一.处理概括关系</title>
    <url>/2018/08/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%81%E4%B8%80-%E5%A4%84%E7%90%86%E6%A6%82%E6%8B%AC%E5%85%B3%E7%B3%BB/</url>
    <content><![CDATA[<h3 id="1-字段上移：pull-up-field"><a href="#1-字段上移：pull-up-field" class="headerlink" title="1.字段上移：pull up field"></a>1.字段上移：pull up field</h3><p>问题：两个子类拥有相同的字段</p>
<p><strong>将该字段移至超类</strong></p>
<span id="more"></span>

<h3 id="2-函数上移：pull-up-method"><a href="#2-函数上移：pull-up-method" class="headerlink" title="2.函数上移：pull up method"></a>2.函数上移：pull up method</h3><p>问题：有些函数，在各个子类中产生完全相同的结果</p>
<p><strong>将该函数移至超类</strong></p>
<p>有一种特殊特殊情况也需要上诉重构：子类的方法覆写了超类的函数，却仍然做相同的工作</p>
<h3 id="3-构造函数本体上移：pull-up-constructor-body"><a href="#3-构造函数本体上移：pull-up-constructor-body" class="headerlink" title="3.构造函数本体上移：pull up constructor body"></a>3.构造函数本体上移：pull up constructor body</h3><p>问题：你在各个子类中拥有一些构造函数，他们的本体几乎完全一致</p>
<p><strong>在超类中新建一个构造函数，并在子类构造函数中调用它</strong></p>
<h3 id="4-函数下移：push-down-method"><a href="#4-函数下移：push-down-method" class="headerlink" title="4.函数下移：push down method"></a>4.函数下移：push down method</h3><p>问题：超类中的某个函数只与部分（而非全部）子类有关</p>
<p><strong>将这个函数移到相关的那些子类去</strong></p>
<h3 id="5-字段下移：push-down-field"><a href="#5-字段下移：push-down-field" class="headerlink" title="5.字段下移：push down field"></a>5.字段下移：push down field</h3><p>问题：超类中的某个字段只被部分（而非全部）子类用到</p>
<p><strong>将这个字段移到需要它的那些子类去</strong></p>
<h3 id="6-提炼子类：extract-subclass"><a href="#6-提炼子类：extract-subclass" class="headerlink" title="6.提炼子类：extract subclass"></a>6.提炼子类：extract subclass</h3><p>问题：类中的某些特性只被某些（而非全部）实例用到</p>
<p><strong>新建一个子类，将上面所说的那一部分特性移到子类中</strong></p>
<h3 id="7-提炼超类：extract-superclass"><a href="#7-提炼超类：extract-superclass" class="headerlink" title="7.提炼超类：extract superclass"></a>7.提炼超类：extract superclass</h3><p>问题：两个类有相似特性</p>
<p><strong>为这两个类建立一个超类，将相同特性移至超类</strong></p>
<h3 id="8-提炼接口：extract-interface"><a href="#8-提炼接口：extract-interface" class="headerlink" title="8.提炼接口：extract interface"></a>8.提炼接口：extract interface</h3><p>问题：若干客户使用类接口中的同一子集，或者两个类的接口有部分相同</p>
<p><strong>将相同的子集提炼到一个独立接口中</strong></p>
<h3 id="9-折叠继承体系：collapse-hierarchy"><a href="#9-折叠继承体系：collapse-hierarchy" class="headerlink" title="9.折叠继承体系：collapse hierarchy"></a>9.折叠继承体系：collapse hierarchy</h3><p>问题：超类和子类之间无太大区别</p>
<p><strong>将它们合为一体</strong></p>
<h3 id="10-塑造模板函数：from-template-method"><a href="#10-塑造模板函数：from-template-method" class="headerlink" title="10.塑造模板函数：from template method"></a>10.塑造模板函数：from template method</h3><p>问题：你有一些子类，其中相应的某些函数以相同顺序执行类似操作，但各个操作的细节上有所不同</p>
<p><strong>将这些操作分别放进独立函数中，并保持他们都有相同的签名，于是原函数也就变得相同了，然后将原函数上移至超类</strong></p>
<p>模板函数：将执行的序列移至超类，并借助多态保证和操作仍然得以保持差异性，这样的函数被称为模板函数</p>
<h3 id="11-以委托取代继承：replace-inheritance-with-delegation"><a href="#11-以委托取代继承：replace-inheritance-with-delegation" class="headerlink" title="11.以委托取代继承：replace inheritance with delegation"></a>11.以委托取代继承：replace inheritance with delegation</h3><p>问题：某个子类只使用超类接口中的一部分，或是根本不需要继承而来的数据</p>
<p><strong>在子类中新建一个字段用以保存超类，调整子类函数，令他改而委托超类，然后去掉两者之间的继承关系</strong></p>
<h3 id="12-以继承取代委托：replace-delegation-with-inheritance"><a href="#12-以继承取代委托：replace-delegation-with-inheritance" class="headerlink" title="12.以继承取代委托：replace delegation with inheritance"></a>12.以继承取代委托：replace delegation with inheritance</h3><p>问题：你在两个类之间使用委托关系，并经常为整个接口编写许多极简单的委托函数</p>
<p><strong>让委托类继承受托类</strong></p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：十四.重构工具</title>
    <url>/2018/08/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%81%E5%9B%9B-%E9%87%8D%E6%9E%84%E5%B7%A5%E5%85%B7/</url>
    <content><![CDATA[<p>重构工具：</p>
<ul>
<li>重构工具最主要的用途就是让程序员可以不必重新测试，便能对代码进行重构</li>
<li>重构工具的最重要要求就是：和其他工具共同集成出重构过程（例如IntelliJ）</li>
</ul>
<p>要想控制软件项目演化过程中产生的复杂度，使用自动化重构工具是最好的办法</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：十三.重构、复用与现实</title>
    <url>/2018/08/12/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%8D%81%E4%B8%89-%E9%87%8D%E6%9E%84%E3%80%81%E5%A4%8D%E7%94%A8%E4%B8%8E%E7%8E%B0%E5%AE%9E/</url>
    <content><![CDATA[<p>1.<strong>重构只是一种手段，不是目的</strong></p>
<span id="more"></span>

<p>2.安全的重构：所谓安全的重构就是不会对程序造成破坏的重构</p>
<p>3.现实是很多人不会也不愿意花时间是重构，重构不是停止开发，全部重构，而是一点一点的重构</p>
<p>4.复用和重构一样，要实现比较困难，原因差不多是：</p>
<ul>
<li>不会，不知道如何重构、不知道如何复用</li>
<li>带采用复用方法和重构缺乏动力，除非能获得短期效益</li>
<li>要考虑成本，开销，学习路线</li>
<li>遗留项目的阻力</li>
</ul>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>重构-改善既有代码的设计：四.构筑测试体系</title>
    <url>/2018/08/03/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E9%87%8D%E6%9E%84,%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1/%E9%87%8D%E6%9E%84-%E6%94%B9%E5%96%84%E6%97%A2%E6%9C%89%E4%BB%A3%E7%A0%81%E7%9A%84%E8%AE%BE%E8%AE%A1%EF%BC%9A%E5%9B%9B-%E6%9E%84%E7%AD%91%E6%B5%8B%E8%AF%95%E4%BD%93%E7%B3%BB/</url>
    <content><![CDATA[<p><strong>重构的前提：</strong></p>
<p>拥有一个<strong>可靠</strong>的测试环境！！！</p>
]]></content>
      <tags>
        <tag>《重构,改善既有代码的设计》</tag>
      </tags>
  </entry>
  <entry>
    <title>创建型模式</title>
    <url>/2018/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h3><p>​    创建型模式(Creational Pattern)对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离。为了使软件的结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚其具体的实现细节，使整个系统的设计更加符合单一职责原则。</p>
<span id="more"></span>

<p>​    创建型模式在创建什么(What)，由谁创建(Who)，何时创建(When)等方面都为软件设计者提供了尽可能大的灵活性。创建型模式隐藏了类的实例的创建细节，通过隐藏对象如何被创建和组合在一起达到使整个系统独立的目的。</p>
<blockquote>
<p>维基百科：</p>
<p>​       定义：创建型模式旨在将系统与它的对象创建、结合、表示的方式分离。这些设计模式在对象创建的类型、主体、方式、时间等方面提高了系统的灵活性。</p>
<p>​    在软件工程中，<strong>创建型模式</strong>是处理对象创建的设计模式，试图根据实际情况使用合适的方式创建对象。基本的对象创建方式可能会导致设计上的问题，或增加设计的复杂度。创建型模式通过以某种方式控制对象的创建来解决问题。</p>
<p>创建型模式由两个主导思想构成。一是将系统使用的具体类封装起来，二是隐藏这些具体类的实例创建和结合的方式。</p>
<p>​    创建型模式又分为对象创建型模式和类创建型模式。对象创建型模式处理对象的创建，类创建型模式处理类的创建。详细地说，对象创建型模式把对象创建的一部分推迟到另一个对象中，而类创建型模式将它对象的创建推迟到子类中</p>
</blockquote>
<p><strong>包含模式</strong></p>
<ul>
<li><a href="http://zhangyuying.cn/2018/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/">简单工厂模式（Simple Factory）</a></li>
<li><a href="http://zhangyuying.cn/2018/08/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">工厂方法模式（Factory Method）</a></li>
<li><a href="http://zhangyuying.cn/2018/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/#more">抽象工厂模式（Abstract Factory）</a></li>
<li><a href="http://zhangyuying.cn/2018/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/">建造者模式（Builder）</a></li>
<li><a href="http://zhangyuying.cn/2018/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/">原型模式（Prototype）</a></li>
<li><a href="http://zhangyuying.cn/2018/08/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/">单例模式（Singleton）</a></li>
</ul>
<p>参考资料：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F">https://zh.wikipedia.org/wiki/%E5%89%B5%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F</a></p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/creational.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>单例模式</title>
    <url>/2018/08/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="单例模式-Singleton-Pattern"><a href="#单例模式-Singleton-Pattern" class="headerlink" title="单例模式( Singleton Pattern)"></a>单例模式( Singleton Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点</p>
<p>单例模式又名单件模式或单态模式。</p>
<p>属于：<strong>创建型模式</strong> </p>
<span id="more"></span>

<blockquote>
<p>单例模式的要点有三个：</p>
<p>一是某个类只能有一个实例；</p>
<p>二是它必须自行创建这个实例；</p>
<p>三是它必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</p>
</blockquote>
<h5 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="单例模式结构图"></p>
<p>单例模式角色：</p>
<p>　　◊  Singleton：单例</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</p>
<p>在单例模式的实现过程中，需要注意如下三点：</p>
<ul>
<li>单例类的构造函数为私有；</li>
<li>提供一个自身的静态私有成员变量；</li>
<li>提供一个公有的静态工厂方法。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong>：　</p>
<ul>
<li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li>
<li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li>
<li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li>
<li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li>
<li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<p>在以下情况下可以使用单例模式：</p>
<ul>
<li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li>
<li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li>
<li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。</li>
<li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li>
<li>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，该模式中包含一个静态私有成员变量与静态公有的工厂方法。该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。</li>
<li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li>
<li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1.饿汉式</span></span><br><span class="line">       <span class="comment">//        依赖 JVM类加载机制，保证单例只会被创建1次，即 线程安全</span></span><br><span class="line">       <span class="comment">//        (1)JVM在类的初始化阶段(即 在Class被加载后、被线程使用前)，会执行类的初始化</span></span><br><span class="line">       <span class="comment">//        (2)在执行类的初始化期间，JVM会去获取一个锁。这个锁可以同步多个线程对同一个类的初始化</span></span><br><span class="line">       eagerlyInitializedSingleton();</span><br><span class="line">       <span class="comment">//2.枚举实现单例类</span></span><br><span class="line">       <span class="comment">//        枚举是可以根据自己特性阻止通过反射获取到私有构造方法从而实例化（实现单例类的方法中唯一可以阻止反射的，</span></span><br><span class="line">       <span class="comment">//        其余方式想要阻止反射，可以设置标志位，具体不在此陈述）</span></span><br><span class="line">       <span class="comment">//        根据枚举类型的特点，满足单例模式所需的 创建单例、线程安全、实现简洁的需求</span></span><br><span class="line">       enumInitializedSingleton();</span><br><span class="line">       <span class="comment">//3.懒汉式-基础实现</span></span><br><span class="line">       <span class="comment">//        不是线程安全的</span></span><br><span class="line">       lazilyBasicInitializedSingleton();</span><br><span class="line">       <span class="comment">//4.懒汉式-同步锁</span></span><br><span class="line">       <span class="comment">//        缺点:每次访问都要进行线程同步（即 调用synchronized锁)，造成过多的同步开销（加锁 = 耗时、耗能）</span></span><br><span class="line">       <span class="comment">//        实际上只需在第1次调用该方法时才需要同步，一旦单例创建成功后，就没必要进行同步</span></span><br><span class="line">       lazilyLockInitializedSingleton();</span><br><span class="line">       <span class="comment">//5.懒汉式-双重校验锁</span></span><br><span class="line">       <span class="comment">//        缺点:实现复杂 = 多种判断，易出错</span></span><br><span class="line">       lazilyDoubleCheckInitializedSingleton();</span><br><span class="line">       <span class="comment">//6.静态内部类</span></span><br><span class="line">       <span class="comment">//        原理：根据 静态内部类 的特性，同时解决了按需加载、线程安全的问题，同时实现简洁</span></span><br><span class="line">       <span class="comment">//        （1）在静态内部类里创建单例，在装载该内部类时才会去创建单例</span></span><br><span class="line">       <span class="comment">//        （2）线程安全：类是由 JVM加载，而JVM只会加载1遍，保证只有1个单例</span></span><br><span class="line">       InternalClassInitializedSingleton();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">eagerlyInitializedSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//1.饿汉式</span></span><br><span class="line">       EagerlySingleton eagerlySingleton1 = EagerlySingleton.getInstance();</span><br><span class="line">       EagerlySingleton eagerlySingleton2 = EagerlySingleton.getInstance();</span><br><span class="line">       eagerlySingleton1.sayHello();</span><br><span class="line">       <span class="comment">//正常获取</span></span><br><span class="line">       System.out.println(eagerlySingleton1);</span><br><span class="line">       System.out.println(eagerlySingleton2);</span><br><span class="line">       <span class="comment">//非正常方式(可通过反射获取到私有构造方法从而实例化)</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           Class eagerlySingletonClass = Class.forName(<span class="string">&quot;cn.zhangyuying.designpattern.singleton.singleton.EagerlySingleton&quot;</span>);</span><br><span class="line">           Constructor eagerlySingletonBuilder = eagerlySingletonClass.getDeclaredConstructor();</span><br><span class="line">           eagerlySingletonBuilder.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">           EagerlySingleton eagerlySingleton = (EagerlySingleton) (eagerlySingletonBuilder.newInstance());</span><br><span class="line">           System.out.println(eagerlySingleton);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           logger.error(<span class="string">&quot;&quot;</span>, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">enumInitializedSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//2.枚举实现单例类</span></span><br><span class="line">       EnumSingleton enumSingleton1 = EnumSingleton.instance;</span><br><span class="line">       EnumSingleton enumSingleton2 = EnumSingleton.instance;</span><br><span class="line">       enumSingleton1.sayHello();</span><br><span class="line">       System.out.println(enumSingleton1);</span><br><span class="line">       System.out.println(enumSingleton2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazilyBasicInitializedSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//3.懒汉式-基础实现</span></span><br><span class="line">       LazilyBasicSingleton lazilyBasicSingleton1 = LazilyBasicSingleton.getInstance();</span><br><span class="line">       LazilyBasicSingleton lazilyBasicSingleton2 = LazilyBasicSingleton.getInstance();</span><br><span class="line">       lazilyBasicSingleton1.sayHello();</span><br><span class="line">       System.out.println(lazilyBasicSingleton1);</span><br><span class="line">       System.out.println(lazilyBasicSingleton2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazilyLockInitializedSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//4.懒汉式-同步锁</span></span><br><span class="line">       LazilyLockSingleton lazilyLockSingleton1 = LazilyLockSingleton.getInstance();</span><br><span class="line">       LazilyLockSingleton lazilyLockSingleton2 = LazilyLockSingleton.getInstance();</span><br><span class="line">       lazilyLockSingleton1.sayHello();</span><br><span class="line">       System.out.println(lazilyLockSingleton1);</span><br><span class="line">       System.out.println(lazilyLockSingleton2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">lazilyDoubleCheckInitializedSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//5.懒汉式-双重校验锁</span></span><br><span class="line">       LazilyDoubleCheckSingleton lazilyDoubleCheckSingleton1 = LazilyDoubleCheckSingleton.getInstance();</span><br><span class="line">       LazilyDoubleCheckSingleton lazilyDoubleCheckSingleton2 = LazilyDoubleCheckSingleton.getInstance();</span><br><span class="line">       lazilyDoubleCheckSingleton1.sayHello();</span><br><span class="line">       System.out.println(lazilyDoubleCheckSingleton1);</span><br><span class="line">       System.out.println(lazilyDoubleCheckSingleton2);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">InternalClassInitializedSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">//6.静态内部类</span></span><br><span class="line">       InternalClassSingleton internalClassSingleton1 = InternalClassSingleton.getInstance();</span><br><span class="line">       InternalClassSingleton internalClassSingleton2 = InternalClassSingleton.getInstance();</span><br><span class="line">       System.out.println(internalClassSingleton1);</span><br><span class="line">       System.out.println(internalClassSingleton2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>单例类的具体实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.饿汉式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EagerlySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> EagerlySingleton instance = <span class="keyword">new</span> EagerlySingleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">EagerlySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EagerlySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//2.枚举实现单例类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">EnumSingleton</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义1个枚举的元素，即为单例类的1个实例</span></span><br><span class="line">    instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐藏了1个空的、私有的 构造方法</span></span><br><span class="line">    <span class="comment">// private Singleton () &#123;&#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getDeclaringClass().getCanonicalName() + <span class="string">&quot;@&quot;</span> + hashCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//3.懒汉式-基础实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazilyBasicSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazilyBasicSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazilyBasicSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazilyBasicSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazilyBasicSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//4.懒汉式-同步锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazilyLockSingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazilyLockSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazilyLockSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazilyLockSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazilyLockSingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="comment">//5.懒汉式-双重校验锁</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazilyDoubleCheckSingleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//volatile，可以保证指令重排</span></span><br><span class="line">    <span class="comment">//    意义：主要在于 instance = new Singleton() 这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。</span></span><br><span class="line">    <span class="comment">//    1.给 instance 分配内存</span></span><br><span class="line">    <span class="comment">//    2.调用 Singleton 的构造函数来初始化成员变量</span></span><br><span class="line">    <span class="comment">//    3.将 instance 对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</span></span><br><span class="line">    <span class="comment">//    但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，</span></span><br><span class="line">    <span class="comment">// 最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，</span></span><br><span class="line">    <span class="comment">// 这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。</span></span><br><span class="line">    <span class="comment">//volatile，可以保证指令重排</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazilyDoubleCheckSingleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazilyDoubleCheckSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazilyDoubleCheckSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (LazilyDoubleCheckSingleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> LazilyDoubleCheckSingleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6.静态内部类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InternalClassSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">InternalClassSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> InternalClassSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Internal.instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Internal</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> InternalClassSingleton instance = <span class="keyword">new</span> InternalClassSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/singleton.html</a></p>
<p><a href="https://www.jianshu.com/p/b8c578b07fbc">https://www.jianshu.com/p/b8c578b07fbc</a></p>
<p><a href="https://www.jianshu.com/p/5fffd190c8e0">https://www.jianshu.com/p/5fffd190c8e0</a></p>
<p><a href="https://my.oschina.net/swearyd7/blog/167822">https://my.oschina.net/swearyd7/blog/167822</a></p>
<p><a href="http://blademastercoder.github.io/2015/01/29/java-Serializable.html">http://blademastercoder.github.io/2015/01/29/java-Serializable.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>工厂方法模式</title>
    <url>/2018/08/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="工厂方法模式-Factorty-Method-Pattern"><a href="#工厂方法模式-Factorty-Method-Pattern" class="headerlink" title="工厂方法模式( Factorty Method Pattern)"></a>工厂方法模式( Factorty Method Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>工厂方法模式（又称工厂模式）定义了一个用于创建对象的接口，让子类决定实例化哪一个类，工厂方法使一个类的实例化延迟到其子类</p>
<p>属于：<strong>创建型模式</strong> </p>
<span id="more"></span>

<p>理解：上面定义中，所谓的<strong>决定</strong>，并不是指模式允许子类本身在运行时做决定，而是在编写创建者类（Creator）时，不需要知道实际创建的产品是哪一个，选择了使用哪个子类，自然就决定了实际创建的产品是什么。</p>
<h5 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="工厂方法模式结构图"></p>
<p>工厂方法模式角色：</p>
<p>　　◊ <em>Product</em>：抽象产品类，将具体产品类公共的代码进行抽象和提取后封装在一个抽象产品类中。</p>
<p>　　◊ <em>ConcreteProduct</em>：具体产品类，将需要创建的各种不同产品对象的相关代码封装到具体产品类中。</p>
<p>　　◊ Creator：抽象工厂，  具体工厂的父类，描述具体工厂的公共接口</p>
<p>　　◊ <em>Concrete Creator</em>：具体工厂类，抽象工厂的子类；被外界调用，描述具体工厂；实现FactoryMethod工厂方法创建产品的实例。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong>：　</p>
<ul>
<li>一个调用者想创建一个对象，只要知道其名称就可以了 ，屏蔽产品的具体实现，调用者只关心产品的接口。</li>
</ul>
<ul>
<li>符合开-闭原则：新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可（扩展性高）</li>
<li>符合单一职责原则 ：每个具体工厂类只负责创建对应的产品</li>
<li>不使用静态工厂方法，可以形成基于继承的等级结构。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；</li>
<li>虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li>
<li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li>
<li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。</p>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码示例类图：</p>
<p><img src="https://raw.githubusercontent.com/ZhangYY-Smile/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="工厂方法代码示例类图"></p>
<p>client：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       sendSMSMessageTest();</span><br><span class="line">       sendWeChatMessageTest();</span><br><span class="line">       sendQQMessageTest();</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendSMSMessageTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       IMsgSendFactory msgSendFactory = <span class="keyword">new</span> SMSSendFactory();</span><br><span class="line">       IMsgSender msgSender = msgSendFactory.createMsgSender();</span><br><span class="line">       msgSender.sendMessage(messageContent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendWeChatMessageTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       IMsgSendFactory msgSendFactory = <span class="keyword">new</span> WechatSendFactory();</span><br><span class="line">       IMsgSender msgSender = msgSendFactory.createMsgSender();</span><br><span class="line">       msgSender.sendMessage(messageContent);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendQQMessageTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       IMsgSendFactory msgSendFactory = <span class="keyword">new</span> QQSendFactory();</span><br><span class="line">       IMsgSender msgSender = msgSendFactory.createMsgSender();</span><br><span class="line">       msgSender.sendMessage(messageContent);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>Creator：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgSendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">IMsgSender <span class="title">createMsgSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <em>Concrete Creator</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQSendFactory</span> <span class="keyword">implements</span> <span class="title">IMsgSendFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMsgSender <span class="title">createMsgSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QQSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSendFactory</span> <span class="keyword">implements</span> <span class="title">IMsgSendFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMsgSender <span class="title">createMsgSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SMSSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatSendFactory</span> <span class="keyword">implements</span> <span class="title">IMsgSendFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMsgSender <span class="title">createMsgSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeChatSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Product：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteProduct：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQSender</span> <span class="keyword">implements</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(QQSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;发送QQ消息！消息内容：%s&quot;</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender</span> <span class="keyword">implements</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SMSSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;发送短信消息！消息内容：%s&quot;</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatSender</span> <span class="keyword">implements</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WeChatSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;发送微信消息！消息内容：%s&quot;</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/factory_method.html</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/52343584">https://blog.csdn.net/carson_ho/article/details/52343584</a></p>
<p><a href="http://www.runoob.com/design-pattern/factory-pattern.html">http://www.runoob.com/design-pattern/factory-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>建造者模式</title>
    <url>/2018/11/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="建造者模式-BuilderPattern"><a href="#建造者模式-BuilderPattern" class="headerlink" title="建造者模式(BuilderPattern)"></a>建造者模式(BuilderPattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
<p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p>
<p>别名生成器模式</p>
<p>对象创建型模式</p>
<span id="more"></span>

<blockquote>
<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<p>封装产品的构造过程，并允许按步骤构造</p>
</blockquote>
<h5 id="建造者模式结构"><a href="#建造者模式结构" class="headerlink" title="建造者模式结构"></a>建造者模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="建造者模式结构图"></p>
<p>建造者模式角色：</p>
<p>​    ◊  Builder：抽象建造者</p>
<p>​    抽象建造者为创建一个产品对象的各个部件指定抽象接口；</p>
<p>​    ◊  ConcreteBuilder：具体建造者</p>
<p>​    具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对          象；</p>
<p>​    ◊  Director：指挥者：</p>
<p>​    指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</p>
<p>​    ◊  Product：产品角色：</p>
<p>​    产品角色是被构建的复杂对象，包含多个组成部件；</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>抽象建造者类中定义了产品的创建方法和返回方法;</p>
<p>建造者模式的结构中还引入了一个指挥者类Director，该类的作用主要有两个：</p>
<ul>
<li><p>一方面它隔离了客户与生产过程；</p>
</li>
<li><p>另一方面它负责控制产品的生成过程。</p>
<p>​</p>
</li>
</ul>
<p>指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象</p>
<p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>易于解耦<br>将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。</li>
<li>易于精确控制对象的创建<br>将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰</li>
<li>易于拓展<br>增加新的具体建造者无需修改原有类库的代码，易于拓展，符合“开闭原则“。</li>
</ul>
<blockquote>
<p>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。</p>
</blockquote>
<blockquote>
<p>建造者允许对象通过对个步骤来创建，并且可以改变过程（这和只有一个步骤的工厂模式不同）</p>
</blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li>
<li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li>
<li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li>
<li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li>
<li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>建造者模式的简化:<ul>
<li>省略抽象建造者角色：如果系统中只需要一个具体建造者的话，可以省略掉抽象建造者。</li>
<li>省略指挥者角色：在具体建造者只有一个的情况下，如果抽象建造者角色已经被省略掉，那么还可以省略指挥者角色，让Builder角色扮演指挥者与建造者双重角色。</li>
</ul>
</li>
<li>建造者模式与抽象工厂模式的比较:<ul>
<li>与抽象工厂模式相比， <strong>建造者模式返回一个组装好的完整产品</strong> ，而 <strong>抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</strong></li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li>
<li>如果将抽象工厂模式看成 <strong>汽车配件生产工厂</strong> ，生产一个产品族的产品，那么建造者模式就是一个 <strong>汽车组装工厂</strong> ，通过对部件的组装可以返回一辆完整的汽车。</li>
</ul>
</li>
<li>建造者模式与抽象工厂模式的比较:<ul>
<li>与抽象工厂模式相比， <strong>建造者模式返回一个组装好的完整产品</strong> ，而 <strong>抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</strong></li>
<li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li>
<li>如果将抽象工厂模式看成 <strong>汽车配件生产工厂</strong> ，生产一个产品族的产品，那么建造者模式就是一个 <strong>汽车组装工厂</strong> ，通过对部件的组装可以返回一辆完整的汽车。</li>
</ul>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="建造者模式代码示例类图"></p>
<p>两种方式：</p>
<ul>
<li>普通方式</li>
<li>内部类方式实现建造者（在messageBody中）</li>
</ul>
<p>普通方式：</p>
<p>Builder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildSender</span><span class="params">(String sender)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildSendMethod</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildReceiveMethod</span><span class="params">(String receiveMethod)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildReceiver</span><span class="params">(String receiver)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildContext</span><span class="params">(String context)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">MessageBody <span class="title">getMessageBody</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">IMsgBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageBody messageBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QQConcreteBuilder</span><span class="params">(MessageBody messageBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageBody = messageBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        messageBody.setSender(MsgContants.createDescribe(MsgContants.senderFormat, SendType.QQ, sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSendMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        messageBody.setSendType(MsgContants.createDescribe(MsgContants.senderTypeDescribe,  SendType.QQ));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildReceiveMethod</span><span class="params">(String receiveMethod)</span> </span>&#123;</span><br><span class="line">        messageBody.setReceiveMethod(MsgContants.createDescribe(MsgContants.receiveMethodFormat, SendType.QQ, receiveMethod));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        messageBody.setReceiver(MsgContants.createDescribe(MsgContants.receiverFormat, SendType.QQ, receiver));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        messageBody.setContext(MsgContants.createDescribe(MsgContants.contextFormat, SendType.QQ, context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageBody <span class="title">getMessageBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">IMsgBuilder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageBody messageBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SMSConcreteBuilder</span><span class="params">(MessageBody messageBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageBody = messageBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        messageBody.setSender(MsgContants.createDescribe(MsgContants.senderFormat, SendType.SMS.getDescribe(), sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSendMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        messageBody.setSendType(MsgContants.createDescribe(MsgContants.senderTypeDescribe, SendType.SMS.getDescribe()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildReceiveMethod</span><span class="params">(String receiveMethod)</span> </span>&#123;</span><br><span class="line">        messageBody.setReceiveMethod(MsgContants.createDescribe(MsgContants.receiveMethodFormat, <span class="string">&quot;手机&quot;</span>, receiveMethod));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        messageBody.setReceiver(MsgContants.createDescribe(MsgContants.receiverFormat, SendType.SMS.getDescribe(), receiver));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        messageBody.setContext(MsgContants.createDescribe(MsgContants.contextFormat, SendType.SMS.getDescribe(), context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageBody <span class="title">getMessageBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatConcreteBuilder</span> <span class="keyword">implements</span> <span class="title">IMsgBuilder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageBody messageBody;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeChatConcreteBuilder</span><span class="params">(MessageBody messageBody)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageBody = messageBody;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        messageBody.setSender(MsgContants.createDescribe(MsgContants.senderFormat, SendType.WECHAT.getDescribe(), sender));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildSendMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        messageBody.setSendType(MsgContants.createDescribe(MsgContants.senderTypeDescribe, SendType.WECHAT.getDescribe()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildReceiveMethod</span><span class="params">(String receiveMethod)</span> </span>&#123;</span><br><span class="line">        messageBody.setReceiveMethod(MsgContants.createDescribe(MsgContants.receiveMethodFormat, <span class="string">&quot;微信：&quot;</span>, receiveMethod));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        messageBody.setReceiver(MsgContants.createDescribe(MsgContants.receiverFormat, SendType.WECHAT.getDescribe(), receiver));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        messageBody.setContext(MsgContants.createDescribe(MsgContants.contextFormat, SendType.WECHAT.getDescribe(), context));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageBody <span class="title">getMessageBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messageBody;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> Director</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgDirector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MessageBody <span class="title">director</span><span class="params">(IMsgBuilder msgBuilder, String sender, String receiver, String receiveMethod, String context)</span> </span>&#123;</span><br><span class="line">        msgBuilder.buildContext(context);</span><br><span class="line">        msgBuilder.buildReceiveMethod(receiveMethod);</span><br><span class="line">        msgBuilder.buildReceiver(receiver);</span><br><span class="line">        msgBuilder.buildSender(sender);</span><br><span class="line">        msgBuilder.buildSendMethod();</span><br><span class="line">        <span class="keyword">return</span> msgBuilder.getMessageBody();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Product</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBody</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sendType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiveMethod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSendType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendType</span><span class="params">(String sendType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendType = sendType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiveMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiveMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiveMethod</span><span class="params">(String receiveMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiveMethod = receiveMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getSendType() + <span class="string">&quot;\n&quot;</span> + getSender() + <span class="string">&quot;\n&quot;</span> + getContext() + <span class="string">&quot;\n&quot;</span> + getReceiver() + <span class="string">&quot;\n&quot;</span> + getReceiveMethod() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageBody</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sendType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiveMethod;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String ext;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageBody</span><span class="params">(Builder builder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = builder.sender;</span><br><span class="line">        <span class="keyword">this</span>.sendType = builder.sendType;</span><br><span class="line">        <span class="keyword">this</span>.context = builder.context;</span><br><span class="line">        <span class="keyword">this</span>.receiveMethod = builder.receiveMethod;</span><br><span class="line">        <span class="keyword">this</span>.receiver = builder.receiver;</span><br><span class="line">        <span class="keyword">this</span>.ext = builder.ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSendType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendType</span><span class="params">(String sendType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendType = sendType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiveMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiveMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiveMethod</span><span class="params">(String receiveMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiveMethod = receiveMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getExt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setExt</span><span class="params">(String ext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ext = ext;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = getSendType() + <span class="string">&quot;\n&quot;</span> + getSender() + <span class="string">&quot;\n&quot;</span> + getContext() + <span class="string">&quot;\n&quot;</span> + getReceiver() + <span class="string">&quot;\n&quot;</span> + getReceiveMethod() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != getExt()) &#123;</span><br><span class="line">            result += getExt() + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String sender;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String sendType;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String context;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String receiveMethod;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String ext;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(String sendType, String sender, String context, String receiver, String receiveMethod)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sender = sender;</span><br><span class="line">            <span class="keyword">this</span>.context = context;</span><br><span class="line">            <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">            <span class="keyword">this</span>.receiveMethod = receiveMethod;</span><br><span class="line">            <span class="keyword">this</span>.sendType = sendType;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">withExt</span><span class="params">(String ext)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ext = ext;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> MessageBody <span class="title">buildMessageBody</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> MessageBody(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端对两种方式的调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuilderApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        buildQQMessage();</span><br><span class="line">        buildWechatMessage();</span><br><span class="line">        buildSMSMessage();</span><br><span class="line">        <span class="comment">//内部类实现的建造者</span></span><br><span class="line">        builderMessageByInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">builderMessageByInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MessageBody messageBody = <span class="keyword">new</span> MessageBody.Builder(SendType.QQ.getDescribe(), <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四请接收&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;123456&quot;</span>).withExt(<span class="string">&quot;这个消息是测试的&quot;</span>)</span><br><span class="line">                .buildMessageBody();</span><br><span class="line">        System.out.println(messageBody);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildSMSMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SMSConcreteBuilder smsBuilder = <span class="keyword">new</span> SMSConcreteBuilder(<span class="keyword">new</span> MessageBody());</span><br><span class="line">        MessageBody messageBody = MsgDirector.director(smsBuilder, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;发送短信消息的消息内容&quot;</span>);</span><br><span class="line">        System.out.println(messageBody.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildWechatMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        WeChatConcreteBuilder weChatBuilder = <span class="keyword">new</span> WeChatConcreteBuilder(<span class="keyword">new</span> MessageBody());</span><br><span class="line">        MessageBody messageBody = MsgDirector.director(weChatBuilder, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;发送微信消息的消息内容&quot;</span>);</span><br><span class="line">        System.out.println(messageBody.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildQQMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        QQConcreteBuilder qqBuilder = <span class="keyword">new</span> QQConcreteBuilder(<span class="keyword">new</span> MessageBody());</span><br><span class="line">        MessageBody messageBody = MsgDirector.director(qqBuilder, <span class="string">&quot;张三&quot;</span>, <span class="string">&quot;李四&quot;</span>, <span class="string">&quot;12345678&quot;</span>, <span class="string">&quot;发送QQ消息的消息内容&quot;</span>);</span><br><span class="line">        System.out.println(messageBody.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html">https://design-patterns.readthedocs.io/zh_CN/latest/creational_patterns/builder.html</a></p>
<p><a href="https://www.jianshu.com/p/be290ccea05a">https://www.jianshu.com/p/be290ccea05a</a></p>
<p><a href="https://www.cnblogs.com/Bobby0322/p/4182546.html">https://www.cnblogs.com/Bobby0322/p/4182546.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象工厂模式</title>
    <url>/2018/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="抽象工厂模式-Abstract-Factory-Pattern"><a href="#抽象工厂模式-Abstract-Factory-Pattern" class="headerlink" title="抽象工厂模式(Abstract Factory Pattern)"></a>抽象工厂模式(Abstract Factory Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>抽象工厂模式</p>
<p>1.提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</p>
<p>2.提供了一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类</p>
<p>属于： <strong>对象创建型模式</strong> </p>
<span id="more"></span>

<blockquote>
<p>抽象工厂模式与工厂方法模式最大的区别：抽象工厂中每个工厂可以创建多种类的产品；而工厂方法每个工厂只能创建一类</p>
</blockquote>
<p> <strong>概念</strong></p>
<p>为了更清晰地理解工厂方法模式，需要先引入两个概念：</p>
<ul>
<li><strong>产品等级结构</strong> ：产品等级结构即产品的继承结构，如一个抽象类是电视机，其子类有海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。</li>
<li><strong>产品族</strong> ：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品，如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中。</li>
</ul>
<h5 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="抽象工厂模式结构图"></p>
<p>工厂方法模式角色：</p>
<p>　　◊ <em>Product</em>：抽象产品类，具体产品的父类，描述具体产品的公共接口。</p>
<p>　　◊ <em>ConcreteProduct</em>：具体产品类，抽象产品的子类；工厂类创建的目标类 ，描述生产的具体产品。</p>
<p>　　◊ Creator(Fcatory)：抽象工厂，  具体工厂的父类，描述具体工厂的公共接口</p>
<p>　　◊ <em>Concrete Creator</em>(Concrete Factory)：具体工厂类，抽象工厂的子类；被外界调用，描述具体工厂；实现FactoryMethod工厂方法创建产品的实例。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>允许使用抽象的接口来创建一组相关产品，而不需要知道或关心实际生产出的具体产品是什么，这样就可以从具体产品中被解耦。</p>
<p>​    抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式则需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建 。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、有效率。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong>：　</p>
<ul>
<li>能够从多个产品族的多个产品中，简洁的获取想要的具体产品。解决了工厂模式中的不符合开闭原则的问题（增加新的产品时候，不修改工厂，而是增加工厂）。  </li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>产品族扩展比较困难，要增加一个系列的某一产品，要增加具体的产品类，还要增加对应的工厂类（或者修改对应产品族的工厂类）</li>
</ul>
<p>产品族难扩展，产品等级易扩展</p>
<blockquote>
<p>对于新的产品族符合开-闭原则；对于新的产品种类不符合开-闭原则，这一特性称为开-闭原则的倾斜性。</p>
</blockquote>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>一个系统不要求依赖产品类实例如何被创建、组合和表达的表达，这点也是所有工厂模式应用的前提。</li>
<li>这个系统有多个系列产品，而系统中只消费其中某一系列产品</li>
<li>系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现。</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码示例类图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="抽象工厂模式代码示例类图"></p>
<p>Creator：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgPlatformFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">IQQSender <span class="title">createQQSender</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">ISMSSender <span class="title">createSMSSender</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">IWeChatSender <span class="title">createWeChatSender</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <em>Concrete Creator</em> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedPlatformFactory</span> <span class="keyword">implements</span> <span class="title">IMsgPlatformFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IQQSender <span class="title">createQQSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomizedQQSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISMSSender <span class="title">createSMSSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomizedSMSSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWeChatSender <span class="title">createWeChatSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomizedWeChatSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnifiedPlatformFactory</span> <span class="keyword">implements</span> <span class="title">IMsgPlatformFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IQQSender <span class="title">createQQSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnifiedQQSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISMSSender <span class="title">createSMSSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnifiedSMSSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IWeChatSender <span class="title">createWeChatSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> UnifiedWeChatSender();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>Product</em> ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IQQSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendQQMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISMSSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSMSMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IWeChatSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendWeChatMessage</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> <em>ConcreteProduct</em>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedQQSender</span> <span class="keyword">implements</span> <span class="title">IQQSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CustomizedQQSender.class);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendQQMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(MsgContants.CUSTOMIZED_MESSAGE.replace(MsgContants.TYPE,MsgContants.QQ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedSMSSender</span> <span class="keyword">implements</span> <span class="title">ISMSSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CustomizedSMSSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSMSMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(MsgContants.CUSTOMIZED_MESSAGE.replace(MsgContants.TYPE, MsgContants.SMS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizedWeChatSender</span> <span class="keyword">implements</span> <span class="title">IWeChatSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CustomizedWeChatSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWeChatMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(MsgContants.CUSTOMIZED_MESSAGE.replace(MsgContants.TYPE, MsgContants.WECHAT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnifiedQQSender</span> <span class="keyword">implements</span> <span class="title">IQQSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(UnifiedQQSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendQQMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(MsgContants.UNIFIED_MESSAGE.replace(MsgContants.TYPE,MsgContants.QQ));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnifiedSMSSender</span> <span class="keyword">implements</span> <span class="title">ISMSSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(UnifiedSMSSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSMSMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(MsgContants.UNIFIED_MESSAGE.replace(MsgContants.TYPE, MsgContants.SMS));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnifiedWeChatSender</span> <span class="keyword">implements</span> <span class="title">IWeChatSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(UnifiedWeChatSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendWeChatMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(MsgContants.UNIFIED_MESSAGE.replace(MsgContants.TYPE, MsgContants.WECHAT));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/54910287">https://blog.csdn.net/carson_ho/article/details/54910287</a></p>
<p><a href="https://www.imooc.com/article/23795?block_id=tuijian_wz">https://www.imooc.com/article/23795?block_id=tuijian_wz</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>原型模式</title>
    <url>/2018/12/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="原型模式-Prototype-Pattern"><a href="#原型模式-Prototype-Pattern" class="headerlink" title="原型模式(Prototype Pattern)"></a>原型模式(Prototype Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。</p>
<p>对象的创建模式</p>
<span id="more"></span>

<blockquote>
<p>使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象</p>
<p>原型模式就是利用一个克隆”原型“来产生新对象的一种模式</p>
<p>克隆又分浅克隆与深克隆，（浅拷贝和深拷贝）</p>
<p>​    浅克隆：将一个对象复制后，基本数据类型的变量都会重新创建，而引用类型，指向的还是原对象所指向的。</p>
<p>​    深克隆：将一个对象复制后，不论是基本数据类型还有引用类型，都是重新创建的。简单来说，就是深复制进行了完全彻底的复制，而浅复制不彻底。</p>
</blockquote>
<h5 id="原型模式结构"><a href="#原型模式结构" class="headerlink" title="原型模式结构"></a>原型模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="原型模式结构图"></p>
<p>原型模式角色：</p>
<p>​    ◊   Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</p>
<p>​        ◊   ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</p>
<p>​        ◊   Client（客户类）：让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>​    原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p>
<p>​    原型模式要求对象实现一个可以“克隆”自身的接口，这样就可以通过复制一个实例对象本身来创建一个新的实例。这样一来，通过原型实例创建新的对象，就不再需要关心这个实例本身的类型，只要实现了克隆自身的方法，就可以通过这个方法来获取新的对象，而无须再去通过new来创建。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>如果创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。</li>
<li>可以使用深克隆保持对象的状态。</li>
<li>原型模式提供了简化的创建结构。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>在实现深克隆的时候可能需要比较复杂的代码。</li>
<li>需要为每一个类配备一个克隆方法，而且这个克隆方法需要对类的功能进行通盘考虑，这对全新的类来说不是很难，但对已有的类进行改造时，不一定是件容易的事，必须修改其源代码，违背了“开闭原则”。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li><p>如果创建新对象成本较大，我们可以利用已有的对象进行复制来获得。</p>
</li>
<li><p>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占内存不大的时候，也可以使用原型模式配合备忘录模式来应用。</p>
<p>相反，如果对象的状态变化很大，或者对象占用的内存很大，那么采用状态模式会比原型模式更好。 </p>
</li>
<li><p>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</p>
</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>原型模式向客户隐藏了创建对象的复杂性。客户只需要知道要创建对象的类型，然后通过请求就可以获得和该对象一模一样的新对象，无须知道具体的创建过程。</p>
</li>
<li><p>我们虽然可以利用原型模式来获得一个新对象，但有时对象的复制可能会相当的复杂，比如深克隆。</p>
</li>
<li><p>java Object中的clone()方法将对象复制了一份并返还给调用者。所谓“复制”的含义与clone()方法是怎么实现的。一般而言，clone()方法满足以下的描述：</p>
<ul>
<li>（1）对任何的对象x，都有：x.clone()!=x。换言之，克隆对象与原对象不是同一个对象。</li>
<li>（2）对任何的对象x，都有：x.clone().getClass() == x.getClass()，换言之，克隆对象与原对象的类型一样。</li>
<li>（3）如果对象x的equals()方法定义其恰当的话，那么x.clone().equals(x)应当成立的。</li>
</ul>
<blockquote>
<p>实现clone的Java类必须要实现一个接口:Cloneable.该接口表示该类能够复制且具体复制的能力，如果不实现该接口而直接调用clone()方法会抛出CloneNotSupportedException异常。</p>
</blockquote>
<blockquote>
<p> 在JAVA语言的API中，凡是提供了clone()方法的类，都满足上面的这些条件。JAVA语言的设计师在设计自己的clone()方法时，也应当遵守着三个条件。一般来说，上面的三个条件中的前两个是必需的，而第三个是可选的。</p>
</blockquote>
</li>
<li><p>原型模式有两种表现形式：（1）简单形式(一般来说包括上述描述的都是简单形式)、（2）登记形式，这两种表现形式仅仅是原型模式的不同实现。</p>
<ul>
<li><p>登记形式的原型模式结构：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-%E7%99%BB%E8%AE%B0%E5%BD%A2%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="登记形式的原型模式结构图"></p>
<p>作为原型模式的第二种形式，它多了一个 **原型管理器(<code>PrototypeManager</code>)**角色，该角色的作用是：创建具体原型类的对象，并记录每一个被创建的对象(可参照代码示例中<code>PrototypeManager</code> 的示例)。</p>
</li>
</ul>
<p>​</p>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="原型模式代码示例类图"></p>
<p>Prototype: <code>java</code>中使用<code>Object</code>（内部的<code>clone()</code>方法）</p>
<p>ConcretePrototype:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessagePrototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sendType;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessagePrototype <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        MessagePrototype messagePrototype = (MessagePrototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        <span class="keyword">return</span> messagePrototype;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;消息发送方式：&quot;</span> + sendType + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;消息内容：&quot;</span> + context + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;接收人信息：名称&quot;</span> + receiver.getName() + <span class="string">&quot;;联系方式：&quot;</span> + receiver.getPhone()</span><br><span class="line">                + <span class="string">&quot;\n&quot;</span> + <span class="string">&quot;------------------&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 利用序列化实现深度克隆</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassNotFoundException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessagePrototype <span class="title">deepClone</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">/* 写入当前对象的二进制流 */</span></span><br><span class="line">        ByteArrayOutputStream bos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(bos);</span><br><span class="line">        oos.writeObject(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 读出二进制流产生的新对象 */</span></span><br><span class="line">        ByteArrayInputStream bis = <span class="keyword">new</span> ByteArrayInputStream(bos.toByteArray());</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(bis);</span><br><span class="line">        <span class="keyword">return</span> (MessagePrototype) ois.readObject();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSendType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sendType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSendType</span><span class="params">(String sendType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendType = sendType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Receiver <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line"></span><br><span class="line">    String phone;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span><span class="params">(String name, String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPhone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> phone;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPhone</span><span class="params">(String phone)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.phone = phone;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p> Client（客户类）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> Receiver(<span class="string">&quot;zyy&quot;</span>, <span class="string">&quot;123456789&quot;</span>);</span><br><span class="line">        MessagePrototype messagePrototype = <span class="keyword">new</span> MessagePrototype();</span><br><span class="line">        messagePrototype.setContext(<span class="string">&quot;收到请回复&quot;</span>);</span><br><span class="line">        messagePrototype.setReceiver(receiver);</span><br><span class="line">        messagePrototype.setSendType(<span class="string">&quot;QQ&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;初始实例:&quot;</span>);</span><br><span class="line">        System.out.println(messagePrototype.toString());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//浅拷贝</span></span><br><span class="line">            MessagePrototype shallowCopyMsgPrototype = messagePrototype.clone();</span><br><span class="line">            shallowCopyMsgPrototype.getReceiver().setName(<span class="string">&quot;zyy1&quot;</span>);</span><br><span class="line">            shallowCopyMsgPrototype.getReceiver().setPhone(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;浅拷贝:&quot;</span>);</span><br><span class="line">            System.out.println(shallowCopyMsgPrototype.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//深拷贝</span></span><br><span class="line">            MessagePrototype deepCopyMsgPrototype = messagePrototype.deepClone();</span><br><span class="line">            deepCopyMsgPrototype.getReceiver().setName(<span class="string">&quot;zyy2&quot;</span>);</span><br><span class="line">            deepCopyMsgPrototype.getReceiver().setPhone(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">            System.out.println(<span class="string">&quot;深拷贝:&quot;</span>);</span><br><span class="line">            System.out.println(deepCopyMsgPrototype.toString());</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;初始实例:&quot;</span>);</span><br><span class="line">            System.out.println(messagePrototype.toString());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//登记形式的原型模式使用</span></span><br><span class="line">            PrototypeManager.setPrototype(<span class="string">&quot;zyy&quot;</span>, messagePrototype);</span><br><span class="line">            PrototypeManager.setPrototype(<span class="string">&quot;zyy1&quot;</span>, shallowCopyMsgPrototype);</span><br><span class="line">            PrototypeManager.setPrototype(<span class="string">&quot;zyy2&quot;</span>, deepCopyMsgPrototype);</span><br><span class="line">            System.out.println(PrototypeManager.getPrototype(<span class="string">&quot;zyy2&quot;</span>).toString());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PrototypeManager:</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrototypeManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来记录原型的编号和原型实例的对应关系</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, MessagePrototype&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私有化构造方法，避免外部创建实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PrototypeManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 向原型管理器里面添加或是修改某个原型注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototype    原型实例</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setPrototype</span><span class="params">(String prototypeId, MessagePrototype prototype)</span> </span>&#123;</span><br><span class="line">        map.put(prototypeId, prototype);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从原型管理器里面删除某个原型注册</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId 原型编号</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removePrototype</span><span class="params">(String prototypeId)</span> </span>&#123;</span><br><span class="line">        map.remove(prototypeId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取某个原型编号对应的原型实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> prototypeId    原型编号</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 原型编号对应的原型实例</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception    如果原型编号对应的实例不存在，则抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> MessagePrototype <span class="title">getPrototype</span><span class="params">(String prototypeId)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        MessagePrototype prototype = map.get(prototypeId);</span><br><span class="line">        <span class="keyword">if</span> (prototype == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;您希望获取的原型还没有注册或已被销毁&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://www.cnblogs.com/longhaolove/p/7847164.html">https://www.cnblogs.com/longhaolove/p/7847164.html</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html">https://www.cnblogs.com/java-my-life/archive/2012/04/11/2439387.html</a></p>
<p><a href="https://www.cnblogs.com/chenssy/p/3313339.html">https://www.cnblogs.com/chenssy/p/3313339.html</a></p>
<p><a href="https://blog.csdn.net/lovelion/article/details/7424559">https://blog.csdn.net/lovelion/article/details/7424559</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>简单工厂</title>
    <url>/2018/08/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%88%9B%E5%BB%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>简单工厂(Simple Factory)：又称为静态工厂方法(Static Factory Method)，它属于 <strong>类创建型模式</strong>。在简单工厂中，可以根据参数的不同返回不同类的实例。简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。</p>
<p>简单工厂其实不是一个设计模式，反而比较像是一种编程习惯（from 《Head First 设计模式》）</p>
<p>不属于23种GOF（4人组的《设计模式》）设计模式。</p>
<span id="more"></span>

<h5 id="模式结构："><a href="#模式结构：" class="headerlink" title="模式结构："></a>模式结构：</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="简单工厂结构图"></p>
<p>简单工厂模式角色：</p>
<p>　　◊ <em>Product</em>：抽象产品类，将具体产品类公共的代码进行抽象和提取后封装在一个抽象产品类中。</p>
<p>　　◊ <em>ConcreteProduct</em>：具体产品类，将需要创建的各种不同产品对象的相关代码封装到具体产品类中。</p>
<p>　　◊ <em>Factory</em>：工厂类，  是简单工厂模式的核心，提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入参数的不同创建不同的具体产品对象。</p>
<p>　　◊ <em>Client</em>：客户端类，只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><ul>
<li>将对象的创建和对象本身业务处理分离可以降低系统的耦合度，使得两者修改起来都相对容易。 </li>
</ul>
<ul>
<li>在调用工厂类的工厂方法时，由于工厂方法是静态方法，使用起来很方便，可通过类名直接调用，而且只需要传入一个简单的参数即可，在实际开发中，还可以在调用时将所传入的参数保存在XML等格式的配置文件中，修改参数时无须修改任何源代码。</li>
<li>简单工厂模式最大的问题在于 <strong>工厂类的职责相对过重，增加新的产品需要修改工厂类的判断逻辑，这一点与开闭原则是相违背的</strong>。</li>
<li>简单工厂模式的要点在于：当你需要什么，只需要传入一个正确的参数，就可以获取你所需要的对象，而无须知道其创建细节。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong>：　</p>
<ul>
<li> 实现创建和使用分离；</li>
<li> Client无需知道所创建的ConcreteProduct类名，只需要知道ConcreteProduct所对应的参数。</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li>Factory类集中所有ConcreteProduct的创建逻辑，职责过重。一旦需要添加新的ConcreteProduct，则需要修改Factory逻辑。这样<em>违背了OCP（开放-关闭原则）</em>。</li>
<li>由于使用了static方法，造成Factory无法形成基于继承的结构。</li>
</ul>
<p>这些缺点在<code>工厂方法模式</code>中得到了一定的克服。</p>
<p><strong>模式适用场景</strong></p>
<p>在以下情况下可以使用简单工厂模式：<br>工厂类负责创建的对象比较少：由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂。<br>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</p>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>简单工厂模式最大的优点在于实现对象的创建和对象的使用分离，将对象的创建交给专门的工厂类负责，</p>
<p>但是其最大的缺点在于工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，而且产品较多时，工厂方法代码将会非常复杂。</p>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码示例类图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="简单工厂代码示例类图"></p>
<p>外面调用工厂方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    sendSMSMessageTest();</span><br><span class="line">    sendWeChatMessageTest();</span><br><span class="line">    sendQQMessageTest();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendSMSMessageTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String smsMessage = <span class="string">&quot;测试发送短信消息&quot;</span>;</span><br><span class="line">    IMsgSender msgSender = MessageSendFactory.getSender(SendType.SMS);</span><br><span class="line">    msgSender.sendMessage(smsMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendWeChatMessageTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String weChatMessage = <span class="string">&quot;测试发送微信消息&quot;</span>;</span><br><span class="line">    IMsgSender msgSender = MessageSendFactory.getSender(SendType.WECHAT);</span><br><span class="line">    msgSender.sendMessage(weChatMessage);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendQQMessageTest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    String qqMessage = <span class="string">&quot;测试发送qq消息&quot;</span>;</span><br><span class="line">    IMsgSender msgSender = MessageSendFactory.getSender(SendType.QQ);</span><br><span class="line">    msgSender.sendMessage(qqMessage);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>工厂角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSendFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IMsgSender <span class="title">getSender</span><span class="params">(SendType type)</span> </span>&#123;</span><br><span class="line">        IMsgSender msgSender;</span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> QQ:</span><br><span class="line">                msgSender = <span class="keyword">new</span> QQSender();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WECHAT:</span><br><span class="line">                msgSender = <span class="keyword">new</span> WeChatSender();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SMS:</span><br><span class="line">                msgSender = <span class="keyword">new</span> SMSSender();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;发送的消息类型为空！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> msgSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>抽象产品角色(在示例中为消息的发送)：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体产品角色（具体发送的消息类别）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQSender</span> <span class="keyword">implements</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(QQSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;发送QQ消息！消息内容：%s&quot;</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender</span> <span class="keyword">implements</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SMSSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;发送短信消息！消息内容：%s&quot;</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatSender</span> <span class="keyword">implements</span> <span class="title">IMsgSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WeChatSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(<span class="string">&quot;发送微信消息！消息内容：%s&quot;</span>, message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>发送消息的类型：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SendType</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * qq类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    QQ(<span class="number">1</span>, <span class="string">&quot;qq消息&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 微信类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    WECHAT(<span class="number">2</span>, <span class="string">&quot;微信消息&quot;</span>),</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 短信类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SMS(<span class="number">3</span>, <span class="string">&quot;短信消息&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型的值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类型的描述信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String describe;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造函数</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value 类型值</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> describe 类型描述</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    SendType(<span class="keyword">int</span> value, String describe) &#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.describe = describe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>





<p>参考资料：</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="http://www.cnblogs.com/Bobby0322/p/4178412.html">http://www.cnblogs.com/Bobby0322/p/4178412.html</a></p>
<p><a href="https://www.cnblogs.com/libingql/p/3887577.html">https://www.cnblogs.com/libingql/p/3887577.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>享元模式</title>
    <url>/2018/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="享元模式-Flyweight-Pattern"><a href="#享元模式-Flyweight-Pattern" class="headerlink" title="享元模式(Flyweight Pattern)"></a>享元模式(Flyweight Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</p>
<p>又被称为蝇量模式，由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式</p>
<p>对象结构型模式。</p>
<span id="more"></span>

<blockquote>
<p>共享模式是支持大量细粒度对象的复用，所以享元模式要求能够共享的对象必须是细粒度对象。</p>
<p> 在了解享元模式之前我们先要了解两个概念：内部状态、外部状态。</p>
<p>​      内部状态：在享元对象内部不随外界环境改变而改变的共享部分。</p>
<p>​      外部状态：随着环境的改变而改变，不能够共享的状态就是外部状态。</p>
<p>即：内部状态存储于享元对象内部，而外部状态则应该由客户端来考虑。</p>
</blockquote>
<h5 id="享元模式结构"><a href="#享元模式结构" class="headerlink" title="享元模式结构"></a>享元模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="享元模式结构图"></p>
<p>享元模式角色：</p>
<p>​    ◊   Flyweight: 抽象享元类：</p>
<p> 抽象享元类。所有具体享元类的超类或者接口，通过这个接口，<code>Flyweight</code>可以接受并作用于外部专题 </p>
<p>​    ◊   ConcreteFlyweight: 具体享元类：</p>
<p>具体享元类。指定内部状态，为内部状态增加存储空间。 </p>
<p>​    ◊   UnsharedConcreteFlyweight: 非共享具体享元类：</p>
<p>非共享具体享元类。指出那些不需要共享的<code>Flyweight</code>子类。 </p>
<p>​    ◊   FlyweightFactory: 享元工厂类：</p>
<p>用来创建并管理<code>Flyweight</code>对象，它主要用来确保合理地共享<code>Flyweight</code>，当用户请求一个<code>Flyweigh</code>t时，<code>FlyweightFactory</code>就会提供一个已经创建的<code>Flyweight</code>对象或者新建一个（如果不存在）。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p>
<p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p>
<p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)。</p>
<ul>
<li>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。</li>
<li>外部状态是随环境改变而改变的、不可以共享的状态。 <strong>享元对象的外部状态必须由客户端保存</strong>，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>享元模式的优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。</li>
<li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>享元模式使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li>
<li>为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>享元模式在编辑器软件中大量使用，如在一个文档中多次出现相同的图片，则只需要创建一个图片对象，通过在应用程序中设置该图片出现的位置，可以实现该图片在不同地方多次重复显示。</p>
</li>
<li><p>单纯享元模式和复合享元模式</p>
<ul>
<li>单纯享元模式：在单纯享元模式中，所有的享元对象都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</li>
<li>复合享元模式：将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</li>
</ul>
</li>
<li><p>享元模式与其他模式的联用</p>
<ul>
<li>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</li>
<li>在一个系统中，通常只有唯一一个享元工厂，因此享元工厂类可以使用单例模式进行设计。</li>
<li>享元模式可以结合组合模式形成复合享元模式，统一对享元对象设置外部状态。</li>
</ul>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="享元模式代码示例类图"></p>
<p>Flyweight: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MsgFlyWeight</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    String MESSAGE_OUT_FORMAT = <span class="string">&quot;%s客户端，发送消息：%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * message 为外部状态</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message 消息内容</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteFlyweight: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQFlyWeight</span> <span class="keyword">implements</span> <span class="title">MsgFlyWeight</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(QQFlyWeight.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  内部状态 */</span></span><br><span class="line">    <span class="keyword">private</span> MsgType msgType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QQFlyWeight</span><span class="params">(MsgType msgType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgType = msgType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(MESSAGE_OUT_FORMAT, msgType.getDescribe(), message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSFlyWeight</span> <span class="keyword">implements</span> <span class="title">MsgFlyWeight</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SMSFlyWeight.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  内部状态 */</span></span><br><span class="line">    <span class="keyword">private</span> MsgType msgType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SMSFlyWeight</span><span class="params">(MsgType msgType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgType = msgType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(MESSAGE_OUT_FORMAT, msgType.getDescribe(), message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatFlyWeight</span> <span class="keyword">implements</span> <span class="title">MsgFlyWeight</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WeChatFlyWeight.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**  内部状态 */</span></span><br><span class="line">    <span class="keyword">private</span> MsgType msgType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeChatFlyWeight</span><span class="params">(MsgType msgType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgType = msgType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(String.format(MESSAGE_OUT_FORMAT, msgType.getDescribe(), message));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>FlyweightFactory: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MsgFlyWeightFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;MsgType, MsgFlyWeight&gt; flyWeightMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function">MsgFlyWeight <span class="title">getMsgClient</span><span class="params">(MsgType msgType)</span> </span>&#123;</span><br><span class="line">        MsgFlyWeight flyWeight = flyWeightMap.get(msgType);</span><br><span class="line">        <span class="keyword">if</span> (flyWeight != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> flyWeight;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">switch</span> (msgType) &#123;</span><br><span class="line">            <span class="keyword">case</span> QQ:</span><br><span class="line">                flyWeight = <span class="keyword">new</span> QQFlyWeight(msgType);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SMS:</span><br><span class="line">                flyWeight = <span class="keyword">new</span> SMSFlyWeight(msgType);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> WECHAT:</span><br><span class="line">                flyWeight = <span class="keyword">new</span> WeChatFlyWeight(msgType);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;传入的消息客户端类型不存在。&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        flyWeightMap.put(msgType, flyWeight);</span><br><span class="line">        <span class="keyword">return</span> flyWeight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAllFlyWeightSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> flyWeightMap.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightApplication</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_CONTEXT_FIRST = <span class="string">&quot;您有未读消息，请查收！&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_CONTEXT_SECOND = <span class="string">&quot;您有未读消息即将过时，请及时查收！&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(FlyweightApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(FlyweightApplication.class, args);</span><br><span class="line">        MsgFlyWeightFactory msgFlyWeightFactory = <span class="keyword">new</span> MsgFlyWeightFactory();</span><br><span class="line">        sendQQMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_FIRST);</span><br><span class="line">        sendWeChatMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_FIRST);</span><br><span class="line">        sendSMSMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_FIRST);</span><br><span class="line">        sendQQMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_FIRST);</span><br><span class="line">        sendWeChatMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_FIRST);</span><br><span class="line">        sendSMSMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_FIRST);</span><br><span class="line">        sendQQMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_SECOND);</span><br><span class="line">        sendWeChatMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_SECOND);</span><br><span class="line">        sendSMSMessage(msgFlyWeightFactory, MESSAGE_CONTEXT_SECOND);</span><br><span class="line">        logger.info(<span class="string">&quot;当前客户端数量：&quot;</span> + msgFlyWeightFactory.getAllFlyWeightSize());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendSMSMessage</span><span class="params">(MsgFlyWeightFactory msgFlyWeightFactory, String message)</span> </span>&#123;</span><br><span class="line">        MsgFlyWeight msgFlyWeight = msgFlyWeightFactory.getMsgClient(MsgType.SMS);</span><br><span class="line">        msgFlyWeight.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendWeChatMessage</span><span class="params">(MsgFlyWeightFactory msgFlyWeightFactory, String message)</span> </span>&#123;</span><br><span class="line">        MsgFlyWeight msgFlyWeight = msgFlyWeightFactory.getMsgClient(MsgType.WECHAT);</span><br><span class="line">        msgFlyWeight.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendQQMessage</span><span class="params">(MsgFlyWeightFactory msgFlyWeightFactory, String message)</span> </span>&#123;</span><br><span class="line">        MsgFlyWeight msgFlyWeight = msgFlyWeightFactory.getMsgClient(MsgType.QQ);</span><br><span class="line">        msgFlyWeight.sendMessage(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/flyweight.html</a></p>
<p><a href="https://www.cnblogs.com/chenssy/p/3330555.html">https://www.cnblogs.com/chenssy/p/3330555.html</a></p>
<p><a href="http://c.biancheng.net/view/1371.html">http://c.biancheng.net/view/1371.html</a></p>
<p><a href="https://www.cnblogs.com/adamjwh/p/9070107.html">https://www.cnblogs.com/adamjwh/p/9070107.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>代理模式</title>
    <url>/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="代理模式-Proxy-Pattern"><a href="#代理模式-Proxy-Pattern" class="headerlink" title="代理模式(Proxy Pattern)"></a>代理模式(Proxy Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>给某一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
<p>属于：对象结构型模式。</p>
<span id="more"></span>

<blockquote>
<p>代理对象控制对原对象的访问</p>
</blockquote>
<blockquote>
<p>代理对象：起到中介作用，连接客户端和目标对象</p>
<p>例子：电脑桌面的快捷方式。电脑对某个程序提供一个快捷方式（代理对象），快捷方式连接客户端和程序，客户端通过操作快捷方式就可以操作那个程序</p>
</blockquote>
<h5 id="代理模式结构"><a href="#代理模式结构" class="headerlink" title="代理模式结构"></a>代理模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="代理模式结构图"></p>
<p>代理模式角色：</p>
<p>​    ◊  Subject: 抽象主题角色</p>
<p>​    ◊  Proxy: 代理主题角色</p>
<p>​    ◊  RealSubject: 真实主题角色</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>通过引入<strong>代理对象</strong>的方式来间接访问<strong>目标对象</strong>,防止<strong>直接</strong>访问目标对象给系统带来的不必要复杂性。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>协调调用者和被调用者，降低了系统的耦合度</li>
<li>代理对象作为客户端和目标对象之间的中介，起到了保护目标对象的作用</li>
</ul>
<blockquote>
<p>远程代理使得客户端可以访问在远程机器上的对象，远程机器 可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</p>
<p>虚拟代理通过使用一个小对象来代表一个大对象，可以减少系 统资源的消耗，对系统进行优化并提高运行速度。</p>
<p>保护代理可以控制对真实对象的使用权限。</p>
</blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>由于在客户端和真实主题之间增加了代理对象，因此会造成请求的处理速度变慢；</li>
<li>实现代理模式需要额外的工作（有些代理模式的实现非常复杂），从而增加了系统实现的复杂度。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>远程(Remote)代理：为一个位于不同的地址空间的对象提供一个本地 的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在 另一台主机中，远程代理又叫做大使(Ambassador)。</li>
<li>虚拟(Virtual)代理：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。<ul>
<li>Copy-on-Write代理：它是虚拟代理的一种，把复制（克隆）操作延迟 到只有在客户端真正需要时才执行。一般来说，对象的深克隆是一个 开销较大的操作，Copy-on-Write代理可以让这个操作延迟，只有对象被用到的时候才被克隆。</li>
</ul>
</li>
<li>保护(Protect or Access)代理：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li>
<li>缓冲(Cache)代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li>
<li>防火墙(Firewall)代理：保护目标不让恶意用户接近。</li>
<li>同步化(Synchronization)代理：使几个用户能够同时使用一个对象而没有冲突。</li>
<li>智能引用(Smart Reference)代理：当一个对象被引用时，提供一些额外的操作，如将此对象被调用的次数记录下来等。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>代理模式包含三个角色：</p>
<ul>
<li>抽象主题角色声明了真实主题和代理主题的共同接口；</li>
<li>代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；</li>
<li>真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li>
</ul>
</li>
<li><p>几种常用的代理模式:</p>
<ul>
<li><p>图片代理：一个很常见的代理模式的应用实例就是对大图浏览的控制。</p>
<p>用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方法来进行处理，在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片的加载方法将大图片加载到客户端。当需要浏览大图片时，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还没有完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</p>
</li>
<li><p>远程代理：远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象承担了大部分的网络通信工作。</p>
</li>
<li><p>虚拟代理：当一个对象的加载十分耗费资源的时候，虚拟代理的优势就非常明显地体现出来了。虚拟代理模式是一种内存节省技术，那些占用大量内存或处理复杂的对象将推迟到使用它的时候才创建。</p>
<p>在应用程序启动的时候，可以用代理对象代替真实对象初始化，节省了内存的占用，并大大加速了系统的启动时间。</p>
</li>
<li><p><strong>动态代理</strong></p>
<ul>
<li>动态代理是一种较为高级的代理模式，它的典型应用就是Spring AOP。</li>
<li>在传统的代理模式中，客户端通过Proxy调用RealSubject类的request()方法，同时还在代理类中封装了其他方法(如preRequest()和postRequest())，可以处理一些其他问题。</li>
<li>如果按照这种方法使用代理模式，那么真实主题角色必须是事先已经存在的，并将其作为代理对象的内部成员属性。如果一个真实主题角色必须对应一个代理主题角色，这将导致系统中的类个数急剧增加，因此需要想办法减少系统中类的个数，此外，如何在事先不知道真实主题角色的情况下使用代理主题角色，这都是动态代理需要解决的问题。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为什么需要代理模式：</p>
<p>​    在某些情况下，一个客户不想或者不能直接引用一个对 象，此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到 中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p>
<p>​    通过引入一个新的对象（如小图片和远程代理 对象）来实现对真实对象的操作或者将新的对 象作为真实对象的一个替身，这种实现机制即 为代理模式，通过引入代理对象来间接访问一 个对象，这就是代理模式的模式动机。</p>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p> <img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="代理模式代码示例图"></p>
<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        String content = <span class="string">&quot;这是一条消息内容！&quot;</span>;</span><br><span class="line">        MessageSenderProxy messageSenderProxy = <span class="keyword">new</span> MessageSenderProxy();</span><br><span class="line">        messageSenderProxy.sendMessage(content);</span><br><span class="line">        messageSenderProxy.sendMessage(content);</span><br><span class="line">        logger.info(<span class="string">&quot;过一分钟后再次发送消息，请等待！&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">60001</span>);</span><br><span class="line">        messageSenderProxy.sendMessage(content);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>Subject: 抽象主题角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String content)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Proxy: 代理主题角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSenderProxy</span> <span class="keyword">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MessageSenderProxy.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date LAST_TIME;</span><br><span class="line"></span><br><span class="line">    MessageSenderProxy() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageSender = <span class="keyword">new</span> MessageSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (LAST_TIME == <span class="keyword">null</span>) &#123;</span><br><span class="line">            LAST_TIME = <span class="keyword">new</span> Date();</span><br><span class="line">            messageSender.sendMessage(content);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Date currentTime = <span class="keyword">new</span> Date();</span><br><span class="line">        currentTime.setTime(currentTime.getTime() - <span class="number">60</span> * <span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">if</span> (LAST_TIME.after(currentTime)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;1分钟内不可重复发送消息！&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        messageSender.sendMessage(content);</span><br><span class="line">        LAST_TIME = <span class="keyword">new</span> Date();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> RealSubject: 真实主题角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> <span class="keyword">implements</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MessageSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String content)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;发送消息成功！消息内容为：&quot;</span> + content);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/proxy.html</a></p>
<p><a href="https://www.jianshu.com/p/a8aa6851e09e">https://www.jianshu.com/p/a8aa6851e09e</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>桥接模式</title>
    <url>/2018/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="桥接模式-Bridge-Pattern"><a href="#桥接模式-Bridge-Pattern" class="headerlink" title="桥接模式(Bridge Pattern)"></a>桥接模式(Bridge Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p>
<p>又称为柄体(<code>Handle and Body</code>)模式或接口(<code>Interface</code>)模式。</p>
<p>对象结构型模式</p>
<span id="more"></span>

<blockquote>
<p>桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。</p>
</blockquote>
<h5 id="桥接模式结构"><a href="#桥接模式结构" class="headerlink" title="桥接模式结构"></a>桥接模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="桥接模式结构图"></p>
<p>桥接模式角色：</p>
<p>​    ◊   Abstraction：抽象类：定义了一个实现类接口类型的对象并可以维护该对象</p>
<p>​    ◊   RefinedAbstraction：扩充抽象类：扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；</p>
<p>​    ◊   Implementor：实现类接口：定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作</p>
<p>​    ◊   ConcreteImplementor：具体实现类：实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>理解桥接模式，重点需要理解如何将抽象化(<code>Abstraction</code>)与实现化(<code>Implementation</code>)脱耦，使得二者可以独立地变化。</p>
<ul>
<li>抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li>
<li>实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li>
<li>脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>分离抽象接口及其实现部分。</li>
<li>桥接模式有时类似于多继承方案，但是多继承方案违背了类的单一职责原则（即一个类只有一个变化的原因），复用性比较差，而且多继承结构中类的个数非常庞大，桥接模式是比多继承方案更好的解决方法。</li>
<li>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</li>
<li>实现细节对客户透明，可以对用户隐藏实现细节。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li><p>桥接模式的引入会增加系统的理解与设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计与编程。</p>
</li>
<li><p>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性。</p>
</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>如果一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
<li>抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li>
<li>一个类存在两个独立变化的维度，且这两个维度都需要进行扩展。</li>
<li>虽然在系统中使用继承是没有问题的，但是由于抽象化角色和具体化角色需要独立变化，设计要求需要独立管理这两者。</li>
<li>对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>适配器模式与桥接模式的联用:<ul>
<li>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</li>
</ul>
</li>
<li>应用：一个<code>Java</code>桌面软件总是带有所在操作系统的视感(<code>LookAndFeel</code>)，如果一个<code>Java</code>软件是在<code>Unix</code>系统上开发的，那么开发人员看到的是<code>Motif</code>用户界面的视感；在<code>Windows</code>上面使用这个系统的用户看到的是<code>Windows</code>用户界面的视感；而一个在<code>Macintosh</code>上面使用的用户看到的则是<code>Macintosh</code>用户界面的视感，Java语言是通过所谓的<code>Peer</code>架构做到这一点的。<code>Java</code>为<code>AWT</code>中的每一个<code>GUI</code>构件都提供了一个<code>Peer</code>构件，在<code>AWT</code>中的<code>Peer</code>架构就使用了桥接模式</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="桥接模式代码示例类图"></p>
<p>Abstraction</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">SendMessage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> SendMethod sendMethod;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeSendMethod</span><span class="params">(SendMethod sendMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendMethod = sendMethod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> RefinedAbstraction</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendWeChatMessage</span> <span class="keyword">extends</span> <span class="title">SendMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SendWeChatMessage.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendWeChatMessage</span><span class="params">(SendMethod sendMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendMethod = sendMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        String client = <span class="string">&quot;微信 client&quot;</span>;</span><br><span class="line">        String result = sendMethod.getSendMsgResultByMethod(client);</span><br><span class="line">        logger.info(<span class="string">&quot;发送消息成功：&quot;</span> + result + <span class="string">&quot;；消息内容：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendSMSMessage</span> <span class="keyword">extends</span> <span class="title">SendMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SendSMSMessage.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendSMSMessage</span><span class="params">(SendMethod sendMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendMethod = sendMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        String client = <span class="string">&quot;短信 client&quot;</span>;</span><br><span class="line">        String result = sendMethod.getSendMsgResultByMethod(client);</span><br><span class="line">        logger.info(<span class="string">&quot;发送消息成功：&quot;</span> + result + <span class="string">&quot;；消息内容：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendQQMessage</span> <span class="keyword">extends</span> <span class="title">SendMessage</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SendQQMessage.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SendQQMessage</span><span class="params">(SendMethod sendMethod)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sendMethod = sendMethod;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        String client = <span class="string">&quot;QQ client&quot;</span>;</span><br><span class="line">        String result = sendMethod.getSendMsgResultByMethod(client);</span><br><span class="line">        logger.info(<span class="string">&quot;发送消息成功：&quot;</span> + result + <span class="string">&quot;；消息内容：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Implementor</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SendMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getSendMsgResultByMethod</span><span class="params">(String messageType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteImplementor：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncMethod</span> <span class="keyword">implements</span> <span class="title">SendMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSendMsgResultByMethod</span><span class="params">(String messageClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;异步方式调用 &quot;</span> + messageClient + <span class="string">&quot; 发送请求&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> <span class="keyword">implements</span> <span class="title">SendMethod</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSendMsgResultByMethod</span><span class="params">(String messageClient)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;同步方式调用 &quot;</span> + messageClient + <span class="string">&quot; 发送请求&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        sendSMSMessage();</span><br><span class="line">        sendQQMessage();</span><br><span class="line">        sendWechatMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendWechatMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SendMessage sendMessage = <span class="keyword">new</span> SendWeChatMessage(<span class="keyword">new</span> SyncMethod());</span><br><span class="line">        sendMessage.sendMessage(<span class="string">&quot;微信提醒：请及时签收&quot;</span>);</span><br><span class="line">        sendMessage.changeSendMethod(<span class="keyword">new</span> AsyncMethod());</span><br><span class="line">        sendMessage.sendMessage(<span class="string">&quot;微信提醒：请及时签收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendSMSMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SendMessage sendMessage = <span class="keyword">new</span> SendSMSMessage(<span class="keyword">new</span> SyncMethod());</span><br><span class="line">        sendMessage.sendMessage(<span class="string">&quot;短信提醒：请及时签收&quot;</span>);</span><br><span class="line">        sendMessage.changeSendMethod(<span class="keyword">new</span> AsyncMethod());</span><br><span class="line">        sendMessage.sendMessage(<span class="string">&quot;短信提醒：请及时签收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendQQMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SendMessage sendMessage = <span class="keyword">new</span> SendQQMessage(<span class="keyword">new</span> SyncMethod());</span><br><span class="line">        sendMessage.sendMessage(<span class="string">&quot;QQ提醒：请及时签收&quot;</span>);</span><br><span class="line">        sendMessage.changeSendMethod(<span class="keyword">new</span> AsyncMethod());</span><br><span class="line">        sendMessage.sendMessage(<span class="string">&quot;QQ提醒：请及时签收&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/bridge.html</a></p>
<p><a href="https://blog.csdn.net/lovelion/article/details/7464195">https://blog.csdn.net/lovelion/article/details/7464195</a></p>
<p><a href="https://www.cnblogs.com/chenssy/p/3317866.html">https://www.cnblogs.com/chenssy/p/3317866.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>组合模式</title>
    <url>/2018/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="组合模式-Composite-Pattern"><a href="#组合模式-Composite-Pattern" class="headerlink" title="组合模式(Composite Pattern)"></a>组合模式(Composite Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>组合模式（Composite Pattern）将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户可以使用一致的方法操作单个对象和组合对象。</p>
<p>组合模式也叫合成模式，有时又叫做部分-整体模式。</p>
<p>结构型模式</p>
<span id="more"></span>

<blockquote>
<p>主要是用来描述部分与整体的关系，将对象组合成树形结构以表示“部分-整体”的层次结构。</p>
</blockquote>
<blockquote>
<p>在软件工程中，复合模式是一种分区设计模式。组合模式描述了一组对象，这些对象的处理方式与同一类型对象的单个实例的处理方式相同。组合的目的是将对象“合成”到树结构中以表示部分 - 整体层次结构。实现组合模式可以让客户端统一处理各个对象和组合。</p>
</blockquote>
<h5 id="组合模式结构"><a href="#组合模式结构" class="headerlink" title="组合模式结构"></a>组合模式结构</h5><p>组合模式分为安全模式和透明模式，通常指的是透明模式</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="组合模式结构图"></p>
<p>组合模式角色：</p>
<p>​    ◊  Component抽象构件角色 ：定义参加组合对象的共有方法和属性，可以定义一些默认的行为或属性。</p>
<p>​    ◊  Leaf叶子构件 ：Leaf叶子构件叶子对象，其下再也没有其他的分支，也就是遍历的最小单位。</p>
<p>​    ◊  Composite树枝构件 ：树枝对象，它的作用是组合树枝节点和叶子节点形成一个树形结构。组合模式的重点就在树枝构件。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><ul>
<li><strong>安全模式和透明模式的区别</strong><ul>
<li>安全模式在抽象组件中只定义一些默认的行为或属性，它是把树枝节点和树叶节点彻底分开；透明模式是把用来组合使用的方法放到抽象类中，不管叶子对象还是树枝对象都有相同的结构，通过判断确认是叶子节点还是树枝节点，如果处理不当，这个会在运行期出现问题，不是很建议的方式。</li>
<li>安全模式与依赖倒置原则冲突；透明模式的好处就是它基本遵循了依赖倒转原则，方便系统进行扩展。</li>
<li>安全模式在遍历树形结构的的时候需要进行强制类型转换；在透明模式下，遍历整个树形结构是比较容易的，不用进行强制类型转换。</li>
</ul>
</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>高层模块调用简单。组合模式中，用户不用关心到底是处理简单组件还是复合组件，可以按照统一的接口处理。不必判断组件类型，更不用为不同类型组件分开处理。</li>
<li>组合模式可以很容易的增加新的组件。若要增加一个简单组件或复合组件，只须找到它的父节点即可，非常容易扩展，符合“开放-关闭”原则。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>无法限制组合组件中的子组件类型。在需要检测组件类型时，不能依靠编译期的类型约束来实现，必须在运行期间动态检测。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>只要是树形结构或者只要是要体现局部和整体的关系的时候，而且这种关系还可能比较深，就要考虑一下组合模式。</li>
<li>从一个整体中能够独立出部分模块或功能的场景。</li>
<li>维护和展示部分-整体关系的场景。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p><strong>组合对象和单个对象可以用一致方式</strong> 对待说的是：透明模式下，组合和叶子结点之间具有共同的方法可以调用（因为集成同一个接口）</p>
<p>组合模式以单一职责设计原则获取了透明性，透明性可能有一些安全问题（比如叶子节点下加节点，运行时异常），看选择，这是折中的，根据需要去平衡透明性和安全性。</p>
<p>只要是树形结构或者只要是要体现局部和整体的关系的时候，而且这种关系还可能比较深，就要考虑使用组合模式。</p>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p> Component抽象构件角色 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//透明模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractOrganization organization)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(AbstractOrganization organization)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractSafetyOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Leaf叶子构件 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//透明模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">extends</span> <span class="title">AbstractOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractOrganization organization)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;user can not add&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(AbstractOrganization organization)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;user can not delete&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafetyUser</span> <span class="keyword">extends</span> <span class="title">AbstractSafetyOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafetyUser</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Composite树枝构件 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//透明模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Corp</span> <span class="keyword">extends</span> <span class="title">AbstractOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;AbstractOrganization&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Corp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractOrganization&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(List&lt;AbstractOrganization&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.add(organization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(AbstractOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.remove(organization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dept</span> <span class="keyword">extends</span> <span class="title">AbstractOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractOrganization&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Dept</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractOrganization&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(List&lt;AbstractOrganization&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.add(organization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(AbstractOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.remove(organization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//安全模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafetyCorp</span> <span class="keyword">extends</span> <span class="title">AbstractSafetyOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;AbstractSafetyOrganization&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafetyCorp</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractSafetyOrganization&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(List&lt;AbstractSafetyOrganization&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractSafetyOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.add(organization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(AbstractSafetyOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.remove(organization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SafetyDept</span> <span class="keyword">extends</span> <span class="title">AbstractSafetyOrganization</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;AbstractSafetyOrganization&gt; children = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SafetyDept</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;AbstractSafetyOrganization&gt; <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setChildren</span><span class="params">(List&lt;AbstractSafetyOrganization&gt; children)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.children = children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(AbstractSafetyOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.add(organization);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(AbstractSafetyOrganization organization)</span> </span>&#123;</span><br><span class="line">        children.remove(organization);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositeApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CompositeApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;transparent&quot;</span>);</span><br><span class="line">        AbstractOrganization organization = OrganContext.getOrganizationTree();</span><br><span class="line">        logger.info(JSONObject.toJSONString(organization, SerializerFeature.PrettyFormat));</span><br><span class="line">        logger.info(<span class="string">&quot;safety&quot;</span>);</span><br><span class="line">        AbstractSafetyOrganization safeOrganization = OrganContext.getSafetyOrganizationTree();</span><br><span class="line">        logger.info(JSONObject.toJSONString(safeOrganization, SerializerFeature.PrettyFormat));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//安全模式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrganContext</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractSafetyOrganization <span class="title">getSafetyOrganizationTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SafetyCorp organization = <span class="keyword">new</span> SafetyCorp(<span class="string">&quot;root:总公司&quot;</span>);</span><br><span class="line">        SafetyDept developmentDept = <span class="keyword">new</span> SafetyDept(<span class="string">&quot;总公司财务部&quot;</span>);</span><br><span class="line">        SafetyDept financeDept = <span class="keyword">new</span> SafetyDept(<span class="string">&quot;总公司财务部&quot;</span>);</span><br><span class="line">        developmentDept.add(<span class="keyword">new</span> SafetyUser(<span class="string">&quot;总公司开发部人员&quot;</span>));</span><br><span class="line">        financeDept.add(<span class="keyword">new</span> SafetyUser(<span class="string">&quot;总公司财务部人员&quot;</span>));</span><br><span class="line">        organization.add(financeDept);</span><br><span class="line">        organization.add(developmentDept);</span><br><span class="line">        organization.add(<span class="keyword">new</span> SafetyUser(<span class="string">&quot;总公司的领导&quot;</span>));</span><br><span class="line">        SafetyCorp partOrganization = <span class="keyword">new</span> SafetyCorp(<span class="string">&quot;第一分公司&quot;</span>);</span><br><span class="line">        partOrganization.add(<span class="keyword">new</span> SafetyUser(<span class="string">&quot;第一分公司直属人员&quot;</span>));</span><br><span class="line">        SafetyDept partDevelopmentDept = <span class="keyword">new</span> SafetyDept(<span class="string">&quot;第一分公司的财务部&quot;</span>);</span><br><span class="line">        SafetyDept partFinanceDept = <span class="keyword">new</span> SafetyDept(<span class="string">&quot;第一分公司的开发部&quot;</span>);</span><br><span class="line">        partDevelopmentDept.add(<span class="keyword">new</span> SafetyUser(<span class="string">&quot;第一分公司的财务部人员&quot;</span>));</span><br><span class="line">        partFinanceDept.add(<span class="keyword">new</span> SafetyUser(<span class="string">&quot;第一分公司的开发部人员&quot;</span>));</span><br><span class="line">        partOrganization.add(partDevelopmentDept);</span><br><span class="line">        partOrganization.add(partFinanceDept);</span><br><span class="line">        organization.add(partOrganization);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> organization;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//透明模式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AbstractOrganization <span class="title">getOrganizationTree</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractOrganization organization = <span class="keyword">new</span> Corp(<span class="string">&quot;root:总公司&quot;</span>);</span><br><span class="line">        AbstractOrganization developmentDept = <span class="keyword">new</span> Dept(<span class="string">&quot;总公司财务部&quot;</span>);</span><br><span class="line">        AbstractOrganization financeDept = <span class="keyword">new</span> Dept(<span class="string">&quot;总公司财务部&quot;</span>);</span><br><span class="line">        developmentDept.add(<span class="keyword">new</span> User(<span class="string">&quot;总公司开发部人员&quot;</span>));</span><br><span class="line">        financeDept.add(<span class="keyword">new</span> User(<span class="string">&quot;总公司财务部人员&quot;</span>));</span><br><span class="line">        organization.add(financeDept);</span><br><span class="line">        organization.add(developmentDept);</span><br><span class="line">        organization.add(<span class="keyword">new</span> User(<span class="string">&quot;总公司的领导&quot;</span>));</span><br><span class="line">        AbstractOrganization partOrganization = <span class="keyword">new</span> Corp(<span class="string">&quot;第一分公司&quot;</span>);</span><br><span class="line">        partOrganization.add(<span class="keyword">new</span> User(<span class="string">&quot;第一分公司直属人员&quot;</span>));</span><br><span class="line">        AbstractOrganization partDevelopmentDept = <span class="keyword">new</span> Dept(<span class="string">&quot;第一分公司的财务部&quot;</span>);</span><br><span class="line">        AbstractOrganization partFinanceDept = <span class="keyword">new</span> Dept(<span class="string">&quot;第一分公司的开发部&quot;</span>);</span><br><span class="line">        partDevelopmentDept.add(<span class="keyword">new</span> User(<span class="string">&quot;第一分公司的财务部人员&quot;</span>));</span><br><span class="line">        partFinanceDept.add(<span class="keyword">new</span> User(<span class="string">&quot;第一分公司的开发部人员&quot;</span>));</span><br><span class="line">        partOrganization.add(partDevelopmentDept);</span><br><span class="line">        partOrganization.add(partFinanceDept);</span><br><span class="line">        organization.add(partOrganization);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> organization;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>





<p>参考资料</p>
<p>《大话设计模式》</p>
<p><a href="https://juejin.im/post/5aa0958f518825555e5d645c">https://juejin.im/post/5aa0958f518825555e5d645c</a></p>
<p><a href="http://www.jasongj.com/design_pattern/composite/">http://www.jasongj.com/design_pattern/composite/</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>结构型模式</title>
    <url>/2018/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>​    结构型模式(Structural Pattern)描述如何将类或者对 象结合在一起形成更大的结构，就像搭积木，可以通过 简单积木的组合形成复杂的、功能更为强大的结构。</p>
<p>结构型模式可以分为类结构型模式和对象结构型模式：</p>
<span id="more"></span>

<ul>
<li>类结构型模式关心类的组合，由多个类可以组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系。</li>
</ul>
<ul>
<li>对象结构型模式关心类与对象的组合，通过关联关系使得在一 个类中定义另一个类的实例对象，然后通过该对象调用其方法。 根据“合成复用原则”，在系统中尽量使用关联关系来替代继 承关系，因此大部分结构型模式都是对象结构型模式。</li>
</ul>
<blockquote>
<p>结构型模式是为解决怎样组装现有的类，设计它们的交互方式，从而达到实现一定的功能目的。结构型模式包容了对很多问题的解决。例如：扩展性（外观、组成、代理、装饰）、封装（适配器、桥接）。</p>
<p>在解决了对象的创建问题之后，对象的组成以及对象之间的依赖关系就成了开发人员关注的焦点，因为如何设计对象的结构、继承和依赖关系会影响到后续程序的维护性、代码的健壮性、耦合性等。对象结构的设计很容易体现出设计人员水平的高低，</p>
</blockquote>
<ul>
<li><a href="http://zhangyuying.cn/2018/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/">适配器模式(Adapter)</a></li>
<li><a href="http://zhangyuying.cn/2018/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/">桥接模式(Bridge)</a></li>
<li><a href="http://zhangyuying.cn/2018/09/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/">组合模式(Composite)</a></li>
<li><a href="http://zhangyuying.cn/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/">装饰模式(Decorator)</a></li>
<li><a href="http://zhangyuying.cn/2018/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/#more">外观模式(Facade)</a></li>
<li><a href="http://zhangyuying.cn/2018/12/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/">享元模式(Flyweight)</a></li>
<li><a href="http://zhangyuying.cn/2018/09/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">代理模式(Proxy)</a></li>
</ul>
<p>参考资料：</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/structural.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/structural.html</a></p>
<p><a href="https://github.com/jiayisheji/blog/issues/2">https://github.com/jiayisheji/blog/issues/2</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>外观模式</title>
    <url>/2018/08/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="外观模式-Facade-Pattern"><a href="#外观模式-Facade-Pattern" class="headerlink" title="外观模式( Facade Pattern)"></a>外观模式( Facade Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用</p>
<p>外观模式又叫门面模式</p>
<p>属于：对象结构型模式</p>
<span id="more"></span>

<blockquote>
<p>定义了一个高层、统一的接口，外部与通过这个统一的接口对子系统中的一群接口进行访问。</p>
<p>子系统可以创建许多外观（head first 设计模式）</p>
<p>通过创建一个统一的类，用来包装子系统中一个或多个复杂的类，客户端可以通过调用外观类的方法来调用内部子系统中所有方法</p>
</blockquote>
<h5 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="外观模式结构图"></p>
<p>外观模式角色：</p>
<p>​    ◊ Facade: 外观角色</p>
<p>​        ◊ SubSystem:子系统角色</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><ul>
<li>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</li>
</ul>
<ul>
<li>外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。 </li>
</ul>
<ul>
<li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li>
<li>外观模式的目的在于降低系统的复杂程度。</li>
<li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong>：　</p>
<ul>
<li>体现了 <strong>最少知识原则</strong>（head fisrt 设计模式）</li>
</ul>
<ul>
<li><p>降低了客户类与子系统类的耦合度，实现了子系统与客户之间的松耦合关系</p>
<blockquote>
<ol>
<li>只是提供了一个访问子系统的统一入口，并不影响用户直接使用子系统类</li>
<li>减少了与子系统的关联对象，实现了子系统与客户之间<br>的松耦合关系，松耦合使得子系统的组件变化不会影响到它的客户。</li>
</ol>
</blockquote>
</li>
<li><p>外观模式对客户屏蔽了子系统组件，从而简化了接口，减少了客户处理的对象数目并使子系统的使用更加简单。</p>
<blockquote>
<p>这个屏蔽不是“强硬的”,外观模式只是提供你更直接的操作，并为将原来的子系统阻隔起来，如果你需要子系统类的更高层的功能，还是可以使用原来的子系统（head first 设计模式）</p>
</blockquote>
<blockquote>
<ol>
<li>引入外观角色之后，用户只需要与外观角色交互；</li>
<li>用户与子系统之间的复杂逻辑关系由外观角色来实现</li>
</ol>
</blockquote>
</li>
<li><p>降低原有系统的复杂度和系统中的编译依赖性，并简化了系统在不同平台之间的移植过程</p>
<blockquote>
<p>因为编译一个子系统一般不需要编译所有其他的子系统。一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象</p>
</blockquote>
</li>
</ul>
<p><strong>缺点</strong> ：</p>
<ul>
<li><p>不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性。</p>
</li>
<li><p>在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</p>
<blockquote>
<p>抽象外观类的引入</p>
<p>外观模式最大的缺点在于违背了“开闭原则”，当增加新的子系统或者移除子系统时需要修改外观类，可以通过引入抽象外观类在一定程度上解决该问题，客户端针对抽象外观类进行编程。对于新的业务需求，不修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改源代码并更换外观类的目的。</p>
</blockquote>
</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>当要为一个复杂子系统提供一个简单接口时可以使用外观模式。该接口可以满足大多数用户的需求，而且用户也可以越过外观类直接访问子系统。</li>
<li>客户程序与多个子系统之间存在很大的依赖性。引入外观类将子系统与客户以及其他子系统解耦，可以提高子系统的独立性和可移植性。</li>
<li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>外观模式包含两个角色：<ul>
<li>外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；</li>
<li>在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li>
</ul>
</li>
<li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li>
<li>适配器和外观模式的区别：在于他们的意图。适配器模式的意图是：将接口转换成不同接口，外观模式的意图是提供子系统的一个简化接口。（head first 设计模式）</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">     sendMessage();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     MsgFacade msgFacade = <span class="keyword">new</span> MsgFacade();</span><br><span class="line">     String textMsg = <span class="string">&quot;这是一段文字消息&quot;</span>;</span><br><span class="line">     String expressionMsg = <span class="string">&quot;开心&quot;</span>;</span><br><span class="line">     msgFacade.sendTextMessage(textMsg);</span><br><span class="line">     msgFacade.sendExpressionMessage(expressionMsg);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>外观类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgFacade</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> QQSender qqSender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeChatSender weChatSender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SMSSender smsSender;</span><br><span class="line"></span><br><span class="line">    MsgFacade() &#123;</span><br><span class="line">        qqSender = <span class="keyword">new</span> QQSender();</span><br><span class="line">        weChatSender = <span class="keyword">new</span> WeChatSender();</span><br><span class="line">        smsSender = <span class="keyword">new</span> SMSSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendTextMessage</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        qqSender.sendText(text);</span><br><span class="line">        weChatSender.sendText(text);</span><br><span class="line">        smsSender.sendText(text);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendExpressionMessage</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        qqSender.sendExpression(expression);</span><br><span class="line">        weChatSender.sendExpression(expression);</span><br><span class="line">        smsSender.sendExpression(expression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体系统类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQSender</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(QQSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        logger.error(String.format(MsgContants.TEXT_MESSAGE, MsgContants.QQ, text));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendExpression</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        logger.error(String.format(MsgContants.EXPRESSION_MESSAGE, MsgContants.QQ, expression));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SMSSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        logger.error(String.format(MsgContants.TEXT_MESSAGE, MsgContants.SMS, text));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendExpression</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        logger.error(String.format(MsgContants.EXPRESSION_MESSAGE, MsgContants.SMS, expression));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WeChatSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendText</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        logger.error(String.format(MsgContants.TEXT_MESSAGE, MsgContants.WECHAT, text));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendExpression</span><span class="params">(String expression)</span> </span>&#123;</span><br><span class="line">        logger.error(String.format(MsgContants.EXPRESSION_MESSAGE, MsgContants.WECHAT, expression));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgContants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TYPE = <span class="string">&quot;type&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String QQ = <span class="string">&quot;QQ&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String WECHAT = <span class="string">&quot;微信&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SMS = <span class="string">&quot;短信&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TEXT_MESSAGE = <span class="string">&quot;%s，已发送文字消息，内容为：%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String EXPRESSION_MESSAGE = <span class="string">&quot;%s，已发送表情消息，内容为：%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/facade.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/facade.html</a></p>
<p><a href="https://blog.csdn.net/carson_ho/article/details/54910625">https://blog.csdn.net/carson_ho/article/details/54910625</a></p>
<p><a href="https://www.jianshu.com/p/1b027d9fc005">https://www.jianshu.com/p/1b027d9fc005</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>适配器模式</title>
    <url>/2018/09/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="适配器模式-Adapter-Pattern"><a href="#适配器模式-Adapter-Pattern" class="headerlink" title="适配器模式(Adapter Pattern)"></a>适配器模式(Adapter Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，</p>
<p>其别名为包装器(Wrapper)。</p>
<p>属于：结构型模式。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p>
<span id="more"></span>

<blockquote>
<p>定义一个包装类，用于包装不兼容接口的对象</p>
<ol>
<li>包装类 = 适配器Adapter；</li>
<li>被包装对象 = 适配者Adaptee = 被适配的类</li>
</ol>
</blockquote>
<h5 id="对象适配器模式结构"><a href="#对象适配器模式结构" class="headerlink" title="对象适配器模式结构"></a>对象适配器模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E5%AF%B9%E8%B1%A1%E9%80%82%E9%85%8D%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="对象适配器结构图"></p>
<h5 id="类适配器模式结构"><a href="#类适配器模式结构" class="headerlink" title="类适配器模式结构"></a>类适配器模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-%E7%B1%BB%E9%80%82%E9%85%8D%E5%99%A8%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="类适配器结构图"></p>
<p>适配器模式角色：</p>
<p>​    ◊ Target：目标抽象类</p>
<p>​        ◊ Adapter：适配器类</p>
<p>​        ◊ Adaptee：适配者类</p>
<p>​        ◊ Client：客户类</p>
<p>​  </p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><ul>
<li><p><strong>3.1 适配器模式</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>更好的复用性<br>系统需要使用现有的类，而此类的接口不符合系统的需要。那么通过适配器模式就可以让这些功能得到更好的复用。</li>
<li>透明、简单<br>客户端可以调用同一接口，因而对客户端来说是透明的。这样做更简单 &amp; 更直接</li>
<li>更好的扩展性<br>在实现适配器功能的时候，可以调用自己开发的功能，从而自然地扩展系统的功能。</li>
<li>解耦性<br>将目标类和适配者类解耦，通过引入一个适配器类重用现有的适配者类，而无需修改原有代码</li>
<li>符合开放-关闭原则<br>同一个适配器可以把适配者类和它的子类都适配到目标接口；可以为不同的目标接口实现不同的适配器，而不需要修改待适配类</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>过多的使用适配器，会让系统非常零乱，不易整体进行把握</li>
</ul>
</li>
<li><p><strong>3.2 类的适配器模式</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>使用方便，代码简化<br>仅仅引入一个对象，并不需要额外的字段来引用Adaptee实例</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>高耦合，灵活性低<br>使用对象继承的方式，是静态的定义方式</li>
</ul>
</li>
<li><p><strong>3.3 对象的适配器模式</strong></p>
<p><strong>优点</strong></p>
<ul>
<li>灵活性高、低耦合<br>采用 “对象组合”的方式，是动态组合方式</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>使用复杂<br>需要引入对象实例</li>
</ul>
<blockquote>
<p> 特别是需要重新定义Adaptee行为时需要重新定义Adaptee的子类，并将适配器组合适配</p>
</blockquote>
</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>系统需要使用现有的类，而这些类的接口不符合系统的需要。</li>
<li>想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>适配器模式包含四个角色：</p>
<ul>
<li>目标抽象类定义客户要用的特定领域的接口；</li>
<li>适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；</li>
<li>适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；</li>
<li>在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li>
</ul>
</li>
<li><p>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；</p>
<p>在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</p>
</li>
<li><p>适配器和外观模式的区别：在于他们的意图。适配器模式的意图是：将接口转换成不同接口，外观模式的意图是提供子系统的一个简化接口。（head first 设计模式）</p>
<p>​</p>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p> Client：客户类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterApplication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String signal = <span class="string">&quot;成功信号&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(AdapterApplication.class, args);</span><br><span class="line">        classAdapterSendSignal();</span><br><span class="line">        objectAdapterSendSignal();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">classAdapterSendSignal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SignalSender signalSender = <span class="keyword">new</span> SignalClassAdapter();</span><br><span class="line">        signalSender.sendSignal(signal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">objectAdapterSendSignal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SignalSender signalSender = <span class="keyword">new</span> SignalObjectAdapter();</span><br><span class="line">        signalSender.sendSignal(signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Target：目标抽象类：信号发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SignalSender</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendSignal</span><span class="params">(String signal)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Adaptee：适配者类:消息发送类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgSender</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MsgSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;消息已发送成功: &quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Adapter：适配器类</p>
<p>类适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalClassAdapter</span> <span class="keyword">extends</span> <span class="title">MsgSender</span> <span class="keyword">implements</span> <span class="title">SignalSender</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSignal</span><span class="params">(String signal)</span> </span>&#123;</span><br><span class="line">        sendMessage(signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象适配器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SignalObjectAdapter</span> <span class="keyword">implements</span> <span class="title">SignalSender</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MsgSender msgSender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SignalObjectAdapter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        msgSender = <span class="keyword">new</span> MsgSender();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendSignal</span><span class="params">(String signal)</span> </span>&#123;</span><br><span class="line">        msgSender.sendMessage(signal);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://www.jianshu.com/p/9d0575311214">https://www.jianshu.com/p/9d0575311214</a></p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/adapter.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>装饰模式</title>
    <url>/2018/10/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%BB%93%E6%9E%84%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="装饰模式-Decorator-Pattern"><a href="#装饰模式-Decorator-Pattern" class="headerlink" title="装饰模式(Decorator Pattern)"></a>装饰模式(Decorator Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>装饰模式(Decorator Pattern) ：动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。</p>
<p>其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。</p>
<p>对象结构型模式</p>
<span id="more"></span>

<blockquote>
<p>也可叫做装饰者模式</p>
<p>装饰者提供有别于继承的另一种选择</p>
</blockquote>
<h5 id="装饰模式结构"><a href="#装饰模式结构" class="headerlink" title="装饰模式结构"></a>装饰模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="装饰模式结构图"></p>
<p>装饰模式角色：</p>
<p>​    ◊   component抽象构件</p>
<p>​         component是一个接口或者是抽象类,就是定义我们最核心的对象,也就是最原始的对象</p>
<p>​        在装饰模式中,必然有一个最基本,最核心,也就是最原始的对象</p>
<p>​    ◊  concreteComponent具体构建</p>
<p>​        concreteComponent是最核心,最原始,最基本的接口或抽象类的实现,要装饰的就是它</p>
<p>​    ◊   Decorator装饰角色</p>
<p>​        一般是一个抽象类,实现接口或者抽象方法</p>
<p>​        它的属性里必定有一个private变量指向Component抽象构建</p>
<p>​    ◊   ConcreteDecorator具体装饰角色</p>
<p>​               ConcreteDecoratorA和ConcreteDecoratorB是两个具体的装饰类,要把最原始,最基本,最核心的进行装饰</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><ul>
<li>与继承关系相比，关联关系的主要优势在于不会破坏类的封装性，而且继承是一种耦合度较大的静态关系，无法在程序运行时动态扩展。在软件开发阶段，关联关系虽然不会比继承关系减少编码量，但是到了软件维护阶段，由于关联关系使系统具有较好的松耦合性，因此使得系统更加容易维护。当然，关联关系的缺点是比继承关系要创建更多的对象。</li>
<li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>装饰类和被装饰类可以独立发展，不会相互耦合。<ul>
<li>Component类无需知道Decorator类，Decorator类是从外部来扩展Component类的功能，Decorator也不用知道具体的构件</li>
</ul>
</li>
<li>装饰模式是继承关系的一个替代方案<ul>
<li>装饰类Decorator不管装饰多少层，返回的对象还是Component，实现的还是is-a关系</li>
</ul>
</li>
<li>装饰模式可以动态地扩展一个实现类的功能，这不需要多说，装饰模式的定义就是如此</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>多层的装饰是比较复杂的</li>
<li>尽量减少装饰类的数量，以便降低系统的复杂度</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>需要扩展一个类的功能，或给出一个类增加附加功能（在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责）</li>
<li>需要动态地给一个对象增加功能，这些功能可以再动态地撤销</li>
<li>需要为一批的兄弟类进行改装或加装功能，当然是首选装饰模式</li>
<li>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展 和维护时。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>装饰模式包含四个角色：<ul>
<li>抽象构件定义了对象的接口，可以给这些对 象动态增加职责（方法）；</li>
<li>具体构件定义了具体的构件对象，实现了 在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）；</li>
<li>抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现；</li>
<li>具体装饰类是抽象装饰类的子类，负责向构 件添加新的职责。</li>
</ul>
</li>
<li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式 态地给一对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li>
<li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的 方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的 排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可 以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺 点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需 要逐级排查，较为烦琐。</li>
<li>装饰模式可分为透明装饰模式和半透明装饰模式：<ul>
<li>在透明装饰模式中，要求客 户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构 件类型和具体装饰类型，而应该全部声明为抽象构件类型；</li>
<li>半透明装饰模式允 许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li>
</ul>
</li>
<li><code>java</code> 中的<code>IO</code> 的实现就是采用的装饰模式</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>装饰模式代码示例类图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="装饰模式代码示例类图"></p>
<p>component抽象构件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">match</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>concreteComponent具体构建</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Rice</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Rice.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">match</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;米饭&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Decorator装饰角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">extends</span> <span class="title">Food</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> Food food;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Food food)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.food = food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food.price();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">match</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;米饭&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteDecorator具体装饰角色</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChineseCabbageDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChineseCabbageDecorator</span><span class="params">(Food food)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food.price() + <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">match</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food.match() + <span class="string">&quot;+小白菜&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpicyPorkDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SpicyPorkDecorator</span><span class="params">(Food message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">price</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food.price() + <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">match</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> food.match()+<span class="string">&quot;+香辣肉丝&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(DecoratorApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Food food = <span class="keyword">new</span> ChineseCabbageDecorator(<span class="keyword">new</span> SpicyPorkDecorator(<span class="keyword">new</span> Rice()));</span><br><span class="line">        logger.info(<span class="string">&quot;菜单的搭配为：&quot;</span>+food.match());</span><br><span class="line">        logger.info(<span class="string">&quot;当前搭配的价钱为：&quot;</span>+food.price());</span><br><span class="line">        Food food2 = <span class="keyword">new</span> ChineseCabbageDecorator((<span class="keyword">new</span> Rice()));</span><br><span class="line">        logger.info(<span class="string">&quot;菜单的搭配为：&quot;</span>+food2.match());</span><br><span class="line">        logger.info(<span class="string">&quot;当前搭配的价钱为：&quot;</span>+food2.price());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/decorator.html</a></p>
<p><a href="https://www.jianshu.com/p/c00436fcb52d">https://www.jianshu.com/p/c00436fcb52d</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>中介者模式</title>
    <url>/2018/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="中介者模式-Mediator-Pattern"><a href="#中介者模式-Mediator-Pattern" class="headerlink" title="中介者模式(Mediator Pattern)"></a>中介者模式(Mediator Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<p>又称为调停者模式</p>
<p>对象行为型模式。</p>
<span id="more"></span>

<blockquote>
<p>中介者主要是通过中介对象来封装对象之间的关系，使之各个对象在不需要知道其他对象的具体信息情况下通过中介者对象来与之通信。同时通过引用中介者对象来减少系统对象之间关系，提高了对象的可复用和系统的可扩展性。</p>
</blockquote>
<h5 id="中介者模式结构"><a href="#中介者模式结构" class="headerlink" title="中介者模式结构"></a>中介者模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="中介者模式结构图"></p>
<p>中介者模式角色：</p>
<p>​    ◊   Mediator: 抽象中介者。定义了同事对象到中介者对象之间的接口。</p>
<p>​          ◊   ConcreteMediator: 具体中介者。实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。</p>
<p>​          ◊   Colleague: 抽象同事类。</p>
<p>​          ◊   ConcreteColleague: 具体同事类。每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>在中介者模式中中介者对象处于核心地位，因为它定义了整个系统中所有具体同事类之间的关系。在整个系统中它主要承担两个方面的责任。</p>
<p>​      1、 结构上起到中转作用。通过中介者对象对关系的封装，使得具体的同事类不再需要显示的引用其他对象，它只需要通过中介者就可以完成与其他同事类之间的通信。</p>
<p>​      2、 行为上起到协作作用。中介者对同事类之间的关系进行封装，同事类在不需要知道其他对象的情况下通过中介者与其他对象完成通信。在这个过程中同事类是不需要指明中介者该如何做，中介者可以根据自身的逻辑来进行协调，对同事的请求进一步处理，将同事成员之间的关系行为进行分离和封装。</p>
<p>​      同时由于中介者对对象的关系进行了封装，使得各个同事类之间的耦合减少了，使得他们可以独立改变和复用。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li> 简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使系统成为松耦合系统。</li>
<li> 减少了子类的生成。</li>
<li> 可以减少各同事类的设计与实现。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>由于中介者对象封装了系统中对象之间的相互关系，导致其变得非常复杂，使得系统维护比较困难。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>系统中对象之间存在比较复杂的引用关系，导致他们之间的依赖关系结构混乱而且难以复用该对象。</li>
<li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li>
<li>交互的公共行为，如果需要改变行为则可以增加新的中介者类。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>因为中介者对象封装了对象之间的关联关系，导致中介者对象变得比较庞大，所承担的责任也比较多。它需要知道每个对象和他们之间的交互细节，如果它出问题，将会导致整个系统都会出问题。所以它比较容易应用也很容易误用。故当系统中出现了“多对多”交互复杂的关系群时， <strong>千万别急着使用中介者模式，你首先需要做的就是反思你的系统在设计上是不是合理。</strong></p>
</li>
<li><p><code>MVC</code>架构中控制器</p>
<p><code>Controller </code>作为一种中介者，它负责控制视图对象<code>View</code>和模型对象<code>Model</code>之间的交互。如在<code>Struts</code>中，<code>Action</code>就可以作为<code>JSP</code>页面与业务对象之间的中介者。</p>
</li>
<li><p>中介者模式与迪米特法则</p>
<ul>
<li>在中介者模式中，通过创造出一个中介者对象，将系统中有关的对象所引用的其他对象数目减少到最少，使得一个对象与其同事之间的相互作用被这个对象与中介者对象之间的相互作用所取代。因此，中介者模式就是迪米特法则的一个典型应用。</li>
</ul>
</li>
<li><p>中介者模式与<code>GUI</code>开发</p>
<ul>
<li>中介者模式可以方便地应用于图形界面(<code>GUI</code>)开发中，在比较复杂的界面中可能存在多个界面组件之间的交互关系。</li>
<li>对于这些复杂的交互关系，有时候我们可以引入一个中介者类，将这些交互的组件作为具体的同事类，将它们之间的引用和控制关系交由中介者负责，在一定程度上简化系统的交互，这也是中介者模式的常见应用之一。</li>
</ul>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="中介者模式代码示例类图"></p>
<p>Mediator：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notice</span><span class="params">(Colleague colleague, String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteMediator:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageMediator</span> <span class="keyword">implements</span> <span class="title">Mediator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Colleague&gt; colleagues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageMediator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        addColleague(<span class="keyword">new</span> FinanceColleague(<span class="keyword">this</span>));</span><br><span class="line">        addColleague(<span class="keyword">new</span> MaintainColleague(<span class="keyword">this</span>));</span><br><span class="line">        addColleague(<span class="keyword">new</span> CleanColleague(<span class="keyword">this</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">(Colleague colleague, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Colleague concreteColleague : colleagues) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!concreteColleague.toString().equals(colleague.toString())) &#123;</span><br><span class="line">                concreteColleague.notice(message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addColleague</span><span class="params">(Colleague colleague)</span> </span>&#123;</span><br><span class="line">        colleagues.add(colleague);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Colleague:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(Colleague.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Mediator mediator;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; nameMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        nameMap.put(<span class="string">&quot;finance&quot;</span>, <span class="string">&quot;财务部门&quot;</span>);</span><br><span class="line">        nameMap.put(<span class="string">&quot;maintain&quot;</span>, <span class="string">&quot;运维部门&quot;</span>);</span><br><span class="line">        nameMap.put(<span class="string">&quot;clean&quot;</span>, <span class="string">&quot;清洁部门&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notice</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.info(nameMap.get(<span class="keyword">this</span>.toString()) + <span class="string">&quot;收到：&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMediator</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mediator = mediator;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        mediator.notice(<span class="keyword">this</span>, message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteColleague:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinanceColleague</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinanceColleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        setMediator(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;finance&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaintainColleague</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaintainColleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        setMediator(mediator);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;maintain&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CleanColleague</span> <span class="keyword">extends</span> <span class="title">Colleague</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CleanColleague</span><span class="params">(Mediator mediator)</span> </span>&#123;</span><br><span class="line">        setMediator(mediator);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;clean&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediatorApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MediatorApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        financeNotice();</span><br><span class="line">        maintainNotice();</span><br><span class="line">        cleanNotice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">cleanNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;清洁部门发送消息：&quot;</span>);</span><br><span class="line">        Colleague cleanColleague = <span class="keyword">new</span> CleanColleague(<span class="keyword">new</span> MessageMediator());</span><br><span class="line">        String cleanMessage = <span class="string">&quot;清洁通知：本周六对公司进行清洁！&quot;</span>;</span><br><span class="line">        cleanColleague.sendMessage(cleanMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">maintainNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;运维部门发送消息：&quot;</span>);</span><br><span class="line">        Colleague maintainColleague = <span class="keyword">new</span> MaintainColleague(<span class="keyword">new</span> MessageMediator());</span><br><span class="line">        String maintainMessage = <span class="string">&quot;运维通知：今晚6点对公司系统进行维护！&quot;</span>;</span><br><span class="line">        maintainColleague.sendMessage(maintainMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">financeNotice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;财务部门发送消息：&quot;</span>);</span><br><span class="line">        Colleague financeColleague = <span class="keyword">new</span> FinanceColleague(<span class="keyword">new</span> MessageMediator());</span><br><span class="line">        String financeMessage = <span class="string">&quot;财务通知：今晚5点可统一报销！&quot;</span>;</span><br><span class="line">        financeColleague.sendMessage(financeMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/mediator.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/mediator.html</a></p>
<p><a href="https://www.cnblogs.com/chenssy/p/3348520.html">https://www.cnblogs.com/chenssy/p/3348520.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>命令模式</title>
    <url>/2018/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="命令模式-Command-Pattern"><a href="#命令模式-Command-Pattern" class="headerlink" title="命令模式(Command Pattern)"></a>命令模式(Command Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。</p>
<p>其别名为动作(Action)模式或事务(Transaction)模式。</p>
<p>对象行为型模式</p>
<span id="more"></span>

<blockquote>
<p>命令模式将发出请求的对象和执行请求的对象解耦</p>
<p>再被解耦的两者之间是通过命令对象进行沟通的，命令对象封装了接收者和一个或一组动作</p>
<p>调用者可以接受命令当做参数，甚至在运行时动态的进行</p>
</blockquote>
<h5 id="命令模式结构"><a href="#命令模式结构" class="headerlink" title="命令模式结构"></a>命令模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="命令模式结构图"></p>
<p>命令模式角色：</p>
<p>​    ◊  Command: 抽象命令类：声明了一个给所有具体命令类的抽象接口。</p>
<p>​    ◊  ConcreteCommand: 具体命令类：定义一个接收者和行为之间的弱耦合；实现execute()方法，负责调用接收者的相应操作。execute()方法通常叫做执行方法。</p>
<p>​    ◊  Invoker: 请求者：负责调用命令对象执行请求，相关的方法叫做行动方法。</p>
<p>​    ◊  Receiver: 接收者：负责具体实施和执行一个请求。任何一个类都可以成为接收者，实施和执行请求的方法叫做行动方法。</p>
<p>​    ◊  Client:客户类：创建一个具体命令(ConcreteCommand)对象并确定其接收者。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</p>
<ul>
<li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li>
<li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li>
<li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>
<li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>降低系统的耦合度。</li>
<li>新的命令可以很容易地加入到系统中。</li>
<li>可以比较容易地设计一个命令队列和宏命令（组合命令）。</li>
<li>可以方便地实现对请求的Undo和Redo。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
<li>系统需要将一组操作组合在一起，即支持宏命令</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>命令模式的典型的案例是：电视机、播放器等</li>
<li>命令模式包含四个角色：<ul>
<li>抽象命令类中声明了用于执行请求的execute()等方法，通过这些方法可以调用请求接收者的相关操作；</li>
<li>具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；</li>
<li>调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；</li>
<li>接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li>
</ul>
</li>
<li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li>
<li>实际操作时，很常见使用“聪明”命令对象，也就是直接实现了请求，而不是将工作委托给接收者</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>命令模式代码示例类图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="命令模式代码示例类图"></p>
<p>Receiver: 接收者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">on</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">previous</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">regresses</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TVReceiver</span> <span class="keyword">implements</span> <span class="title">Receiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(TVReceiver.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> MAX_CHANNEL = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TV tv;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TVReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv = TV.instance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">on</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.setOn(<span class="keyword">true</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;打开电视机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.setOn(<span class="keyword">false</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;关闭电视机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tv.isOn()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前电视未打开！不能进行操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tv.setHistory(tv.getCurrent());</span><br><span class="line">        <span class="keyword">if</span> (tv.getCurrent() == MAX_CHANNEL) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前已是最大频道&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tv.setCurrent(tv.getCurrent() + <span class="number">1</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;进入下一个频道&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">previous</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tv.isOn()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前电视未打开！不能进行操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        tv.setHistory(tv.getCurrent());</span><br><span class="line">        <span class="keyword">if</span> (tv.getCurrent() == <span class="number">0</span>) &#123;</span><br><span class="line">            tv.setCurrent(MAX_CHANNEL);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tv.setCurrent(tv.getCurrent() - <span class="number">1</span>);</span><br><span class="line">        logger.info(<span class="string">&quot;回到前一个频道&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">regresses</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tv.isOn()) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前电视未打开！不能进行操作！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> current = tv.getCurrent();</span><br><span class="line">        tv.setCurrent(tv.getHistory());</span><br><span class="line">        tv.setHistory(current);</span><br><span class="line">        logger.info(<span class="string">&quot;回到前一步&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;当前电视的状态为：&quot;</span> + (tv.isOn() ? <span class="string">&quot;开启。&quot;</span> : <span class="string">&quot;关闭。&quot;</span>) + <span class="string">&quot;\t&quot;</span> + <span class="string">&quot;当前频道为：&quot;</span> + tv.getCurrent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Command: 抽象命令类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteCommand: 具体命令类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OnCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.on();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.on();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloseCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CloseCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.on();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NextCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.previous();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreviousCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PreviousCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.previous();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.previous();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegressesCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Receiver receiver;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RegressesCommand</span><span class="params">(Receiver receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        receiver.regresses();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.regresses();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">            receiver.regresses();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//宏命令实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MacroTVCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Command&gt; commands;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MacroTVCommand</span><span class="params">(List&lt;Command&gt; commands)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.commands = commands;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.execute();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">undo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.undo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">redo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Command command : commands) &#123;</span><br><span class="line">            command.redo();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Invoker: 请求者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoteControl</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Map&lt;TVOperation, Command&gt; commandMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCommand</span><span class="params">(TVOperation operation, Command command)</span> </span>&#123;</span><br><span class="line">        commandMap.put(operation, command);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commandExecute</span><span class="params">(TVOperation operation)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (commandMap.get(operation) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;遥控器不存在此命令！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        commandMap.get(operation).execute();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Client:客户类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(CommandApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建 接收者：当前场景为电视机</span></span><br><span class="line">        Receiver receiver = <span class="keyword">new</span> TVReceiver();</span><br><span class="line">        <span class="comment">//创建具体命令</span></span><br><span class="line">        Command onCommand = <span class="keyword">new</span> OnCommand(receiver);</span><br><span class="line">        Command closeCommand = <span class="keyword">new</span> CloseCommand(receiver);</span><br><span class="line">        Command nextCommand = <span class="keyword">new</span> NextCommand(receiver);</span><br><span class="line">        Command previousCommand = <span class="keyword">new</span> PreviousCommand(receiver);</span><br><span class="line">        Command regressesCommand = <span class="keyword">new</span> RegressesCommand(receiver);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建 请求者：当前场景为遥控器</span></span><br><span class="line">        RemoteControl remoteControl = <span class="keyword">new</span> RemoteControl();</span><br><span class="line">        <span class="comment">//为请求者设置可执行的命令</span></span><br><span class="line">        remoteControl.addCommand(TVOperation.ON, onCommand);</span><br><span class="line">        remoteControl.addCommand(TVOperation.NEXT, nextCommand);</span><br><span class="line">        remoteControl.addCommand(TVOperation.PREVIOUS, previousCommand);</span><br><span class="line">        remoteControl.addCommand(TVOperation.REGRESSES, regressesCommand);</span><br><span class="line">        remoteControl.addCommand(TVOperation.CLOSE, closeCommand);</span><br><span class="line">        <span class="comment">//对遥控器的命令操作</span></span><br><span class="line">        remoteControl.commandExecute(TVOperation.ON);</span><br><span class="line">        logger.info(receiver.toString());</span><br><span class="line">        remoteControl.commandExecute(TVOperation.NEXT);</span><br><span class="line">        remoteControl.commandExecute(TVOperation.NEXT);</span><br><span class="line">        remoteControl.commandExecute(TVOperation.PREVIOUS);</span><br><span class="line">        remoteControl.commandExecute(TVOperation.REGRESSES);</span><br><span class="line">        logger.info(receiver.toString());</span><br><span class="line">        remoteControl.commandExecute(TVOperation.CLOSE);</span><br><span class="line">        logger.info(receiver.toString());</span><br><span class="line">        remoteControl.commandExecute(TVOperation.ON);</span><br><span class="line">        logger.info(receiver.toString());</span><br><span class="line">        remoteControl.commandExecute(TVOperation.NEXT);</span><br><span class="line">        logger.info(receiver.toString());</span><br><span class="line">        logger.info(<span class="string">&quot;开始执行宏命令！&quot;</span>);</span><br><span class="line">        Command macroCommand = <span class="keyword">new</span> MacroTVCommand(<span class="keyword">new</span> ArrayList&lt;Command&gt;() &#123;</span><br><span class="line">            &#123;</span><br><span class="line">                add(onCommand);</span><br><span class="line">                add(nextCommand);</span><br><span class="line">                add(nextCommand);</span><br><span class="line">                add(closeCommand);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        remoteControl.addCommand(TVOperation.MACRO, macroCommand);</span><br><span class="line">        remoteControl.commandExecute(TVOperation.MACRO);</span><br><span class="line">        logger.info(receiver.toString());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/command.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/command.html</a></p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html">https://www.cnblogs.com/java-my-life/archive/2012/06/01/2526972.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>备忘录模式</title>
    <url>/2018/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="备忘录模式-Memento-Pattern"><a href="#备忘录模式-Memento-Pattern" class="headerlink" title="备忘录模式(Memento Pattern)"></a>备忘录模式(Memento Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>在不被破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。</p>
<p>又称标记（Token）模式。</p>
<p>行为型模式</p>
<span id="more"></span>

<blockquote>
<p>备忘录主要作用便是可以保存和恢复数据的相关状态。必要时可提供一个可回滚（rollback）的操作。</p>
</blockquote>
<h5 id="备忘录模式结构"><a href="#备忘录模式结构" class="headerlink" title="备忘录模式结构"></a>备忘录模式结构</h5><p>“白箱”备忘录模式：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-%E7%99%BD%E7%AE%B1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="备忘录模式-白箱结构图"></p>
<p>“黑箱”备忘录模式：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F-%E9%BB%91%E7%AE%B1%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="备忘录模式-黑箱结构图"></p>
<p>备忘录模式角色：</p>
<p>​    ◊   Originator ： 原发器(发起人角色 )。负责创建一个备忘录，用以记录当前对象的内部状态，通过也可以使用它来利用备忘录恢复内部状态。同时原发器还可以根据需要决定<code>Memento</code>存储<code>Originator</code>的哪些内部状态。</p>
<p>​    ◊   Memento： 备忘录。用于存储<code>Originator</code>的内部状态，并且可以防止<code>Originator</code>以外的对象访问<code>Memento</code>。在备忘录<code>Memento</code>中有两个接口，其中<code>Caretaker</code>只能看到备忘录中的窄接口，它只能将备忘录传递给其他对象。<code>Originator</code>可以看到宽接口，允许它访问返回到先前状态的所有数据。</p>
<p>​    ◊   Caretaker： 负责人(备忘录管理员角色)。负责保存好备忘录，不能对备忘录的内容进行操作和访问，只能够将备忘录传递给其他对象。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>备忘录模式实现了内部状态的封装，除了创建它的原发器之外其他对象都不能够访问它。</p>
<p>  在备忘录模式中，最重要的就是备忘录<code>Memento</code>了。我们都是备忘录中存储的就是原发器的部分或者所有的状态信息，而这些状态信息是不能够被其他对象所访问了，也就是说我们是不可能在备忘录之外的对象来存储这些状态信息，如果暴漏了内部状态信息就违反了封装的原则，故备忘录是除了原发器外其他对象都是不可以访问的。</p>
<blockquote>
<p>备忘录：</p>
<p>对原发器：可以访问备忘录里的所有信息。</p>
<p>对负责人：不可以访问备忘录里面的数据，但是他可以保存备忘录并且可以将备忘录传递给其他对象。</p>
<p>其他对象：不可访问也不可以保存，它只负责接收从负责人那里传递过来的备忘录同时恢复原发器的状态。</p>
<p>所以就备忘录模式而言理想的情况就是只允许生成该备忘录的那个原发器访问备忘录的内部状态。</p>
</blockquote>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>给用户提供了一种可以恢复状态的机制（实现新的封装和提供了状态恢复的实现机制）。可以是用户能够比较方便地回到某个历史的状态。</li>
<li>实现了信息的封装。使得用户不需要关心状态的保存细节。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>资源消耗过大。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>需要保存一个对象在某一个时刻的状态或部分状态，即需要保存和恢复数据的相关状态场景</li>
<li>提供一个可回滚（<code>rollback</code>）的操作。</li>
<li>如果用一个接口来让其他对象得到这些状态，将会暴露对象的实现细节并破坏对象的封装性，一个对象不希望外界直接访问其内部状态，通过中间对象可以简洁访问其内部状态</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>数据库连接的事务管理就是用的备忘录模式。</p>
</li>
<li><p>在<code>java</code>系统中，其实可以考虑使用序列化（<code>serialization</code>）机制存储系统的状态</p>
</li>
<li><p>使用备忘录模式需要注意：</p>
<ul>
<li>备忘录创建出来就要在“最近”的代码中使用，要主动管理它的生命周期，建立就要使用，不使用就要立刻删除其引用，等待垃圾回收器对它的回收处理</li>
<li>不要在频繁建立备份的场景中使用备忘录模式（比如一个<code>for</code>循环中），原因有二：一是控制不了备忘录建立的对象数量；二是大对象的建立是要消耗资源的，系统的性能需要考虑。</li>
</ul>
</li>
<li><p>“白箱”模式和”黑箱”模式的区别：</p>
<ul>
<li>“白箱”实现将发起人角色的状态存储在一个大家都看得到的地方，因此是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。因此白箱实现仍然是有意义的。 </li>
<li>备忘录角色对发起人（Originator）角色对象提供一个宽接口，而为其他对象提供一个窄接口。这样的实现叫做“黑箱实现”。 在JAVA语言中，实现双重接口的办法就是将备忘录角色类设计成发起人角色类的内部成员类。 </li>
</ul>
</li>
<li><p>多重检查点：</p>
<p>​    前面所给出的白箱和黑箱的示意性实现都是只存储一个状态的简单实现，也可以叫做只有一个检查点。常见的系统往往需要存储不止一个状态，而是需要存储多个状态，或者叫做有多个检查点。 备忘录模式可以将发起人对象的状态存储到备忘录对象里面，备忘录模式可以将发起人对象恢复到备忘录对象所存储的某一个检查点上。</p>
</li>
<li><p>”自述历史”模式</p>
<p>  所谓“自述历史”模式(<code>History-On-Self Pattern</code>)实际上就是备忘录模式的一个变种。在备忘录模式中，发起人(<code>Originator</code>)角色、负责人(<code>Caretaker</code>)角色和备忘录 (<code>Memento</code>)角色都是独立的角色。虽然在实现上备忘录类可以成为发起人类的内部成员类，但是备忘录类仍然保持作为一个角色的独立意义。在“自述历 史”模式里面，发起人角色自己兼任负责人角色。 </p>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="备忘录模式代码示例类图"></p>
<p>白箱实现：</p>
<p>Originator :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageOriginator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MessageOriginator.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageOriginator</span><span class="params">(String context, String state, String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageMemento <span class="title">saveMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MessageMemento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetMsgState</span><span class="params">(MessageMemento msgMemento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = msgMemento.getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;接收人为空，不可发送消息&quot;</span>);</span><br><span class="line">            setState(<span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;发送消息成功，接收人为：&quot;</span> + receiver + <span class="string">&quot;消息内容为：&quot;</span> + context);</span><br><span class="line">        setState(<span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Memento:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageMemento</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MessageMemento.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    MessageMemento(String state) &#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        logger.info(<span class="string">&quot;白箱备忘录保存当前状态：&quot;</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caretaker:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageCaretaker</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageMemento msgMemento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MessageMemento <span class="title">getMsgMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> msgMemento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsgMemento</span><span class="params">(MessageMemento msgMemento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgMemento = msgMemento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>黑箱实现：</p>
<p>Originator :</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgOriginator</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MessageOriginator.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MsgOriginator</span><span class="params">(String context, String state, String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">saveMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MsgMemento(state);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resetMsgState</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = ((MsgMemento) memento).getState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (receiver == <span class="keyword">null</span>) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;接收人为空，不可发送消息&quot;</span>);</span><br><span class="line">            setState(<span class="string">&quot;发送失败&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        logger.info(<span class="string">&quot;发送消息成功，接收人为：&quot;</span> + receiver + <span class="string">&quot;消息内容为：&quot;</span> + context);</span><br><span class="line">        setState(<span class="string">&quot;发送成功&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgMemento</span> <span class="keyword">implements</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MsgMemento</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.state = state;</span><br><span class="line">            logger.info(<span class="string">&quot;黑箱备忘录保存当前状态：&quot;</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.state = state;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Memento:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Memento</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Caretaker:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgCaretaker</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Memento memento;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Memento <span class="title">getMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> memento;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMemento</span><span class="params">(Memento memento)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.memento = memento;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MementoApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MementoApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SpringApplication.run(MementoApplication.class, args);</span><br><span class="line">        whiteBoxMemento();</span><br><span class="line">        blackBoxMemento();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">blackBoxMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MsgOriginator msgOriginator = <span class="keyword">new</span> MsgOriginator(<span class="string">&quot;黑箱消息：请及时签收&quot;</span>, <span class="string">&quot;待发送&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        MsgCaretaker msgCaretaker = <span class="keyword">new</span> MsgCaretaker();</span><br><span class="line">        msgCaretaker.setMemento(msgOriginator.saveMemento());</span><br><span class="line">        <span class="keyword">boolean</span> sendResult = msgOriginator.sendMessage();</span><br><span class="line">        logger.info(<span class="string">&quot;消息发送后的消息状态：&quot;</span> + msgOriginator.getState());</span><br><span class="line">        <span class="keyword">if</span> (!sendResult) &#123;</span><br><span class="line">            msgOriginator.resetMsgState(msgCaretaker.getMemento());</span><br><span class="line">            logger.info(<span class="string">&quot;回退后的消息状态：&quot;</span> + msgOriginator.getState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">whiteBoxMemento</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        MessageOriginator messageOriginator = <span class="keyword">new</span> MessageOriginator(<span class="string">&quot;白箱消息：请及时签收&quot;</span>, <span class="string">&quot;待发送&quot;</span>, <span class="keyword">null</span>);</span><br><span class="line">        MessageCaretaker messageCaretaker = <span class="keyword">new</span> MessageCaretaker();</span><br><span class="line">        messageCaretaker.setMsgMemento(messageOriginator.saveMemento());</span><br><span class="line">        <span class="keyword">boolean</span> sendResult = messageOriginator.sendMessage();</span><br><span class="line">        logger.info(<span class="string">&quot;消息发送后的消息状态：&quot;</span> + messageOriginator.getState());</span><br><span class="line">        <span class="keyword">if</span> (!sendResult) &#123;</span><br><span class="line">            messageOriginator.resetMsgState(messageCaretaker.getMsgMemento());</span><br><span class="line">            logger.info(<span class="string">&quot;回退后的消息状态：&quot;</span> + messageOriginator.getState());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://www.cnblogs.com/chenssy/p/3341526.html">https://www.cnblogs.com/chenssy/p/3341526.html</a></p>
<p><a href="https://blog.csdn.net/o279642707/article/details/60767258">https://blog.csdn.net/o279642707/article/details/60767258</a></p>
<p><a href="https://blog.csdn.net/u012124438/article/details/70473553">https://blog.csdn.net/u012124438/article/details/70473553</a></p>
<p><a href="https://blog.csdn.net/afei__/article/details/80725916">https://blog.csdn.net/afei__/article/details/80725916</a></p>
<p><a href="https://www.imooc.com/article/14517">https://www.imooc.com/article/14517</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>模板方法模式</title>
    <url>/2018/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="模板方法模式-Template-Method-Pattern"><a href="#模板方法模式-Template-Method-Pattern" class="headerlink" title="模板方法模式(Template Method Pattern)"></a>模板方法模式(Template Method Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤</p>
<p>属于：行为型模式。</p>
<span id="more"></span>

<blockquote>
<p>定义一个模板结构，将具体内容延迟到子类去实现。</p>
<p>在不改变模板结构的前提下在子类中重新定义模板中的内容。</p>
<blockquote>
<p>模板方法模式是基于”继承“的；</p>
</blockquote>
</blockquote>
<h5 id="模板方法模式结构"><a href="#模板方法模式结构" class="headerlink" title="模板方法模式结构"></a>模板方法模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="模板方法结构图"></p>
<p>模板方法模式角色：</p>
<p>​    ◊ 抽象模板(Abstract Template)：• 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。<br>​                                 • 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</p>
<p>​    ◊ 具体模板(Concrete Template)：• 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。<br>​                                   • 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是                 顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>​        模板方法模式是所有模式中最为常见的几个模式之一，是基于继承的代码复用的基本技术。</p>
<p>　　模板方法模式需要开发抽象类和具体子类的设计师之间的协作。一个设计师负责给出一个算法的轮廓和骨架，另一些设计师则负责给出这个算法的各个逻辑步骤。代表这些具体逻辑步骤的方法称做基本方法(primitive method)；而将这些基本方法汇总起来的方法叫做模板方法(template method)，这个设计模式的名字就是从此而来。</p>
<p>　　模板方法所代表的行为称为顶级行为，其逻辑称为顶级逻辑。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>提高代码复用性<br>将相同部分的代码放在抽象的父类中</li>
<li>提高了拓展性<br>将不同的代码放入不同的子类中，通过对子类的扩展增加新的行为</li>
<li>实现了反向控制<br>通过一个父类调用其子类的操作，通过对子类的扩展增加新的行为，实现了反向控制 &amp; 符合“开闭原则”</li>
</ul>
<p><strong>缺点</strong></p>
<p>引入了抽象类，每一个不同的实现都需要一个子类来实现，导致类的个数增加，从而增加了系统实现的复杂度。</p>
<p><strong>算法骨架不容易升级</strong> ：模板方法模式最基本的功能就是通过模板的制定，把算法骨架完全固定下来。事实上模板和子类是非常耦合的，如果要对模板中的算法骨架进行变更，可能就会要求所有相关的子类进行相应的变化。所以抽取算法骨架的时候要特别小心，尽量确保是不会变化的部分才放到模板中。</p>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现；</li>
<li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复；</li>
<li>控制子类的扩展。 </li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>模板方法会定义一个算法的大纲，然后由子类通过继承来实现其中某些步骤的内容；</p>
<p>策略模式则是通过对象组合的方式，让客户可以选择算法实现。即，使用委托来改变整个算法。</p>
</li>
<li><p>模板方法可做到代码复用，减少代码重复</p>
</li>
<li><p><strong>模板方法中还存在钩子：钩子是一种被声明在抽象类中的方法，但只要空的或默认的实现，钩子的存在，可以让子类有能力对算法的不同点进行挂钩，要不要挂钩（是否覆盖），由子类自己决定。</strong></p>
</li>
<li><p>好莱坞原则：别调用我们，我们会调用你（这个原则可以防止依赖腐败（循环调用））：将决策权放在高层模块中，以便决定如何以及何时调用底层模块</p>
<p>模板方法中应用这个原则：父类告诉子类：不要调用我们，我们会调用你</p>
<p>​</p>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="模板方法代码示例类图"></p>
<p>抽象模板(Abstract Template):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 发送消息的模板：</span></span><br><span class="line"><span class="comment"> * 1.校验参数是否正确</span></span><br><span class="line"><span class="comment"> * 2.消息存入到本地数据库</span></span><br><span class="line"><span class="comment"> * 3.发送消息</span></span><br><span class="line"><span class="comment"> * 4.回执：是否成功（钩子，是否需要回执由子类选择）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MsgTemplate.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        checkMessage(message);</span><br><span class="line">        save2DB(message);</span><br><span class="line">        send();</span><br><span class="line">        <span class="keyword">if</span> (needFeedback()) &#123;</span><br><span class="line">            feedback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(String meaage)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">save2DB</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;save message to DB! message:&quot;</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needFeedback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">feedback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;message status!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体模板(Concrete Template):</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQSender</span> <span class="keyword">extends</span> <span class="title">MsgTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(QQSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String QQ = <span class="string">&quot;QQ:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(String meaage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!meaage.contains(QQ)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        logger.error(<span class="string">&quot;校验QQ消息通过！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getQQClient();</span><br><span class="line">        logger.error(<span class="string">&quot;发送QQ消息成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getQQClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;获取到QQ消息客户端！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSSender</span> <span class="keyword">extends</span> <span class="title">MsgTemplate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SMSSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String PHONE = <span class="string">&quot;phone:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(String meaage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!meaage.contains(PHONE)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        logger.error(<span class="string">&quot;校验短信消息通过！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getSMSClient();</span><br><span class="line">        logger.error(<span class="string">&quot;发送短信消息成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 回执</span></span><br><span class="line"><span class="comment">     */</span>  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">needFeedback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getSMSClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;获取到短信消息客户端！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatSender</span> <span class="keyword">extends</span> <span class="title">MsgTemplate</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WeChatSender.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String WECHAT = <span class="string">&quot;wechat:&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">checkMessage</span><span class="params">(String meaage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!meaage.contains(WECHAT)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        logger.error(<span class="string">&quot;校验微信消息通过！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        getWeChatClient();</span><br><span class="line">        logger.error(<span class="string">&quot;发送微信消息成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">getWeChatClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.error(<span class="string">&quot;获取到微信消息客户端！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料：</p>
<p>《大话设计模式》</p>
<p>《Head Firsh 设计模式》</p>
<p><a href="https://www.jianshu.com/p/a3474f4fee57">https://www.jianshu.com/p/a3474f4fee57</a></p>
<p><a href="http://wangkuiwu.github.io/2012/10/27/design_pattern/">http://wangkuiwu.github.io/2012/10/27/design_pattern/</a></p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95">https://zh.wikipedia.org/wiki/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>观察者模式</title>
    <url>/2018/10/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="观察者模式-ObserverPattern"><a href="#观察者模式-ObserverPattern" class="headerlink" title="观察者模式(ObserverPattern)"></a>观察者模式(ObserverPattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>定义对象之间的一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新</p>
<p>又叫发布-订阅（Publish/Subscribe）模式</p>
<p>对象行为型模式</p>
<span id="more"></span>

<blockquote>
<p>观察者模式对应了对象之间一对多的关系</p>
<p>观察者和被观察者之间用松耦合方式实现，被观察者不知道观察者的细节，只知道观察者实现了观察者接口</p>
<p>有多个观察者时，不可以依赖特定的通知次序</p>
</blockquote>
<h5 id="观察者模式结构"><a href="#观察者模式结构" class="headerlink" title="观察者模式结构"></a>观察者模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="观察者模式结构图"></p>
<p>观察者模式角色：</p>
<p>​    ◊  Subject: 目标，目标又称为主题，它是指被观察的对象</p>
<p>​    ◊  ConcreteSubject: 具体目标，目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知</p>
<p>​    ◊  Observer: 观察者，将对观察目标的改变做出反应</p>
<p>​    ◊  ConcreteObserver: 具体观察者，维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><ul>
<li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li>
<li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li>
<li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为发布-订阅(publishsubscribe)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li>
<li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li>
<li>观察者模式支持广播通信。</li>
<li>观察者模式符合“开闭原则”的要求。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li>
<li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li>
<li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li>
<li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li>
<li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li>
<li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>扩展：MVC模式<ul>
<li>MVC模式是一种架构模式，它包含三个角色：模型(Model)，视图(View)和控制器(Controller)。观察者模式可以用来实现MVC模式，观察者模式中的观察目标就是MVC模式中的模型(Model)，而观察者就是MVC中的视图(View)，控制器(Controller)充当两者之间的中介者(Mediator)。当模型层的数据发生改变时，视图层将自动改变其显示内容。</li>
</ul>
</li>
<li>在JDK的java.util包中，提供了Observable类以及Observer接口，它们构成了Java语言对观察者模式的支持。</li>
<li>此模式也被应用在很多地方：比如JavaBeans、RMI</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图（包含两种：主题和观察者自定义的和从util包中集成的）</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="观察者模式代码示例类图"></p>
<p>  Subject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSubject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> List&lt;CustomObserver&gt; observerList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(CustomObserver observer)</span> </span>&#123;</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(CustomObserver observer)</span> </span>&#123;</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (CustomObserver observer : observerList) &#123;</span><br><span class="line">            observer.update();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">subjectChange</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ConcreteSubject</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承自自定义的主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgSubject</span> <span class="keyword">extends</span> <span class="title">CustomSubject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MsgSubject.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MsgSubject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        observerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subjectChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;消息已成功发送，可修改状态&quot;</span>);</span><br><span class="line">        notifyObserver();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承自util包中的主题</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgSubjectImplUtil</span> <span class="keyword">extends</span> <span class="title">Observable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subjectChange</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setChanged();</span><br><span class="line">        notifyObservers();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Observer</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CustomObserver</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ConcreteObserver</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//继承自自定义的观察者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQObserver</span> <span class="keyword">implements</span> <span class="title">CustomObserver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(QQObserver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;QQ状态已更新&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatObserver</span> <span class="keyword">implements</span> <span class="title">CustomObserver</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(WeChatObserver.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;微信消息状态已更新&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承自util包中的观察者</span></span><br><span class="line"><span class="comment">//并且observer里面含有被观察者的引用：可以自己将自己注册进去</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SMSObserver.class);</span><br><span class="line">    <span class="keyword">private</span> MsgSubjectImplUtil msgSubjectImplUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SMSObserver</span><span class="params">(MsgSubjectImplUtil msgSubjectImplUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgSubjectImplUtil=msgSubjectImplUtil;</span><br><span class="line">        <span class="keyword">this</span>.msgSubjectImplUtil.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;短信状态更新&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyLetterObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(FlyLetterObserver.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MsgSubjectImplUtil msgSubjectImplUtil;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FlyLetterObserver</span><span class="params">(MsgSubjectImplUtil msgSubjectImplUtil)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgSubjectImplUtil=msgSubjectImplUtil;</span><br><span class="line">        <span class="keyword">this</span>.msgSubjectImplUtil.addObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;飞信状态更新&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>外部调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ObserverApplication.class, args);</span><br><span class="line">        <span class="comment">//1.观察者模式：自定义的变化主题和观察者</span></span><br><span class="line">        CustomSubject subject = <span class="keyword">new</span> MsgSubject();</span><br><span class="line">        subject.attach(<span class="keyword">new</span> QQObserver());</span><br><span class="line">        subject.attach(<span class="keyword">new</span> WeChatObserver());</span><br><span class="line">        subject.subjectChange();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.观察者模式：使用JDK util中的被观察者类和观察者接口</span></span><br><span class="line">        <span class="comment">//此处没有使用  Observable observable=new MsgSubjectImplUtil();</span></span><br><span class="line">        <span class="comment">//因为 改变状态的接口是非static的且为protected，所以此处直接使用了子类</span></span><br><span class="line">        MsgSubjectImplUtil msgSubject = <span class="keyword">new</span> MsgSubjectImplUtil();</span><br><span class="line">        <span class="comment">// observer里面含有被观察者的引用：可以自己将自己注册进去</span></span><br><span class="line">        <span class="keyword">new</span> SMSObserver(msgSubject);</span><br><span class="line">        <span class="keyword">new</span> FlyLetterObserver(msgSubject);</span><br><span class="line">        msgSubject.subjectChange();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/observer.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>状态模式</title>
    <url>/2018/12/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="状态模式-State-Pattern"><a href="#状态模式-State-Pattern" class="headerlink" title="状态模式(State Pattern)"></a>状态模式(State Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。</p>
<p>其别名为状态对象<code>(Objects for States)</code></p>
<p>状态模式是一种对象行为型模式。</p>
<p>行为型模式</p>
<span id="more"></span>

<blockquote>
<p>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</p>
<p>行为会随着内部状态而改变，就是一个请求，当前对象的状态不同而得到不同的结果</p>
<p>“看起来好像修改了她的类”：从客户角度来看：如果你使用的对象能够完全改变他的行为，那么你会觉得，这个对象实际上是从别的类实例化而来的，然而事实上，这是使用组合通过简单引用不同的状态对象来造成类改变的假象</p>
</blockquote>
<h5 id="状态模式结构"><a href="#状态模式结构" class="headerlink" title="状态模式结构"></a>状态模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="状态模式结构图"></p>
<p>状态模式角色：</p>
<p>​    ◊  Context: 环境类，又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；（<code>Context</code> 会将行为委托给当前状态对象）</p>
<p>​    ◊  State: 抽象状态类：用于定义一个接口以封装与环境类的一个特定状态相关的行为；</p>
<p>​    ◊  ConcreteState: 具体状态类：是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><ul>
<li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li>
<li>状态模式的关键是引入了一个抽象类来专门表示对象的状态，这个类我们叫做抽象状态类，而对象的每一种具体状态类都继承了该类，并在不同具体状态类中实现了不同状态的行为，包括各种状态之间的转换。</li>
</ul>
<p>在状态模式结构中需要理解环境类与抽象状态类的作用：</p>
<ul>
<li>环境类实际上就是拥有状态的对象，环境类有时候可以充当状态管理器(<code>State Manager</code>)的角色，可以在环境类中对状态进行切换操作。</li>
<li>抽象状态类可以是抽象类，也可以是接口，不同状态类就是继承这个父类的不同子类，状态类的产生是由于环境类存在多个状态，同时还满足两个条件： 这些状态经常需要切换，在不同的状态下对象的行为不同。因此可以将不同对象下的行为单独提取出来封装在具体的状态类中，使得环境类对象在其内部状态改变时可以改变它的行为，对象看起来似乎修改了它的类，而实际上是由于切换到不同的具体状态类实现的。由于环境类可以设置为任一具体状态类，因此它针对抽象状态类进行编程，在程序运行时可以将任一具体状态类的对象设置到环境类中，从而使得环境类可以改变内部状态，并且改变行为。</li>
</ul>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>封装了转换规则。</li>
<li>枚举可能的状态，在枚举状态之前需要确定状态种类。</li>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
<li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。</li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为。</li>
<li>代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。在这些条件语句中包含了对象的行为，而且这些条件对应于对象的各种状态。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>共享状态</p>
<ul>
<li>在有些情况下多个环境对象需要共享同一个状态，如果希望在系统中实现多个环境对象实例共享一个或多个状态对象，那么需要将这些状态对象定义为环境的静态成员对象。</li>
</ul>
</li>
<li><p>简单状态模式与可切换状态的状态模式</p>
<ul>
<li>简单状态模式：简单状态模式是指状态都相互独立，状态之间无须进行转换的状态模式，这是最简单的一种状态模式。对于这种状态模式，每个状态类都封装与状态相关的操作，而无须关心状态的切换，可以在客户端直接实例化状态类，然后将状态对象设置到环境类中。如果是这种简单的状态模式，它遵循“开闭原则”，在客户端可以针对抽象状态类进行编程，而将具体状态类写到配置文件中，同时增加新的状态类对原有系统也不造成任何影响。</li>
<li>可切换状态的状态模式：大多数的状态模式都是可以切换状态的状态模式，在实现状态切换时，在具体状态类内部需要调用环境类<code>Context</code>的<code>setState()</code> 方法进行状态的转换操作，在具体状态类中可以调用到环境类的方法，因此状态类与环境类之间通常还存在关联关系或者依赖关系。通过在状态类中引用环境类的对象来回调环境类的<code>setState()</code>方法实现状态的切换。在这种可以切换状态的状态模式中，增加新的状态类可能需要修改其他某些状态类甚至环境类的源代码，否则系统无法切换到新增状态。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ConcreteState不是一定要决定下一个状态是什么，Context也可以决定状态转换的流向，一般来说，当状态转换是固定的就是适合放在Context中</span><br></pre></td></tr></table></figure>

<p>​</p>
</li>
<li><p>状态模式和责任链模式的区别</p>
<p>​     <strong>状态模式</strong>是让各个状态对象自己知道其下一个处理的对象是谁，即在编译时便设定。相当于If ，else-if，else-if……， 设计思路是把逻辑判断转移到各个State类的内部实现(相当于If，else If)，执行时客户端通过调用环境—<code>Context</code>类的方法来间接执行状态类的行为，客户端不直接和状态交互。<br>​      <strong>职责链模式</strong>中的各个对象并不指定其下一个处理的对象到底是谁，只有在客户端才设定某个类型的链条，请求发出后穿越链条，直到被某个职责类处理或者链条结束。本质相当于swich-case，设计思路是把各个业务逻辑判断封装到不同职责类，且携带下一个职责的对应引用，但不像状态模式那样需要明确知道这个引用指向谁，而是在环境类设置链接方式或者过程。使用时，向链的第一个子类的执行方法传递参数就可以。客户端去通过环境类调用责任链，全自动运转起来。</p>
</li>
<li><p>状态模式和策略模式的区别（最重要的差别在于 <strong>意图</strong>）</p>
<ul>
<li>环境角色的职责不同</li>
</ul>
<p>两者都有一个叫做Context环境角色的类，但是两者的区别很大，策略模式的环境角色只是一个委托作用，负责算法的替换；而状态模式的环境角色不仅仅是委托行为，它还具有登记状态变化的功能，与具体的状态类协作，共同完成状态切换行为随之切换的任务。</p>
<ul>
<li>解决问题的重点不同</li>
</ul>
<p>策略模式旨在解决内部算法如何改变的问题，也就是将内部算法的改变对外界的影响降低到最小，它保证的是算法可以自由地切换；而状态模式旨在解决内在状态的改变而引起行为改变的问题，它的出发点是事物的状态，封装状态而暴露行为，一个对象的状态改变，从外界来看就好像是行为改变。</p>
<ul>
<li>解决问题的方法不同</li>
</ul>
<p>策略模式只是确保算法可以自由切换，但是什么时候用什么算法它决定不了；而状态模式对外暴露的是行为，状态的变化一般是由环境角色和具体状态共同完成的，也就是说状态模式封装了状态的变化而暴露了不同的行为或行为结果。</p>
<ul>
<li>应用场景不同</li>
</ul>
<p>两者都能实现前面例子中的场景，但并不表示两者的应用场景相同，这只是为了更好地展示出两者的不同而设计的一个场景。我们来想一下策略模式和状态模式的使用场景有什么不同，策略模式只是一个算法的封装，可以是一个有意义的对象，也可以是一个无意义的逻辑片段，比如MD5加密算法，它是一个有意义的对象吗？不是，它只是我们数学上的一个公式的相关实现，它是一个算法，同时DES算法、RSA算法等都是具体的算法，也就是说它们都是一个抽象算法的具体实现类，从这点来看策略模式是一系列平行的、可相互替换的算法封装后的结果，这就限定了它的应用场景：算法必须是平行的，否则策略模式就封装了一堆垃圾，产生了“坏味道”。状态模式则要求有一系列状态发生变化的场景，它要求的是有状态且有行为的场景，也就是一个对象必须具有二维（状态和行为）描述才能采用状态模式，如果只有状态而没有行为，则状态的变化就失去了意义。</p>
<ul>
<li>复杂度不同</li>
</ul>
<p>通常策略模式比较简单，这里的简单指的是结构简单，扩展比较容易，而且代码也容易阅读。当然，一个具体的算法也可以写得很复杂，只有具备很高深的数学、物理等知识的人才可以看懂，这也是允许的，我们只是说从设计模式的角度来分析，它是很容易被看懂的。而状态模式则通常比较复杂，因为它要从两个角色看到一个对象状态和行为的改变，也就是说它封装的是变化，要知道变化是无穷尽的，因此相对来说状态模式通常都比较复杂，涉及面很多，虽然也很容易扩展，但是一般不会进行大规模的扩张和修正。</p>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="状态模式代码示例类图"></p>
<p> State: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgState</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(MsgContext msgContext, MsgSendState msgSendState)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ConcreteState: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgFailState</span> <span class="keyword">extends</span> <span class="title">MsgState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MsgFailState.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(MsgContext msgContext, MsgSendState msgSendState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MsgSendState.FAIL.equals(msgSendState)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;消息当前的发送状态为失败&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前的状态不是失败，设置状态为成功&quot;</span>);</span><br><span class="line">            msgContext.changeState(<span class="keyword">new</span> MsgSuccessState(), msgSendState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgRetryState</span> <span class="keyword">extends</span> <span class="title">MsgState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MsgRetryState.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(MsgContext msgContext, MsgSendState msgSendState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MsgSendState.RETRY.equals(msgSendState)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;消息当前的发送状态为重试&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前的状态不是重试，设置状态为失败&quot;</span>);</span><br><span class="line">            msgContext.changeState(<span class="keyword">new</span> MsgFailState(),msgSendState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgSuccessState</span> <span class="keyword">extends</span> <span class="title">MsgState</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MsgSuccessState.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">(MsgContext msgContext, MsgSendState msgSendState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (MsgSendState.SUCCESS.equals(msgSendState)) &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;消息当前的发送状态为成功&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logger.info(<span class="string">&quot;当前的状态不是成功，设置状态为重试&quot;</span>);</span><br><span class="line">            msgContext.changeState(<span class="keyword">new</span> MsgRetryState(),msgSendState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  Context: </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MsgState msgState;</span><br><span class="line"></span><br><span class="line">    MsgContext() &#123;</span><br><span class="line">        <span class="keyword">this</span>.msgState = <span class="keyword">new</span> MsgSuccessState();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleState</span><span class="params">(MsgSendState msgSendState)</span> </span>&#123;</span><br><span class="line">        msgState.handle(<span class="keyword">this</span>, msgSendState);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeState</span><span class="params">(MsgState msgState, MsgSendState msgSendState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgState = msgState;</span><br><span class="line">        handleState(msgSendState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StateApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MsgContext msgContext = <span class="keyword">new</span> MsgContext();</span><br><span class="line">        msgContext.handleState(MsgSendState.RETRY);</span><br><span class="line">        msgContext.handleState(MsgSendState.SUCCESS);</span><br><span class="line">        msgContext.handleState(MsgSendState.FAIL);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/state.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/state.html</a></p>
<p><a href="https://www.cnblogs.com/xibei666/p/6858145.html">https://www.cnblogs.com/xibei666/p/6858145.html</a></p>
<p><a href="https://alaric.iteye.com/blog/1938400">https://alaric.iteye.com/blog/1938400</a></p>
<p><a href="https://www.kancloud.cn/sstd521/design/193631">https://www.kancloud.cn/sstd521/design/193631</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>访问者模式</title>
    <url>/2018/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="访问者模式-Visitor-Pattern"><a href="#访问者模式-Visitor-Pattern" class="headerlink" title="访问者模式(Visitor Pattern)"></a>访问者模式(Visitor Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>表示一个作用于某对象结构中的各元素的操作，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p>
<p>对象行为型模式。</p>
<span id="more"></span>

<blockquote>
<pre><code>  访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。
  为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式，这就是访问者模式的模式动机。</code></pre>
<p>  ​    首先我们要明确一点就是访问者模式适用于数据结构相对稳定的系统。它是将数据的操作与数据结构进行分离了，如果某个系统的数据结构相对稳定，但是操作算法易于变化的话，就比较适用适用访问者模式，因为访问者模式使得算法操作的增加变得比较简单了。</p>
</blockquote>
<h5 id="访问者模式结构"><a href="#访问者模式结构" class="headerlink" title="访问者模式结构"></a>访问者模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="访问者模式结构图"></p>
<p>访问者模式角色：</p>
<p>​    ◊   Vistor ：抽象访问者：为该对象结构中的<code>ConcreteElement</code>的每一个类声明的一个操作。<br>​          ◊   ConcreteVisitor ：具体访问者：实现<code>Visitor</code>申明的每一个操作，每一个操作实现算法的一部分。<br>​         ◊   Element ： 抽象元素：定义一个<code>Accept</code>操作，它以一个访问者为参数。<br>​         ◊   ConcreteElement ：具体元素 ：实现<code>Accept</code>操作。<br>​        ◊   ObjectStructure ：对象结构：能够枚举它的元素，可以提供一个高层的接口来允许访问者访问它的元素。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p> 在访问者模式中对象结构存储了不同类型的对象，以便不同的访问者来访问。从上面的<code>UML</code>结构图中我们可以看出，访问者模式主要分为两个层次结构，</p>
<p>​    一个是访问者层次结构，提供了抽象访问者和具体访问者，主要用于什么一些操作。</p>
<p>​    一个是元素层次结构，提供了抽象元素和具体元素，主要用于声明<code>Accept</code>操作。</p>
<p>​     在访问者模式中相同的访问者可以以不同的方式访问不同的元素，所以在访问者模式中增加新的访问者无需修改现有代码，可扩展行强。</p>
<p>​     同时在访问者模式用到了一种双分派的技术，所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（<code>receiver</code>）的运行时区别（<code>Run time type</code>），还要根据参数的运行时区别。在访问者模式中，客户端将具体状态当做参数传递给具体访问者，这里完成第一次分派，然后具体访问者作为参数的“具体状态”中的方法，同时也将自己<code>this</code>作为参数传递进去，这里就完成了第二次分派。双分派意味着得到的执行操作决定于请求的种类和接受者的类型。</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>使得新增新的访问操作变得更加简单。</li>
<li>能够使得用户在不修改现有类的层次结构下，定义该类层次结构的操作。</li>
<li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散搞一个个的元素类中。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，违背了“开闭原则”的要求。 </li>
<li>破坏封装。当采用访问者模式的时候，就会打破组合类的封装。</li>
<li>比较难理解。貌似是最难的设计模式了。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li>
<li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>.访问者模式有两个特点</p>
<ul>
<li><p>一般被访问的东西所持有的方法是固定的，就像账单只有收入和支出两个功能。而访问者是不固定的。</p>
<blockquote>
<p>访问者模式封装了对象结构元素之上的操作，使得新增元素的操作变得非常简单。所以它比较适用于那么对象结构很少变化的类。</p>
</blockquote>
</li>
<li><p>数据操作与数据结构相分离：频繁的更改数据，但不结构不变。比如：虽然每一天账单的数据都会变化（数据变化），但是只有两类数据，就是支出和收入（结构不变）</p>
<blockquote>
<p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。  </p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="访问者模式代码示例类图"></p>
<p>Vistor ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMessageVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitQQClient</span><span class="params">(QQElement qqElement)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitWeChatClient</span><span class="params">(WeChatElement weChatElement)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitSMSClient</span><span class="params">(SMSElement smsElement)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ConcreteVisitor ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodVisitor</span> <span class="keyword">implements</span> <span class="title">IMessageVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_FORMAT = <span class="string">&quot;设置%s，采用的发送方式为：%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(MethodVisitor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitQQClient</span><span class="params">(QQElement qqElement)</span> </span>&#123;</span><br><span class="line">        qqElement.setMethod(<span class="string">&quot;异步发送，启用重试机制&quot;</span>);</span><br><span class="line">        String qqMethod = String.format(MESSAGE_FORMAT, qqElement.getName(), qqElement.getMethod());</span><br><span class="line">        logger.info(qqMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitWeChatClient</span><span class="params">(WeChatElement weChatElement)</span> </span>&#123;</span><br><span class="line">        weChatElement.setMethod(<span class="string">&quot;异步发送，启用重试机制&quot;</span>);</span><br><span class="line">        String weChatMethod = String.format(MESSAGE_FORMAT, weChatElement.getName(), weChatElement.getMethod());</span><br><span class="line">        logger.info(weChatMethod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSMSClient</span><span class="params">(SMSElement smsElement)</span> </span>&#123;</span><br><span class="line">        smsElement.setMethod(<span class="string">&quot;同步发送&quot;</span>);</span><br><span class="line">        String smsMethod = String.format(MESSAGE_FORMAT, smsElement.getName(), smsElement.getMethod());</span><br><span class="line">        logger.info(smsMethod);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeVisitor</span> <span class="keyword">implements</span> <span class="title">IMessageVisitor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_FORMAT = <span class="string">&quot;设置%s，主题为：%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(ThemeVisitor.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitQQClient</span><span class="params">(QQElement qqElement)</span> </span>&#123;</span><br><span class="line">        qqElement.setTheme(<span class="string">&quot;QQ独家活动&quot;</span>);</span><br><span class="line">        String qqTheme = String.format(MESSAGE_FORMAT, qqElement.getName(), qqElement.getTheme());</span><br><span class="line">        logger.info(qqTheme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitWeChatClient</span><span class="params">(WeChatElement weChatElement)</span> </span>&#123;</span><br><span class="line">        weChatElement.setTheme(<span class="string">&quot;微信独家活动&quot;</span>);</span><br><span class="line">        String weChatTheme = String.format(MESSAGE_FORMAT, weChatElement.getName(), weChatElement.getTheme());</span><br><span class="line">        logger.info(weChatTheme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitSMSClient</span><span class="params">(SMSElement smsElement)</span> </span>&#123;</span><br><span class="line">        smsElement.setTheme(<span class="string">&quot;短信独家活动&quot;</span>);</span><br><span class="line">        String smsTheme = String.format(MESSAGE_FORMAT, smsElement.getName(), smsElement.getTheme());</span><br><span class="line">        logger.info(smsTheme);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Element ： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageElement</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String method;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String theme;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMethod</span><span class="params">(String method)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> theme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTheme</span><span class="params">(String theme)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.theme = theme;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IMessageVisitor messageVisitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>ConcreteElement ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQElement</span> <span class="keyword">extends</span> <span class="title">MessageElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">QQElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setName(<span class="string">&quot;QQ消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IMessageVisitor messageVisitor)</span> </span>&#123;</span><br><span class="line">        messageVisitor.visitQQClient(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSElement</span> <span class="keyword">extends</span> <span class="title">MessageElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SMSElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setName(<span class="string">&quot;短信消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IMessageVisitor messageVisitor)</span> </span>&#123;</span><br><span class="line">        messageVisitor.visitSMSClient(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatElement</span> <span class="keyword">extends</span> <span class="title">MessageElement</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeChatElement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setName(<span class="string">&quot;微信消息&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(IMessageVisitor messageVisitor)</span> </span>&#123;</span><br><span class="line">        messageVisitor.visitWeChatClient(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ObjectStructure ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MessageStructure</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;MessageElement&gt; messageElements;</span><br><span class="line"></span><br><span class="line">    MessageStructure() &#123;</span><br><span class="line">        <span class="keyword">this</span>.messageElements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addMessageElement</span><span class="params">(MessageElement messageElement)</span> </span>&#123;</span><br><span class="line">        messageElements.add(messageElement);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMessageProperties</span><span class="params">(IMessageVisitor messageVisitor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (MessageElement messageElement : messageElements) &#123;</span><br><span class="line">            messageElement.accept(messageVisitor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VisitorApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MessageStructure messageStructure = <span class="keyword">new</span> MessageStructure();</span><br><span class="line">        messageStructure.addMessageElement(<span class="keyword">new</span> QQElement());</span><br><span class="line">        messageStructure.addMessageElement(<span class="keyword">new</span> WeChatElement());</span><br><span class="line">        messageStructure.addMessageElement(<span class="keyword">new</span> SMSElement());</span><br><span class="line"></span><br><span class="line">        messageStructure.setMessageProperties(<span class="keyword">new</span> ThemeVisitor());</span><br><span class="line">        messageStructure.setMessageProperties(<span class="keyword">new</span> MethodVisitor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://www.cnblogs.com/chenssy/p/3339756.html">https://www.cnblogs.com/chenssy/p/3339756.html</a></p>
<p><a href="https://blog.csdn.net/u012124438/article/details/70537203">https://blog.csdn.net/u012124438/article/details/70537203</a></p>
<p><a href="https://blog.csdn.net/cooldragon/article/details/52177273">https://blog.csdn.net/cooldragon/article/details/52177273</a></p>
<p><a href="https://www.cnblogs.com/Bobby0322/p/4201058.html">https://www.cnblogs.com/Bobby0322/p/4201058.html</a></p>
<p><a href="https://www.jianshu.com/p/80b9cd7c0da5">https://www.jianshu.com/p/80b9cd7c0da5</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>解释器模式</title>
    <url>/2018/12/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="解释器模式-Interpreter-Pattern"><a href="#解释器模式-Interpreter-Pattern" class="headerlink" title="解释器模式(Interpreter Pattern)"></a>解释器模式(Interpreter Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语句中的句子。</p>
<p>类行为型模式。</p>
<span id="more"></span>

<blockquote>
<p>比方说，我们通常在字符串中搜索匹配的字符或判断一个字符串是否符合我们规定的格式，我们会用到正则表达式，正则表达式就是解释器模式的一种应用，解释器为正则表达式定义了一个文法， 如何表示一个特定的正则表达式，以及如何解释这个正则表达式。</p>
</blockquote>
<h5 id="解释器模式结构"><a href="#解释器模式结构" class="headerlink" title="解释器模式结构"></a>解释器模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="解释器模式结构图"></p>
<p>解释器模式角色：</p>
<p>​    ◊    Abstract Expression(抽象表达式)角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p>
<p>​    ◊    Terminal Expression(终结符表达式)角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。比如公式R=R1+R2，R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。</p>
<blockquote>
<p> 实现与文法中的元素相关联的解释操作,通常一个解释器模式中只有一个终结符表达式,但有多个实例对应不同的终结符.</p>
</blockquote>
<p>​    ◊   Nonterminal Expression(非终结符表达式)角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。</p>
<p>​    ◊   Context(环境)角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p>
<p>​    ◊   Client(客户端)：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p>
<blockquote>
<p>它的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，给R1赋值100，给R2赋值200，这些信息需要存放到环境中。</p>
</blockquote>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>​    解释器模式描述了如何构成一个简单的语言解释器，主要应用在使用面向对象语言开发的编译器中。它描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。</p>
<p>​    在解释器模式中除了能够使用文法规则来定义一个语言，还有通过一个更加直观的方法来表示——使用抽象语法树。抽象语法树能够更好地，更直观地表示一个语言的构成，每一颗抽象语法树对应一个语言实例。</p>
<blockquote>
<p>   抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符和非终结符类。 在解释器模式中由于每一种终结符表达式、非终结符表达式都会有一个具体的实例与之相对应，所以系统的扩展性比较好。</p>
</blockquote>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li>可扩展性比较好，灵活。</li>
<li>增加了新的解释表达式的方式。</li>
<li>易于实现文法。</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>执行效率比较低，可利用场景比较少。</li>
<li>对于复杂的文法比较难维护。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</li>
<li>一些重复出现的问题可以用一种简单的语言来进行表达。</li>
<li>文法较为简单。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>虽然解释器的可扩展性强，但是如果语法规则的数目太大的时候，该模式可能就会变得异常复杂。所以解释器模式适用于文法较为简单的。</li>
</ul>
<ul>
<li>解释器模式可以处理脚本语言和编程语言。常用于解决某一特定类型的问题频繁发生情况。</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="解释器模式代码示例类图"></p>
<p>Abstract Expression：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Terminal Expression：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacialExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageContext context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FacialExpression</span><span class="params">(MessageContext context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context.getFacial() + <span class="string">&quot;表情&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Nonterminal Expression：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BoldExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BoldExpression</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!message.contains(SymbolContants.COLON)) &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] messageList = message.split(SymbolContants.COLON);</span><br><span class="line">        <span class="keyword">if</span> (!messageList[<span class="number">0</span>].equalsIgnoreCase(SymbolContants.BOLD)) &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.format(SymbolContants.BOLD_FORMAT, messageList[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ItalicExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ItalicExpression</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!message.contains(SymbolContants.COLON)) &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] messageList = message.split(SymbolContants.COLON);</span><br><span class="line">        <span class="keyword">if</span> (!messageList[<span class="number">0</span>].equalsIgnoreCase(SymbolContants.ITALIC)) &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.format(SymbolContants.ITALIC_FORMAT, messageList[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UrlExpression</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">interpret</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!message.contains(SymbolContants.COLON)) &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">        String[] messageList = message.split(SymbolContants.COLON);</span><br><span class="line">        <span class="keyword">if</span> (!messageList[<span class="number">0</span>].equalsIgnoreCase(SymbolContants.URL)) &#123;</span><br><span class="line">            <span class="keyword">return</span> message;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.format(SymbolContants.URL_FORMAT, messageList[<span class="number">1</span>] + messageList[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>Context：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageContext</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String facial;</span><br><span class="line"></span><br><span class="line">    MessageContext(String facial) &#123;</span><br><span class="line">        <span class="keyword">this</span>.facial = facial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFacial</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> facial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFacial</span><span class="params">(String facial)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.facial = facial;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Client：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterpreterApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(InterpreterApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String regex = <span class="string">&quot;(\\([^\\)]*\\))&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Pattern pattern = Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String message = <span class="string">&quot;您在本次(I:幸运转转)的抽奖活动中，被抽中为(B:幸运观众)，并且已获得(B:二等奖),请登录(url:http://zhangyuying.cn)领取。&quot;</span>;</span><br><span class="line">        List&lt;String&gt; convertMessage = extractMessageByRegular(message);</span><br><span class="line">        <span class="keyword">for</span> (String convertMsg : convertMessage) &#123;</span><br><span class="line">            Expression expression = symbolFactory(convertMsg);</span><br><span class="line">            String interpretMessage = expression.interpret();</span><br><span class="line">            message = message.replace(String.format(SymbolContants.BRACKETS_FORMAT, convertMsg), interpretMessage);</span><br><span class="line">        &#125;</span><br><span class="line">        MessageContext context = <span class="keyword">new</span> MessageContext(<span class="string">&quot;撒花&quot;</span>);</span><br><span class="line">        message += <span class="keyword">new</span> FacialExpression(context).interpret();</span><br><span class="line">        logger.info(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">extractMessageByRegular</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Matcher m = pattern.matcher(msg);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            list.add(m.group().substring(<span class="number">1</span>, m.group().length() - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Expression <span class="title">symbolFactory</span><span class="params">(String convertMsg)</span> </span>&#123;</span><br><span class="line">        String symbol = convertMsg.substring(<span class="number">0</span>, convertMsg.indexOf(SymbolContants.COLON));</span><br><span class="line">        <span class="keyword">switch</span> (symbol) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;I&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> ItalicExpression(convertMsg);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;B&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> BoldExpression(convertMsg);</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;url&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> UrlExpression(convertMsg);</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;不支持的特殊符号:&quot;</span> + symbol);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://www.cnblogs.com/chenssy/p/3346427.html">https://www.cnblogs.com/chenssy/p/3346427.html</a></p>
<p><a href="https://www.cnblogs.com/sc0791/p/3679769.html">https://www.cnblogs.com/sc0791/p/3679769.html</a></p>
<p><a href="http://c.biancheng.net/view/1402.html">http://c.biancheng.net/view/1402.html</a></p>
<p><a href="http://www.cnblogs.com/zhou-yi/p/5462663.html">http://www.cnblogs.com/zhou-yi/p/5462663.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>行为型模式</title>
    <url>/2018/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>​    行为型模式(Behavioral Pattern)是对在不同的对象之间划分责任和算法的抽象化。</p>
<p>​    行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。</p>
<p>通过行为型模式，可以更加清晰地划分类与对象的职责，并研究系统在运行时实例对象 之间的交互。在系统运行时，对象并不是孤立的，它们可以通过相互通信与协作完成某些复杂功能，一个对象在运行时也将影响到其他对象的运行。</p>
<span id="more"></span>

<p>行为型模式分为类行为型模式和对象行为型模式两种：</p>
<ul>
<li>类行为型模式：类的行为型模式使用继承关系在几个类之间分配行为，类行为型模式主要通过多态等方式来分配父类与子类的职责。</li>
<li>对象行为型模式：对象的行为型模式则使用对象的聚合关联关系来分配行为，对象行为型模式主要是通过对象关联等方式来分配两个或多个类的职责。根据“合成复用原则”，系统中要尽量使用关联关系来取代继承关系，因此大部分行为型设计模式都属于对象行为型设计模式。</li>
</ul>
<blockquote>
<p>行为型模式设计到算法和对象间的职责分配，不仅描述对象或类的模式，还描述它们之间的通信方式，刻划了运行时难以跟踪的复杂的控制流，它们将你的注意力从控制流转移到对象间的关系上来。</p>
<p>行为对象模式使用对象复合而不是继承。一些行为对象模式描述了一组相互对等的对象如何相互协作以完成其中任何一个对象都单独无法完成的任务，如Mediator、Chain of Responsibility、Strategy；其它的行为对象模式常将行为封装封装在一个对象中，并将请求指派给它。</p>
</blockquote>
<blockquote>
<p>行为型模式描述类或对象如何交互及如何分配职责，它 主要涉及通过合理的处理方法，达到使系统升级性和维护性提高的目的。</p>
</blockquote>
<ul>
<li><a href="http://zhangyuying.cn/2018/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/">职责链模式(Chain of Responsibility)</a></li>
<li><a href="http://zhangyuying.cn/2018/10/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/">命令模式(Command)</a></li>
<li><a href="http://zhangyuying.cn/2018/12/29/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/">解释器模式(Interpreter)</a></li>
<li><a href="http://zhangyuying.cn/2018/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/">迭代器模式(Iterator)</a></li>
<li><a href="http://zhangyuying.cn/2018/12/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/">中介者模式(Mediator)</a></li>
<li><a href="http://zhangyuying.cn/2018/12/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/">备忘录模式(Memento)</a></li>
<li><a href="http://zhangyuying.cn/2018/10/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/">观察者模式(Observer)</a></li>
<li><a href="http://zhangyuying.cn/2018/12/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/">状态模式(State)</a></li>
<li><a href="http://zhangyuying.cn/2018/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/">策略模式(Strategy)</a></li>
<li><a href="http://zhangyuying.cn/2018/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/">模板方法模式(Template Method)</a></li>
<li><a href="http://zhangyuying.cn/2018/12/28/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/">访问者模式(Visitor)</a></li>
</ul>
<p>参考资料：</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/structural.html">https://design-patterns.readthedocs.io/zh_CN/latest/structural_patterns/structural.html</a></p>
<p><a href="https://github.com/jiayisheji/blog/issues/2">https://github.com/jiayisheji/blog/issues/2</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>责任链模式</title>
    <url>/2018/11/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="责任链模式-Chain-of-Responsibility-Pattern"><a href="#责任链模式-Chain-of-Responsibility-Pattern" class="headerlink" title="责任链模式(Chain of Responsibility Pattern)"></a>责任链模式(Chain of Responsibility Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>
<p>行为型模式</p>
<span id="more"></span>

<blockquote>
<p>使多个对象都有机会处理请求，从而避免了请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有对象处理它为止。</p>
<p>责任链可能是一条直线、一个环链或者一个树结构的一部分。</p>
</blockquote>
<h5 id="责任链模式结构"><a href="#责任链模式结构" class="headerlink" title="责任链模式结构"></a>责任链模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="责任链模式结构图"></p>
<p>责任链模式角色：</p>
<p>​    ◊   Handler：抽象处理者<br>​    handler 定义了处理请求的接口，handler知道，下一个处理者是谁，如果自己无法处理请求，就转给下一个处理者。</p>
<p>​    ◊   concreteHandler ：具体的处理者<br>​    具体的处理者是处理请求的具体角色。具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家</p>
<p>​    ◊  Client</p>
<p>​    请求者角色，就是向第一个具体的handler发送请求的角色，并连接好责任链。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>解耦请求的发送者和接受者，并且可动态的改变链中的环节。使得每个角色更专注的处理自己的事物</p>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li><p>弱化了发出请求的人和处理请求的人之间的关系（解耦）</p>
<p>发出请求的人只需要向第一个具体的处理者发送请求，然后就可以不用管了，处理者会在责任链上自己寻找处理的方法。这样就解耦了处理者和请求者之间的关系。如果我们不采取责任链模式，那么请求者就必须要很清楚哪个处理者能处理它的请求，就必须对所有的处理者都有所了解，类似于上帝视角，然而在实际中，要求请求这了解这么多是不实际的</p>
</li>
<li><p>可以动态的改变责任链</p>
<p>责任链还有的好处就是可以动态的改变责任，删除或者添加或者改变顺序。</p>
</li>
<li><p>让各个处理者专注于实现自己的职责</p>
<p>责任链模式同时还做到了处理者之间的解耦，处理者自己专注于自己的处理逻辑就好，不管其他处理者干什么。</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>推卸责任也可能导致处理延迟<br>我们可以责任链模式需要在责任链上传播责任，直至找到合适的处理对象。这样提高了程序的灵活性，但同时也出现了处理的延迟，因为有一个寻找的过程。所以需要低延迟的情况下，就不应该使用责任链模式</li>
<li>不容易观察运行时的特征，有碍于排查错误</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>假如使用if…else…语句来组织一个责任链时感到力不从心，代码看上去很糟糕时，就可以使用责任链模式来进行重构。</li>
</ul>
<ul>
<li>在视窗系统中，经常会使用到责任链模式，尤其是事件的处理，熟悉<code>javascript</code>开发的朋友，可能会知道，浏览器中的事件有冒泡机制，就是事件的是向父控件传播的，如果自己处理不了，就会传播给父控件去处理。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li>责任链模式其实就是一个灵活版的<code>if…else…</code>语句，它就是将这些判定条件的语句放到了各个处理类中，这样做的优点是比较灵活了，但同样也带来了风险，比如设置处理类前后关系时，一定要特别仔细，搞对处理类前后逻辑的条件判断关系，并且注意不要在链中出现循环引用的问题。</li>
<li>纯责任链模式和不纯的责任链模式：<ul>
<li>如果一个类要么承担责任处理请求要么将请求踢给下一个皮球，则被称为纯责任链模式。</li>
<li>如果一个类承担了一部分责任，还将请求踢给下一个皮球，则被称为不纯的责任链模式。（常用一些）</li>
</ul>
</li>
<li><code>Tomcat</code>中的<code>Filter</code>就是使用了责任链模式</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>责任链模式代码示例类图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="责任链模式代码示例类图"></p>
<p>​    </p>
<p>Handler：抽象处理者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> MessageHandler messageHandler;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Message message)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">nextSendMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (messageHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">            messageHandler.sendMessage(message);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;责任链的下一个接受者为空&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setMessageHandler</span><span class="params">(MessageHandler messageHandler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageHandler = messageHandler;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> concreteHandler ：具体的处理者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQMessageHandler</span> <span class="keyword">extends</span> <span class="title">MessageHandler</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ChainContants.MESSAGE_TYPE_QQ.equals(message.getType())) &#123;</span><br><span class="line">            System.out.println(ChainContants.getFormatResult(message));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(ChainContants.getUnHandlerFormat(ChainContants.MESSAGE_TYPE_QQ, message));</span><br><span class="line">            nextSendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SMSMessageHandler</span> <span class="keyword">extends</span> <span class="title">MessageHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ChainContants.MESSAGE_TYPE_SMS.equals(message.getType())) &#123;</span><br><span class="line">            System.out.println(ChainContants.getFormatResult(message));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(ChainContants.getUnHandlerFormat(ChainContants.MESSAGE_TYPE_SMS,message));</span><br><span class="line">            nextSendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatMessageHandler</span> <span class="keyword">extends</span> <span class="title">MessageHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ChainContants.MESSAGE_TYPE_WECHAT.equals(message.getType())) &#123;</span><br><span class="line">            System.out.println(ChainContants.getFormatResult(message));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(ChainContants.getUnHandlerFormat(ChainContants.MESSAGE_TYPE_WECHAT, message));</span><br><span class="line">            nextSendMessage(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> Client</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainOfResponsibilityApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MessageHandler messageChain = <span class="keyword">new</span> QQMessageHandler();</span><br><span class="line">        MessageHandler weChatMessageHandler = <span class="keyword">new</span> WeChatMessageHandler();</span><br><span class="line">        MessageHandler smsMessageHandler = <span class="keyword">new</span> SMSMessageHandler();</span><br><span class="line"></span><br><span class="line">        smsMessageHandler.setMessageHandler(messageChain);</span><br><span class="line">        weChatMessageHandler.setMessageHandler(smsMessageHandler);</span><br><span class="line">        messageChain.setMessageHandler(weChatMessageHandler);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送短信消息---&quot;</span>);</span><br><span class="line">        Message smsMessage = buildMessage();</span><br><span class="line">        smsMessage.setType(ChainContants.MESSAGE_TYPE_SMS);</span><br><span class="line">        messageChain.sendMessage(smsMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送微信消息---&quot;</span>);</span><br><span class="line">        Message weChatMessage = buildMessage();</span><br><span class="line">        weChatMessage.setType(ChainContants.MESSAGE_TYPE_WECHAT);</span><br><span class="line">        messageChain.sendMessage(weChatMessage);</span><br><span class="line">        System.out.println(<span class="string">&quot;开始发送QQ消息---&quot;</span>);</span><br><span class="line">        Message qqMessage = buildMessage();</span><br><span class="line">        qqMessage.setType(ChainContants.MESSAGE_TYPE_QQ);</span><br><span class="line">        messageChain.sendMessage(qqMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">buildMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Message message = <span class="keyword">new</span> Message();</span><br><span class="line">        message.setContext(<span class="string">&quot;这是消息的内容&quot;</span>);</span><br><span class="line">        message.setReceiver(<span class="string">&quot;接收人&quot;</span>);</span><br><span class="line">        message.setSender(<span class="string">&quot;发送人&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Message</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String sender;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String receiver;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setType</span><span class="params">(String type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(String context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSender</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSender</span><span class="params">(String sender)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sender = sender;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getReceiver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> receiver;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setReceiver</span><span class="params">(String receiver)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.receiver = receiver;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainContants</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_TYPE_QQ = <span class="string">&quot;QQ&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_TYPE_WECHAT = <span class="string">&quot;微信&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE_TYPE_SMS = <span class="string">&quot;短信&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String resultFormat = <span class="string">&quot;%s 客户端发送 %s消息成功，消息内容：%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String unHandlerFormat = <span class="string">&quot;不是%s类型消息，%s客户端不处理!消息类型为：%s&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getFormatResult</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(ChainContants.resultFormat, message.getType(), message.getType(), message.getContext());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getUnHandlerFormat</span><span class="params">(String currentType, Message message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> String.format(ChainContants.unHandlerFormat, currentType, currentType, message.getType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html">https://www.cnblogs.com/java-my-life/archive/2012/05/28/2516865.html</a></p>
<p><a href="https://www.jianshu.com/p/198a29556f30">https://www.jianshu.com/p/198a29556f30</a></p>
<p><a href="http://wiki.jikexueyuan.com/project/java-design-pattern/chain-responsibility-pattern.html">http://wiki.jikexueyuan.com/project/java-design-pattern/chain-responsibility-pattern.html</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>策略模式</title>
    <url>/2018/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="策略模式-Strategy-Pattern"><a href="#策略模式-Strategy-Pattern" class="headerlink" title="策略模式(Strategy Pattern)"></a>策略模式(Strategy Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>定义一系列算法，将每个算法封装到具有公共接口的一系列策略类中，从而使它们可以相互替换 &amp; 让算法可在不影响客户端的情况下发生变化</p>
<p>也称为政策模式(Policy)。</p>
<p>对象行为型模式</p>
<span id="more"></span>

<blockquote>
<p>简单来说：准备一组算法 &amp; 将每一个算法封装起来，让外部按需调用 &amp; 可以互换</p>
</blockquote>
<blockquote>
<p>策略模式指对象有某个行为，但是在不同的场景中，该行为有不同的实现算法。</p>
<ul>
<li>定义了一族算法（业务规则）；</li>
<li>封装了每个算法；</li>
<li>这族的算法可互换代替（interchangeable）。</li>
</ul>
</blockquote>
<h5 id="策略模式结构"><a href="#策略模式结构" class="headerlink" title="策略模式结构"></a>策略模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.jpg" alt="策略模式结构图"></p>
<p>策略模式角色：</p>
<p>​    ◊  Context: 环境类</p>
<p>​    ◊  Strategy: 抽象策略类</p>
<p>​    ◊  ConcreteStrategy: 具体策略类</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>将算法的责任和本身进行解耦，使得：</p>
<ol>
<li>算法可独立于使用外部而变化</li>
<li>客户端方便根据外部条件选择不同策略来解决不同问题</li>
</ol>
<blockquote>
<p>策略模式仅仅封装算法（包括添加 &amp; 删除），但策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定</p>
</blockquote>
<blockquote>
<ol>
<li>策略模式的主要目的是将算法的定义与使用分开，也就是将算法的行为和环境分开</li>
<li>动态改变算法(热插拔)</li>
<li>算法可以重用(模板方法中算法不可重用)</li>
</ol>
</blockquote>
<h5 id="模式优缺点"><a href="#模式优缺点" class="headerlink" title="模式优缺点"></a>模式优缺点</h5><p><strong>优点</strong></p>
<ul>
<li><p>策略类之间可以自由切换<br>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p>
</li>
<li><p>易于扩展<br>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p>
</li>
<li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。​</p>
</li>
</ul>
<blockquote>
<p>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。</p>
<p>策略模式提供了管理相关的算法族的办法。</p>
<p>策略模式提供了可以替换继承关系的办法。</p>
<p>使用策略模式可以避免使用多重条件转移语句。</p>
</blockquote>
<p><strong>缺点</strong></p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>
</ul>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li>
<li>一个系统需要动态地在几种算法中选择一种。</li>
<li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li>
<li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li>
</ul>
<blockquote>
<p>动态选择多种复杂行为,该行为可理解为：</p>
<ol>
<li>复杂的算法 / 数据结构</li>
<li>类的行为 / 方法<br>注：提高了行为的保密</li>
</ol>
</blockquote>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><ul>
<li><p>策略模式包含三个角色：</p>
<ul>
<li>环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；</li>
<li>抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；</li>
<li>具体策略类实现了在抽象策略类中定义的算法。</li>
</ul>
</li>
<li><p>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</p>
</li>
<li><p>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</p>
</li>
<li><p>策略模式与模版方法模式的区别仅仅是多了一个单独的封装类Context，它与模版方法模式的区别在于：</p>
<p>在模版方法模式中，调用算法的主体在抽象的父类中，</p>
<p>而在策略模式中，调用算法的主体则是封装到了封装类Context中，抽象策略Strategy一般是一个接口，目的只是为了定义规范，里面一般不包含逻辑。</p>
<p>其实，这只是通用实现，而在实际编程中，因为各个具体策略实现类之间难免存在一些相同的逻辑，为了避免重复的代码，我们常常使用抽象类来担任Strategy的角色，在里面封装公共的代码，因此，在很多应用的场景中，在策略模式中一般会看到模版方法模式的影子。</p>
</li>
</ul>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>代码类图</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E4%BB%A3%E7%A0%81%E7%A4%BA%E4%BE%8B%E7%B1%BB%E5%9B%BE.png" alt="策略模式代码示例类图"></p>
<p>Context: 环境类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MsgSenderContext</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IMsgSendStrategy msgSendStrategy;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MsgSenderContext</span><span class="params">(IMsgSendStrategy msgSendStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgSendStrategy = msgSendStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeSendMethod</span><span class="params">(IMsgSendStrategy msgSendStrategy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgSendStrategy = msgSendStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessageMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        msgSendStrategy.sendMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Strategy: 抽象策略类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgSendStrategy</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sendMethod</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​ ConcreteStrategy: 具体策略类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsynchronousStrategy</span> <span class="keyword">implements</span> <span class="title">IMsgSendStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(AsynchronousStrategy.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;异步方式发送消息！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizeStrategy</span> <span class="keyword">implements</span> <span class="title">IMsgSendStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(SynchronizeStrategy.class);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        logger.info(<span class="string">&quot;同步方式发送消息！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       SpringApplication.run(StrategyApplication.class, args);</span><br><span class="line">       MsgSenderContext msgSender = <span class="keyword">new</span> MsgSenderContext(<span class="keyword">new</span> AsynchronousStrategy());</span><br><span class="line">       msgSender.sendMessageMethod();</span><br><span class="line">       msgSender.changeSendMethod(<span class="keyword">new</span> SynchronizeStrategy());</span><br><span class="line">       msgSender.sendMessageMethod();</span><br><span class="line"></span><br><span class="line">       msgSender.changeSendMethod(() -&gt; &#123;</span><br><span class="line">           logger.info(<span class="string">&quot;使用java8的声明式函数发送消息！&quot;</span>);</span><br><span class="line">       &#125;);</span><br><span class="line">       msgSender.sendMessageMethod();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html">https://design-patterns.readthedocs.io/zh_CN/latest/behavioral_patterns/strategy.html</a></p>
<p><a href="https://www.jianshu.com/p/0c62bf587b9c">https://www.jianshu.com/p/0c62bf587b9c</a></p>
<p><a href="https://www.jianshu.com/p/d0c1b312d563">https://www.jianshu.com/p/d0c1b312d563</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>迭代器模式</title>
    <url>/2018/09/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A1%8C%E4%B8%BA%E5%9E%8B%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h3 id="迭代器模式-Iterator-Pattern"><a href="#迭代器模式-Iterator-Pattern" class="headerlink" title="迭代器模式(Iterator Pattern)"></a>迭代器模式(Iterator Pattern)</h3><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>提供一种方法，顺序访问一个聚合对象中各个元素，而又不暴露该对象的内部表示</p>
<p>行为型模式</p>
<span id="more"></span>

<blockquote>
<p>迭代器是为容器服务的，那什么是容器呢？ 能容纳对象的所有类型都可以称之为容器，例如Collection集合类型、Set类型等，迭代器模式就是为解决遍历这些容器中的元素而诞生的。</p>
</blockquote>
<blockquote>
<p>把游走的任务放在迭代器上，而不是聚合对象上。这样简化了聚合对象的接口和实现，也让责任各得其所。</p>
</blockquote>
<h5 id="迭代器模式结构"><a href="#迭代器模式结构" class="headerlink" title="迭代器模式结构"></a>迭代器模式结构</h5><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="迭代器模式结构图"></p>
<p>迭代器模式角色：</p>
<p>​    ◊  　抽象迭代器(Iterator)角色：此抽象角色定义出遍历元素所需的接口。</p>
<p>​    ◊  　具体迭代器(ConcreteIterator)角色：此角色实现了Iterator接口，并保持迭代过程中的游标位置。</p>
<p>​    ◊ 　 聚集(Aggregate)角色：此抽象角色给出创建迭代器(Iterator)对象的接口。迭代器模式要求聚集对象必须有一个工厂方法，也就是createIterator()方法，以向外界提供迭代器对象的实例。</p>
<p>​    ◊  　具体聚集(ConcreteAggregate)角色：实现了创建迭代器(Iterator)对象的接口，返回一个合适的具体迭代器实例。</p>
<p>​    ◊  　客户端(Client)角色：持有对聚集及其迭代器对象的引用，调用迭代子对象的迭代接口，也有可能通过迭代子操作聚集元素的增加和删除。</p>
<h5 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h5><p>迭代器模式可提供一种方法来序列访问一个聚合对象的元素，而不暴露它底层的实现。</p>
<p><strong>优点</strong></p>
<ul>
<li>简化了遍历方式，对于对象集合的遍历，还是比较麻烦的，对于数组或者有序列表，我们尚可以通过游标来取得，但用户需要在对集合了解很清楚的前提下，自行遍历对象，但是对于hash表来说，用户遍历起来就比较麻烦了。而引入了迭代器方法后，用户用起来就简单的多了。</li>
<li>可以提供多种遍历方式，比如说对有序列表，我们可以根据需要提供正序遍历，倒序遍历两种迭代器，用户用起来只需要得到我们实现好的迭代器，就可以方便的对集合进行遍历了。</li>
<li>封装性良好，用户只需要得到迭代器就可以遍历，而对于遍历算法则不用去关心。</li>
</ul>
<p><strong>缺点</strong></p>
<p>对于比较简单的遍历（像数组或者有序列表），使用迭代器方式遍历较为繁琐，大家可能都有感觉，像ArrayList，我们宁可愿意使用for循环和get方法来遍历集合。</p>
<p><strong>模式适用场景</strong>  </p>
<ul>
<li>访问一个聚合对象的内容，但却不想暴露它的内部实现。</li>
<li>为聚合对象支持所有遍历方法。</li>
<li>为遍历不同的聚合结构提供一种统一的接口（即，支持多态迭代化）。</li>
</ul>
<h5 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h5><p>迭代器模式是与集合共生共死的，一般来说，我们只要实现一个集合，就需要同时提供这个集合的迭代器，就像java中的Collection，List、Set、Map等，这些集合都有自己的迭代器。假如我们要实现一个这样的新的容器，当然也需要引入迭代器模式，给我们的容器实现一个迭代器。</p>
<p>但是，由于容器与迭代器的关系太密切了，所以大多数语言在实现容器的时候都给提供了迭代器，并且这些语言提供的容器和迭代器在绝大多数情况下就可以满足我们的需要，所以现在需要我们自己去实践迭代器模式的场景还是比较少见的，我们只需要使用语言中已有的容器和迭代器就可以了。</p>
<h4 id="代码示例："><a href="#代码示例：" class="headerlink" title="代码示例："></a>代码示例：</h4><p>示例代码均在：<a href="https://github.com/zhangyuying-cn/design-pattern">https://github.com/zhangyuying-cn/design-pattern</a></p>
<p>抽象迭代器(Iterator)角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Boolean <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体迭代器(ConcreteIterator)角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.普通实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatIterator</span> <span class="keyword">implements</span> <span class="title">IMsgIterator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WeChatAggregate msgAggregate;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer index;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeChatIterator</span><span class="params">(WeChatAggregate msgAggregate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (msgAggregate == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.msgAggregate = msgAggregate;</span><br><span class="line">        <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.size = msgAggregate.getMessages().size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Integer nextIndex = index++;</span><br><span class="line">        <span class="keyword">if</span> (nextIndex.compareTo(size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> msgAggregate.getMessages().get(nextIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Boolean <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> index.compareTo(size) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index.compareTo(size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> msgAggregate.getMessages().get(index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;当前操作元素为null!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>聚集(Aggregate)角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMsgAggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">IMsgIterator <span class="title">createIterator</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Object item)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>具体聚集(ConcreteAggregate)角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对应上方普通方式实现的迭代器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatAggregate</span> <span class="keyword">implements</span> <span class="title">IMsgAggregate</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Object&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMsgIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WeChatIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        messages.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">List <span class="title">getMessages</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> messages;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//内部类实现迭代器</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QQAggregate</span> <span class="keyword">implements</span> <span class="title">IMsgAggregate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Object&gt; messages = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IMsgIterator <span class="title">createIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QQIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(Object item)</span> </span>&#123;</span><br><span class="line">        messages.add(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">QQIterator</span> <span class="keyword">implements</span> <span class="title">IMsgIterator</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Integer index;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Integer size;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">QQIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.index = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">this</span>.size = messages.size();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Integer nextIndex = index++;</span><br><span class="line">            <span class="keyword">if</span> (nextIndex.compareTo(size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> messages.get(nextIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> index.compareTo(size) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (index.compareTo(size) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> messages.get(index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;当前操作元素为null!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端(Client)角色：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IteratorApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** logger */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger logger = LoggerFactory.getLogger(IteratorApplication.class);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        testWeChatIterator();</span><br><span class="line">        <span class="comment">//内部类实现迭代器</span></span><br><span class="line">        testQQIterator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testQQIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IMsgAggregate qqAggregate = <span class="keyword">new</span> QQAggregate();</span><br><span class="line">        qqAggregate.addItem(<span class="string">&quot;第一条微信消息&quot;</span>);</span><br><span class="line">        qqAggregate.addItem(<span class="string">&quot;QQ表情消息&quot;</span>);</span><br><span class="line">        qqAggregate.addItem(<span class="string">&quot;QQ语音消息&quot;</span>);</span><br><span class="line">        qqAggregate.addItem(<span class="string">&quot;QQ文字消息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IMsgIterator msgIterator = qqAggregate.createIterator();</span><br><span class="line">        logger.info(msgIterator.currentItem().toString());</span><br><span class="line">        <span class="keyword">while</span> (!msgIterator.isDone()) &#123;</span><br><span class="line">            logger.info(msgIterator.currentItem().toString());</span><br><span class="line">            msgIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testWeChatIterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        IMsgAggregate msgAggregate = <span class="keyword">new</span> WeChatAggregate();</span><br><span class="line">        msgAggregate.addItem(<span class="string">&quot;第一条微信消息&quot;</span>);</span><br><span class="line">        msgAggregate.addItem(<span class="string">&quot;微信表情消息&quot;</span>);</span><br><span class="line">        msgAggregate.addItem(<span class="string">&quot;微信语音消息&quot;</span>);</span><br><span class="line">        msgAggregate.addItem(<span class="string">&quot;微信文字消息&quot;</span>);</span><br><span class="line"></span><br><span class="line">        IMsgIterator msgIterator = msgAggregate.createIterator();</span><br><span class="line">        logger.info(msgIterator.currentItem().toString());</span><br><span class="line">        <span class="keyword">while</span> (!msgIterator.isDone()) &#123;</span><br><span class="line">            logger.info(msgIterator.currentItem().toString());</span><br><span class="line">            msgIterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考资料</p>
<p>《大话设计模式》</p>
<p>《Head First 设计模式》</p>
<p><a href="https://www.jianshu.com/p/3d0406a01b73">https://www.jianshu.com/p/3d0406a01b73</a></p>
<p><a href="http://dreamrunner.org/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/">http://dreamrunner.org/blog/2014/05/04/%E6%B5%85%E8%B0%88%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F11/</a></p>
<p><a href="https://www.kancloud.cn/sstd521/design/193578">https://www.kancloud.cn/sstd521/design/193578</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM参数</title>
    <url>/2019/12/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E5%8F%82%E6%95%B0/</url>
    <content><![CDATA[<p>JVM参数参考</p>
<span id="more"></span>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">-Xms512m	&#x2F;&#x2F;最小堆内存</span><br><span class="line">-Xmx2g	 &#x2F;&#x2F;最大堆内存</span><br><span class="line">-XX:MaxDirectMemorySize	&#x2F;&#x2F;直接内存容量，若是不指定取-Xmx值</span><br><span class="line">-Xss	&#x2F;&#x2F;设定每个线程的分配的内存大小</span><br><span class="line">-XX:PermSize	&#x2F;&#x2F;方法区容量</span><br><span class="line">-XX:MaxPermSize	&#x2F;&#x2F;最大方法区容量</span><br><span class="line">-XX:+HeapDumpOnOutOfMemoryError	 &#x2F;&#x2F;让虚拟机在出现内存溢出异常是Dump出当前的内存堆转储快照，以便事后分析</span><br><span class="line">-XX:HeapDumpPath&#x3D;$&#123;path&#125;	&#x2F;&#x2F;设置dump日志路径</span><br><span class="line">-XX:UseG1GC	&#x2F;&#x2F;设置垃圾收集器为G1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-Xnoclassgc 是否对类进行回收</span><br><span class="line">-verbose:class 以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading 查看类加载信息和卸载信息</span><br><span class="line">	注意：Product版本虚拟机不支持-XX:+TraceClassUnLoading</span><br><span class="line"></span><br><span class="line">-XX:MaxTenuringThreshold	新生代对象晋升到老年代年龄阈值</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM:12.Java内存模型与线程</title>
    <url>/2019/11/11/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-12-Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<p>计算机的运算速度与他的存储和通信子系统的速度差距太大，所以现代计算机会实现多任务处理，Java中实现多任务的方式即为多线程处理</p>
<span id="more"></span>

<h3 id="物理计算机的并发问题"><a href="#物理计算机的并发问题" class="headerlink" title="物理计算机的并发问题"></a>物理计算机的并发问题</h3><ol>
<li>存储设备和处理器的运算速度差距好几个数量级，所以加入一层读写速度尽可能接近运算速度的高速缓存（Cache）作为内存与处理器之前的缓冲，因此产生了缓存一致性问题，每个处理器有自己的高速缓存，又共享同一内存，保证数据一致性的问题的协议有MSI、MOSI、Synapse等。</li>
<li>内存模型：即在特定的操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象，不同架构的物理机可以拥有不一样的内存模型</li>
<li>为了处理器的运算速度充分利用，处理器会对输入的代码进行乱序执行（<code>Out-Of-Order Execution</code>）优化，处理对会在计算之后将乱序执行的结合重组，保证该结果和顺序执行的结果是一致的</li>
<li>Java虚拟机中的内存模型和指令重排序(<code>Instruction Reorder</code>)优化可以和物理计算机的进行类比</li>
</ol>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>Java内存模型（<code>Java Memory Model ,JMM</code>）来屏蔽掉各种硬件和操作系统的内存访问差异，已实现让Java程序在各种平台下都能达成一致的内存访问效果</p>
<h4 id="1-主内存与工作内存"><a href="#1-主内存与工作内存" class="headerlink" title="1.主内存与工作内存"></a>1.主内存与工作内存</h4><p>Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节（此处的变量包括了实例字段、静态字段、和构成数组对象的元素，但不包括线程私有的局部变量与方法参数）</p>
<p>Java内存模型规定了</p>
<ul>
<li><p>所有的变量都存储在主内存(<code>Main Memory</code>)中 （类比物理机，名称一样，这里指的是虚拟机内存的一部分）</p>
</li>
<li><p>每个线程还有自己的工作内存 （<code>Work Memory</code>，可类比处理器的高速缓存）</p>
</li>
<li><p>线程的工作内存中保存了该线程用到的变量的主内存副本拷贝，线程对变量的所有操作(读取、赋值等)都必须在工作内存中进行，而不能直接读写主内存中的变量，不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p>
</li>
<li><p>线程、主内存、工作内存三者交互的关系如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BA%BF%E7%A8%8B%E3%80%81%E4%B8%BB%E5%86%85%E5%AD%98%E3%80%81%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E7%9A%84%E4%BA%A4%E4%BA%92%E5%85%B3%E7%B3%BB.png" alt="线程、主内存、工作内存三者的交互关系"></p>
</li>
</ul>
<h4 id="2-内存间交互操作"><a href="#2-内存间交互操作" class="headerlink" title="2.内存间交互操作"></a>2.内存间交互操作</h4><p>关于主内存和工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型中定义了8中操作来完成</p>
<p>这8个操作是虚拟机保证原子的、不可再分的（double、long类型有例外）</p>
<ul>
<li><code>lock</code>（锁定）：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li><code>unlock</code>（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li><code>read</code>（读取）：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的<code>load</code>动作使用。</li>
<li><code>load</code>（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li><code>use</code>（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。</li>
<li><code>assign</code>（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li><code>store</code>（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li><code>write</code>（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>Java内存模型还规定了在执行上述8中基本操作时必须满足如下规则</p>
<ul>
<li>不允许<code>read</code>和<code>load</code>、<code>store</code>和<code>write</code>操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者从工作内存发起回写了但主内存不接受的情况出现。</li>
<li>不允许一个线程丢弃它的最近的<code>assign</code>操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程无原因地（没有发生过任何<code>assign</code>操作）把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化（<code>load</code>或<code>assign</code>）的变量，换句话说，就是对一个变量实施<code>use、store</code>操作之前，必须先执行过了<code>assign</code>和<code>load</code>操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行<code>lock</code>操作，但<code>lock</code>操作可以被同一条线程重复执行多次，多次执行<code>lock</code>后，只有执行相同次数的<code>unlock</code>操作，变量才会被解锁。</li>
<li>如果对一个变量执行<code>lock</code>操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行<code>load</code>或<code>assign</code>操作初始化变量的值。</li>
<li>如果一个变量事先没有被<code>lock</code>操作锁定，那就不允许对它执行<code>unlock</code>操作，也不允许去<code>unlock</code>一个被其他线程锁定住的变量。</li>
<li>对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中（执行<code>store</code>、<code>write</code>操作）。</li>
</ul>
<p>先行发生原则：是和这些定义等效的判断原则，用来确定一个访问在并发环境下是否线程安全</p>
<h4 id="3-对于volatile型变量的特殊规则"><a href="#3-对于volatile型变量的特殊规则" class="headerlink" title="3.对于volatile型变量的特殊规则"></a>3.对于volatile型变量的特殊规则</h4><ol>
<li><p>保证变量对所有线程的可见性：一个线程修改了这个变量的值，其他的线程是立即得知的</p>
<p>不符合以下场景时，仍然要通过加锁来保证原子性</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li>
<li>变量不需要和其他的状态变量共同参与不变约束</li>
</ul>
</li>
<li><p>可以禁止指令重排优化</p>
<ul>
<li>内存屏障是被插入两个 CPU 指令之间的一种指令，用来禁止处理器指令发生重排序（像屏障一样），从而保障有序性的。</li>
</ul>
</li>
</ol>
<h4 id="4-对于long和double型变量的特殊规则"><a href="#4-对于long和double型变量的特殊规则" class="headerlink" title="4.对于long和double型变量的特殊规则"></a>4.对于long和double型变量的特殊规则</h4><p>Java内存模型要求<code>lock、unlock、read、load、assign、use、store、write</code>这8个操作都具有原子性，但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性，这点就是所谓的long和double的非原子性协定（<code>Nonatomic Treatment ofdouble and long Variables</code>）。</p>
<p>但是一般商用虚拟机，几乎都是将long和double的读写操作作为原子操作对待的，所以一般不需要特殊对待，无需再过在意这个规则</p>
<h4 id="5-原子性、可见性与有序性"><a href="#5-原子性、可见性与有序性" class="headerlink" title="5.原子性、可见性与有序性"></a>5.原子性、可见性与有序性</h4><p>Java内存模型是围绕着在并发过程中如何处理原子性、可见性、有序性这三个特征来建立的</p>
<ul>
<li><p>原子性（<code>Atomicity</code>）：由Java内存模型来直接保证原子性变量的操作包括<code>read、load、assign、use、store</code>和<code>write</code>，可大致认为基本数据类型的访问读写是具备原子性的（long和double例外）</p>
</li>
<li><p>可见性（<code>Visibility</code>）：一个线程修改了共享变量的值，其他线程能够立即得知这个修改，Java中实现可见性：</p>
<ul>
<li><code>volatile</code>：保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新</li>
<li><code>synchronized</code>：“对一个变量执行<code>unlock</code>操作之前，必须先把此变量同步回主内存中(执行<code>store、write</code>操作)”这个规则保证了可见性</li>
<li><code>final</code>：被<code>final</code>修饰的字段在构造器中一旦初始化完成，其他线程就能看见<code>final</code>字段的值</li>
</ul>
</li>
<li><p>有序性（<code>Ordering</code>）：如果在本线程内观察，所有的操作都是有序的，如果在一个线程中观察另一个线程，所有的操作都是无序的，前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”现象和“工作内存与主内存同步延迟”现象</p>
<p>Java中提供了<code>volatile</code>和<code>synchronized</code>两个关键字来保证线程操作的有序性</p>
<ul>
<li><code>volatile</code>：本身包含了禁止指令重新排序的语义</li>
<li><code>synchronized</code>：保证同时只有一个线程操作，从而保证了有序性</li>
</ul>
</li>
</ul>
<h4 id="6-先行发生原则：happens-before"><a href="#6-先行发生原则：happens-before" class="headerlink" title="6.先行发生原则：happens-before"></a>6.先行发生原则：happens-before</h4><p>判断数据是否存在竞争、线程是否安全的主要依据</p>
<p>下面是Java内存模型下一些“天然的”先行发生关系，这些先行发生关系无须任何同步器协助就已经存在，可以在编码中直接使用，如果两个操作之间的关系不在此列，并且无法从下列规则推导出来的话，他们就没有顺序性保障，虚拟机可以对它们随意的进行重排序</p>
<ul>
<li>程序次序规则（<code>Program Order Rule</code>）：在一个线程内，按照程序代码顺序，书写在前面的操作先行发生于书写在后面的操作。准确地说，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构。</li>
<li>管程锁定规则（<code>Monitor Lock Rule</code>）：一个<code>unlock</code>操作先行发生于后面对同一个锁的<code>lock</code>操作。这里必须强调的是同一个锁，而“后面”是指时间上的先后顺序。</li>
<li><code>volatile</code>变量规则（<code>Volatile Variable Rule</code>）：对一个<code>volatile</code>变量的写操作先行发生于后面对这个变量的读操作，这里的“后面”同样是指时间上的先后顺序。</li>
<li>线程启动规则（<code>Thread Start Rule</code>）：Thread对象的<code>start()</code>方法先行发生于此线程的每一个动作。</li>
<li>线程终止规则（<code>Thread Termination Rule</code>）：线程中的所有操作都先行发生于对此线程的终止检测，我们可以通过<code>Thread.join()</code>方法结束、<code>Thread.isAlive()</code>的返回值等手段检测到线程已经终止执行。</li>
<li>线程中断规则（<code>Thread Interruption Rule</code>）：对线程<code>interrupt()</code>方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过<code>Thread.interrupted()</code>方法检测到是否有中断发生。</li>
<li>对象终结规则（<code>Finalizer Rule</code>）：一个对象的初始化完成（构造函数执行结束）先行发生于它的<code>finalize()</code>方法的开始。</li>
<li>传递性（<code>Transitivity</code>）：如果操作A先行发生于操作B，操作B先行发生于操作C，那就可以得出操作A先行发生于操作C的结论。</li>
</ul>
<h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><p>Java中的并发大多为多线程</p>
<h4 id="1-线程的实现"><a href="#1-线程的实现" class="headerlink" title="1.线程的实现"></a>1.线程的实现</h4><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以独立调度（线程是CPU调度的基本单位）</p>
<p>Java语言提供了在不同硬件和操作系统平台下对线程操作的统一的处理，每个<code>start()</code>且还未结束的java.lang.Thread类的实例就代表了一个线程</p>
<p>实现线程主要有3种方式：使用内核线程实现，使用用户线程实现和使用用户线程加轻量级进程混合实现</p>
<ul>
<li><p>使用内核线程实现</p>
<ul>
<li>内核线程(<code>Kernel-Level Thread,KLT</code>)就是直接由操作系统内核(<code>Kernel</code>)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器（<code>Scheduler</code>）对线程进行调度，并负责将线程的任务映射到各个处理器上</li>
<li>每个内核线程可以视为内核的一个分身，这样操作系统就有能力同事处理多件事情，支持多线程的内核就叫做多线程内核(<code>Multi-Threads Kernel</code>)</li>
<li>程序一般不会直接去使用内核线程，而是去使用内核线程的一种高级接口—轻量级进程(<code>Light Weight Process,LWP</code>),轻量级进程就是我们通常意义上所讲的线程</li>
<li>由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程，这种轻量级进程与内核线程之前1:1的关系称为一对一的线程模型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E4%BD%BF%E7%94%A8%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg"></p>
<p>优点：</p>
<p>由于内核线程的支持，每个轻量级进程都成为一个独立的调度单元，即使有一个轻量级进程在系统调用中阻塞了，也不会影响这个进程继续工作</p>
<p>缺点：</p>
<p>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用，而系统调用的代价相对较高，需要在用户态(<code>User Mode</code>)和内核态(<code>Kernel Mode</code>)中来回切换</p>
<p>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间)，因此一个系统支持轻量级进程的数量是有限的</p>
</li>
<li><p>使用用户线程实现</p>
<ul>
<li>广义上，一个线程只要不是内核线程，就可以认为是用户线程（<code>User Thread,UT</code>），狭义上，用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知线程存在的实现。</li>
<li>用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助，如果程序得当，这种线程不需要切换到内核态，因此操作是非常快速且低消耗的，也可以支持规模更大的线程数量</li>
<li>这种进程与用户线程之间1:N的关系称为一对多的线程模型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%AE%9E%E7%8E%B0.jpg"></p>
<p>优点：</p>
<p>不需要系统内核支援，快速缺低消耗</p>
<p>缺点：</p>
<p>没有系统内核支援，所有线程操作都是用户自己处理，线程创建、切换、调度、“阻塞如何处理”、“多处理器系统中如何将线程映射到其他处理器上”都是需要考虑的，因而使用用户线程实现的程序一般都比较复杂</p>
</li>
<li><p>使用用户线程加轻量级进程混合实现</p>
<ul>
<li>将内核线程与用户线程一起使用的实现方式，即存在用户线程，也存在轻量级进程</li>
<li>用户线程与轻量级进程的数量比是不定的，即为N:M的关系，称为多对多的线程模型</li>
</ul>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%E5%8A%A0%E8%BD%BB%E9%87%8F%E7%BA%A7%E8%BF%9B%E7%A8%8B%E6%B7%B7%E5%90%88%E5%AE%9E%E7%8E%B0.jpg"></p>
<p>优点：</p>
<p>用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发，</p>
<p>而操作系统提供支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级线程来完成，大大降低了整个进程被完全阻塞的风险</p>
</li>
<li><p>Java线程的实现</p>
<p>Java线程模型1.2之后为基于操作系统原生线程模型来实现，不同的平台是不一致的</p>
<p>线程模型只对线程的并发规模和操作成本产生影响，对Java程序的编码和运行过程来说，这些差异都是透明的</p>
</li>
</ul>
<h4 id="2-Java线程调度"><a href="#2-Java线程调度" class="headerlink" title="2.Java线程调度"></a>2.Java线程调度</h4><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是：</p>
<ul>
<li><p>协同式线程调度（<code>Cooperative Threads-Scheduling</code>）</p>
<p>线程的执行时间由线程本身来控制，线程把自己的工作执行完了之后，要主动通知系统切换到另外一个线程上</p>
<ul>
<li>优点：实现简单，由于线程操作对自己是控制的，所以没什么线程同步的问题</li>
<li>缺点：线程的执行时间不可控制，甚至如果一个线程编写的有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里，可能导致整个系统崩溃</li>
</ul>
</li>
<li><p>抢占式线程调度（<code>Preemptive Threads-Scheduling</code>）</p>
<p>每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定</p>
<p>（Java中，<code>Thread.yield()</code>可以让出执行时间，但是要获取执行时间的话，线程本身是没有什么办法的）</p>
<ul>
<li>优点：线程的执行时间是系统可控的，也不会有一个线程导致整个进程阻塞的问题，一个进程出现问题，可以“杀掉”，而不至于导致系统崩溃</li>
</ul>
</li>
</ul>
<p>Java使用的线程调度方式就是抢占式来实现多进程的，可以通过设置线程优先级“建议”系统多给某些线程分配一点时间，不过不是太靠谱</p>
<h4 id="3-状态转换"><a href="#3-状态转换" class="headerlink" title="3.状态转换"></a>3.状态转换</h4><p>Java语言定义5中线程状态，在任意一个时间点，一个线程只能有且只有其中的一种状态</p>
<ul>
<li>新建（<code>new</code>）：创建后尚未启动的线程处于这种状态</li>
<li>运行（<code>Runable</code>）：<code>Runable</code>包括了操作系统线程状态的<code>Running</code>和<code>Ready</code>，也就是处于此状态的线程有可能正在执行，也有可能正在等待着CPU为他分配执行时间</li>
<li>无限期等待（<code>Waiting</code>）：处于这种状态的线程不会被分配CPU执行时间，他们要等待被其他线程显示地唤醒看，以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置TimeOut参数的<code>Object.wait()</code>方法</li>
<li>没有设置TimeOut参数的<code>Thread.join()</code>方法</li>
<li><code>LockSupport.park()</code>方法</li>
</ul>
</li>
<li>限期等待（<code>Timed Waiting</code>）：处于这种状态的线程也不会被分配CPU执行时间，不过无须等待被其他线程显式的唤醒，在一定时间之后他们会由系统自动唤醒，以下方法会让线程进入限期等待状态：<ul>
<li><code>Thread.sleep()</code>方法</li>
<li>设置了TimeOut参数的<code>Object.wait()</code>方法</li>
<li>设置了TimeOut参数的<code>Thread.join()</code>方法</li>
<li><code>LockSupport.parkNanos()</code>方法</li>
<li><code>LockSupport.parkUntil()</code>方法</li>
</ul>
</li>
<li>阻塞（<code>Blokced</code>）：线程被阻塞了，“阻塞状态”与“等待状态”的区别是：”阻塞状态”在等待着获取到一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生，而“等待状态”则是在等待一段时间，或者唤醒动作的发生，在程序等待进入同步区域的时候，线程将进入这种状态</li>
<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行</li>
</ul>
<p>上述5种状态在遇到特定事件发生的时候将会互相转换，转换关系如图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%E5%85%B3%E7%B3%BB.png"></p>
<p>​</p>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-3-垃圾收集器与内存分配策略</title>
    <url>/2019/12/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-3-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</url>
    <content><![CDATA[<p>内存分配和回收指的是Java堆和方法区</p>
<span id="more"></span>

<h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><p>不可能在被任何途径使用的对象将被回收</p>
<h4 id="引用的种类："><a href="#引用的种类：" class="headerlink" title="引用的种类："></a>引用的种类：</h4><ul>
<li>强引用：普遍存在的，<code>Object obj = new Object()</code> 这类的，只要强引用还存在，GC永远不会回收掉被引用的对象</li>
<li>软引用：有用但是非必须的对象，在系统将要发生内存溢出异常之前。会把软引用对象列进回收范围进行第二次回收，这次回收还没有足够的内存，才会抛出内存溢出异常，<code>SoftReference</code> 类实现</li>
<li>弱引用：描述非必须对象，弱引用关联的对象只能生存到下一次GC发生之前，GC工作是时，无论当前内存是否足够，都会回收掉软引用关联的对象，<code>WeakReference</code>类实现</li>
<li>虚引用：也称为幽灵引用或幻影引用，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，为一个对象设置虚引用的唯一目的就是能在这个对象GC回收时收到一个系统通知，<code>PhantomRefence</code> 类实现</li>
</ul>
<h4 id="对象回收方法："><a href="#对象回收方法：" class="headerlink" title="对象回收方法："></a>对象回收方法：</h4><p>对象的回收方法有引用计数算法和可达性分析算法，如下：</p>
<p><strong>1.引用计数算法</strong></p>
<p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1，引用失效时，计数器就减1，任何时刻计数器为0的对象就是不可能再被使用的</p>
<p>此方法很难解决对象之间相互循环引用的问题</p>
<p><strong>2.可达性分析算法</strong></p>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时(即不可达)，则证明此对象是不可用的，即可回收对象</p>
<p>在Java语言中，可作为GC Roots的对象包括以下几种</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中JNI(native方法)引用的对象</li>
</ul>
<p><strong>finalize()方法：</strong></p>
<p>可达性分析算法中不可达的对象，也并非是一定会被回收的，回收一个对象要经过两次标记，第一次是可达性分析中不可达即做第一次标记，第二次是查看对象的<code>finalize()</code> 方法</p>
<p>此时如果对象没有覆盖<code>finalize()</code>方法，或者<code>finalize()</code>已经被虚拟机调用过了，就可直接回收。</p>
<p>如果需要执行<code>finalize()</code>的对象，会放置在一个叫做F-Queue的队列中，并在稍后由虚拟机自动建立的、低优先级的Finalizer线程去执行它，如果<code>finalize()</code>中对象进行自救，即可不被回收</p>
<p><code>finalize()</code> 方法一是只会被执行一次，二是并不一定能确保一定执行且执行成功，所以知道就好，尽量少用</p>
<h4 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h4><p>方法区(即Java8之前的永久代)，垃圾收集效率较低，主要回收两部分内容：废弃常量和无用的类，</p>
<p>一个类满足以下3个条件才达到可回收的条件：</p>
<ol>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例</li>
<li>加载该类的<code>ClassLoader</code>已经被回收</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法</li>
</ol>
<p>对类的回收不是无用及回收，虚拟机提供了参数进行配置</p>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义<code>ClassLoader</code>的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出</p>
<h3 id="HotSpot中可达性行分析具体实现"><a href="#HotSpot中可达性行分析具体实现" class="headerlink" title="HotSpot中可达性行分析具体实现"></a>HotSpot中可达性行分析具体实现</h3><h4 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h4><p>可达性分析中从GC roots节点找引用链这个操作，需要检查所有引用，必然消耗很多时间，这个过程称为枚举根节点</p>
<p>**Stop the World(GC停顿)**：可达性分析需要GC进行时必须停顿所有Java执行线程，即可达性分析期间需要保证整个执行系统的一致性，对象的引用关系不能发生变化</p>
<p>查找GC Roots的时候，一般主流的JVM都是<strong>准确式GC</strong>,可以<strong>直接得知哪些地方存放着对象的引用</strong>，所以在<code>Stop The World</code>的时候，并不需要全部、逐个检查完全局性和执行上下文的引用位置。</p>
<p>在<code>HotSpot</code>中，是使用的一组称为<code>OopMap </code>的数据结构来实现准确式GC:</p>
<ul>
<li>在类加载的时候，计算对象内什么偏移量上是什么类型的数据</li>
<li>在JIT编译时，也会在特定位置(安全点)记录下栈和寄存器中哪些位置是引用</li>
</ul>
<h4 id="安全点（Safepoint）"><a href="#安全点（Safepoint）" class="headerlink" title="安全点（Safepoint）"></a>安全点（Safepoint）</h4><ol>
<li><p>什么安全点</p>
<p>HotSpot在<code>OopMap</code>的帮助下可以快速且准确的完成GC Roots枚举，但是有这样一个问题：运行过程中，非常多的指令会导致引用关系变化，如果为这些执行都生成对应的<code>OopMap</code>,那么需要的空间成本太高</p>
<p>问题解决：只在特定的位置记录<code>OopMap</code>的引用关系，这些位置，则称为<strong>安全点（Safepoint）</strong></p>
<blockquote>
<p>特定的位置指的是程序只能运行到<strong>安全点</strong>才能停下来进行GC</p>
</blockquote>
</li>
<li><p>安全点的选定 ：安全点不能太少，否则GC等待的时间太长；也不能太多，空间开销过大，因此安全点基本上是以<strong>是否具有让程序长时间执行为特征</strong>为标准选定，”长时间执行“最明显的便是<strong>指令序列复用</strong>：方法调用，循环跳转，循环的末尾，异常跳转等；</p>
<blockquote>
<p> 使用安全点的规则，解决了OopMap对象过多的问题</p>
</blockquote>
</li>
<li><p>如何在安全点上停顿 ：虽然规定的安全点规则，但是如何在需要GC的时候让所有的线程到达安全点的时候再停顿呢？</p>
<ul>
<li><p>抢先式中断</p>
<p>不需要线程配合，实现如下：</p>
<ol>
<li>在GC发生的时候，首先中断所有的线程</li>
<li>检查如果发现有不在安全点上的线程，就恢复其运行直到到达安全点</li>
</ol>
<blockquote>
<p>现在几乎没有JVM使用这种方式</p>
</blockquote>
</li>
<li><p>主动式中断</p>
<p>在GC发生的时候，不直接操作线程中断，而是简单的设置一个标志，让各个线程主动去轮询这个标志，发现中断标志为真的时候就自己中断挂起，<strong>而轮询标志的地方和安全点是重合的，因此可以直接挂起</strong></p>
</li>
</ul>
</li>
</ol>
<h4 id="安全区域（Safe-Region）"><a href="#安全区域（Safe-Region）" class="headerlink" title="安全区域（Safe Region）"></a>安全区域（Safe Region）</h4><p>对于安全点，还有一个问题：对于程序没有CPU时间的时候（<code>Sleep</code>或 <code>Block</code> 状态），无法运行到<code>Safe Point </code>上中断再挂起，于是这个时候需要安全区。</p>
<ol>
<li><p>什么是安全区</p>
<p>安全区指的是在一段代码片段中，引用关系都不会再发生变化，在这个区域中任意地方开始GC都是安全的</p>
</li>
<li><p>如何利用安全区</p>
<p>线程进入安全区的时候，首先标志自己已经进入了安全区。</p>
<p>线程被唤醒离开安全区的时候，检查系统是否已经完成的根节点枚举(或者整个GC)，如果已经完成，则继续执行，否则必须等待，直到收到可以安全离开安全区的信号通知。</p>
</li>
</ol>
<h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p><code>Mark-Sweep</code></p>
<p>最基础的收集算法，后续算法是在他的基础进行改进</p>
<p>两个阶段，先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</p>
<p>不足：</p>
<ul>
<li>效率问题，标记和清除两个过程的效率都不高</li>
<li>空间问题，标记清除之后会产生大量不连续的内存碎片，控件碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前出发另一次垃圾收集动作</li>
</ul>
<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p><code>Copying</code></p>
<p>将可用的内存按容量划分为大小相等的两块，每次只使用一块，当着一块内存用完了，就将还存活着的对象复制到另外一块上面，然后吧已使用过的内存空间一次清理掉</p>
<p>优点：</p>
<ul>
<li><p>效率高，每次对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要一动堆顶指针，按顺序分配内存即可，实现简单，运行高效，</p>
<p>不过在对象存活率较高时，就需要较多的复制操作，效率变低</p>
</li>
</ul>
<p>不足：</p>
<ul>
<li>内存被缩小为原来的一半，代价太高</li>
</ul>
<p>实际应用：</p>
<p>现在JVM新生代使用的是此算法，新生代对象98%都是可回收的，所以不需要按照<code>1:1</code>的比例划分内存空间，而是按照<code>8:1:1</code>的比例分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活的对象一次性地复制到另外一块Survivor空间上(设计到分配担保)，最后清理掉Eden和刚才用过的Survivor空间，</p>
<p>分配担保：当回收之后有多于10%的对象存活，Survivor内存不够使用时，这些对象将直接通过分配担保机制进入到老年代</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p><code>Mark-Compact</code></p>
<p>标记过程和标记-清除算法一样，</p>
<p>步骤：先标记出所有需要回收的对象，所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存</p>
<p>JVM的老年代使用此算法</p>
<h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p><code>Generational Collection</code></p>
<p>当前JVM都是此算法，不是新的思想，根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的算法</p>
<ul>
<li>新生代：GC时会有大批对象被回收，少量存活，所以选择复制算法</li>
<li>老年代：对象存活率高，没有额外空间对它进行分配担保，所以选择标记-清理算法或者标记-整理算法</li>
</ul>
<h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p>如果说垃圾收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现</p>
<blockquote>
<p>首先解释两个名词，并发和并行，在谈垃圾收集器的上下文语境中，解释如下：</p>
<ul>
<li>并行（<code>Parallel</code>）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态</li>
<li>并发（<code>Concurrent</code>）：指用户线程与垃圾收集线程同时执行(但不一定是并行的，可能会交替执行)，用户程序在继续运行，而垃圾收集程序运行与另一个CPU上</li>
</ul>
</blockquote>
<h4 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h4><p>最基本、历史最悠久的收集器</p>
<p>新生代</p>
<p>复制算法</p>
<p>单线程的收集器</p>
<p>主要应用：<code>Client</code>模式下的虚拟机</p>
<p>与其他收集器的单线程比：简单而高效，对于限定单个CPU的环境来说，Serial没有线程交互的开销</p>
<h4 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h4><p>Serial的多线程版本，除了使用多线程进行垃圾收集之外，其余行为和Serial完全一样，实现上，这两种收集器也共用了很多代码</p>
<p>新生代</p>
<p>复制算法</p>
<p>多线程的收集器</p>
<p>主要应用：<code>Server</code>模式下的虚拟机，一个重要原因是，除了Serial只有他能和CMS收集器配合工作</p>
<p>在单CPU的环境中效果不会好于Serial</p>
<h4 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h4><p>新生代</p>
<p>复制算法</p>
<p>并行的多线程收集器</p>
<p>目标：达到一个可控制的吞吐量，吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），也成为了吞吐量优先的收集器</p>
<hr>
<h4 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h4><p>Serial收集器的老年代版本</p>
<p>标记-整理算法</p>
<p>单线程收集器</p>
<p>主要使用：<code>Client</code>模式下的虚拟机</p>
<p>不过<code>Server</code>模式下，还有两大用途：</p>
<ol>
<li>在JDK1.5以及之前的版本中与<code>Parallel Scavenge</code>收集器搭配使用</li>
<li>是作为CMS收集器的后背预案，在并发收集发生<code>Concurrent Mode Failure</code>时使用</li>
</ol>
<h4 id="parallel-Old收集器"><a href="#parallel-Old收集器" class="headerlink" title="parallel Old收集器"></a>parallel Old收集器</h4><p><code>Parallel Old</code> 是 <code>Parallel Scavenge</code> 收集器的老年代版本</p>
<p>标记-整理算法</p>
<p>并行多线程</p>
<p>注重吞吐量以及CPU资源敏感的场合，都可以优先考虑<code>Parallel Scavenge</code> 加 <code>Parallel Old</code>收集器</p>
<h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><p><code>Concurrent Mark Sweep</code></p>
<p>老年代</p>
<p>标记清除算法</p>
<p>并发多线程</p>
<p>目标是获取最短回收停顿时间，整个过程分为4个步骤</p>
<ol>
<li>初始标记（<code>CMS initial mark</code>）</li>
<li>并发标记（<code>CMS concurrent mark</code>）</li>
<li>重新标记（<code>CMS remark</code>）</li>
<li>并发清除（<code>CMS concurrent sweep</code>）</li>
</ol>
<p>初始标记和重新标记两步还是需要<code>Stop The World</code>,但是这两个步骤耗时较短，而耗时较长的并发标记和并发清除是可以和用户线程一起工作的</p>
<p>CMS的缺点：</p>
<ul>
<li>对CPU资源非常敏感</li>
<li>无法处理浮动垃圾，可能出现 <code>Concurrent Mode Failure</code> 失败而导致另一次Full GC的产生，出现此报错将会启用后备方案，即Serial Old收集器来重新进行老年代的GC</li>
<li>由于标记清除算法产生大量的空间碎片，不过提供了参数可以设置是否在FullGC时进行碎片合并整理</li>
</ul>
<hr>
<h4 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h4><p><code>Garbage-First</code></p>
<p>新生代+老年代</p>
<p>复制算法+标记整理算法</p>
<p>面向服务端应用的垃圾收集器，特点如下：</p>
<ul>
<li>并行与并发：G1能充分利用多CPU，多核环境下的硬件优势，使用多<code>CPU</code>能缩短<code>Stop The World</code>的停顿时间</li>
<li>分代收集：依然存在分代的概念，但G1不需要其他收集器就能完成整个GC堆的回收。</li>
<li>空间整合：G1从整体上看是基于 标记-清理算法实现，从局部上看，属于复制算法，因此<code>G1</code>不会产生内存碎片</li>
<li>可预测的停顿： G1可以建立可预测的停顿时间模型。</li>
</ul>
<p>G1运行可以大致分为以下几个步骤：</p>
<ol>
<li>初始标记（<code>Initial Marking</code>）</li>
<li>并发标记（<code>Concurrent Marking</code>）</li>
<li>最终标记（<code>Final Marking</code>）</li>
<li>帅选回收（<code>Live Data Counting and Evacuation</code>）：根据各个区域(Region)的回收价值和成本进行排序，然后根据用户所期望的GC停顿来制定回收计划</li>
</ol>
<p>初始标记和最终标记是<code>Stop The World</code></p>
<h4 id="垃圾收集器使用关系"><a href="#垃圾收集器使用关系" class="headerlink" title="垃圾收集器使用关系"></a>垃圾收集器使用关系</h4><p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/HotSpot%E7%9A%84%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.png"></p>
<h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><p>Java中自动内存管理可以理解为自动化的解决了两个问题：</p>
<ol>
<li>给对象分配内存</li>
<li>回收分配给对象的内存</li>
</ol>
<p>回收已经说过，下面探讨内存分配</p>
<blockquote>
<ol>
<li><p>Minor GC 和 Full GC 有什么不同</p>
<p>新生代GC（<code>Minor GC</code>）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快</p>
<p>老年代GC（<code>Major GC / Full GC</code>）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程），Major GC的速度一般会比Minor GC慢10倍以上</p>
</li>
<li><p>理解GC日志</p>
<p>打印<code>GC</code>日志参数,并在进程退出的时候输出当前的内存各区域分配情况： <code>-XX:+PrintGCDetails</code> ，可以通过GC日志查看对象分配</p>
</li>
</ol>
</blockquote>
<ul>
<li><strong>对象优先在Eden分配</strong> ：当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC</li>
<li><strong>大对象直接进入老年代</strong> ：大对象是指需要大量连续内存空间的Java对象，最典型的就是很长的字符串以及数组，经常出现大对象容易导致内存还有不少空间就提前触发GC以获取足够的连续空间来安置他们。大对象直接进入老年代，目的是避免导致新生代内存不足频繁Minor GC，实际开发中应避免大对象，尤其是朝生夕死的大对象</li>
<li><strong>长期存活的对象将进入老年代</strong> ：JVM给每个对象定义了一个对象年龄计数器，经过一次Minor GC，年龄增加1岁，增加到一定程度(默认15,<code>-XX:MaxTenuringThreshold</code> 设置)，就会晋升到老年代</li>
<li><strong>动态对象年龄判定</strong> ：为适应不同程序的内存情况，不是要求对象年龄必须达到<code>MaxTenuringThreshold</code>才能晋升到老年代，如果在Survivor空间中相同年龄所有对象大小的 总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无需等到<code>MaxTenuringThreshold</code>中要求的年龄</li>
<li><strong>空间分配担保</strong> ：在发生Minor GC之前虚拟机会检查是否老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，如果大于,进行一次Minor GC，此时如果Minor GC失败(<code>HadnlePromotionFailure</code>)，失败之后重新发起一次Full GC，如果小于，则改为进行一次Full GC，</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-6-类文件结构</title>
    <url>/2019/12/25/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-6-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p>越来的越多的语言选择与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式</p>
<span id="more"></span>

<h3 id="无关性的基石"><a href="#无关性的基石" class="headerlink" title="无关性的基石"></a>无关性的基石</h3><p>Java : <code>Write Once , Run Anywhere</code></p>
<p>各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——字节码（<code>ByteCode</code>）是构成平台无关性的基石，也实现了语言无关性</p>
<h3 id="Class类文件的结构"><a href="#Class类文件的结构" class="headerlink" title="Class类文件的结构"></a>Class类文件的结构</h3><p>Class文件是Java虚拟机执行引擎的数据入口，也是Java技术体系的基础构成之一</p>
<p>Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑的排列在Class文件之中，中间没有添加任何分隔符，Class文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙。</p>
<p>Class中只有两种数据类型：无符号数和表</p>
<ul>
<li>无符号数：属于基本的数据类型，以<code>u1</code>、<code>u2</code>、<code>u4</code>、<code>u8</code>来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</li>
<li>表：是多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性的以 <code>_info</code> 结尾，表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表</li>
</ul>
<p>无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合</p>
<p>Class文件格式各个数据项如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F.jpg"></p>
<ol>
<li><p>头4个字节称为魔数(<code>Magic Number</code>)，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，Class文件的魔数值为：<code>0xCAFEBABE</code></p>
</li>
<li><p>紧接着的4个字节是版本号，5、6字节是次版本号(<code>Minor Version</code>)，7、8字节是主版本号(<code>Major Version</code>)，Java的版本号从45开始，JDK7是51</p>
</li>
<li><p>紧接着是常量池入口，常量池可以理解为Class文件之中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，是Class文件中第一个出现的表类型数据项目</p>
<p>常量池数量不固定，常量池入口放置了一个<code>u2</code>类型的数据，代表常量池容量计数值(<code>constant_pool_count</code>)，从1开始计数，0表示不引用任何一个常量池项目</p>
<p>常量池主要存放两大类型常量：字面量(<code>Literal</code>)和符号引用(<code>Symbolic References</code>)</p>
<ul>
<li>字面量比较接近于Java语言层面的常量感念，如字符串、声明为<code>final</code>的常量值等</li>
<li>符号引用则属于编译原理方面的概念，包括了下面三类常量<ul>
<li>类和接口的全限定名（<code>Fully Qualified Name</code>）</li>
<li>字段的名称和描述符（<code>Descriptor</code>）</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<p>常量池中每一项常量都是一个表，JDK1.7为止共有14中结构不同的表结构，这14中表开始的第一位是一个<code>u1</code>类型的标志位，代表中这个常量属于那种常量类型，每种常量类型各自均有自己的结构</p>
<p>常量池的作用：Java在编译的时候，并不像C/C++一样有<code>link</code>这一步骤，而是在虚拟机加载Class文件的时候动态加载，也就是说在Class文件中不会保存各个方法，字段的最终内存布局信息，因此这些字段，方法的符号引用需要在运行期转换为对应的内存入口地址。当虚拟机运行的时候，需要从常量池获取对应的符号引用，再在类创建的时候或者运行时解析，翻译到具体的内存地址之中</p>
</li>
<li><p>后面两个字节代表访问标志（<code>access_flags</code>），用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类是否被声明为final等</p>
<p><code>access_flags</code>一共16个标志位，例如<code>ACC_PUBLIC</code></p>
</li>
<li><p>然后是类索引、父类索引和接口索引集合</p>
<p>类索引(<code>this_class</code>)和父类索引(<code>super_class</code>)都是<code>u2</code>类型的数据，紧接着是<code>u2</code>类型的接口计数器(<code>interfaces_count</code>)，表示索引表的容量，然后才是接口索引集合(<code>interfaces</code>)，是一组<code>u2</code>类型的数据的集合</p>
<p>Class文件中由这三个数据项来确定类的继承关系</p>
<ul>
<li>类索引确定类的全限定名</li>
<li>父类索引确定这个类的父类的全限定名(不允许多继承，所以只有一个)，<code>Java.lang.Object</code>的父类索引是0</li>
<li>接口索引集合确定这个类实现了哪些接口</li>
</ul>
</li>
<li><p>字段表集合</p>
<p>字段表(<code>filed_info</code>)用于描述接口或者类中声明的变量，字段表前也有一个<code>u2</code>类型的数据为容量计数器<code>fields_count</code></p>
<p>字段表集合不会列出从超类或者父接口中继承而来的字段，但是可能列出原本Java代码中不存在字段(例如内部类中对外部类的实例字段)</p>
<p>对于字段表，都使用简单的标识字符描述字段类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- B： byte</span><br><span class="line">- C： char</span><br><span class="line">- D: double</span><br><span class="line">- F:  float</span><br><span class="line">- I : int</span><br><span class="line">- J： long</span><br><span class="line">- S : short</span><br><span class="line">- Z:  boolean</span><br><span class="line">- V:  void</span><br><span class="line">- L: 引用，如Ljava&#x2F;lang&#x2F;Object</span><br><span class="line">数组：[ 如[I 标识int数组</span><br></pre></td></tr></table></figure>

<blockquote>
<p>描述符描述方法：</p>
<ol>
<li>当前类中的方法：()V</li>
<li>toString ： ()Ljava/lang/String</li>
<li>int indexOf(char[] source, int sourceOffset, int sourceCount, char[] target, int tagetOffset, int targetCount, int fromIndex) ： ([CII[CIII)I </li>
</ol>
</blockquote>
</li>
<li><p>方法表集合</p>
<p>描述接口或类中定义的方法</p>
<ul>
<li>在Java中，方法特征名包括参数，方法名，但是不包括返回值</li>
<li>在JVM中，方法特征名包括参数，方法名以及返回值，也就是说，在JVM中，返回值不同的方法是可以重载的</li>
</ul>
<p>方法里面的代码存放在方法属性表集合中一个名为<code>Code</code>的属性里面</p>
</li>
<li><p>属性表集合</p>
<p>在Class文件、字段表、方法表都可以携带自己的属性集合，以用于描述某些场景专有信息</p>
<p>关于异常：使用异常表处理，编译器使用异常表而不是简单的跳转命令来实现Java异常及<code>finally</code>处理机制</p>
</li>
</ol>
<h3 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h3><p>Java虚拟机的指令由操作码(一个字节)以及跟随其后的操作数构成的</p>
<ul>
<li>不过Java虚拟机采用面向操作数栈而不是寄存器的架构，所以大多数的指令都不包含操作数</li>
<li>由于Java的操作码长度为一个字节(<code>0~255</code>)，所以指令集的操作码中暑不可能超过<code>256</code></li>
</ul>
<p><code>JVM</code>没有单独对<code>byte,short,char,boolean</code>的指令，他们都是使用的<code>int</code>的指令类型，在使用的时候，<code>byte,short</code>会被带符号扩展为<code>int</code>类型，<code>char,boolean</code>会被零位扩展为<code>int</code>类型（对应的数组也会进行转换）</p>
<p>指令简介：</p>
<blockquote>
<p>指令_<n>  :一组指令，某个带有一个操作数的通用指令的特殊形式，例如iload_1的语义与操作数为1时的iload指令语义完全一致</p>
</blockquote>
<p>字节码指令在此按照用途大致分为9类</p>
<ul>
<li><p>加载和存储指令</p>
<p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</p>
<ul>
<li>将一个局部变量加载到操作栈：<code>iload、iload_&lt;n&gt;、lload、lload_&lt;n&gt;、fload、fload_&lt;n&gt;、dload、dload_&lt;n&gt;、aload、aload_&lt;n&gt;</code>。</li>
<li>将一个数值从操作数栈到局部变量表：<code>istore、istore_&lt;n&gt;、lstore、lstore_&lt;n&gt;、fstore、fstore_&lt;n&gt;、dstore、dstore_&lt;n&gt;、astore、astore_&lt;n&gt;</code>。</li>
<li>将一个常量加载到操作数栈：<code>bipush、sipush、ldc、ldc_w、ldc2_w、aconst_null、iconst_m1、iconst_&lt;i&gt;、lconst_&lt;l&gt;、fconst_&lt;f&gt;、dconst_&lt;d&gt;</code>。</li>
<li>扩充局部变量表的访问索引的指令：<code>wide</code>。</li>
</ul>
</li>
<li><p>运算指令</p>
<p>运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把运算结果重新存入到操作栈顶</p>
<ul>
<li>加法指令：<code>iadd，ladd，fadd，dadd</code>。</li>
<li>减法指令：<code>isub，lsub，fsub，dsub</code>。</li>
<li>乘法指令：<code>imul，lmul，fmul，dmul</code>。</li>
<li>除法指令：<code>idiv，ldiv，fdiv，ddiv</code>。</li>
<li>求余指令：<code>irem，lrem，frem，drem</code>。</li>
<li>取反指令：<code>ineg，lneg，fneg，dneg</code>。</li>
<li>位移指令：<code>ish1，ishr，iushr，lshl，lshr，lushr</code>。</li>
<li>按位或指令：<code>ior，lor</code>。</li>
<li>按位与指令：<code>iand，land</code>。</li>
<li>按位异或指令：<code>ixor，lxor</code>。</li>
<li>局部变量自增指令：<code>iinc</code>。</li>
<li>比较指令：<code>dcmpg，dcmpl，fcmpg，fcmpl，lcmp</code>。</li>
</ul>
</li>
<li><p>类型转换指令</p>
<p>可以将两种不同的数值类型进行相互转换</p>
<ul>
<li>Java虚拟机直接支持(即转换时无需显式的转换指令)宽化类型转换(即小范围类型向大范围类型的安全转换)：</li>
<li>窄化类型转换，必须显示的使用转换指令来完成，包括：<code>i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l、d2f</code></li>
<li>Java虚拟机明确规定数值类型的窄化转化指令永远不可能导致虚拟机抛出异常</li>
</ul>
</li>
<li><p>对象创建与访问指令</p>
<p>类实例和数组使用不同的字节码，对象创建后即可通过访问指令访问</p>
<ul>
<li>创建类实例的指令：<code>new</code>。</li>
<li>常见数组的指令：<code>newarray、anewarray、multianewarray</code>。</li>
<li>访问类字段(<code>static</code>字段，类变量)和实例字段(非<code>static</code>字段，实例变量)的指令：<code>getstatic、putstatic；getfield、putfield</code>。</li>
<li>把一个数组元素加载到操作数栈的指令：<code>baload、caload、saload、iaload、laload、faload、daload、aaload</code>。</li>
<li>将一个操作数栈的值存储到数组元素中的指令：<code>bastore、castore、sastore、iastore、fastore，dastore，aastore</code>。</li>
<li>取数组长度的指令：<code>arraylength</code>。</li>
<li>检查类实例类型的指令：<code>instanceof、checkcast</code>。</li>
</ul>
</li>
<li><p>操作数栈管理指令</p>
<p>直接操作操作数栈的指令</p>
<ul>
<li>将操作数栈的栈顶一个或两个元素出栈：<code>pop、pop2</code>。</li>
<li>复制栈顶一个或两个数值并将复制值或双份的复制重新压入栈顶：<code>dup、dup2、dup_x1、dup2_x1、dup_x2、dup1_x2</code>。</li>
<li>将栈最顶端的两个数值互换：<code>swap</code>。</li>
</ul>
</li>
<li><p>控制转移指令</p>
<p>让Java虚拟机有条件或无条件的从指定的位置指令而不是控制转移指令的下一条指令继续执行程序</p>
<p>各种类型的比较最终都会转化为<code>int</code>类型的比较操作，所以Java虚拟机<code>int</code>类的条件分支指令是最为丰富和强大的</p>
<ul>
<li>条件分支：<code>ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、if_icmpgt、if_icmple、if_icmpge、if_acmpeq、if_acmpne</code>。</li>
<li>复合条件分支：<code>tableswitch、lookupswitch</code>。</li>
<li>无条件分支：<code>goto、goto_w、jsr、jsr_w、ret</code>。</li>
</ul>
</li>
<li><p>方法调用和返回指令</p>
<p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的</p>
<ul>
<li><code>invokevirtual</code>：指令用于调用对象的实例方法，根据对象的实例类型进行分派(虚方法分派)，这也是Java语言中最常见的方法分派方式。</li>
<li><code>invokeinterface</code>：指令用于调用接口方法，它会再运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用。</li>
<li><code>invokespecial</code>：指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和分类方法。</li>
<li><code>invokestatic</code>：指令用于调用类方法(<code>static</code>方法)。</li>
<li><code>invokedynamic</code>：指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法。前4条固化在Java虚拟机内部，而<code>invokedynamic</code>指令的分派逻辑是由用户所设定的引导方法决定的</li>
<li>返回指令：<code>ireture</code>(当返回值时<code>boolean，byte，char，short</code>和<code>int</code>类型时使用)、<code>lreturn、freture、dreturn</code>和<code>areturn</code>，<code>return</code>指令供声明为<code>void</code>的方法、实例初始化方法以及类和接口的类初始化方法使用。</li>
</ul>
</li>
<li><p>异常处理指令</p>
<p>Java程序中显示抛出异常的操作（<code>throw</code>语句）都由<code> athrow</code>指令实现</p>
<p>还有许多运行时异常会在其他指令检测到异常情况时自动抛出</p>
<p>而处理异常(<code>catch</code>)是异常表实现的</p>
</li>
<li><p>同步指令</p>
<p>Java虚拟机可以支持方法级同步和方法内部一段指令序列同步，这两种同步结构都是使用管程(<code>Monitor</code>)来支持的，同步方法执行时先获取管程，执行完成释放管程</p>
<ul>
<li><p>方法级同步无需指令控制，使用<code>ACC_SYNCHRONIZED</code>访问标志来确定方法是否为同步，</p>
<p>如果执行期间发生异常，所持有管程将在异常抛出到同步方法之外时自动释放</p>
</li>
<li><p>一段指令序列的同步：使用的指令集是<code>monitorenter</code>和<code>monitorexit</code></p>
<p>为保证<code>monitorexit</code>指令的必须执行，编译器会自动产生一个异常处理器</p>
</li>
</ul>
</li>
</ul>
<h3 id="虚拟机实现"><a href="#虚拟机实现" class="headerlink" title="虚拟机实现"></a>虚拟机实现</h3><p>对于规范的Class文件格式和字节码指令集，虚拟机的主要实现方式有两种</p>
<ul>
<li>将输入的Java虚拟机代码在加载或执行时翻译成另外一种虚拟机的指令集</li>
<li>将输入的Java虚拟机代码在加载或执行时翻译成宿主机CPU的本地指令集（即JIT代码生成技术）</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-2-Java内存区域与内存溢出异常</title>
    <url>/2019/12/09/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-2-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<p>Java中把内存控制的权利交给了Java虚拟机，一旦出现内存泄漏和内存溢出方面的问题，不了解虚拟机是怎样使用内存的，排查错误将会很艰难</p>
<span id="more"></span>

<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>Java虚拟机所管理的内存包含以下几个运行时数据区域</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA.jpg" alt="JVM运行时数据区域"></p>
<h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>Program Counter Register</p>
<p>一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器，字节码解释器工作时就是通过改变这个计数器的值来选择下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器</p>
<p>为了线程切换后能恢复到正确的执行位置，每个线程都需要一个独立的程序计数器，所以程序计数器是线程私有的。线程私有：各线程之间互不影响，独立存储的内存区域为线程私有的内存区域</p>
<p>如果线程正在执行的是Java方法，则计数器记录的是正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，则计数器值为空（Undefined）</p>
<p>程序计数器是唯一一个没有规定任何OutOfMemoryError的区域</p>
<h4 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h4><p>Java Virual Machine Stacks</p>
<p>每个方法在执行的同时都会创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口的信息，每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程</p>
<p>线程私有，声明周期与线程相同</p>
<p>Java内存被粗糙的划分为堆内存和栈内存时，其中所指的栈内存就是现在将的虚拟机栈，或者说是虚拟机栈中局部变量表部分</p>
<p>局部变量表存放了编译期可知的各种基本数据类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference类型)和returnAddress类型</p>
<p>此区域规定了两种异常情况：</p>
<ol>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常</li>
<li>如果虚拟机栈可以动态扩展，扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常</li>
</ol>
<h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>Native Method Stack</p>
<p>与虚拟机栈作用很相似，区别不过是虚拟机栈为虚拟机执行Java方法(也就是字节码)服务,而本地方法栈则为虚拟机使用到的Native方法服务</p>
<p>本地方法栈区域也会抛出StackOverflowError和OutOfMemoryError异常</p>
<h4 id="Java堆"><a href="#Java堆" class="headerlink" title="Java堆"></a>Java堆</h4><p>Java heap</p>
<p>是Java虚拟机所管理的内存中最大的一块，是被所有线程共享的一块区域，在虚拟机启动的时候创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存，不过由于JIT编译器的发展与逃逸分析技术的逐渐成熟，所有对象都分配在堆上也渐渐变得不那么绝对了</p>
<p>Java堆是垃圾收集器管理的主要区域，因此很多时候称为“GC”堆(Garbage Collected Heap)</p>
<ul>
<li>从内存回收的角度来看，由于现在收集器基本采用分代收集算法，所以Java堆可细分为：新生代和老年代</li>
<li>从内存分配的角度来看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer TLAB)</li>
</ul>
<p>不过无论如何划分，都与存放的内容无关，无论哪个区域存储的都是仍然是对象实例，进一步划分是为了更好的回收内存或者更快的分配内存</p>
<p>Java堆在主流的虚拟机中都实现为可扩展的(可以通过-Xmx和-Xms控制)</p>
<p>如果堆中没有内存完成实例分配，并且堆也无法在扩展时，将会抛出OutOfMemoryError异常</p>
<h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>Methid Area</p>
<p>用于存储已被虚拟机加载的类信息、常量、静态常量、即时编辑器编译后的代码等数据</p>
<p>各个线程共享的内存区域</p>
<p>虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是他还有一个别名叫做Non Heap(非堆)，目的是和Java堆区分开</p>
<p>方法区也被称为“永久代”，不过Java8开始已经没有“永久代”了</p>
<p>方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常</p>
<h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Runtime Constant Pool</p>
<p>是方法区的一部分</p>
<p>Class文件除了有类的版本、字段、方法、接口等描述信息外，还有一项是常量池(Constant Pool Table)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放</p>
<p>Java虚拟机对Class文件的每一部分(自然也包括常量池)的格式都有严格规定，每一个字节用于存储哪种数据都必须符合规范上的要求，才会被虚拟机认可、装载和执行，但是对于运行时常量池，Java虚拟机没有做任何细节的要求，可以按需实现，一般来说，除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中</p>
<p>运行时常量池相对Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译器才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量池放入池中，这种特性被开发人员利用得比较多的便是String类放入intern()方法</p>
<p>运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法在申请到内存时会抛出OutOfMemoryError异常</p>
<blockquote>
<p>关于字面量和符号引用的说明</p>
<p>字面量包括：</p>
<ul>
<li>文本字符串</li>
<li>八种基本类型的值</li>
<li>被声明为final的编译时常量</li>
</ul>
<blockquote>
<p>有些比较小的基本数据类型会直接嵌入指令中，比如int a=1;会直接编译为 iconst_1,这种值不会放入常量池，也就说常量池找不到1，但是如果是具有final修饰的final int a=1;这个时候1便会放入常量池中,而比较大的基本数据类型是会放在运行时常量池的（比如int a=1234567）。</p>
</blockquote>
<p>符号（Symbol）引用包括：</p>
<ul>
<li>类和方法的全限定名称</li>
<li>字段和名称的描述符</li>
<li>方法的名称和描述符</li>
</ul>
<p>还有一种常量池，叫做常量池技术。比如<code>Integer</code>,<code>Short</code>等，在[-128,127]，（127可以通过配置扩大）之间能够缓存对象，这种常量池应该和运行时常量池区分开理解，基本类型包装类的常量池技术是通过包装类本身通过在<code>static</code>代码块中初始化256个对象实现的，而静态变量又是放在方法区中，所以包装类的常量池是放在方法区中的。</p>
<p><code>Double</code>和<code>Float</code>并没有实现常量池，因为不确定[-128,127]中一共应该缓存多少个数</p>
</blockquote>
<h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>Direct Memory</p>
<p>不是虚拟机运行时数据区的一部分，但是也会被频繁使用且也可能导致OutOfMemoryError异常</p>
<p>JDK1.4增加了NIO类，引入了一种基于通道(Channel)与缓冲区(Buffer)的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据</p>
<p>本机直接内存不会受到Java堆大小的限制，但是会受到本机总内存(包括RAM以及SWAP区或者分页文件)大小以及处理器寻址空间的限制，如果使得各个内存区域总和大于物理内存限制(包括物理的和操作系统级的限制)，从而会导致动态扩展时出现OutOgMemoryError异常</p>
<h3 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h3><p>HotSpot虚拟机在Java堆中对象分配、布局和访问的全过程</p>
<ul>
<li><p>对象的创建</p>
<ol>
<li>加载：new指令，首先检查指令的参数是否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过，如果没有则先执行相应的类加载过程(第7章)</li>
<li>为新生对象分配内存，对象所需内存在类加载完成后便可完全确定，<ul>
<li>分配方式：指针碰撞(Java堆内存规整)或空闲列表(Java堆内存不规整)，取决于使用哪种垃圾收集器</li>
<li>分配内存的线程安全问题，解决方案：一是对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性，二是本地线程分配缓冲(Thread Local Allocation Buffer,TLAB)，即为每个线程分配单独的空间</li>
</ul>
</li>
<li>初始化内存空间为零值(不包括对象头)，这一步保证了对象的示例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值</li>
<li>对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象的对象头中，根据虚拟机当前的运行状态不同，对象头会有不同的设置方式</li>
<li>上面工作完成，虚拟机角度的一个新的对象已经产生了，但是Java程序视角来说，对象创建才刚刚开始——执行 <init> 方法，一般来说，执行new指令之后会接着执行<init> 方法，把对象按照程序员的意愿进行初始化，这样一个可用的对象才算完全产生出来</li>
</ol>
</li>
<li><p>对象的内存布局</p>
<p>HotSpot虚拟机中，对象在内存中存储的布局可以分为3个区域：对象头(Header)、实例数据(Instance Data)和对齐填充(padding)</p>
<ul>
<li><p>对象头</p>
<ol>
<li>第一部分用于存储对象自身的运行时数据，如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等，这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”，“Mark Word”是非固定的数据结构，会根据对象状态复用自己的存储空间</li>
<li>第二部分是类型指针(非必须)，即对象指向他的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>如果对象是一个Java数组，对象头中必须存在一块用于记录数据长度的数据，因为虚拟机了可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数据的大小</li>
</ol>
</li>
<li><p>实例数据部分</p>
<p>是对象真正存储的有效信息，是程序代码中所定义的各种类型的字段内容，包括父类继承的和子类定义的</p>
</li>
<li><p>对象填充</p>
<p>非必须，无特别含义，仅仅起着占位符的作用</p>
<p>HotSpot VM 的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍，对象头部分正好是8字节的倍数(1倍或者2倍)，因此对象实例数据部分没有对齐时，就需要通过对齐填充来补全</p>
</li>
</ul>
</li>
<li><p>对象的访问定位</p>
<p>Java程序需要通过栈上的reference数据来操作堆上的具体对象，这个引用如何定位、访问堆中的对象的具体位置呢，句柄和直接指针(对象头中的类型指针)两种方式</p>
<ul>
<li><p>句柄</p>
<p>如果使用句柄访问的话，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息</p>
<p>优点：</p>
<p>reference中存储的是稳定的句柄地址，在对象被移动(GC时移动对象是普遍行为)时只会改变句柄中的实例数据指针，而reference本身不需要修改</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%BC%95%E7%94%A8%E9%80%9A%E8%BF%87%E5%8F%A5%E6%9F%84%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png"></p>
</li>
<li><p>直接指针</p>
<p>如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址</p>
<p>优点：</p>
<p>速度快，节省了一次指针定位的时间开销</p>
<p>HotSpot虚拟机是使用直接指针进行对象访问的</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E5%BC%95%E7%94%A8%E9%80%9A%E8%BF%87%E7%9B%B4%E6%8E%A5%E6%8C%87%E9%92%88%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1.png"></p>
<p>​</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-13-线程安全与锁优化</title>
    <url>/2019/11/22/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-13-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<p>首先要让程序在计算机中正确无误的运行，然后在考虑如何将代码组织的更好，让程序运行的更快，所以需要考虑如何保证并发的正确性和如何实现线程安全</p>
<span id="more"></span>

<h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>线程安全的定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那这个对象是线程安全的</p>
<p>不过这个定义一般会被弱化</p>
<h4 id="Java语言中的线程安全"><a href="#Java语言中的线程安全" class="headerlink" title="Java语言中的线程安全"></a>Java语言中的线程安全</h4><p>Java中的各种操作共享的数据的线程安全的“安全程度”由强到弱分为以下5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立</p>
<p><strong>不可变</strong></p>
<p>Java语言中，不可变（<code>Immutable</code>）的对象一定是线程安全的</p>
<p>只要一个不可变的对象被正确的构建出来（没有发生<code>this</code>引用逃逸的情况），那其外部的可见状态永远也不会改变</p>
<p>Java中常见的此类型包括：String 、枚举类、Number的部分子类，如Long和Double等数值包装类型、BigInteger和BigDecimal等大数据类型，但是同为Number的子类型的原子类AtomicInteger和AtomicLong则并非不可变的</p>
<p><strong>绝对线程安全</strong></p>
<p>意味着满足严苛的线程安全定义，在Java API中标注自己是线程安全的类，大多数都不是绝对的线程安全</p>
<p>比如Vector类定义为线程安全的容器，但是在两个线程中分别循环调用<code>synchronized</code>修饰的方法<code>vector.remove(i)</code>和<code>vector.get(i)</code>,就会出现<code>get</code>的时候抛出<code>ArrayIndexOutOfBoundsException</code>，如果想不出问题，就必须在两个线程中的for循环外增加<code>synchronized(vector)</code>，才能保证不会抛出异常</p>
<p><strong>相对线程安全</strong></p>
<p>我们通常意义上的所讲的线程安全，需要保证对这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施</p>
<p>但对于一些特定顺序的连续调用(上述对Vector的调用)，就可能需要在调用端使用额外的同步手段来保证调用的正确性</p>
<p>Java中，大部分的线程安全类型都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等</p>
<p><strong>线程兼容</strong></p>
<p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全使用</p>
<p>我们平时说一个类不是线程安全的，绝大多数是指的这种情况</p>
<p>Java中大部分的类都是线程兼容的，例如ArrayList、HashMap等</p>
<p><strong>线程对立</strong></p>
<p>线程度对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码</p>
<p>Java天生是支持多线程，线程对立的代码很少出现，而且通常有害，应该避免</p>
<p>例如：Thread类的<code>suspend()</code>和<code>resume()</code>方法，如果两个线程同时持有一个线程对象，一个尝试中途线程，一个尝试恢复线程，如果并发进行的话，无论是否进行了同步，目标线程都是存在死锁风险的，所以<code>suspend()</code>和<code>resume()</code>方法已经被JDK声明废弃了</p>
<p>常见的线程对立的操作还有<code>System.setIn()</code>、<code>System.setOut()</code>、<code>System.runFinalizersOnExit()</code>等</p>
<h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><p>如何实现线程安全，如何实现同步与锁</p>
<p><strong>互斥同步（Mutual Exclusion&amp;Synchronization）</strong></p>
<p>是常见的一种并发正确性保障手段</p>
<ul>
<li>同步：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个（或者是一些，使用信号量的时候）线程使用</li>
<li>互斥：是实现同步的一种手段，临界区（<code>Critical Section</code>）、互斥量（<code>Mutex</code>）和信号量（<code>Semaphore</code>）都是主要的互斥实现方式</li>
</ul>
<p>互斥是因，同步是果，互斥是方法，同步目的</p>
<p>Java中最基本的互斥同步手段是<code>synchronized</code>关键字，除了<code>synchronized</code>，还可以使用<code>java.util.concurrent</code>包中的重入锁（<code>ReentrantLock</code>）来实现同步，<code>ReentrantLock</code>比<code>synchronized</code>多了一些高级功能，主要有：等待可中断、可实现公平锁、锁可以绑定多个条件</p>
<ul>
<li>等待可中断：当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情</li>
<li>公平锁：多个线程在等待同一个锁时，必须按照申请锁的时候顺序来依次获得锁，<code>synchronized</code>中的锁是非公平的，<code>ReentrantLock</code>默认是非公平的，但可以通过带布尔值的构造函数要求使用公平锁</li>
<li>锁绑定多个条件：一个<code>ReentrantLock</code>对象可以同时绑定多个<code>Condition</code>对象</li>
</ul>
<p><strong>非阻塞同步</strong></p>
<p>互斥同步最主要的问题就是进行现场阻塞和唤醒所带来的的性能问题，因此这种同步也称为阻塞同步（<code>Blocking Synchronization</code>）</p>
<p>处理问题的方式上来说，互斥同步属于一种悲观的并发策略</p>
<p>随着硬件指令集的发展，有了另一个选择：基于冲突检测的乐观并发策略，通俗的说，就是先进行操作，如果没有其他线程争用共享数据，那操作就成功了，如果共享数据有争用，产生了冲突，就采取其他的补偿措施（最常见的补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步</p>
<p>为什么需要硬件指令集的发展？</p>
<p>需要操作和冲突检测这两个步骤具备原子性，此时是互斥同步保证就失去了意义，所以只能靠硬件来完成，</p>
<p>在硬件支持的基础上Java在JDK1.5才可以使用CAS操作，由<code>sun.misc.Unsafe</code>类里面的<code>compareAndSwapInt()</code>和<code>compareAndSwapLong()</code>等几个方法包装提供，不过Unsafe类不提供给用户，我们只能Java API来简介使用它，如java.util.concurrent包中的整数原子类，其中的<code>compareAndSet()</code>和<code>getAndIncrement()</code>等方法都使用了Unsafe类的CAS操作</p>
<p>示例：i++不是原子操作，但是如果i是AtomicInteger变量，线程内循环<code>i.incrementAndGet()</code>操作20000次，最后结果即可为20000</p>
<p><strong>无同步方案</strong></p>
<p>要保证线程安全，并不是一定要同步，同步只是保证共享数据争用时的正确性的手段，如果一个方法本来就不涉及共享数据，那自然不需要同步，因此有些代码天生就是安全的</p>
<ul>
<li><p>可重入代码（<code>Reentrant Code</code>）</p>
<p>也叫纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码(包括递归调用他本身)，而在控制权返回后，原来的程序不会出现任何错误，</p>
<p>可重入性是比线程安全更基本的特性，所有可重入的代码都是线程安全的，但是并非所有的线程安全的代码都是可重入的</p>
<p>可重入代码有一些共同特征：不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数传入、不调用非可重入方法等，判断代码是否具备可重入性：如果一个方法，他的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那他就满足可重入性的要求，也就是线程安全的</p>
</li>
<li><p>线程本地存储（<code>Thread Local Storage</code>）</p>
<p>如果一段代码中所需的数据必须与其他代码共享，那就看看这些共享数据的代码是否能保证在同一个线程中执行？如果能保证，就可以把共享数据的可见范围限制在同一个线程之内，这样，无需同步也能保证线程之前不出现数据争用问题</p>
<p>Java中的应用实例最经典Web交互模型中的“一个请求对应一个服务器线程”(<code>Thread-per-Request</code>)的处理方式，这种处理方式，是的很多Web服务端应用都可以使用线程本地存储来解决线程安全问题</p>
<p>Java中，如果一个变量被某个线程独享，可以通过<code>java.lang.ThreadLocal</code>类来实现线程本地存储的功能，每一个线程的Thread对象中都有一个<code>ThreadLocalMap</code>对象，这个对象存储了一组以<code>ThreadLocal.threadLocalHashCode</code>为键，以本地线程变量为值的K-V值对，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量</p>
</li>
</ul>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><p>JDK1.5到JDK1.6为了搞笑并发，实现了各种锁优化技术</p>
<h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p>因为互斥同步对性能影响最大的是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，给系统并发性能带来了很大的压力</p>
<p>自旋锁：许多应用上，共享数据的锁定状态只会持续很短一段时间，为了这段时间去挂起和恢复线程并不值得，如果物理机器上有一个以上的处理器，能让两个以上的线程同时并行执行，我们就可以让后面请求锁的那个线程”稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁，为了让线程等待，我们只需让线程执行一个忙循环（自旋）,这项技术就是所谓的自旋锁</p>
<p>不过如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，带来性能上的浪费，此时即引入了自适应的自旋锁</p>
<p>自适应意味着自旋的时间不在固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</p>
<ul>
<li>如果一个对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间</li>
<li>如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁将可能省掉自旋过程，以避免浪费处理器资源</li>
</ul>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行删除，锁消除的主要判定依据来源于逃逸分析的数据支持</p>
<p>因为不存在竞争，程序员不会增加同步措施，所以锁消除存在的意义更大的地方在于，Java代码中有许多同步代码，比如字符串相加（转化为StringBuilder之后，锁的对象为sb），其中的锁经过逃逸分析会被消除</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，推荐将同步块的作用范围限制的尽量小</p>
<p>但是如果一系列的练习操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争，频繁的进行互斥同步操作也会导致不必要的性能损耗</p>
<p>如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部</p>
<h4 id="轻量级锁和偏向锁"><a href="#轻量级锁和偏向锁" class="headerlink" title="轻量级锁和偏向锁"></a>轻量级锁和偏向锁</h4><p>轻量级是相对于使用操作系统互斥量来实现的传统锁而言的，传统锁机制称为重量级锁</p>
<ul>
<li>轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量</li>
<li>偏向锁是在无竞争的情况下把整个同步都去掉</li>
</ul>
<p>是什么类型的锁是存储在对象头（Mark Word）中的</p>
<p>偏向锁：</p>
<ul>
<li>锁对象第一次被线程获取时，虚拟机将Mark Word中的标志位设为“01”,即偏向模式，同时使用CAS把获取到这个锁的线程ID记录在对象的Mark Word中</li>
<li>如果CAS操作成功，那么持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都不在进行任何同步操作</li>
<li>当另一个线程是尝试获取这个锁时，偏向模式就宣告结束，根据锁对象目前是否处于被锁定的状态，撤销偏向后恢复到未锁定(标志位为:01)或轻量锁定(标志位为:00)</li>
</ul>
<p>轻量级锁</p>
<ul>
<li>加锁过程<ul>
<li>在代码进入同步块的时候，如果此同步对象没有被锁定(标志位:01)，虚拟机首先将在当前线程的栈帧中建立一个名为锁记录(Lock Record)的空间，用于存储锁对象目前的Mark Word的拷贝(官方把这份考分增加了一个Displaced前缀，即Displaced Mark Word)</li>
<li>然后虚拟机将使用Cas操作尝试将对象的Mark Word更新为指向Lock Record的指针，<ul>
<li>如果这个更新动作成功，那么这个线程就拥有了该对象的锁，对象Mark Word的锁标志位将转变为“00”,即处于轻量级锁定状态</li>
<li>如果这个更新动作失败，虚拟机首先会检查对象的Mark Word是否指向当前线程的栈帧，如果是是当前线程，则直接进入同步块继续执行，如果是其他线程，则这个锁被其他线程抢占了，如果有两条以上的线程争用同一锁，那轻量级就不在生效，膨胀为重量级锁，所标志位变为:10</li>
</ul>
</li>
</ul>
</li>
<li>解锁过程<ul>
<li>如果对象的Mark Word仍然指向着线程的锁记录，那就用CAS操作把对象当前的Mark Word和线程中复制的Displaced Mark Word替换回来，如果替换成功，那整个同步过程完成，如果替换失败，说明有其他线程尝试过获取该锁，那就要在释放锁的同时，唤醒被挂起的线程</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-7-虚拟机类加载机制</title>
    <url>/2019/12/27/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-7-%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析、和初始化，最终形成可以被虚拟机直接使用的Java类型，这就是虚拟机的类加载机制</p>
<span id="more"></span>

<p>Java语言中，类型的加载、连接和初始化过程都是在程序运行期间完成的</p>
<h3 id="类加载时机"><a href="#类加载时机" class="headerlink" title="类加载时机"></a>类加载时机</h3><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的声明周期包括：加载(<code>Loading</code>)、验证(<code>Verification</code>)、准备(<code>Preparation</code>)、解析(<code>Resolution</code>)、初始化(<code>Initialization</code>)、使用(<code>Using</code>)和卸载(<code>Unloading</code>)7个阶段</p>
<p>其中验证、准备、解析3个部分统称为连接(<code>Linking</code>)，7个阶段的发生顺序如图：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg"></p>
<p>所有阶段通常都是互相交叉地混合式进行的，在一个阶段的执行过程中调用、激活另一个阶段，不过开始的顺序是确定的，但是其中解析阶段在某些情况下可以在初始化阶段之后在开始，这是为了支持Java语言的运行时绑定</p>
<p>什么时候开始加载：JVM没有强制约束，可由具体实现自己把控</p>
<p>什么时候开始初始化：JVM规范规定有且只有5种情况如果类没有进行初始化，必须立即对类进行初始化(加载、验证、准备自然在此之前)，这五种行为成为对一个类的主动引用。</p>
<ol>
<li><p>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这4条指令时，生成这4条指令对应的Java代码场景：</p>
<ul>
<li>使用new关键字实例化对象时</li>
<li>读取或设置一个类的静态字段时（被<code>final</code>修饰、已在编译器把结果放入常量池的静态字段除外）</li>
<li>调用一个类的静态方法时</li>
</ul>
</li>
<li><p>使用<code>java.lang.reflect</code>包的方法对类进行反射调用时</p>
</li>
<li><p>当初始化一个的时候，发现其父类还没有进行过初始化，则需要先出发其父类的初始化</p>
</li>
<li><p>当虚拟机启动时，用户需要指定一个要执行的主类(包含<code>main()</code>方法的那个类)，虚拟机会先初始化这个主类</p>
</li>
<li><p>当使用JDK1.7的动态语言支持时，如果一个<code>java.lang.invoke.MethodHandle</code>实例最后的解析结果<code>REF_getStatic</code>、<code>REF_putStatic</code>、<code>REF_invokeStatic</code>的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要触发其初始化</p>
</li>
</ol>
<p>除上述5种主动引用的场景外，所有类的引用类的方式都不会出发初始化，称为被动引用，例如：</p>
<ul>
<li>通过子类引用父类的静态字段,子类不会被初始化</li>
<li>定义此类型的数组不会引起初始化</li>
<li>常量能够通过编译期间直接替换的属性的引用不会初始化</li>
</ul>
<blockquote>
<p>对于接口来说，也有初始化的过程，这过程大多数和类初始化差不多，不过唯一不同的是接口在初始化时不会导致其父类接口的初始化。(第三点不同)，只有在真正使用到父接口的时候才会初始化</p>
</blockquote>
<h3 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h3><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载阶段需要完成3件事</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流</li>
<li>将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的<code>java.lang.Class</code>对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<p>对于第一点，由于没有具体要求实现方式很多，例如从ZIP包中读取，最终成为日后的JAR、WAR格式，再比如运算时生成，即动态代理技术，还有等等…不一一列举</p>
<p>加载阶段与连接的部分内容是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但是这两个阶段的开始时间还是保持着固定顺序</p>
<h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p>
<p>验证阶段大致分为4个阶段的检验动作</p>
<ol>
<li><p>文件格式验证</p>
<p>验证字节流是否符合Class文件格式的规范，并且能被虚拟机处理，例如：</p>
<ul>
<li>是否以魔数<code>0xCAFEBAB</code>E开头</li>
<li>主、次版本号是否在当前虚拟机的处理范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型</li>
<li>…</li>
</ul>
<p>只有此阶段是基于二进制字节流进行的，通过此阶段的验证，字节流才会进入内存的方法区中进行存储，所以后面的3个验证阶段都是基于方法区的存储结构进行的，不会再直接操作字节流</p>
</li>
<li><p>元数据验证</p>
<p>对字节码描述的信息进行语义分析，确保其符合Java语言规范，例如：</p>
<ul>
<li>这个类是否有父类(除了<code>java.lang.Object</code>外，所有类都应该有父类)</li>
<li>这个类的父类是否继承了不允许被继承的类(被<code>final</code>修饰的类)</li>
<li>…</li>
</ul>
</li>
<li><p>字节码验证<br>最复杂的的一个阶段，主要是通过数据流和控制流分析，确认语义是合法的、符合逻辑的，例如：</p>
<ul>
<li>保证任何时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现放置<code>int</code>类型，使用时按照<code>long</code>来加载的情况</li>
<li>保证跳转指令不会跳转到方法体以外的字节码指令上</li>
<li>…</li>
</ul>
<p>如果一个类方法体的字节码没有通过字节码验证，一定有问题，但是通过了字节码验证，不能说明一定安全</p>
</li>
<li><p>符号引用验证</p>
<p>发生在虚拟机将符号引用转化为直接引用的时候（这个转化动作在连接的第三个阶段—解析中发生），符号引用验证可以看作是对类自身以外(常量池中的各种符号引用)的信息进行匹配性校验，例如：</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类</li>
<li>在指定类中是否存在符合方法的字段描述以及简单名称所描述的方法和字段</li>
<li>符号引用中的类、字段、方法的访问性是否可以被当前类访问</li>
<li>…</li>
</ul>
<p>符号引用验证是确保解析动作能正常执行，如果无法通过验证，将会抛出一个<code>java.lang.IncompatibleClassError</code>异常的子类，如：<code>java.lang.IllegalAccessError</code>、<code>java.lang.NoSuchFieldError</code>等</p>
</li>
</ol>
<p>对于虚拟机来说，验证阶段是一个非常重要、但不是一定必要的阶段，<code>-Xverify:none</code> 参数来关闭大部分的类验证措施</p>
<h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>正式<strong>类变量分配内存</strong>并<strong>设置类变量</strong>(被<code>static</code>修饰的变量)<strong>初始值</strong>的阶段，这些变量所使用的内存都将在方法去中进行分配</p>
<ul>
<li>这里不包含实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中</li>
<li>这里说的初始值“通常”是数据类型的零值，例如：<code>static int value =123;</code> 那么准备阶段过后初始值为0而不是123<ul>
<li><code>value</code>被赋予123的地方在初始化阶段，执行类构造器<code>&lt;clinit&gt;()</code>方法中</li>
<li>上述说的是通常情况，特殊情况：如果类字段的字段属性表中存在<code>ConstantValue</code>属性，那在准备阶段变量<code>value</code>就会被初始化为<code>ConstantValue</code>属性所指定的值，即上例变为：<code>static final int value =123; </code></li>
</ul>
</li>
</ul>
<h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>是虚拟机将常量池内的符号引用替换为直接引用的过程</p>
<blockquote>
<p>解析阶段的符号引用与直接引用：</p>
<ul>
<li><p>符号引用（<code>Symbolic References</code>）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可</p>
<p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中，各种虚拟机实现的内存布局可以各不相同，但是他们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在虚拟机的Class文件格式中</p>
</li>
<li><p>直接引用（<code>Direct References</code>）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄</p>
<p>直接引用是和虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在</p>
</li>
</ul>
</blockquote>
<p>虚拟机规范中没有规范解析阶段发生的具体时间，只要求在执行用于操作符号引用的字节码指令之前，先对他们所使用的符号引用进行解析</p>
<p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄、和调用点限定符7类符号引用（分别对应于常量池的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Fieldref_info</code>、<code>CONSTANT_Methodref_info</code>、<code>CONSTANT_InterfaceMethodref_info</code>、<code>CONSTANT_MethodType_info</code>、<code>CONSTANT_MethodHandle_info</code>和<code>CONSTANT_InvokeDynamic_info</code> 7种常量类型）</p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>类加载过程中（加载、验证、准备、解析），除了加载阶段可以通过自定义类加载器参与之外，其余动作完全有虚拟机主导和控制</p>
<p>初始化阶段，才真正开始执行类中定义的Java程序代码(或者说是字节码)</p>
<p>初始化阶段是执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程</p>
<p><code>&lt;clinit&gt;()</code> 方法执行过程对程序运行行为的特点和细节的影响</p>
<ul>
<li><code>&lt;clinit&gt;()</code> 方法是编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并而成，收集顺序是语句在源文件中出现的顺序</li>
<li><code>&lt;clinit&gt;()</code> 方法与类的构造函数(实例构造器<code>&lt;init&gt;()</code>方法)不同，不需要显示的调用父类构造器，虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类肯定是<code>java.lang.Object</code></li>
<li>由于父类的<code>&lt;clinit&gt;()</code> 方法先执行，就意味着父类中定义的静态语句顺序比子类优先</li>
<li><code>&lt;clinit&gt;()</code> 方法对于类或接口来说并不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;()</code> 方法</li>
<li>接口与类不同的是，执行接口的<code>&lt;clinit&gt;()</code>方法(或者接口的实现类)不需要先执行父接口的<code>&lt;clinit&gt;()</code>方法，只有当父接口中定义的变量使用时，父接口才会初始化</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;()</code>方法在多线程环境中被正确的加锁、同步。</li>
</ul>
<h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>类加载的加载过程：通过有个类的全限定名来获取描述此类的二进制字节流，放到了虚拟机外部去实现，一边让应用程序自己决定如何去获取所需要的类，实现这个动作的代码模块称为<strong>类加载器</strong></p>
<h4 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h4><p>对于任意一个类，都需要加载他的类加载器和这个类本身一同确定其在JVM中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。通俗的讲：比较两个类是否相等(<code>equals()</code>、<code>isAssignableFrom()</code>、<code>inInstance()</code>、<code>instanceof</code> 等)，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则必定不相等</p>
<h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>对于虚拟机来讲，只存在两种不同的类加载器：</p>
<ol>
<li>启动类加载器(<code>Bootstrap ClassLoader</code>)，C++实现，是虚拟机自身的一部分</li>
<li>其他的类加载器，Java语言实现，独立于虚拟机外部，全部继承自抽象类<code>java.lang.ClassLoader</code></li>
</ol>
<p>从Java开发来看，类加载器可以划分的更细致，绝大部分Java程序都会使用到以下3种系统提供的类加载器</p>
<ol>
<li><p>启动类加载器(<code>Bootstrap ClassLoader</code>)，负责将存放在<code>&lt;JAVA_HOME&gt;\lib</code>目录中的，或者被<code>-Xbootclasspath</code>参数所指令的路径中的，且是被JVM识别的类库加载到虚拟机内存中</p>
<p>此加载器无法被Java程序直接引用，用户自己编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，直接使用<code>null</code>代替即可(<code>return null</code>)</p>
</li>
<li><p>扩展类加载器(<code>Extension ClassLoader</code>)，由<code>sun.misc.Launcher$ExtClassLoader</code>实现，负责加载<code>&lt;JAVA_HOME&gt;\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器</p>
</li>
<li><p>应用程序类加载器(<code>Application ClassLoader</code>)，由<code>sun.misc.Launcher$AppClassLoader</code>实现，由于这个类加载器是<code>ClassLoader</code>中的<code>getSystemClassLoader()</code>方法的返回值，所以一般也称他为系统类加载器，负责加载用户类路径(<code>ClassPath</code>)上所指定的类库，开发者可以直接使用这个类加载器</p>
<p>如果应用程序没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器</p>
</li>
</ol>
<p>应用程序是由这三种类加载器互相配合进行加载的，有必要可以自己定义类加载器，这些类加载器的关系如下：</p>
<p><img src="https://raw.githubusercontent.com/zhangyuying-cn/images/master/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B.jpg"></p>
<p>上图展示的类加载器之间的这种层次关系，称为类加载器的**双亲委派模型(<code>Parents Delegation Model</code>)**：要求除了顶层的启动类加载器外，其余的类都应当有自己的父类加载器</p>
<blockquote>
<p>这里类加载器之间的父子关系一般不会以继承(<code>Inheritance</code>)的关系来实现，而是都使用组合(<code>Composition</code>)关系来复用父加载器的代码</p>
</blockquote>
<p>双亲委派模型的工作过程：如果一个类加载器收到了类加载的请求，他首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当类加载器反馈自己无法完成这个加载请求(他的搜索范围中没有找到所需的类)时，子加载器才会尝试自己去加载</p>
<p>双亲委派模型的一个好处是：Java类随着他的类加载器一起具备了一种带有优先级的层次关系，且保证稳定性：用户自己编写的<code>rt.jar</code>中重名的Java类可以编译但是不会被加载运行</p>
<h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>双亲委派模型并不是一个强制性的约束模型，而是Java设计者推荐给开发者的类加载器实现方式，大部分的类加载器都是遵循这个模型，有3个例外：</p>
<ol>
<li>JDK1.2之前，双亲委派模型还没有出现时，JDK1.2之后继承<code>ClassLoader</code>应该实现<code>findClass()</code>方法，写入自己的类加载逻辑</li>
<li>自身缺陷导致的，双亲委派很好的解决了各个类加载器的基础类的统一问题，但是如果基础类又要调回用户代码，如何处理？例如<code>JSDN</code>。使用线程上下文类加载器(<code>Thread Context ClassLoader</code>)，这个加载器可以打通双亲委派的层次结构来逆向使用类加载器，Java中所有涉及<code>SPI</code>的加载动作基本上都采用这种方式，例如：<code>JSDN</code>、<code>JDBC</code>、<code>JCE</code>、<code>JAXB</code>、<code>JBI</code>等</li>
<li>由于用户对程序动态性的追求而导致的，比如：代码热替换(<code>HotSwap</code>)、模块热部署(<code>Hot Deployment</code>)等。<code>OSGi</code>实现模块热不熟关键就是他自定义的类加载器机制的实现：每一个程序模块(<code>Bundle</code>)都有一个自己的类加载器，需要更换一个<code>Bundle</code>时，就把<code>Bundle</code>连同类加载器一起替换掉以实现代码的热替换，在<code>OSGi</code>环境下，类加载器不再是双亲委派的树状结构，而是更加复杂的网状结构</li>
</ol>
]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
  <entry>
    <title>深入理解JVM-8-虚拟机字节码执行引擎</title>
    <url>/2020/01/02/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3JVM-8-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<p>执行引擎是JVM最核心的组成部分之一，在不同的虚拟机实现中，执行引擎在执行Java代码的时候可能会有解释执行(通过解释器执行)和编译执行(通过即时编译器产生本地代码执行)两种选择，也可能两者兼备，但是从外观来看所有JVM执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果</p>
<span id="more"></span>

<h3 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h3><p>栈帧(<code>Stack Frame</code>)是用于支持虚拟机进行方法调用和方法执行的数据结构，是虚拟机运行时数据区中的虚拟机栈的栈元素。</p>
<p>栈帧存储了方法的局部变量表、操作数栈、动态连接和方法返回地址等信息，每一个方法从调用开始至执行完成的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程</p>
<p>每一个栈帧都包含了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息，一个栈帧需要分配多少内存不会受到程序运行期变量数据的影响，在编译代码时，已经完全确定了</p>
<blockquote>
<p>一个线程中的方法调用链可能会很长，很多方法都同时处于执行状态，对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（<code>Current Stack Frame</code>），与这个栈帧关联的方法称为当前方法（<code>Current Method</code>）。执行引擎运行的所有字节码指令都只针对当前栈帧进行操作</p>
</blockquote>
<ul>
<li><p><strong>局部变量表</strong> </p>
<p><code>Local Variable Table</code> 是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量</p>
<p>最大容量在编译的时，在方法的<code>Code</code>属性的<code>max_locals</code>数据项中确定了</p>
<p>局部变量表以变量槽(<code>Variable Slot</code>)为最小单位，<code>Slot</code>没有明确的内存空间大小。</p>
<p>虚拟机通过索引定位的方式使用局部变量表，索引值的范围是从0开始至局部变量表的最大<code>Slot</code>数量。</p>
<p>在方法执行时，虚拟机是使用局部变量表完成参数值到参数列表的传递过程的，如果执行的是实例方法(非<code>static</code>方法)，那局部变量表中第0位索引的<code>Slot</code>默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字<code>this</code>来访问这个隐含的参数，其余参数按照参数表顺序排列</p>
<p>为了尽可能节省栈帧空间，局部变量表中的<code>Slot</code>是可以重用的</p>
<p>局部变量定义了就必须赋值，否则不能使用</p>
</li>
<li><p><strong>操作数栈</strong></p>
<p><code>Operand Stack</code> 也常称为操作栈，是一个后入先出(<code>Last In First Out LIFO</code>)栈</p>
<p>最大深度在编译时写入到了<code>Code</code>属性的<code>max_stacks</code>数据项中</p>
<p>方法开始执行时，这个方法的操作数栈是空的，方法执行过程中，会有各种字节码指令往操作数栈中写出和提取，也就是出栈 / 入栈操作</p>
<p>操作数栈中元素的数据类型必须与字节码指令的序列严格匹配，例如<code>iadd</code>执行时，栈顶两个元素数据类型必须为<code>int</code></p>
<p>JVM的解释执行引擎称为：基于栈的执行引擎，其中所指的栈就是操作数栈</p>
</li>
<li><p><strong>动态连接</strong></p>
<p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接(<code>Dynamic Linking</code>) </p>
<p>动态连接：符号引用在每一次运行期间转化为直接引用，这部分称为动态连接</p>
</li>
<li><p><strong>方法返回地址</strong></p>
<p>当一个方法执行后，只有两种方式可以退出这个方法</p>
<ol>
<li>执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式成为正常完成出口（<code>Normal Method Invocation Completion</code>）</li>
<li>在执行方法过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是JVN内部产生的异常，还是代码中使用<code>athrow</code>字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出，一个方法使用异常完成出口的方式退出，是不会给他的上层调用者产生任何返回值的</li>
</ol>
<p>无论何种退出方式，都需要返回方法被调用的位置，方法返回时可能需要在栈帧中保存一些信息，用来恢复他的上层方法的执行状态</p>
</li>
<li><p><strong>附加信息</strong></p>
<p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，取决于具体实现.</p>
<p>在实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，称为栈帧信息</p>
</li>
</ul>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>方法调用阶段唯一的任务就是确定被调用方法的版本(即调用哪个一个方法)，暂时还不涉及方法内部的具体运行过程，一切方法调用在Class文件里面存储的都是符号引用，Java方法调用需要在类加载期间，或者到运行期间才能确定目标方法的直接引用</p>
<p>方法的调用有解析调用和分派调用</p>
<p>解析调用一定是一个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成</p>
<p>分派调用则可能是静态的也可能是动态的</p>
<p>解析与分派不是二选一的排它关系，他们是在不同层次上去筛选、确定目标方法的过程</p>
<ul>
<li><p><strong>解析调用</strong> </p>
<p>方法在程序运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，换句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来，这类方法的调用称为解析（发生在类加载的解析阶段）</p>
<p>符合解析条件的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可访问，除此之外还包括被<code>final</code>修饰的方法，这三种方法称为非虚方法，其他方法称为虚方法</p>
<p>对应指令：</p>
<ul>
<li><code>invokestatic</code>：调用静态方法</li>
<li><code>invokespecial</code>：调用实例构造器<code>&lt;init&gt;</code>方法、私有方法和父类方法</li>
<li><code>final</code>方法虽然使用<code>invokevirtual</code>指令，但是由于<code>final</code>无法被覆盖，没有其他版本，所以无法多态，所以为虚方法</li>
</ul>
</li>
<li><p><strong>分派调用</strong> </p>
<p>重写是静态分派实现，重载是动态分派实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Human man = <span class="keyword">new</span> Man();</span><br><span class="line">变量的静态类型：Human 也叫做外观类型</span><br><span class="line">变量的实际类型：Man</span><br><span class="line">静态类型是编译期可知，实际类型是运行期才可确定</span><br></pre></td></tr></table></figure>

<ul>
<li><p>静态分派</p>
<p>方法的重载是通过参数的静态类型而不是实际类型作为判断依据的，由于静态类型是编译期可知的，因此在编译阶段Javac编译期会根据参数的静态类型决定使用哪个重载版本</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作称为静态分派，发生在编译阶段</p>
</li>
<li><p>动态分派</p>
<p>Java重写是典型的的动态分派，<code>invokevirtual</code>指令的运行时解析过程大致如下：</p>
<ol>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记做为<code>C</code></li>
<li>如果在类型<code>C</code>中找到与该方法特征完全符合的方法，并且访问权限校验能通过，则返回这个方法的直接引用（访问权限校验不通过，则返回<code>java.lang.IllegalAccessError</code>异常）</li>
<li>否则，按照继承关系从下往上依次对<code>C</code>的各个父类进行搜索和验证过程</li>
<li>如果始终没有找到方法，则抛出<code>java.lang.AbstractMethodError</code>异常。</li>
</ol>
<p>可以看出来，方法的每次动态调用都会涉及到依次搜索过程，而且动态调用是一个非常频繁的操作，因此为了节约性能，JVM会在方法区中为类建立一个<strong>虚方法表</strong>（接口执行的时，也会有接口方法表），虚方法表存放了各个方法的实际入口地址，如果某个方法子类没有被重写，那么子类的虚方法表中的地址入口和父类相同方法一致，都指向父类的实现入口，如果重写了方法，子类方法表中的地址将会<strong>替换</strong>为指向子类实现方法的入口地址。</p>
<p>虚方法表一般在类的加载的连接阶段进行初始化，在准备了类的变量初始值后，虚拟机会将该类的方法表也初始化完毕。</p>
</li>
</ul>
</li>
</ul>
<h3 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h3><p>虚拟机如何执行方法中的字节码指令的呢？</p>
<blockquote>
<p>半独立编译器：Java语言中，Javac编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程</p>
<p>因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现</p>
</blockquote>
<h4 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h4><p>Java编译器输出的指令流，基本上是一种基于栈的指令集架构（<code>Instruction Set Architecture，ISA</code>），指令流中的指令大部分都是零地址指令，他们依赖操作数栈进行工作。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">iconst_1</span><br><span class="line">iconst_1</span><br><span class="line">iadd</span><br><span class="line">istore_0</span><br></pre></td></tr></table></figure>

<p>基于栈的指令集的主要优点是可移植，但是速度稍慢</p>
<p>与其对应的另外一套的指令集架构是基于寄存器的指令集，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, 1</span><br><span class="line">add eax, 1</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>《深入理解Java虚拟机》</tag>
      </tags>
  </entry>
</search>
